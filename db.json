{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"themes/icarus/source/css/cyberpunk.styl","path":"css/cyberpunk.styl","modified":1,"renderable":1},{"_id":"themes/icarus/source/css/default.styl","path":"css/default.styl","modified":1,"renderable":1},{"_id":"themes/icarus/source/css/style.styl","path":"css/style.styl","modified":1,"renderable":1},{"_id":"themes/icarus/source/img/avatar.png","path":"img/avatar.png","modified":1,"renderable":1},{"_id":"themes/icarus/source/img/favicon.png","path":"img/favicon.png","modified":1,"renderable":1},{"_id":"themes/icarus/source/img/favicon.svg","path":"img/favicon.svg","modified":1,"renderable":1},{"_id":"themes/icarus/source/img/logo.png","path":"img/logo.png","modified":1,"renderable":1},{"_id":"themes/icarus/source/img/logo.svg","path":"img/logo.svg","modified":1,"renderable":1},{"_id":"themes/icarus/source/img/og_image.png","path":"img/og_image.png","modified":1,"renderable":1},{"_id":"themes/icarus/source/img/razor-bottom-black.svg","path":"img/razor-bottom-black.svg","modified":1,"renderable":1},{"_id":"themes/icarus/source/img/razor-top-black.svg","path":"img/razor-top-black.svg","modified":1,"renderable":1},{"_id":"themes/icarus/source/js/animation.js","path":"js/animation.js","modified":1,"renderable":1},{"_id":"themes/icarus/source/js/back_to_top.js","path":"js/back_to_top.js","modified":1,"renderable":1},{"_id":"themes/icarus/source/js/column.js","path":"js/column.js","modified":1,"renderable":1},{"_id":"themes/icarus/source/js/main.js","path":"js/main.js","modified":1,"renderable":1},{"_id":"source/images/cover_image_library.png","path":"images/cover_image_library.png","modified":1,"renderable":0},{"_id":"source/images/cover_ksp.png","path":"images/cover_ksp.png","modified":1,"renderable":0},{"_id":"source/images/cover_jepack_compose.png","path":"images/cover_jepack_compose.png","modified":1,"renderable":0},{"_id":"source/images/cover_system_ui.png","path":"images/cover_system_ui.png","modified":1,"renderable":0},{"_id":"source/images/cover_ui_rendering.png","path":"images/cover_ui_rendering.png","modified":1,"renderable":0}],"Cache":[{"_id":"source/.DS_Store","hash":"f3059fcbc25d06eacefd31e7fa4c39bfb7730e9d","modified":1628863785076},{"_id":"source/images/cover_image_library.png","hash":"9d10dac56e57d04551477524caf9214157925393","modified":1627219643652},{"_id":"source/images/cover_jepack_compose.png","hash":"0f17f71dd25d58a7b9220a5d88354d247249e695","modified":1627195390393},{"_id":"source/images/cover_system_ui.png","hash":"fb20cd5f11731675f596caf148535970f950fe9b","modified":1628753259181},{"_id":"source/_posts/.DS_Store","hash":"403b28003a2f10f891f4785004353708d3648a2c","modified":1628863810925},{"_id":"source/_posts/2021-04-07 Jetpack Compose Part 1.md","hash":"1f3006f1a7703fc988b29b67537d29a61059fb0f","modified":1627195703351},{"_id":"source/_posts/2021-04-07 Jetpack Compose Part 2.md","hash":"bed0bb57d955697851e51dda1535d2e85ba8c550","modified":1627197372124},{"_id":"source/_posts/2021-05-19 Android UI Rendering Optimization Part 1.md","hash":"7d3be4ca6c447b99490e222c213eb55079fbf211","modified":1627219700235},{"_id":"source/_posts/2021-04-07 Jetpack Compose Part 3.md","hash":"a3ad0cadca8cf18eb6953ec12e687a4d5989525c","modified":1627197522912},{"_id":"source/_posts/2021-05-19 Android UI Rendering Optimization Part 2.md","hash":"8303d8e786e4cd86e0bbe11ca732d0be9250c4ab","modified":1627219704789},{"_id":"source/_posts/2021-06-24 Image Loading and Caching Library Part 1.md","hash":"625ca9e43d4886bafa53ff6bab00ec5c3ca2ea7f","modified":1627219746334},{"_id":"source/_posts/2021-06-24 Image Loading and Caching Library Part 2.md","hash":"04a75717b87a5e86742d991872d26e4981a8962c","modified":1627219750314},{"_id":"source/_posts/2021-05-19 Android UI Rendering Optimization Part 3.md","hash":"1bb598a94e6e07abae4da3240feb1fc4802b2b06","modified":1627219708008},{"_id":"source/_posts/2021-06-24 Image Loading and Caching Library Part 3.md","hash":"de901bc74271426fdef7bd6b516457286f99abce","modified":1627219755183},{"_id":"source/_posts/2021-07-21 Kotlin Symbol Processing Api Part 2.md","hash":"b0e2fc994441106745b67f5e3b06b890cf462204","modified":1628865608375},{"_id":"source/_posts/2021-07-21 Kotlin Symbol Processing Api Part 1.md","hash":"2ba72fe9341141cd5807650fe9bfa6f42f1052e5","modified":1628865608375},{"_id":"source/_posts/2021-07-21 Kotlin Symbol Processing Api Part 3.md","hash":"41bcc183f019c357b7680e8082fd1e6b86b55747","modified":1628865608375},{"_id":"source/_posts/2021-04-07 Jetpack Compose Part 1/WprDTs1.png","hash":"1e7a9e83f70a8a888576c9414310dc2c5ecd42b6","modified":1627192041705},{"_id":"source/_posts/2021-04-07 Jetpack Compose Part 1/aO6Jlsg.png","hash":"cb2a6385373460ed62d557f5fd6857b9add5154b","modified":1627192007543},{"_id":"source/_posts/2021-04-07 Jetpack Compose Part 2/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1627197393446},{"_id":"source/_posts/2021-04-07 Jetpack Compose Part 2/1_5RZOM7sWV0sXctJtTPdshQ.png","hash":"ffe02f83fee60952e843f6851f901bea72ce9dca","modified":1627196858090},{"_id":"source/_posts/2021-04-07 Jetpack Compose Part 2/1_T9Pww7JyPMPhCJ_6yU8fyQ.png","hash":"54f618490e46ada03f3a75d198acc1c7ddc0f321","modified":1627196899753},{"_id":"source/_posts/2021-04-07 Jetpack Compose Part 2/1_9IA2k2s5hAS9pSyzpmQ6Pw.png","hash":"2b7af6d2978089bb374422102202071ab277d7b0","modified":1627196844240},{"_id":"source/_posts/2021-04-07 Jetpack Compose Part 2/1_UoLVl1dbUjKh9kd4uY0ROA.png","hash":"11b60f2e071153fcbe560e89aaef163a87ad142e","modified":1627196977774},{"_id":"source/_posts/2021-04-07 Jetpack Compose Part 2/1_XVvr-CB2pn88Te7Gg52GPA.png","hash":"fc39b18462260b52dc5a6bab6f2cc387b257ede9","modified":1627196828869},{"_id":"source/_posts/2021-04-07 Jetpack Compose Part 2/1_m7mSalYCza-SoJjmlYeWdA.png","hash":"d5d4958f6e2304ad94f4dc38104c99b9173376b5","modified":1627196954517},{"_id":"source/_posts/2021-04-07 Jetpack Compose Part 2/1_bSyX8yT7H2HevBNw9fbyYw.png","hash":"dffd3bbd66021f82170b9067b5826289b15bd4cb","modified":1627196887978},{"_id":"source/_posts/2021-04-07 Jetpack Compose Part 2/1_tPAf-Akf2IpDRrrZo1f1dg.png","hash":"67bb69909c81fcebf26ce429115685c0c0aa3bae","modified":1627196938353},{"_id":"source/_posts/2021-04-07 Jetpack Compose Part 2/add_002_001.png","hash":"7c35a0d3efc17ff4a8f4eb8a1d8c3a589dac2db3","modified":1627197004745},{"_id":"source/_posts/2021-04-07 Jetpack Compose Part 2/1_wFM4jF71V5aJog3lALaRKQ.png","hash":"7cc0b73358aa886719fb51ccb88413fa740b38e9","modified":1627196925904},{"_id":"source/_posts/2021-05-19 Android UI Rendering Optimization Part 1/EzHZMUm.png","hash":"e3dcee986a1f76c3c2ea0ccc1c9eecc1214d67a3","modified":1627202405453},{"_id":"source/_posts/2021-05-19 Android UI Rendering Optimization Part 1/UntitledDiagram.png","hash":"b68cd0059aaaecf07dbab3022d520f09f06738e2","modified":1627202456572},{"_id":"source/_posts/2021-05-19 Android UI Rendering Optimization Part 1/qu5Mr6x.png","hash":"594c20fd4933bcb82a65637f0e8339456277d9eb","modified":1627202422049},{"_id":"source/_posts/2021-05-19 Android UI Rendering Optimization Part 2/4.png","hash":"b370fb9f3328a259420945173c0830594f008bba","modified":1627202925466},{"_id":"source/_posts/2021-05-19 Android UI Rendering Optimization Part 2/7990Bf0.png","hash":"855bcdec520ce2b85ad119ff869059c006a7f89d","modified":1627202792984},{"_id":"source/_posts/2021-05-19 Android UI Rendering Optimization Part 2/image.png","hash":"05307b5c204033dfb679b0da0b35eb93d03e5127","modified":1627202814031},{"_id":"source/_posts/2021-05-19 Android UI Rendering Optimization Part 2/image-1.png","hash":"59da23e7f344900920338920b9be39158ea8c03e","modified":1627202904486},{"_id":"source/_posts/2021-05-19 Android UI Rendering Optimization Part 3/gpu_profile.png","hash":"92eb4ea0978a9a2f8d392e2e6e1c0a08845704dd","modified":1627204852970},{"_id":"source/_posts/2021-05-19 Android UI Rendering Optimization Part 3/graph_color.png","hash":"4e5e3364237d63abb0e2593176d88ac774fa84ca","modified":1627204884765},{"_id":"source/_posts/2021-05-19 Android UI Rendering Optimization Part 3/image.png","hash":"05307b5c204033dfb679b0da0b35eb93d03e5127","modified":1627204828551},{"_id":"source/_posts/2021-05-19 Android UI Rendering Optimization Part 3/overdrawn_2.png","hash":"9b070bf77d97d74b4986c838cebb375872d9d748","modified":1627205089107},{"_id":"source/_posts/2021-05-19 Android UI Rendering Optimization Part 3/overdrawn_3.png","hash":"8d7bca48042bd3de4bcf2385d024791e77297b81","modified":1627205095602},{"_id":"source/_posts/2021-05-19 Android UI Rendering Optimization Part 3/overdrawn_1.png","hash":"8463613a962832bb022985971c157193e1d421da","modified":1627205083776},{"_id":"source/_posts/2021-05-19 Android UI Rendering Optimization Part 3/overdrawn_4.png","hash":"d872a7e885a2cb8433beadcdcaf9a4257cce9fcb","modified":1627205100103},{"_id":"source/_posts/2021-06-24 Image Loading and Caching Library Part 1/Screenshot_1623775512.png","hash":"52bb418f744f4cc1d98be5488aaf32f030369f0d","modified":1627217984734},{"_id":"source/_posts/2021-06-24 Image Loading and Caching Library Part 2/image.png","hash":"115dd7645f37ff98157ae2b4b63223eabcecaafb","modified":1627218996223},{"_id":"source/_posts/2021-06-24 Image Loading and Caching Library Part 3/BntHJ2Y-1.png","hash":"ec4826ed266043b069bba5c8692f0e3266be756f","modified":1627219180158},{"_id":"source/_posts/2021-06-24 Image Loading and Caching Library Part 3/QafKUB1.png","hash":"853b656381d79fa28df6cac3ec0f54983328045d","modified":1627219280720},{"_id":"source/_posts/2021-06-24 Image Loading and Caching Library Part 3/BntHJ2Y.png","hash":"ec4826ed266043b069bba5c8692f0e3266be756f","modified":1627219156535},{"_id":"source/_posts/2021-06-24 Image Loading and Caching Library Part 3/m7itaqy.png","hash":"a775273c03df6f608be713464615885fe06f677d","modified":1627219117622},{"_id":"source/_posts/2021-06-24 Image Loading and Caching Library Part 3/TIrybR8.png","hash":"80e2e2f9b0ee58a857ac5a69ca110ca217107d58","modified":1627219243151},{"_id":"source/_posts/2021-07-21 Kotlin Symbol Processing Api Part 3/0HScWJk.png","hash":"410d0c6d93c29e9eed8fc3d5648401683cb76cc5","modified":1628865608376},{"_id":"source/_posts/2021-07-21 Kotlin Symbol Processing Api Part 3/HyjEy1l.png","hash":"4da24729f65cbed64944db8960654cdfc5312c39","modified":1628865608377},{"_id":"source/_posts/2021-07-21 Kotlin Symbol Processing Api Part 3/rcWvgv0.png","hash":"d7f53e4ff16ee13f19f30f00ca699afa2e68af0c","modified":1628865608378},{"_id":"source/_posts/2021-07-21 Kotlin Symbol Processing Api Part 3/NjWXyw6.png","hash":"e6626f172649dcb0fa248b0d62b887e4ad28e8b4","modified":1628865608378},{"_id":"source/images/cover_ui_rendering.png","hash":"ba9275bcac22bc1d658d52e72486ddd04817ec12","modified":1627219643621},{"_id":"source/_posts/2021-04-07 Jetpack Compose Part 1/VLTxB8C.png","hash":"d37822b0cf3b0a6c6092faa237fb50b917a291c7","modified":1627192230337},{"_id":"source/_posts/2021-04-07 Jetpack Compose Part 1/1_5gfrQWfxyEC7Oq6b2xlJ9w.png","hash":"4612b82b8aaeb87d65092177d8a8179943c08ced","modified":1627191371716},{"_id":"source/_posts/2021-04-07 Jetpack Compose Part 1/qgQ6oY4.png","hash":"7de89cfdcd8b8c0c88f0247648b9d5979d61f737","modified":1627192071727},{"_id":"source/_posts/2021-05-19 Android UI Rendering Optimization Part 1/image.png","hash":"0ddca9ebe8f1b2f638a69ea59e35fc4a9e250a3e","modified":1627202549416},{"_id":"source/_posts/2021-05-19 Android UI Rendering Optimization Part 3/example1.png","hash":"46c035f09667529176804fea518a1187985510c2","modified":1627205321782},{"_id":"source/_posts/2021-05-19 Android UI Rendering Optimization Part 3/example2.png","hash":"57a32b74b701e2c7456aadcec8ea6f7db7e06a08","modified":1627205353571},{"_id":"source/_posts/2021-06-24 Image Loading and Caching Library Part 1/coil_heap_dump.png","hash":"5075bd3f0e7d141e1eafda7543992bd32a6cf794","modified":1627218461169},{"_id":"source/_posts/2021-06-24 Image Loading and Caching Library Part 1/glide_heap_dump.png","hash":"4843c8a41b204b8038ca97b58a13f7095a928624","modified":1627218393226},{"_id":"source/_posts/2021-06-24 Image Loading and Caching Library Part 1/heap_dump.png","hash":"c58604ef40d3acc6c3e573f33bcd5861217ff15e","modified":1627218240318},{"_id":"source/_posts/2021-05-19 Android UI Rendering Optimization Part 2/JNfYVx7.png","hash":"5ec4cd78e27b85ce7513f3afbe8ab1648876fc93","modified":1627202734691},{"_id":"source/_posts/2021-05-19 Android UI Rendering Optimization Part 3/after_merge.png","hash":"bab66dea17776ea6ce52d510794b4fe01db1d5a0","modified":1627205282181},{"_id":"source/_posts/2021-05-19 Android UI Rendering Optimization Part 3/gpu_rendering_profile_1.png","hash":"d605385d5c363bdc0c9500ae892d852936fc8b46","modified":1627204912586},{"_id":"source/_posts/2021-05-19 Android UI Rendering Optimization Part 3/gpu_rendering_profile_2.png","hash":"2f7dce54e2b42c7c6a33e8b3d319b908593e6d0e","modified":1627204967987},{"_id":"source/_posts/2021-06-24 Image Loading and Caching Library Part 3/0oDUU69.png","hash":"c2a367ee700f8e4bf56244ea8ef1e4987188ba81","modified":1627219228956},{"_id":"source/_posts/2021-06-24 Image Loading and Caching Library Part 3/rb1bMMt.png","hash":"1aa58cbd1e91b335ef9023f5b58cd3754a1c6a5a","modified":1627219212364},{"_id":"themes/icarus/layout/comment/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1626871710183},{"_id":"themes/icarus/layout/donate/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1626871710187},{"_id":"themes/icarus/layout/misc/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1626871710188},{"_id":"themes/icarus/layout/search/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1626871710189},{"_id":"themes/icarus/layout/share/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1626871710190},{"_id":"themes/icarus/include/schema/comment/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1626871710170},{"_id":"themes/icarus/include/schema/misc/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1626871710173},{"_id":"themes/icarus/include/schema/donate/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1626871710173},{"_id":"themes/icarus/include/schema/share/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1626871710174},{"_id":"themes/icarus/include/schema/search/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1626871710174},{"_id":"source/_posts/2021-05-19 Android UI Rendering Optimization Part 2/ha7Eriy.png","hash":"215f5dd7c94d383974afc86a7c97e6e94b4a5ca5","modified":1627202858060},{"_id":"source/_posts/2021-05-19 Android UI Rendering Optimization Part 3/before_merge.png","hash":"33ddb5b572f4683762679075bd76caa3e1f2209f","modified":1627205232204},{"_id":"themes/icarus/.eslintrc.json","hash":"43c7740158c8690242720b4ff7fa11426fc20c79","modified":1626871710164},{"_id":"themes/icarus/.DS_Store","hash":"c16e31ab96d11a9d5523f6539d4b162123962ddf","modified":1627059163641},{"_id":"themes/icarus/.eslintignore","hash":"5410a1bef9807f666cd92a0d2020f700e67e4096","modified":1626871710164},{"_id":"themes/icarus/.gitignore","hash":"36084c0851a22bfd393933abb8e262562ffc6802","modified":1626873230442},{"_id":"themes/icarus/.npmignore","hash":"42242c8da7a020a3295e7dd3d18bf022cb08b661","modified":1626871710168},{"_id":"themes/icarus/README.md","hash":"247ec8047ee3105d31099dd8e6ca498b6bff1336","modified":1626871710169},{"_id":"themes/icarus/CONTRIBUTING.md","hash":"70254c6778c1e41bb2ff222bbf3a70b2239b9bc1","modified":1626871710168},{"_id":"themes/icarus/package.json","hash":"b87737dd30d2eaa5b240b196c55cc8d52ffba75c","modified":1626871710191},{"_id":"themes/icarus/LICENSE","hash":"86037e5335a49321fa73b7815cab542057fac944","modified":1626871710169},{"_id":"themes/icarus/include/config.js","hash":"1ff0f174e9670074ad2bee890d5b6da486800c9a","modified":1626871710169},{"_id":"themes/icarus/include/dependency.js","hash":"d30dbcefd58619f6705d6369b644bc7ba44d2421","modified":1626871710169},{"_id":"themes/icarus/include/register.js","hash":"a974b56a1fbb254f1ae048cc2221363faaccec25","modified":1626871710170},{"_id":"themes/icarus/languages/de.yml","hash":"01d9c27c3c9224d8c58b1cf7099ef008b9411a45","modified":1626871710178},{"_id":"themes/icarus/languages/es.yml","hash":"48fe3d7d304239b5e5e93f63600093700d6f0fed","modified":1626871710178},{"_id":"themes/icarus/languages/en.yml","hash":"1bdb74288808c4d306b46630860e586a1fcd88a7","modified":1626871710178},{"_id":"themes/icarus/languages/fr.yml","hash":"14765cc6216b4af5a05341315c9f6ee54d636a78","modified":1626871710179},{"_id":"themes/icarus/languages/id.yml","hash":"c04fca89e536d539a8bf95980bff7dff79125ba3","modified":1626871710179},{"_id":"themes/icarus/languages/ja.yml","hash":"7568f246a21813527ccea8a1da72a9526aa2d233","modified":1626871710179},{"_id":"themes/icarus/languages/ko.yml","hash":"f2211a8ca1d73f05a1c931aa11accb4e34c483c4","modified":1626871710179},{"_id":"themes/icarus/languages/pl.yml","hash":"612639b0e0a15185c12eecfe3e8913b629ecdfdf","modified":1626871710180},{"_id":"themes/icarus/languages/pt-BR.yml","hash":"531b22c71fab8aae60ddc7599aaa5f46140cf2c1","modified":1626871710180},{"_id":"themes/icarus/languages/ru.yml","hash":"bf784c6f31e8fb7ed78509468bddecd447c3b73b","modified":1626871710180},{"_id":"themes/icarus/languages/tk.yml","hash":"e5b9b369bbcf90c199a65a877eb75fba05cd7f90","modified":1626871710180},{"_id":"themes/icarus/languages/tr.yml","hash":"96d94f7a5d56b2682ae2792f0808139d4b950704","modified":1626871710181},{"_id":"themes/icarus/languages/vn.yml","hash":"64307bfa16d851334e2f37a29a84d644624c2060","modified":1626871710181},{"_id":"themes/icarus/languages/zh-TW.yml","hash":"92f8cf599ad06bb14f79f4806ac4c695f60044d7","modified":1626871710182},{"_id":"themes/icarus/languages/zh-CN.yml","hash":"82ff607b1671b88d259d10b6ce8ca1bb05b2cff4","modified":1626871710181},{"_id":"themes/icarus/layout/archive.jsx","hash":"05677e93d4a43f417dbbf0d63ca37a99e6349e3b","modified":1626871710182},{"_id":"themes/icarus/layout/categories.jsx","hash":"b8ad43e28a4990d222bfbb95b032f88555492347","modified":1626871710183},{"_id":"themes/icarus/layout/category.jsx","hash":"fd15e4eac32de9ac8687aeb3dbe179ab61375700","modified":1626871710183},{"_id":"themes/icarus/layout/page.jsx","hash":"d26c2db57e5a88d6483a03aeb51cda9d191d8cea","modified":1626871710188},{"_id":"themes/icarus/layout/index.jsx","hash":"0a84a2348394fa9fc5080dd396bd28d357594f47","modified":1626871710187},{"_id":"themes/icarus/layout/layout.jsx","hash":"27dcef37bb2986ba7baf869ef4886ebe9917dabf","modified":1627045299033},{"_id":"themes/icarus/layout/post.jsx","hash":"d26c2db57e5a88d6483a03aeb51cda9d191d8cea","modified":1626871710189},{"_id":"themes/icarus/layout/tag.jsx","hash":"d2f18cac32ca2725d34ccff3f2051c623be6c892","modified":1626871710190},{"_id":"themes/icarus/layout/tags.jsx","hash":"2c42cb64778235dd220c563a27a92108ddc50cc4","modified":1626871710190},{"_id":"themes/icarus/scripts/index.js","hash":"0c666db6fcb4ffc4d300f4e108c00ee42b1cbbe6","modified":1626871710191},{"_id":"themes/icarus/source/.DS_Store","hash":"ae53dfd2a20622619f81b0f3718694cc25286ff8","modified":1627059174203},{"_id":"themes/icarus/include/migration/head.js","hash":"269ba172013cbd2f10b9bc51af0496628081329b","modified":1626871710169},{"_id":"themes/icarus/include/migration/v3_v4.js","hash":"9faf2184d7fe87debfbe007f3fc9079dcbcafcfe","modified":1626871710170},{"_id":"themes/icarus/include/migration/v2_v3.js","hash":"3ccb2d2ce11018bebd7172da66faecc3983bff00","modified":1626871710170},{"_id":"themes/icarus/include/schema/config.json","hash":"ac633f9d349bca4f089d59d2c3738b57376f1b31","modified":1626871710173},{"_id":"themes/icarus/include/style/card.styl","hash":"f78674422eb408cd17c17bbdc3ee1ebe4a453e05","modified":1626871710176},{"_id":"themes/icarus/include/style/donate.styl","hash":"8d0af00628c13134b5f30a558608e7bebf18c2ec","modified":1626871710176},{"_id":"themes/icarus/include/style/base.styl","hash":"2bca6ad099949d52236c87db8db1002ffb99774c","modified":1626871710175},{"_id":"themes/icarus/include/style/article.styl","hash":"580b1e9bd356ed6781c32ccc49c6fa3486b94620","modified":1626973290439},{"_id":"themes/icarus/include/style/button.styl","hash":"0fb35b4786be1b387c751fa2849bc71523fcedd4","modified":1626871710175},{"_id":"themes/icarus/include/style/footer.styl","hash":"a4ad715dee38b249538ac6cce94efc9b355a904b","modified":1626871710176},{"_id":"themes/icarus/include/style/codeblock.styl","hash":"30bee4cf6792e9665eb648cc20b352d9eaff1207","modified":1626871710176},{"_id":"themes/icarus/include/style/helper.styl","hash":"9f3393e6122cc9f351091bfab960674e962da343","modified":1626871710176},{"_id":"themes/icarus/include/style/navbar.styl","hash":"ecc73c8ad504c0fa4bb910eb51500c14e0a8d662","modified":1626871710177},{"_id":"themes/icarus/include/style/pagination.styl","hash":"b81bcd7ff915b4e9299533addc01bc4575ec35e3","modified":1626871710177},{"_id":"themes/icarus/include/style/responsive.styl","hash":"207083fe287612cddee6608b541861b14ac8de81","modified":1626972686487},{"_id":"themes/icarus/include/style/plugin.styl","hash":"679b61b5fc5b3281735a21c37aeb64229d9c51ea","modified":1626871710177},{"_id":"themes/icarus/include/style/search.styl","hash":"416737e1da4e7e907bd03609b0fee9e2aacfe56c","modified":1626871710177},{"_id":"themes/icarus/include/style/timeline.styl","hash":"ea61798a09bffdda07efb93c2ff800b63bddc4c4","modified":1626871710177},{"_id":"themes/icarus/include/util/console.js","hash":"59cf9d277d3ac85a496689bd811b1c316001641d","modified":1626871710178},{"_id":"themes/icarus/include/style/widget.styl","hash":"c746902251136544eb3fe523235b3183f4189460","modified":1626871710178},{"_id":"themes/icarus/layout/common/comment.jsx","hash":"427089c33002707b76e2f38709459a6824fd0f9b","modified":1626871710184},{"_id":"themes/icarus/layout/common/article.jsx","hash":"16513ab1745533d0f4cdbdee323339ebab6d02c1","modified":1626871710184},{"_id":"themes/icarus/layout/common/donates.jsx","hash":"889fb0a7ccc502f0a43b4a18eb330e351e50493c","modified":1626871710184},{"_id":"themes/icarus/layout/common/footer.jsx","hash":"baa8e40e036a3ec0114d96893b708435104b4ba9","modified":1626871710185},{"_id":"themes/icarus/layout/common/head.jsx","hash":"37f2f2efcb102c706e2460dc9cdeaa302366d318","modified":1626871710185},{"_id":"themes/icarus/layout/common/plugins.jsx","hash":"f6826c1a5f5f59f4a0aa00c63bdb0ad4ff4eab69","modified":1626871710186},{"_id":"themes/icarus/layout/common/navbar.jsx","hash":"fcd9fd4624dee49207ef09ea2a1c63f524f3710c","modified":1626871710185},{"_id":"themes/icarus/layout/common/scripts.jsx","hash":"0fe1fddab431fb9f63906d8c480d5cd6b33abc32","modified":1626871710186},{"_id":"themes/icarus/layout/common/search.jsx","hash":"6f244a37293031670a2964fe424ecd062e591d7b","modified":1626871710186},{"_id":"themes/icarus/layout/common/share.jsx","hash":"c9fb0319ad5e5a10ad3636b26a6c2afed14c590f","modified":1626871710186},{"_id":"themes/icarus/layout/common/widgets.jsx","hash":"689cf4a6b79337b11d1d56afa9dda09223a809a1","modified":1626871710187},{"_id":"themes/icarus/layout/plugin/animejs.jsx","hash":"e2aa27c3501a58ef1e91e511557b77395c2c02aa","modified":1626871710188},{"_id":"themes/icarus/layout/plugin/back_to_top.jsx","hash":"7fc0c5aaabd7d0eaff04cb68ec139442dc3414e8","modified":1626871710189},{"_id":"themes/icarus/layout/widget/profile.jsx","hash":"0d3a7fd922c12cc45d2c8d26a8f4d3a9a6ed0ae0","modified":1626964877654},{"_id":"themes/icarus/source/css/cyberpunk.styl","hash":"ae17d3528df0c3f089df14a06b7bd82f1bc5fed9","modified":1626871710192},{"_id":"themes/icarus/source/css/default.styl","hash":"b01da3028e5a1267a40aaae5c86a11187a2259e3","modified":1626871710192},{"_id":"themes/icarus/source/css/style.styl","hash":"5b9815586e993a6ccbe8cdcfc0c65ea38fc315ac","modified":1626871710192},{"_id":"themes/icarus/source/img/avatar.png","hash":"5f294e72d6b2385e2f7f946ded9f06ca9f3cf6c6","modified":1627059137118},{"_id":"themes/icarus/source/img/favicon.png","hash":"11c336162b4b87962f1e58c06e6d1c1b23eb5d45","modified":1627059457976},{"_id":"themes/icarus/source/img/favicon.svg","hash":"16fd847265845063a16596761cddb32926073dd2","modified":1626871710193},{"_id":"themes/icarus/source/img/logo.png","hash":"be05b47728f1276b913de1191bd7df1929cfbf5d","modified":1626970438413},{"_id":"themes/icarus/source/img/logo.svg","hash":"e9b5c1438ddb576693a15d0713b2a1d9ceda4be9","modified":1626871710193},{"_id":"themes/icarus/source/img/razor-bottom-black.svg","hash":"a3eda07b1c605b456da9cdf335a1075db5e5d72c","modified":1626871710194},{"_id":"themes/icarus/source/js/.eslintrc.json","hash":"6bf0641cb69dffac97f69baea192d7fa3ab612cb","modified":1626871710195},{"_id":"themes/icarus/source/img/og_image.png","hash":"b03f163096ca9c350ec962feee9836277b5c2509","modified":1626871710194},{"_id":"themes/icarus/source/img/razor-top-black.svg","hash":"201f1171a43ce667a39091fe47c0f278857f18f0","modified":1626871710194},{"_id":"themes/icarus/source/js/animation.js","hash":"12cedd5caaf9109eed97e50eeab8f883f6e49be3","modified":1626871710195},{"_id":"themes/icarus/source/js/back_to_top.js","hash":"d91f10c08c726135a13dfa1f422c49d8764ef03f","modified":1626871710195},{"_id":"themes/icarus/source/js/column.js","hash":"0baee024ab67474c073a4c41b495f3e7f0df4505","modified":1626871710195},{"_id":"themes/icarus/source/js/main.js","hash":"13e4b1c4fa287f3db61aae329ad093a81992f23d","modified":1626871710196},{"_id":"themes/icarus/include/schema/common/article.json","hash":"8d78149f44629d0848921c6fb9c008b03cef3116","modified":1626871710170},{"_id":"themes/icarus/include/schema/common/footer.json","hash":"09d706cbb94d6da9a0d15c719ce7139325cae1c7","modified":1626871710171},{"_id":"themes/icarus/include/schema/common/head.json","hash":"98889f059c635e6bdbd51effd04cf1cf44968a66","modified":1626871710171},{"_id":"themes/icarus/include/schema/common/donates.json","hash":"ae86e6f177bedf4afbe638502c12635027539305","modified":1626871710171},{"_id":"themes/icarus/include/schema/common/plugins.json","hash":"6036a805749816416850d944f7d64aaae62e5e75","modified":1626871710172},{"_id":"themes/icarus/include/schema/common/comment.json","hash":"7d744391a8abee9a2c450b6fdd36a3866a488025","modified":1626871710170},{"_id":"themes/icarus/include/schema/common/providers.json","hash":"97ec953d497fb53594227ae98acaef8a8baa91da","modified":1626871710172},{"_id":"themes/icarus/include/schema/common/navbar.json","hash":"6691e587284c4cf450e0288680d5ff0f3565f090","modified":1626871710171},{"_id":"themes/icarus/include/schema/common/search.json","hash":"985fbcbf47054af714ead1a124869d54f2a8b607","modified":1626871710172},{"_id":"themes/icarus/include/schema/common/share.json","hash":"cf4f9ff4fb27c3541b35f57db355c228fa6873e4","modified":1626871710172},{"_id":"themes/icarus/include/schema/common/sidebar.json","hash":"eb241beaec4c73e3085dfb3139ce72e827e20549","modified":1626871710172},{"_id":"themes/icarus/include/schema/common/widgets.json","hash":"d000b4d1d09bdd64756265aa4cd2ea980ab7ddc7","modified":1626871710173},{"_id":"themes/icarus/include/schema/plugin/animejs.json","hash":"e62ab6e20bd8862efa1ed32e7c0db0f8acbcfdec","modified":1626871710173},{"_id":"themes/icarus/include/schema/plugin/back_to_top.json","hash":"dc0febab7e7b67075d0ad3f80f5ec8b798b68dea","modified":1626871710174},{"_id":"themes/icarus/include/schema/widget/profile.json","hash":"e801d302e680b4256f89b35d9caff7c9a0b0d178","modified":1626965515768},{"_id":"source/_posts/2021-04-07 Jetpack Compose Part 2/1_ybDWG4W2bPYNq79vr1gE8w.png","hash":"6fe0ceafc9915691608eef8ec7e77e066d68ce2f","modified":1627195804776},{"_id":"source/_posts/2021-05-19 Android UI Rendering Optimization Part 2/cK00ybR.png","hash":"00568c975badabd8f3a34ed80010cb0c1dff7858","modified":1627202775772},{"_id":"source/_posts/2021-06-24 Image Loading and Caching Library Part 2/Screenshot_1624078627.png","hash":"1bc61f65ecedd54e42b4e9b36b12b51d2dd7d31c","modified":1627218933198},{"_id":"source/_posts/2021-05-19 Android UI Rendering Optimization Part 2/1ZQEOg0.png","hash":"298ed70f7e45a45b535692f8cd0dc26e4ac203f2","modified":1627202879259},{"_id":"source/_posts/2021-05-19 Android UI Rendering Optimization Part 2/ptHtNno.png","hash":"050745bd3e63e9c93d3680c16bd8057257745665","modified":1627202690833},{"_id":"source/_posts/2021-06-24 Image Loading and Caching Library Part 2/IMG_06A0242D2ABE-1.jpg","hash":"db9d640eb79429bbe63537a9698ced34b9d29741","modified":1627218968945},{"_id":"source/_posts/2021-07-21 Kotlin Symbol Processing Api Part 2/ClassDiagram.svg","hash":"61d495eb303ce426aa371518ff39e0118cc34f50","modified":1628753259178},{"_id":"source/images/cover_ksp.png","hash":"7e6e4981dc0112b925e9506dfd503ed95ce06637","modified":1628753259180},{"_id":"source/_posts/2021-04-07 Jetpack Compose Part 1/compose_animation.gif","hash":"3045c10cf0a91ce3907c24026a381134b0674f24","modified":1627100104526},{"_id":"source/_posts/2021-04-07 Jetpack Compose Part 3/add_002_002.png","hash":"b6c651b7403cc7c29e41fb3ba13177081c381621","modified":1627197460431},{"_id":"source/_posts/2021-05-19 Android UI Rendering Optimization Part 1/7AGranC.png","hash":"efb008bffb6016c91d56c468680ea2c56272711b","modified":1627201959822},{"_id":"source/_posts/2021-07-21 Kotlin Symbol Processing Api Part 1/processing_rounds.png","hash":"90aa4c057fb520245e4db67310ab93d84b2401d2","modified":1628753259177},{"_id":"source/_posts/2021-06-24 Image Loading and Caching Library Part 1/IMG_8FF7402ED110-1.jpg","hash":"0e35a673de5a4bbd788adcbec13325c3d127b7a9","modified":1627218337563},{"_id":"source/_posts/2021-06-24 Image Loading and Caching Library Part 1/coil_caching.gif","hash":"bde7beac3e050248aeded688e1c4f2dd6c918c37","modified":1627218420261},{"_id":"source/_posts/2021-05-19 Android UI Rendering Optimization Part 3/zw3H5pZ.png","hash":"380b169de9250a0f2f99ef1db243598b2dcf06f9","modified":1627205159509},{"_id":"source/_posts/2021-06-24 Image Loading and Caching Library Part 1/IMG_9F5E046409C4-1.jpg","hash":"6cb839e17e7e42316078b7acde21e37486d61e3f","modified":1627218179234},{"_id":"source/_posts/2021-06-24 Image Loading and Caching Library Part 1/picasso_caching.gif","hash":"a327e9dab98a059c81896074044ef8b940496d2e","modified":1627218074820},{"_id":"source/_posts/2021-06-24 Image Loading and Caching Library Part 1/glide_caching.gif","hash":"eef2348b6b077d7e361fe3c22c6e72a50a5d1707","modified":1627218274604},{"_id":"source/_posts/2021-05-19 Android UI Rendering Optimization Part 2/n6fsbPA.png","hash":"e6ceac60a769b34ce7eb0f71929950ecae487020","modified":1627202847808},{"_id":"source/_posts/2021-06-24 Image Loading and Caching Library Part 1/coil_test.gif","hash":"2f56dfb1f5dcb99bbd30f70c4ef1960c9e7c9feb","modified":1627218417539},{"_id":"source/_posts/2021-06-24 Image Loading and Caching Library Part 1/glide_test.gif","hash":"a418ec06099fe9ed0ffeb48fe1a5c053e04f0a8e","modified":1627218272406},{"_id":"source/_posts/2021-06-24 Image Loading and Caching Library Part 1/picasso_test.gif","hash":"82c5439dd99073b331626a6da8668bd1a56154ea","modified":1627218063932},{"_id":"source/_posts/2021-06-24 Image Loading and Caching Library Part 1/glide_gif.gif","hash":"42ef9fa37a30979eecea95c255d39472a931e4a0","modified":1627218368838},{"_id":"public/js/algolia.js","hash":"a8df0c0abeeb4ee1d2d720161f3aea7339380704","modified":1628865618062},{"_id":"public/js/google_cse.js","hash":"1a9881669dfdeb2b3214074eee0d3e01e52db2c4","modified":1628865618062},{"_id":"public/js/insight.js","hash":"86bbdb7305d9bf19ad62d2ca2cf169fc8d9f9d31","modified":1628865618062},{"_id":"public/js/toc.js","hash":"da6fb757a1b083b8ed138bf29aad3a7bf8ec4f11","modified":1628865618062},{"_id":"public/content.json","hash":"de7bd4217142c1b4cc52f39c45d6d102dd44cdce","modified":1628865618062},{"_id":"public/manifest.json","hash":"e304ac116ed2377427b5d86fa1b011b9eaea0f10","modified":1628865618062},{"_id":"public/archives/page/2/index.html","hash":"1f297eed4a4157ef62070756cb3b2354fb9f5db7","modified":1628865618062},{"_id":"public/archives/2021/04/index.html","hash":"40b21cc16c90df6a6551a48e0424af104c8f33dc","modified":1628865618062},{"_id":"public/archives/2021/page/2/index.html","hash":"f97e34db2b3a4b111b484ae50b3829110e1a2158","modified":1628865618062},{"_id":"public/archives/2021/05/index.html","hash":"72ab350d4ff1a2b20adeeba0f7eeaf43e467f2e4","modified":1628865618062},{"_id":"public/archives/2021/06/index.html","hash":"6c269ee84e6178c33d862730abea4f48ab7063e1","modified":1628865618062},{"_id":"public/archives/2021/07/index.html","hash":"cfd68de2b5e0ff649f15efc9ec58f907e5d8b889","modified":1628865618062},{"_id":"public/2021/07/21/2021-07-21 Kotlin Symbol Processing Api Part 3/index.html","hash":"0e12bdde570f1c42a837418c7e31ec0fba179af5","modified":1628865618062},{"_id":"public/2021/07/21/2021-07-21 Kotlin Symbol Processing Api Part 1/index.html","hash":"a1487c09363b7879ae685550db83d5100d2aa0df","modified":1628865618062},{"_id":"public/2021/07/21/2021-07-21 Kotlin Symbol Processing Api Part 2/index.html","hash":"1324399ab2922840248410cd75035f96b6393763","modified":1628865618062},{"_id":"public/2021/06/24/2021-06-24 Image Loading and Caching Library Part 3/index.html","hash":"1350ba99c9cc1b036331203b15b459bdada4a6b2","modified":1628865618062},{"_id":"public/2021/06/24/2021-06-24 Image Loading and Caching Library Part 1/index.html","hash":"2608e22f71b720486cf36e87c9a8ab40f336617f","modified":1628865618062},{"_id":"public/2021/06/24/2021-06-24 Image Loading and Caching Library Part 2/index.html","hash":"f52560035a43640872e2d1993b6247b067d39ea4","modified":1628865618062},{"_id":"public/2021/05/19/2021-05-19 Android UI Rendering Optimization Part 3/index.html","hash":"42e39d4d79ac15d6d4b7f131b8330d186ed76d17","modified":1628865618062},{"_id":"public/2021/05/19/2021-05-19 Android UI Rendering Optimization Part 2/index.html","hash":"9e081293481b296d88790f4db3c930b3f0bf3b2f","modified":1628865618062},{"_id":"public/2021/05/19/2021-05-19 Android UI Rendering Optimization Part 1/index.html","hash":"2585c170fa243568ebb512e15275d65bbf0d6543","modified":1628865618062},{"_id":"public/2021/04/07/2021-04-07 Jetpack Compose Part 3/index.html","hash":"7a95aa07cce095ecee03605e878542a5585024ee","modified":1628865618062},{"_id":"public/2021/04/07/2021-04-07 Jetpack Compose Part 2/index.html","hash":"2811aa3ad27e947391b3936964be9f2dd385a43e","modified":1628865618062},{"_id":"public/2021/04/07/2021-04-07 Jetpack Compose Part 1/index.html","hash":"b53447061c6f5a16f3113ddf45a628b4f9841a82","modified":1628865618062},{"_id":"public/archives/index.html","hash":"9caba5500135ad7a3d73c3e5b361db95ec3bce50","modified":1628865618062},{"_id":"public/archives/2021/index.html","hash":"43d174b85c979fc103717e711b14c8c2002e8e75","modified":1628865618062},{"_id":"public/categories/Jetpack-Compose/index.html","hash":"3ac841f4d8d7ef92fd89c509859372ab3fad1898","modified":1628865618062},{"_id":"public/categories/User-Interface/index.html","hash":"3d2def097e736202bea6d2b8f3a3dad61862837e","modified":1628865618062},{"_id":"public/categories/Image-Library/index.html","hash":"66ab7829dfc4bc4e1d71a3ca3b8fc17641fd0068","modified":1628865618062},{"_id":"public/categories/KSP/index.html","hash":"a7dd7aa8aaa2bc4767a4ce60346ca3e0384948a6","modified":1628865618062},{"_id":"public/index.html","hash":"62f607da83baa4698546bb66d51468dc189bbc42","modified":1628865618062},{"_id":"public/page/2/index.html","hash":"d402bbb17f5f3ddf14d292d939ce2ca2697e9e9e","modified":1628865618062},{"_id":"public/tags/Android/index.html","hash":"33a7a575c511144faa39d2e4ce2935b110331dc8","modified":1628865618062},{"_id":"public/tags/Compose/index.html","hash":"aaf616eded3b95c8e088d9156099b817f0452907","modified":1628865618062},{"_id":"public/tags/Jetpack/index.html","hash":"dd7797c4713cc114e49a4a72b09c6cc667f818c5","modified":1628865618062},{"_id":"public/tags/Rendering/index.html","hash":"bd045a1c505ce0fb57d7a5cf62a6f43057000b1d","modified":1628865618062},{"_id":"public/tags/Principle/index.html","hash":"ca8f0a8b46b23bea825b3f0f5c00a43143a2da80","modified":1628865618062},{"_id":"public/tags/Optimize/index.html","hash":"c9e13f0d9ee01388f6dc3aa26b39f1c357ddde9f","modified":1628865618062},{"_id":"public/tags/UI/index.html","hash":"11c9eae647415850c0fb461ab0fadcc91016075f","modified":1628865618062},{"_id":"public/tags/Image/index.html","hash":"8cd44d0d7b13faf24dbeb07b4ac7312f9062a797","modified":1628865618062},{"_id":"public/tags/Library/index.html","hash":"f05658c3caec8e267ff928f838ebb63aa81e8abf","modified":1628865618062},{"_id":"public/tags/KSP/index.html","hash":"0729826db7b2785c0efc6fd369ffe3e53c4c962e","modified":1628865618062},{"_id":"public/tags/Kotlin/index.html","hash":"acf43f0fba0d6b74dde98ae56ff2c413ac586247","modified":1628865618062},{"_id":"public/tags/Symbol/index.html","hash":"d2620e2b6f6bf3943bacc5ee36551c4cc8101598","modified":1628865618062},{"_id":"public/tags/Processing/index.html","hash":"ba1ae1d9ce2e9ea5c4a7f36768e76dcb9cf6db71","modified":1628865618062},{"_id":"public/tags/KAPT/index.html","hash":"b1d549f7e9033e5e7bc9d62b35df422308d17969","modified":1628865618062},{"_id":"public/tags/Annotation/index.html","hash":"03509f34b1cc478380f9dc60fc4d152e09a93ad1","modified":1628865618062},{"_id":"public/categories/index.html","hash":"3bc3febf368122d9c6a512a5f2d1b34e3db21571","modified":1628865618062},{"_id":"public/tags/index.html","hash":"ec8945437558a6cf16acb8d4d8b87be2824f812e","modified":1628865618062},{"_id":"public/img/avatar.png","hash":"5f294e72d6b2385e2f7f946ded9f06ca9f3cf6c6","modified":1628865618062},{"_id":"public/img/favicon.png","hash":"11c336162b4b87962f1e58c06e6d1c1b23eb5d45","modified":1628865618062},{"_id":"public/img/logo.png","hash":"be05b47728f1276b913de1191bd7df1929cfbf5d","modified":1628865618062},{"_id":"public/img/favicon.svg","hash":"16fd847265845063a16596761cddb32926073dd2","modified":1628865618062},{"_id":"public/img/logo.svg","hash":"e9b5c1438ddb576693a15d0713b2a1d9ceda4be9","modified":1628865618062},{"_id":"public/img/og_image.png","hash":"b03f163096ca9c350ec962feee9836277b5c2509","modified":1628865618062},{"_id":"public/img/razor-bottom-black.svg","hash":"a3eda07b1c605b456da9cdf335a1075db5e5d72c","modified":1628865618062},{"_id":"public/img/razor-top-black.svg","hash":"201f1171a43ce667a39091fe47c0f278857f18f0","modified":1628865618062},{"_id":"public/images/cover_image_library.png","hash":"9d10dac56e57d04551477524caf9214157925393","modified":1628865618062},{"_id":"public/images/cover_system_ui.png","hash":"fb20cd5f11731675f596caf148535970f950fe9b","modified":1628865618062},{"_id":"public/images/cover_jepack_compose.png","hash":"0f17f71dd25d58a7b9220a5d88354d247249e695","modified":1628865618062},{"_id":"public/2021/04/07/2021-04-07 Jetpack Compose Part 1/aO6Jlsg.png","hash":"cb2a6385373460ed62d557f5fd6857b9add5154b","modified":1628865618062},{"_id":"public/2021/04/07/2021-04-07 Jetpack Compose Part 1/WprDTs1.png","hash":"1e7a9e83f70a8a888576c9414310dc2c5ecd42b6","modified":1628865618062},{"_id":"public/2021/04/07/2021-04-07 Jetpack Compose Part 2/1_5RZOM7sWV0sXctJtTPdshQ.png","hash":"ffe02f83fee60952e843f6851f901bea72ce9dca","modified":1628865618062},{"_id":"public/2021/04/07/2021-04-07 Jetpack Compose Part 2/1_9IA2k2s5hAS9pSyzpmQ6Pw.png","hash":"2b7af6d2978089bb374422102202071ab277d7b0","modified":1628865618062},{"_id":"public/2021/04/07/2021-04-07 Jetpack Compose Part 2/1_UoLVl1dbUjKh9kd4uY0ROA.png","hash":"11b60f2e071153fcbe560e89aaef163a87ad142e","modified":1628865618062},{"_id":"public/2021/04/07/2021-04-07 Jetpack Compose Part 2/1_T9Pww7JyPMPhCJ_6yU8fyQ.png","hash":"54f618490e46ada03f3a75d198acc1c7ddc0f321","modified":1628865618062},{"_id":"public/2021/04/07/2021-04-07 Jetpack Compose Part 2/1_XVvr-CB2pn88Te7Gg52GPA.png","hash":"fc39b18462260b52dc5a6bab6f2cc387b257ede9","modified":1628865618062},{"_id":"public/2021/04/07/2021-04-07 Jetpack Compose Part 2/1_m7mSalYCza-SoJjmlYeWdA.png","hash":"d5d4958f6e2304ad94f4dc38104c99b9173376b5","modified":1628865618062},{"_id":"public/2021/04/07/2021-04-07 Jetpack Compose Part 2/1_bSyX8yT7H2HevBNw9fbyYw.png","hash":"dffd3bbd66021f82170b9067b5826289b15bd4cb","modified":1628865618062},{"_id":"public/2021/04/07/2021-04-07 Jetpack Compose Part 2/1_tPAf-Akf2IpDRrrZo1f1dg.png","hash":"67bb69909c81fcebf26ce429115685c0c0aa3bae","modified":1628865618062},{"_id":"public/2021/04/07/2021-04-07 Jetpack Compose Part 2/1_wFM4jF71V5aJog3lALaRKQ.png","hash":"7cc0b73358aa886719fb51ccb88413fa740b38e9","modified":1628865618062},{"_id":"public/2021/04/07/2021-04-07 Jetpack Compose Part 2/add_002_001.png","hash":"7c35a0d3efc17ff4a8f4eb8a1d8c3a589dac2db3","modified":1628865618062},{"_id":"public/2021/05/19/2021-05-19 Android UI Rendering Optimization Part 1/EzHZMUm.png","hash":"e3dcee986a1f76c3c2ea0ccc1c9eecc1214d67a3","modified":1628865618062},{"_id":"public/2021/05/19/2021-05-19 Android UI Rendering Optimization Part 1/UntitledDiagram.png","hash":"b68cd0059aaaecf07dbab3022d520f09f06738e2","modified":1628865618062},{"_id":"public/2021/05/19/2021-05-19 Android UI Rendering Optimization Part 1/qu5Mr6x.png","hash":"594c20fd4933bcb82a65637f0e8339456277d9eb","modified":1628865618062},{"_id":"public/2021/05/19/2021-05-19 Android UI Rendering Optimization Part 2/4.png","hash":"b370fb9f3328a259420945173c0830594f008bba","modified":1628865618062},{"_id":"public/2021/05/19/2021-05-19 Android UI Rendering Optimization Part 2/7990Bf0.png","hash":"855bcdec520ce2b85ad119ff869059c006a7f89d","modified":1628865618062},{"_id":"public/2021/05/19/2021-05-19 Android UI Rendering Optimization Part 2/image-1.png","hash":"59da23e7f344900920338920b9be39158ea8c03e","modified":1628865618062},{"_id":"public/2021/05/19/2021-05-19 Android UI Rendering Optimization Part 2/image.png","hash":"05307b5c204033dfb679b0da0b35eb93d03e5127","modified":1628865618062},{"_id":"public/2021/05/19/2021-05-19 Android UI Rendering Optimization Part 3/gpu_profile.png","hash":"92eb4ea0978a9a2f8d392e2e6e1c0a08845704dd","modified":1628865618062},{"_id":"public/2021/05/19/2021-05-19 Android UI Rendering Optimization Part 3/graph_color.png","hash":"4e5e3364237d63abb0e2593176d88ac774fa84ca","modified":1628865618062},{"_id":"public/2021/05/19/2021-05-19 Android UI Rendering Optimization Part 3/image.png","hash":"05307b5c204033dfb679b0da0b35eb93d03e5127","modified":1628865618062},{"_id":"public/2021/05/19/2021-05-19 Android UI Rendering Optimization Part 3/overdrawn_1.png","hash":"8463613a962832bb022985971c157193e1d421da","modified":1628865618062},{"_id":"public/2021/05/19/2021-05-19 Android UI Rendering Optimization Part 3/overdrawn_2.png","hash":"9b070bf77d97d74b4986c838cebb375872d9d748","modified":1628865618062},{"_id":"public/2021/05/19/2021-05-19 Android UI Rendering Optimization Part 3/overdrawn_3.png","hash":"8d7bca48042bd3de4bcf2385d024791e77297b81","modified":1628865618062},{"_id":"public/2021/05/19/2021-05-19 Android UI Rendering Optimization Part 3/overdrawn_4.png","hash":"d872a7e885a2cb8433beadcdcaf9a4257cce9fcb","modified":1628865618062},{"_id":"public/2021/06/24/2021-06-24 Image Loading and Caching Library Part 2/image.png","hash":"115dd7645f37ff98157ae2b4b63223eabcecaafb","modified":1628865618062},{"_id":"public/2021/06/24/2021-06-24 Image Loading and Caching Library Part 1/Screenshot_1623775512.png","hash":"52bb418f744f4cc1d98be5488aaf32f030369f0d","modified":1628865618062},{"_id":"public/2021/06/24/2021-06-24 Image Loading and Caching Library Part 3/BntHJ2Y-1.png","hash":"ec4826ed266043b069bba5c8692f0e3266be756f","modified":1628865618062},{"_id":"public/2021/06/24/2021-06-24 Image Loading and Caching Library Part 3/QafKUB1.png","hash":"853b656381d79fa28df6cac3ec0f54983328045d","modified":1628865618062},{"_id":"public/2021/06/24/2021-06-24 Image Loading and Caching Library Part 3/BntHJ2Y.png","hash":"ec4826ed266043b069bba5c8692f0e3266be756f","modified":1628865618062},{"_id":"public/2021/06/24/2021-06-24 Image Loading and Caching Library Part 3/TIrybR8.png","hash":"80e2e2f9b0ee58a857ac5a69ca110ca217107d58","modified":1628865618062},{"_id":"public/2021/06/24/2021-06-24 Image Loading and Caching Library Part 3/m7itaqy.png","hash":"a775273c03df6f608be713464615885fe06f677d","modified":1628865618062},{"_id":"public/2021/07/21/2021-07-21 Kotlin Symbol Processing Api Part 3/HyjEy1l.png","hash":"4da24729f65cbed64944db8960654cdfc5312c39","modified":1628865618062},{"_id":"public/2021/07/21/2021-07-21 Kotlin Symbol Processing Api Part 3/0HScWJk.png","hash":"410d0c6d93c29e9eed8fc3d5648401683cb76cc5","modified":1628865618062},{"_id":"public/2021/07/21/2021-07-21 Kotlin Symbol Processing Api Part 3/NjWXyw6.png","hash":"e6626f172649dcb0fa248b0d62b887e4ad28e8b4","modified":1628865618062},{"_id":"public/2021/07/21/2021-07-21 Kotlin Symbol Processing Api Part 3/rcWvgv0.png","hash":"d7f53e4ff16ee13f19f30f00ca699afa2e68af0c","modified":1628865618062},{"_id":"public/2021/04/07/2021-04-07 Jetpack Compose Part 1/1_5gfrQWfxyEC7Oq6b2xlJ9w.png","hash":"4612b82b8aaeb87d65092177d8a8179943c08ced","modified":1628865618062},{"_id":"public/2021/04/07/2021-04-07 Jetpack Compose Part 1/VLTxB8C.png","hash":"d37822b0cf3b0a6c6092faa237fb50b917a291c7","modified":1628865618062},{"_id":"public/images/cover_ui_rendering.png","hash":"ba9275bcac22bc1d658d52e72486ddd04817ec12","modified":1628865618062},{"_id":"public/2021/04/07/2021-04-07 Jetpack Compose Part 1/qgQ6oY4.png","hash":"7de89cfdcd8b8c0c88f0247648b9d5979d61f737","modified":1628865618062},{"_id":"public/2021/05/19/2021-05-19 Android UI Rendering Optimization Part 1/image.png","hash":"0ddca9ebe8f1b2f638a69ea59e35fc4a9e250a3e","modified":1628865618062},{"_id":"public/2021/05/19/2021-05-19 Android UI Rendering Optimization Part 3/example1.png","hash":"46c035f09667529176804fea518a1187985510c2","modified":1628865618062},{"_id":"public/2021/05/19/2021-05-19 Android UI Rendering Optimization Part 3/example2.png","hash":"57a32b74b701e2c7456aadcec8ea6f7db7e06a08","modified":1628865618062},{"_id":"public/2021/06/24/2021-06-24 Image Loading and Caching Library Part 1/coil_heap_dump.png","hash":"5075bd3f0e7d141e1eafda7543992bd32a6cf794","modified":1628865618062},{"_id":"public/2021/06/24/2021-06-24 Image Loading and Caching Library Part 1/glide_heap_dump.png","hash":"4843c8a41b204b8038ca97b58a13f7095a928624","modified":1628865618062},{"_id":"public/2021/06/24/2021-06-24 Image Loading and Caching Library Part 1/heap_dump.png","hash":"c58604ef40d3acc6c3e573f33bcd5861217ff15e","modified":1628865618062},{"_id":"public/2021/05/19/2021-05-19 Android UI Rendering Optimization Part 2/JNfYVx7.png","hash":"5ec4cd78e27b85ce7513f3afbe8ab1648876fc93","modified":1628865618062},{"_id":"public/2021/05/19/2021-05-19 Android UI Rendering Optimization Part 3/after_merge.png","hash":"bab66dea17776ea6ce52d510794b4fe01db1d5a0","modified":1628865618062},{"_id":"public/2021/05/19/2021-05-19 Android UI Rendering Optimization Part 3/gpu_rendering_profile_1.png","hash":"d605385d5c363bdc0c9500ae892d852936fc8b46","modified":1628865618062},{"_id":"public/2021/05/19/2021-05-19 Android UI Rendering Optimization Part 3/gpu_rendering_profile_2.png","hash":"2f7dce54e2b42c7c6a33e8b3d319b908593e6d0e","modified":1628865618062},{"_id":"public/2021/06/24/2021-06-24 Image Loading and Caching Library Part 3/0oDUU69.png","hash":"c2a367ee700f8e4bf56244ea8ef1e4987188ba81","modified":1628865618062},{"_id":"public/2021/06/24/2021-06-24 Image Loading and Caching Library Part 3/rb1bMMt.png","hash":"1aa58cbd1e91b335ef9023f5b58cd3754a1c6a5a","modified":1628865618062},{"_id":"public/js/animation.js","hash":"12cedd5caaf9109eed97e50eeab8f883f6e49be3","modified":1628865618062},{"_id":"public/js/column.js","hash":"0baee024ab67474c073a4c41b495f3e7f0df4505","modified":1628865618062},{"_id":"public/js/main.js","hash":"13e4b1c4fa287f3db61aae329ad093a81992f23d","modified":1628865618062},{"_id":"public/js/back_to_top.js","hash":"d91f10c08c726135a13dfa1f422c49d8764ef03f","modified":1628865618062},{"_id":"public/css/cyberpunk.css","hash":"33cb6e6c54af1717a2447f527d0ccf1a06502cb1","modified":1628865618062},{"_id":"public/css/default.css","hash":"d1be246b56d96525ef38324dd769a4d70b932124","modified":1628865618062},{"_id":"public/css/style.css","hash":"d1be246b56d96525ef38324dd769a4d70b932124","modified":1628865618062},{"_id":"public/2021/05/19/2021-05-19 Android UI Rendering Optimization Part 2/ha7Eriy.png","hash":"215f5dd7c94d383974afc86a7c97e6e94b4a5ca5","modified":1628865618062},{"_id":"public/2021/05/19/2021-05-19 Android UI Rendering Optimization Part 3/before_merge.png","hash":"33ddb5b572f4683762679075bd76caa3e1f2209f","modified":1628865618062},{"_id":"public/2021/04/07/2021-04-07 Jetpack Compose Part 2/1_ybDWG4W2bPYNq79vr1gE8w.png","hash":"6fe0ceafc9915691608eef8ec7e77e066d68ce2f","modified":1628865618062},{"_id":"public/2021/05/19/2021-05-19 Android UI Rendering Optimization Part 2/cK00ybR.png","hash":"00568c975badabd8f3a34ed80010cb0c1dff7858","modified":1628865618062},{"_id":"public/2021/06/24/2021-06-24 Image Loading and Caching Library Part 2/Screenshot_1624078627.png","hash":"1bc61f65ecedd54e42b4e9b36b12b51d2dd7d31c","modified":1628865618062},{"_id":"public/2021/05/19/2021-05-19 Android UI Rendering Optimization Part 2/1ZQEOg0.png","hash":"298ed70f7e45a45b535692f8cd0dc26e4ac203f2","modified":1628865618062},{"_id":"public/2021/05/19/2021-05-19 Android UI Rendering Optimization Part 2/ptHtNno.png","hash":"050745bd3e63e9c93d3680c16bd8057257745665","modified":1628865618062},{"_id":"public/2021/06/24/2021-06-24 Image Loading and Caching Library Part 2/IMG_06A0242D2ABE-1.jpg","hash":"db9d640eb79429bbe63537a9698ced34b9d29741","modified":1628865618062},{"_id":"public/2021/07/21/2021-07-21 Kotlin Symbol Processing Api Part 2/ClassDiagram.svg","hash":"61d495eb303ce426aa371518ff39e0118cc34f50","modified":1628865618062},{"_id":"public/images/cover_ksp.png","hash":"7e6e4981dc0112b925e9506dfd503ed95ce06637","modified":1628865618062},{"_id":"public/2021/04/07/2021-04-07 Jetpack Compose Part 3/add_002_002.png","hash":"b6c651b7403cc7c29e41fb3ba13177081c381621","modified":1628865618062},{"_id":"public/2021/04/07/2021-04-07 Jetpack Compose Part 1/compose_animation.gif","hash":"3045c10cf0a91ce3907c24026a381134b0674f24","modified":1628865618062},{"_id":"public/2021/05/19/2021-05-19 Android UI Rendering Optimization Part 1/7AGranC.png","hash":"efb008bffb6016c91d56c468680ea2c56272711b","modified":1628865618062},{"_id":"public/2021/07/21/2021-07-21 Kotlin Symbol Processing Api Part 1/processing_rounds.png","hash":"90aa4c057fb520245e4db67310ab93d84b2401d2","modified":1628865618062},{"_id":"public/2021/06/24/2021-06-24 Image Loading and Caching Library Part 1/IMG_8FF7402ED110-1.jpg","hash":"0e35a673de5a4bbd788adcbec13325c3d127b7a9","modified":1628865618062},{"_id":"public/2021/06/24/2021-06-24 Image Loading and Caching Library Part 1/coil_caching.gif","hash":"bde7beac3e050248aeded688e1c4f2dd6c918c37","modified":1628865618062},{"_id":"public/2021/05/19/2021-05-19 Android UI Rendering Optimization Part 3/zw3H5pZ.png","hash":"380b169de9250a0f2f99ef1db243598b2dcf06f9","modified":1628865618062},{"_id":"public/2021/06/24/2021-06-24 Image Loading and Caching Library Part 1/picasso_caching.gif","hash":"a327e9dab98a059c81896074044ef8b940496d2e","modified":1628865618062},{"_id":"public/2021/06/24/2021-06-24 Image Loading and Caching Library Part 1/IMG_9F5E046409C4-1.jpg","hash":"6cb839e17e7e42316078b7acde21e37486d61e3f","modified":1628865618062},{"_id":"public/2021/06/24/2021-06-24 Image Loading and Caching Library Part 1/glide_caching.gif","hash":"eef2348b6b077d7e361fe3c22c6e72a50a5d1707","modified":1628865618062},{"_id":"public/2021/06/24/2021-06-24 Image Loading and Caching Library Part 1/coil_test.gif","hash":"2f56dfb1f5dcb99bbd30f70c4ef1960c9e7c9feb","modified":1628865618062},{"_id":"public/2021/05/19/2021-05-19 Android UI Rendering Optimization Part 2/n6fsbPA.png","hash":"e6ceac60a769b34ce7eb0f71929950ecae487020","modified":1628865618062},{"_id":"public/2021/06/24/2021-06-24 Image Loading and Caching Library Part 1/glide_test.gif","hash":"a418ec06099fe9ed0ffeb48fe1a5c053e04f0a8e","modified":1628865618062},{"_id":"public/2021/06/24/2021-06-24 Image Loading and Caching Library Part 1/picasso_test.gif","hash":"82c5439dd99073b331626a6da8668bd1a56154ea","modified":1628865618062},{"_id":"public/2021/06/24/2021-06-24 Image Loading and Caching Library Part 1/glide_gif.gif","hash":"42ef9fa37a30979eecea95c255d39472a931e4a0","modified":1628865618062}],"Category":[{"name":"Jetpack Compose","_id":"cksagj7ku00023lredvpg7r2d"},{"name":"User Interface","_id":"cksagj7l7000d3lre98av44g2"},{"name":"Image Library","_id":"cksagj7lv001t3lre61by7gxv"},{"name":"KSP","_id":"cksagj7m100253lre15wh1kot"}],"Data":[],"Page":[],"Post":[{"title":"Jetpack Compose Part 1 - Compose 소개 및 코드랩 따라하기","date":"2021-04-06T16:00:00.000Z","cover":"https://androiddeepdive.github.io/Team-Blog/images/cover_jepack_compose.png","_content":"\n<article class=\"message message-immersive is-primary\">\n    <div class=\"message-body\">\n        <i class=\"fas fa-pen-fancy mr-2\"></i>Writers<br>\n        by 김남훈 @Naver<br>\n        by 배희성 @RocketPunch<br>\n        by 송시영 @SmartStudy<br>\n        by 이기정 @BankSalad\n    </div>\n</article>\n\n<!-- more -->\n\n## Jetpack Compose란 무엇인가?\n\n{% asset_img compose_animation.gif [compose_animation] %}\n\n> **출처** [Android Developers#Jetpack Compse](https://developer.android.com/jetpack/compose)\n\nCompose는 Native UI를 코드레벨로 구현할 수 있는 최신 툴킷이다. \n\n기존의 뷰를 업데이트하는 방식과 달리 Compose를 사용하면 필요한 영역의 뷰를 다시 그려주는 방식으로 작업할 수 있다.\n\n아래는 아주 간단한 예제이다.\n\n```kotlin\n@Composable\nfun Greeting(name: String) {\n\tText(\"Hello $name\")\n}\n```\n\n위의 예제처럼 UI를 구성하는 것이 아니라 화면을 구성하는 뷰의 State 설명하는 것이므로 아무것도 반환하지 않는다.\n\n아래는 공식 서비스 소개 영상이다.\n\n{% youtube U5BwfqBpiWU %}\n\n### Compose의 4가지 특징\n\n구글에서 설명하는 Compose를 이용시 얻을 수 있는 장점은 아래와 같다.\n\n- `Less Code` - 코드 감소\n  - 적은 수의 코드로 더 많은 작업을 하고 전체 버그 클래스를 방지할 수 있으므로 코드가 간단하며 유지 관리하기 쉽습니다.\n- `Intuitive` - 직관적\n  - UI만 설명하면 나머지는 Compose에서 처리합니다. 앱 상태가 변경되면 UI가 자동으로 업데이트됩니다.\n- `Accelerate Development` - 빠른 개발 과정\n  - 기존의 모든 코드와 호환되므로 언제 어디서든 원하는 대로 사용할 수 있습니다. 실시간 미리보기 및 완전한 Android 스튜디오 지원으로 빠르게 반복할 수 있습니다.\n- `Powerful` - 강력한 성능\n  - Android 플랫폼 API에 직접 액세스하고 머티리얼 디자인, 어두운 테마, 애니메이션 등을 기본적으로 지원하는 멋진 앱을 만들 수 있습니다.\n\n늘 그렇듯 구글에서 말하는 설명만 보면 안 쓸 이유가 없어보이고, 대세가 된다면 Android 개발자에게 또 하나의 러닝커브로 작용할 것이다.\n\n## Codelab - Jetpack Compose basics\n\n### 1. 시작하기전에\n\nCompose는 아직 정식으로 릴리즈되지 않은 기능이므로 Android Studio Canary에서 프로젝트를 구성하며 몇 가지 제한사항이 존재한다.\n\n1. Android Studio Canary \n\nCanary는 아래 링크에서 다운 받을 수 있다.\n\n> [Android Studio Preview](https://developer.android.com/studio/preview)\n\n2. 최신 버전의 Kotlin plugin \n\n```groovy\next.kotlin_version = '1.4.31'\n```\n\n3. buildFeatures 및 composeOption 활성화\n\n```groovy\nandroid {\n    ...\n    buildFeatures {\n        compose true\n    }\n    composeOptions {\n        kotlinCompilerExtensionVersion 1.0.0-beta02\n    }\n}\n\ndependencies {\n    ...\n    implementation \"androidx.compose.ui:ui:1.0.0-beta02\"\n    implementation \"androidx.activity:activity-compose:1.3.0-alpha03\"\n    implementation \"androidx.compose.material:material:1.0.0-beta02\"\n    implementation \"androidx.compose.ui:ui-tooling:1.0.0-beta02\"\n    ...\n}\n```\n\n### 2. Empty Compose 프로젝트 생성\n\n[File] - [New] - [New Project…] 를 눌러 새로운 프로젝트를 선택하고(Preview) Empty Compose Activity 를 선택한다.\n\n{% asset_img 1_5gfrQWfxyEC7Oq6b2xlJ9w.png [1_5gfrQWfxyEC7Oq6b2xlJ9w] %}\n\n선택 이후 Next를 클릭하고, Compose를 구현할 수 있는 최소 API 레벨인 21을 선택해야한다.\n\n프로젝트를 생성하면 아래와 같이 app/build.gradle에 의존성 설정 및 추가가 되어 있는것을 알 수 있다.\n\n```groovy\nandroid {\n    ...\n    kotlinOptions {\n        jvmTarget = '1.8'\n        useIR = true\n    }\n    buildFeatures {\n        compose true\n    }\n    composeOptions {\n        kotlinCompilerExtensionVersion compose_version\n    }\n}\n\ndependencies {\n    ...\n    implementation \"androidx.compose.ui:ui:$compose_version\"\n    implementation \"androidx.activity:activity-compose:1.3.0-alpha03\"\n    implementation \"androidx.compose.material:material:$compose_version\"\n    implementation \"androidx.compose.ui:ui-tooling:$compose_version\"\n    ...\n}\n```\n\n이때 composeOptions 설정에서 kotlinCompilerVersion 에 따라 compose 가 다르게 동작할 수 있음을 유의하자.\n\n프로젝트를 생성하면 아래와 같은 기본 파일들이 생성된다.\n\n**MainActivity.kt**\n```kotlin\nclass MainActivity : AppCompatActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContent {\n            MyFirstComposeApplicationTheme {\n                // A surface container using the 'background' color from the theme\n                Surface(color = MaterialTheme.colors.background) {\n                    Greeting(\"Android\")\n                }\n            }\n        }\n    }\n}\n\n@Composable\nfun Greeting(name: String) {\n    Text(text = \"Hello $name!\")\n}\n\n@Preview(showBackground = true)\n@Composable\nfun DefaultPreview() {\n    MyFirstComposeApplicationTheme {\n        Greeting(\"Android\")\n    }\n}\n```\n\n**ui/theme/Theme.kt**\n```kotlin\nprivate val DarkColorPalette = darkColors(\n    primary = Purple200,\n    primaryVariant = Purple700,\n    secondary = Teal200\n)\n\nprivate val LightColorPalette = lightColors(\n    primary = Purple500,\n    primaryVariant = Purple700,\n    secondary = Teal200*\n\n    /* Other default colors to override\n    background = Color.White,\n    surface = Color.White,\n    onPrimary = Color.White,\n    onSecondary = Color.Black,\n    onBackground = Color.Black,\n    onSurface = Color.Black,\n    */\n)\n\n@Composable\nfun MyFirstComposeApplicationTheme(darkTheme: Boolean = isSystemInDarkTheme(), content: @Composable () -> Unit) {\n    val colors = if (darkTheme) {\n        DarkColorPalette*\n    } else {\n        LightColorPalette*\n    }\n\n    MaterialTheme(\n        colors = colors,\n        typography = Typography,\n        shapes = Shapes,\n        content = content\n    )\n}\n```\n\n기본 생성된 코드를 보았을 때, Compose는 총 3가지의 구성 요소를 가지는 것으로 추측할 수 있다.\n\n1. 위젯을 포함하는 Composable 함수\n2. Preview를 하기 위한 Preview Composable 함수\n3. setContent 람다 표현식으로 실제 화면에 노출하는 코드\n\n일반적으로 우리가 아는 Activity의 라이프사이클 콜백 `onCreate()`에서   `setContentView(Int)` 함수를 호출하던것이 `setContent()` 함수로 바뀐것이 가장 큰 특징으로 보여진다.\n\n### 3. Composable Function\n\nComposable Function은 어노테이션을 이용한 기술이다. 함수위에 `@Composable` 어노테이션을 붙이게 되면 함수 안 다른 함수를 호출할 수 있게된다. 아래 코드를 보자.\n\n```kotlin\n@Composable\nfun Greeting(names: List<String>) {\n    for (name in names) {\n        Text(\"Hello $name\")\n    }\n}\n```\n\n단순하게 내부에는 Text라는 함수가 존재하는데, 이를 통해 UI계층 별 요구하는 컴포넌트를 생성해준다. 기본적으로 보이는 text 파라미터는 내부 속성에서 받는 일부 중 하나이다.\n\n### 4. TextView 만들기\n\n위 코드를 실행시켜보면 당연하게도 Hello로 시작하는 TextView가 화면에 그려질것을 암시한다.\n\n```kotlin\nsetContent {\n  BasicsCodelabTheme {\n    // A surface container using the 'background' color from the theme\n    Surface(color = MaterialTheme.colors.background) {\n      Greeting(\"Android\")\n    }\n  }\n}\n```\n\n{% asset_img aO6Jlsg.png [aO6Jlsg] %}\n\n### 5. `@Preview`\n\n말 그대로 어노테이션을 이용하여 IDE에서 Preview를하기 위한 용도이다. 아래 코드와 같이 @Preview 어노테이션을 추가하면 다음 결과를 볼 수 있다.\n\n```kotlin\n@Preview(\"Greeting Preview\")\n@Composable\nfun GreetingPreview() {\n    BasicsCodelabTheme {\n        Surface(color = MaterialTheme.colors.background) {\n            Greeting(\"Android\")\n        }\n    }\n}\n```\n\n{% asset_img WprDTs1.png [WprDTs1] %}\n\n### 6. setContent / Theme / Surface\n\n```kotlin\nsetContent {\n  BasicsCodelabTheme {\n    // A surface container using the 'background' color from the theme\n    Surface(color = MaterialTheme.colors.background) {\n      Greeting(\"Android\")\n    }\n  }\n}\n```\n\n기존에 onCreate시점에 화면을 그려주기 위한 필수적인 요소를 정리해보자면\n\n- **setContent** : Activity에서 setContentView함수를 사용하는 것과 동일한 동작을 하는 확장함수이다. 다만, setContent의 경우 (@Composable) -> Unit 타입의 컴포즈 UI를 구현해주어야한다.\n\n- **XXXTheme** : Theme정보를 의미한다. 해당 프로젝트에서는 Theme.kt에 여러 테마에 필요한 정보를 정리하고, 컴포즈 UI 구현을 위한 코드를 작성해두었다.\n\n```kotlin\nprivate val DarkColorPalette = darkColors(\n    primary = purple200,\n    primaryVariant = purple700,\n    secondary = teal200\n)\n\nprivate val LightColorPalette = lightColors(\n    primary = purple500,\n    primaryVariant = purple700,\n    secondary = teal200\n\n    /* Other default colors to override\n    background = Color.White,\n    surface = Color.White,\n    onPrimary = Color.White,\n    onSecondary = Color.Black,\n    onBackground = Color.Black,\n    onSurface = Color.Black,\n    */\n)\n\n@Composable\nfun BasicsCodelabTheme(\n    darkTheme: Boolean = isSystemInDarkTheme(),\n    content: @Composable () -> Unit\n) {\n    val colors = if (darkTheme) {\n        DarkColorPalette\n    } else {\n        LightColorPalette\n    }\n\n    MaterialTheme(\n        colors = colors,\n        typography = typography,\n        shapes = shapes,\n        content = content\n    )\n}\n```\n\n- **Surface** : Greeting을 감싸는 뷰에 해당한다. 여기서는 크기를 정하지 않고, background 색상을 정의하고 있다. 역시 람다 표현식이다. 색상에 대한 Paramter로 `color` 라는 값을 사용하여 부여가 가능하다. 내부코드를 보면\n\n```kotlin\n@Composable\nfun Surface(\n    modifier: Modifier = Modifier,\n    shape: Shape = RectangleShape,\n    color: Color = MaterialTheme.colors.surface,\n    contentColor: Color = contentColorFor(color),\n    border: BorderStroke? = null,\n    elevation: Dp = 0.dp,\n    content: @Composable () -> Unit\n) {\n    val elevationPx = with(LocalDensity.current) { elevation.toPx() }\n    val elevationOverlay = LocalElevationOverlay.current\n    val absoluteElevation = LocalAbsoluteElevation.current + elevation\n    val backgroundColor = if (color == MaterialTheme.colors.surface && elevationOverlay != null) {\n        elevationOverlay.apply(color, absoluteElevation)\n    } else {\n        color\n    }\n    CompositionLocalProvider(\n        LocalContentColor provides contentColor,\n        LocalAbsoluteElevation provides absoluteElevation\n    ) {\n        Box(\n            modifier.graphicsLayer(shadowElevation = elevationPx, shape = shape)\n                .then(if (border != null) Modifier.border(border, shape) else Modifier)\n                .background(\n                    color = backgroundColor,\n                    shape = shape\n                )\n                .clip(shape),\n            propagateMinConstraints = true\n        ) {\n            content()\n        }\n    }\n}\n```\n\n### 7. Declarative UI - 선언형 UI\n\n노란색 배경을 입혀 기존 TextView에 추가해보았다. 또한, Greeting에는 Modifier라는 것을 이용하여 Padding을 추가했다. 아래와 같은 결과가 나오게 되었다.\n\n```kotlin\nBasicsCodelabTheme {\n  // A surface container using the 'background' color from the theme\n  Surface(color = Color.Yellow) {\n    Greeting(\"Android\")\n  }\n}\n```\n\n```kotlin\n@Composable\nfun Greeting(name: String) {\n    var isSelected by remember { mutableStateOf(false) }\n    val backgroundColor by animateColorAsState(if (isSelected) Color.Red else Color.Transparent)\n\n    Text(\n        text = \"Hello $name!\",\n        modifier = Modifier\n            .padding(24.dp)\n            .background(color = backgroundColor)\n            .clickable(onClick = { isSelected = !isSelected })\n    )\n}\n```\n\n{% asset_img qgQ6oY4.png [qgQ6oY4] %}\n\n선언형 UI의 장점은 말 그대로 내가 UI를 정의한대로 시각적으로 표현이 가능하다는 장점이 있다. 기존에는 속성을 매번 On/Off와 같은 옵션을 통해 변경하는 것이 다반사였지만, 이제는 매번 속성에 변경이 생길때마다 새로 그려주게 되는것이다.\n\n\n### 8. 재사용\n\nCompose의 장점 중 하나는 재사용성이 뛰어난것인데, XML에서 우리가 include 태그를 통해 여러곳에서 갖다쓸 수 있던것처럼, 함수를 통해 여러곳에서 정의하여 사용이 가능하다.\n\n참고해야할 점은 Compose 컴포넌트 확장 시 `@Composable` 어노테이션을 붙여야 한다.\n\n### 9. Container 작성\n\nMyApp이라는 이름으로 컴포즈 컴포넌트를 구횬하여 여러곳에서 공통으로 사용할 수 있는 Composable을 구현하였다. 내부적으로 Container내 내가 원하는 컴포넌트를 넣어주려면 아래와 같이 인자로 `@Composable () -> Unit` 타입을 넘겨받아 처리해주면 된다.\n\n```kotlin\n@Composable\nfun MyApp(content: @Composable () -> Unit) {\n    BasicsCodelabTheme {\n        Surface(color = Color.Yellow) {\n            content()\n        }\n    }\n}\n```\n\n위 함수를 통해 이제는 어디서든 반복해서 사용할 수 있는 Container를 구현하게 되어 아래와 같이 코드를 활용할 수 있게되었다.\n\n```kotlin\nclass MainActivity : AppCompatActivity() {\n  override fun onCreate(savedInstanceState: Bundle?) {\n    super.onCreate(savedInstanceState)\n    setContent {\n      MyApp {\n        Greeting(\"Android\")\n      }\n    }\n    ...\n  }\n```\n\n### 10. 레이아웃을 활용한 Compose function의 다중 호출\n\n지금까지는 하나의 컴포넌트만을 갖고 사용했지만, 여러개의 컴포넌트를 넣는것도 가능하다.\n\n```kotlin\n@Composable\nfun MyScreenContent() {\n    Column {\n        Greeting(\"Android\")\n        Divider(color = Color.Black)\n        Greeting(\"there\")\n    }\n}\n```\n\n `Column`과 위에서부터 사용하던 `Greeting` 함수를 사용하고, 라인을 그어주기 위한 `Divider`를 추가한 결과물은 다음과 같다.\n\n{% asset_img VLTxB8C.png [VLTxB8C] %}\n\n위 컴포넌트 중 못보던 컴포저블이 있는데, 아래와 같이 설명이 가능하다.\n\n- Column : 항목을 순서대로 배치하기 위해 사용한다.\n- Divider : 선 긋기 가능한 Compose 함수이다.\n\n이를 리스트 형태로도 구현이 가능하다.\n\n```kotlin\n@Composable\nfun MyColumnScreen(names: List<String> = listOf(\"Line One\", \"Line Two\")) {\n    Column {\n        names.forEach {\n            Greeting(name = it)\n            Divider(color = Color.Black)\n        }\n    }\n}\n```\n\n### 11. State in Compose - Compose에서의 상태값 관리\n\n\n컴포넌트에 버튼을 클릭했을 때 클릭한 카운트를 집계하는 간단한 컴포넌트를 만들어보았다.\n\n```kotlin\n@Composable\nfun MyColumnScreen(names: List<String> = listOf(\"Line One\", \"Line Two\")) {\n    val counterState = remember { mutableStateOf(0) } // \n\n    Column {\n        names.forEach {\n            Greeting(name = it)\n            Divider(color = Color.Black)\n        }\n        Counter(\n            count = counterState.value,\n            updateCount = { newCount ->\n                counterState.value = newCount\n            }\n        )\n    }\n}\n```\n\nremember라는 함수를 사용하여 기존에 존재하는 컴포넌트의 상태값을 기억하게 하는 함수가 있다. \n\n`remember` 함수의 내부를 살펴보자.\n\n```kotlin\n/**\n * Remember the value produced by [calculation]. [calculation] will only be evaluated during the composition.\n * Recomposition will always return the value produced by composition.\n */\n@OptIn(ComposeCompilerApi::class)\n@Composable\ninline fun <T> remember(calculation: @DisallowComposableCalls () -> T): T =\n    currentComposer.cache(false, calculation)\n```\n\n매 호출마다 Recomposition(재조합)하게되는 경우 컴포넌트에 값을 다시 제공하는 것을 알 수 있다. @Composable 어노테이션에 들어간 함수는 매번 해당 상태를 구독하고, 상태가 변경될때마다 알림을 받아 기존 화면을 갱신해준다.\n\n그리고, 아래 Counter를 보면 Button을 이용하여 이벤트를 받아 처리하도록 했다.\n\n```kotlin\n@Composable\nfun Counter(count: Int, updateCount: (Int) -> Unit) {\n    Button(\n        onClick = { updateCount(count + 1) },\n        colors = ButtonDefaults.buttonColors(\n            backgroundColor = if (count > 5) Color.Green else Color.White\n        )\n    ) {\n        Text(\"I've been clicked $count times\")\n    }\n}\n```\n\n`updateCount(Int)` 함수릉 통해 매번 값을 업데이트 해주는데, 이를 통해 counterState에 값을 넣어주면서 해당 컴포넌트가 매번 변경이 되는것이다.\n\n따라서 결과를 보면, 다음과 같다. Count가 5가 넘어가면 초록색으로 바뀐다.\n\n{% asset_img Ju6BSg2.gif [Ju6BSg2] %}\n\n그 외에도 여러형태의 모양을 구성할수 있도록 옵션이 제공되어 있다. 자세한 정보는 나중에 [Codelabs](https://developer.android.com/codelabs/jetpack-compose-basics)에 더 나와 있으니 보도록하고, 이번에 setContent에 대한 동작원리를 함께 고민해보자.\n\n### 12. Activity에서의 View 생성 방식과의 비교\n\nCompose를 안드로이드 앱에서 사용하려면 Activity, Fragment와 같은곳에서 contentView로 뿌려줘야한다. 기존에 우리가 사용하던 함수를 보자.\n\n```java\n/**\n* Set the activity content from a layout resource.  The resource will be\n* inflated, adding all top-level views to the activity.\n*\n* @param layoutResID Resource ID to be inflated.\n*\n* @see #setContentView(android.view.View)\n* @see #setContentView(android.view.View, android.view.ViewGroup.LayoutParams)\n*/\npublic void setContentView(@LayoutRes int layoutResID) {\n  getWindow().setContentView(layoutResID);\n  initWindowDecorActionBar();\n}\n```\n\nUI 컴포넌트에서 화면을 붙일 수 있는 Window라는 녀석에서 Layout Resource Id를 통해 기존에 등록되어있던 Layout XML 파일을 로드하여 인플레이터에서 파싱하고, 이를통해 레이아웃 계층에 있는 뷰객체를 생성하여 순차적으로 ViewGroup, View를 만들어 넣어주게 된다.\n\n`PhoneWindow`를 보면 자세하게 알 수 있는데, Window를 구현한 setContentView에서 처음에 생성되는 최상위 레이아웃 그 위에 따로 없다면 `installDecor()` 함수를 통해 mContentParent(레이아웃 리소스가 붙게될 ViewGroup)를 생성하고, 하위에 넣어주게 된다.\n\n그러면 기존 방식은 이정도로 설명을하고, 이번엔 Compose에서 `setContent()` 라는 함수를 어떻게 사용하는지 보자.\n\n```kotlin\n/**\n * Composes the given composable into the given activity. The [content] will become the root view\n * of the given activity.\n *\n * This is roughly equivalent to calling [ComponentActivity.setContentView] with a [ComposeView]\n * i.e.:\n *\n * ```\n * setContentView(\n *   ComposeView(this).apply {\n *     setContent {\n *       MyComposableContent()\n *     }\n *   }\n * )\n * ```\n *\n * @param parent The parent composition reference to coordinate scheduling of composition updates\n * @param content A `@Composable` function declaring the UI contents\n */\npublic fun ComponentActivity.setContent(\n    parent: CompositionContext? = null,\n    content: @Composable () -> Unit\n) {\n    val existingComposeView = window.decorView\n        .findViewById<ViewGroup>(android.R.id.content)\n        .getChildAt(0) as? ComposeView\n\n    if (existingComposeView != null) with(existingComposeView) {\n        setParentCompositionContext(parent)\n        setContent(content)\n    } else ComposeView(this).apply {\n        // Set content and parent **before** setContentView\n        // to have ComposeView create the composition on attach\n        setParentCompositionContext(parent)\n        setContent(content)\n        // Set the view tree owners before setting the content view so that the inflation process\n        // and attach listeners will see them already present\n        setOwners()\n        setContentView(this, DefaultActivityContentLayoutParams)\n    }\n}\n```\n\n이녀석도 마찬가지로 `window.decorView.findViewById<ViewGroup>(android.R.id.content)`  함수를 호출하여 decorView를 가져온다. 만약 compose를 통해 만들어진 최상위 레이아웃이 존재하면, 기존에 inflator에서 ViewGroup, View를 생성해서 넣어주던것 처럼 `setContent()` => window가 Activity/Fragment에 붙으면 `createComposition()`를 호출하여 검증 후 `ensureCompsositionCreated()` 함수를 호출한다. 현재는 내부적으로 `ViewGroup.setContent()` 를 사용하고 있는데, 곧 교체 될 예정이라고 한다. 이코드도 보면 기존에 있는 ViewGroup에 확장함수로 구현한 녀석인데, 쉽게 말해 ViewGroup에 하위 View, ViewGroup에 Composable로 구현된 함수로 컴포넌트를 넣어줄 때 AndroidComposeView라는 객체를 꺼내오거나 없다면 새로 생성하여 넣어준다.\n\n```kotlin\n/**\n * Composes the given composable into the given view.\n *\n * The new composition can be logically \"linked\" to an existing one, by providing a\n * [parent]. This will ensure that invalidations and CompositionLocals will flow through\n * the two compositions as if they were not separate.\n *\n * Note that this [ViewGroup] should have an unique id for the saved instance state mechanism to\n * be able to save and restore the values used within the composition. See [View.setId].\n *\n * @param parent The [Recomposer] or parent composition reference.\n * @param content Composable that will be the content of the view.\n */\ninternal fun ViewGroup.setContent(\n    parent: CompositionContext,\n    content: @Composable () -> Unit\n): Composition {\n    GlobalSnapshotManager.ensureStarted()\n    val composeView =\n        if (childCount > 0) {\n            getChildAt(0) as? AndroidComposeView\n        } else {\n            removeAllViews(); null\n        } ?: AndroidComposeView(context).also { addView(it.view, DefaultLayoutParams) }\n    return doSetContent(composeView, parent, content)\n}\n```\n\n\n\n다시 돌아와서, ComposeView의 `setContent()` 이라는 녀석을 보자.\n\n```kotlin\n/**\n * A [android.view.View] that can host Jetpack Compose UI content.\n * Use [setContent] to supply the content composable function for the view.\n *\n * This [android.view.View] requires that the window it is attached to contains a\n * [ViewTreeLifecycleOwner]. This [androidx.lifecycle.LifecycleOwner] is used to\n * [dispose][androidx.compose.runtime.Composition.dispose] of the underlying composition\n * when the host [Lifecycle] is destroyed, permitting the view to be attached and\n * detached repeatedly while preserving the composition. Call [disposeComposition]\n * to dispose of the underlying composition earlier, or if the view is never initially\n * attached to a window. (The requirement to dispose of the composition explicitly\n * in the event that the view is never (re)attached is temporary.)\n */\nclass ComposeView @JvmOverloads constructor(\n    context: Context,\n    attrs: AttributeSet? = null,\n    defStyleAttr: Int = 0\n) : AbstractComposeView(context, attrs, defStyleAttr) {\n\n    private val content = mutableStateOf<(@Composable () -> Unit)?>(null)\n\n    @Suppress(\"RedundantVisibilityModifier\")\n    protected override var shouldCreateCompositionOnAttachedToWindow: Boolean = false\n        private set\n\n    @Composable\n    override fun Content() {\n        content.value?.invoke()\n    }\n\n    /**\n     * Set the Jetpack Compose UI content for this view.\n     * Initial composition will occur when the view becomes attached to a window or when\n     * [createComposition] is called, whichever comes first.\n     */\n    fun setContent(content: @Composable () -> Unit) {\n        shouldCreateCompositionOnAttachedToWindow = true\n        this.content.value = content\n        if (isAttachedToWindow) {\n            createComposition()\n        }\n    }\n}\n```\n\n결론적으로 `AbstractComposeView` 라는 녀석은 ViewGroup을 상속받은 녀석이며, 모든 composable의 상태가 변화 되었을 때 이를 감지하는 중요한 녀석이다.\n\n`setContent()`라는 함수는 위에서 설명했으니 넘어가고, 이번에는 `Content`라는 녀석을 보자. 이녀석은 추상 메소드로, `createComposition()` 이라는 함수가 호출 되었을 때, 가장 먼저 불리는 함수이다. 아까 언급되었던 `ensureCompsositionCreated()` 함수에서 tree계층의 ComposeView가 다 붙었다면, 이후에 즉시 Content함수가 호출이된다.\n\n```kotlin\n@Suppress(\"DEPRECATION\") // Still using ViewGroup.setContent for now\n    private fun ensureCompositionCreated() {\n        if (composition == null) {\n            try {\n                creatingComposition = true\n                composition = setContent(\n                    parentContext ?: findViewTreeCompositionContext() ?: windowRecomposer\n                ) {\n                    Content() // 이곳에서 뷰가 다 window에 붙게되면 콜백을 호출한다.\n                }\n            } finally {\n                creatingComposition = false\n            }\n        }\n    }\n```\n\n그러면 아래 `ComposeView`의 오버라이딩 된 Content가 호출되면서, 기존에 생성된 View에 UI속성과 같은 Content가 붙게된다.\n\n```kotlin\n/**\n* The Jetpack Compose UI content for this view.\n* Subclasses must implement this method to provide content. Initial composition will\n* occur when the view becomes attached to a window or when [createComposition] is called,\n* whichever comes first.\n*/\n@Composable\nabstract fun Content()\n```\n\nContent는 설명에서 보는것과 같이 `createComposition()` 함수 호출 후 View가 Window에 붙은 이후 즉시 호출된다.\n\n최종적으로 `ComponentActivity.setContent(CompositionContext?, @Composable () -> Unit)` 함수에서 구현된 ComposeView 인스턴스를 ContentLayout을 widht/height를 wrapContent크기로 정하여 ContentView를 Set해주게 된다.\n\n```kotlin\n/**\n * Composes the given composable into the given activity. The [content] will become the root view\n * of the given activity.\n *\n * This is roughly equivalent to calling [ComponentActivity.setContentView] with a [ComposeView]\n * i.e.:\n *\n * ```\n * setContentView(\n *   ComposeView(this).apply {\n *     setContent {\n *       MyComposableContent()\n *     }\n *   }\n * )\n * ```\n *\n * @param parent The parent composition reference to coordinate scheduling of composition updates\n * @param content A `@Composable` function declaring the UI contents\n */\npublic fun ComponentActivity.setContent(\n    parent: CompositionContext? = null,\n    content: @Composable () -> Unit\n) {\n  \t...\n\t\telse ComposeView(this).apply {\n        // Set content and parent **before** setContentView\n        // to have ComposeView create the composition on attach\n        setParentCompositionContext(parent)\n        setContent(content)\n        // Set the view tree owners before setting the content view so that the inflation process\n        // and attach listeners will see them already present\n        setOwners()\n        setContentView(this, DefaultActivityContentLayoutParams)\n    }\n}\n```\n\n### 13. ComposeView\n\nandroid.view.View 는 Jetpack Compose UI 콘텐츠를 사용할 수 있도록 해줍니다. setContent 를 사용하면 composable function content 를 뷰에 제공할 수 있다.\n\nCompose 의 계층 구조는 아래와 같으며. ComposeView 를 통해 androidx.compose.materia 에 정의된 다양한 컴포넌트를 조합하여 Composable function 콘텐츠를 구성할 수 있다.\n\n```\nkotlin.Any\n ↳ android.view.View\n   ↳ android.view.ViewGroup\n     ↳ androidx.compose.ui.platform.AbstractComposeView\n       ↳ androidx.compose.ui.platform.ComposeView\n```\n\n### 14. Compose Compiler / Compose Runtime\n\nCompose Compiler 는 `@Composable` 이 설정된 경우 Composable function 으로 코드 변환과 코틀린 컴파일러 플러그인과 함께 최적화를 활성화한다.\n\nCompose Runtime은 Compose의 프로그래밍 모델과 상태 관리, 그리고 Compose 컴파일러를 지정하기 위한 코어 런타임에 대한 기본 설정을 수행한다.\n\n\n```koltin\n@Composable\nfun Greeting(name: String) {\n    var greet by remember { mutableStateOf(\"Hello $name\") }\n    Text(text = greet, color = Color.Red)\n}\n```\n\n위의 코드는 Compose Compiler에 의해 `@Composeable`은 아래와 같이 변경된다.\n\n```kotlin\nfun Greeting(\n  $composer: Composer,\n  $static: Int,\n  name: String\n) {\n  $composer.start(123)\n  var greet by remember { mutableStateOf(\"Hello $name\") }\n  Text(text = greet, color = Color.Red)\n  $composer.end()\n}\n```\n\nCompose 는 `composer.start` 에서 고유의 키를 가지고 있고, 이는 Compose 의 state 가 변경될 때 해당 키를 가진 Compose 만 변경되도록 동작한다.\n\nstatic 은 상태(state)의 변경여부를 알 수 있는데 상태의 변화가 없는 경우, `composer.start` 와 `composer.end` 사이의 UI 의 변경을 하지 않는다.\n\n이때 데이터의 상태가 변경되어 UI 를 다시 구성하는 경우는 Recomposition 이라고 한다.","source":"_posts/2021-04-07 Jetpack Compose Part 1.md","raw":"---\ntitle: Jetpack Compose Part 1 - Compose 소개 및 코드랩 따라하기\ndate: 2021-04-07 01:00\ncover: https://androiddeepdive.github.io/Team-Blog/images/cover_jepack_compose.png\ncategories:\n- Jetpack Compose\ntags:\n- Android\n- Jetpack\n- Compose\n---\n\n<article class=\"message message-immersive is-primary\">\n    <div class=\"message-body\">\n        <i class=\"fas fa-pen-fancy mr-2\"></i>Writers<br>\n        by 김남훈 @Naver<br>\n        by 배희성 @RocketPunch<br>\n        by 송시영 @SmartStudy<br>\n        by 이기정 @BankSalad\n    </div>\n</article>\n\n<!-- more -->\n\n## Jetpack Compose란 무엇인가?\n\n{% asset_img compose_animation.gif [compose_animation] %}\n\n> **출처** [Android Developers#Jetpack Compse](https://developer.android.com/jetpack/compose)\n\nCompose는 Native UI를 코드레벨로 구현할 수 있는 최신 툴킷이다. \n\n기존의 뷰를 업데이트하는 방식과 달리 Compose를 사용하면 필요한 영역의 뷰를 다시 그려주는 방식으로 작업할 수 있다.\n\n아래는 아주 간단한 예제이다.\n\n```kotlin\n@Composable\nfun Greeting(name: String) {\n\tText(\"Hello $name\")\n}\n```\n\n위의 예제처럼 UI를 구성하는 것이 아니라 화면을 구성하는 뷰의 State 설명하는 것이므로 아무것도 반환하지 않는다.\n\n아래는 공식 서비스 소개 영상이다.\n\n{% youtube U5BwfqBpiWU %}\n\n### Compose의 4가지 특징\n\n구글에서 설명하는 Compose를 이용시 얻을 수 있는 장점은 아래와 같다.\n\n- `Less Code` - 코드 감소\n  - 적은 수의 코드로 더 많은 작업을 하고 전체 버그 클래스를 방지할 수 있으므로 코드가 간단하며 유지 관리하기 쉽습니다.\n- `Intuitive` - 직관적\n  - UI만 설명하면 나머지는 Compose에서 처리합니다. 앱 상태가 변경되면 UI가 자동으로 업데이트됩니다.\n- `Accelerate Development` - 빠른 개발 과정\n  - 기존의 모든 코드와 호환되므로 언제 어디서든 원하는 대로 사용할 수 있습니다. 실시간 미리보기 및 완전한 Android 스튜디오 지원으로 빠르게 반복할 수 있습니다.\n- `Powerful` - 강력한 성능\n  - Android 플랫폼 API에 직접 액세스하고 머티리얼 디자인, 어두운 테마, 애니메이션 등을 기본적으로 지원하는 멋진 앱을 만들 수 있습니다.\n\n늘 그렇듯 구글에서 말하는 설명만 보면 안 쓸 이유가 없어보이고, 대세가 된다면 Android 개발자에게 또 하나의 러닝커브로 작용할 것이다.\n\n## Codelab - Jetpack Compose basics\n\n### 1. 시작하기전에\n\nCompose는 아직 정식으로 릴리즈되지 않은 기능이므로 Android Studio Canary에서 프로젝트를 구성하며 몇 가지 제한사항이 존재한다.\n\n1. Android Studio Canary \n\nCanary는 아래 링크에서 다운 받을 수 있다.\n\n> [Android Studio Preview](https://developer.android.com/studio/preview)\n\n2. 최신 버전의 Kotlin plugin \n\n```groovy\next.kotlin_version = '1.4.31'\n```\n\n3. buildFeatures 및 composeOption 활성화\n\n```groovy\nandroid {\n    ...\n    buildFeatures {\n        compose true\n    }\n    composeOptions {\n        kotlinCompilerExtensionVersion 1.0.0-beta02\n    }\n}\n\ndependencies {\n    ...\n    implementation \"androidx.compose.ui:ui:1.0.0-beta02\"\n    implementation \"androidx.activity:activity-compose:1.3.0-alpha03\"\n    implementation \"androidx.compose.material:material:1.0.0-beta02\"\n    implementation \"androidx.compose.ui:ui-tooling:1.0.0-beta02\"\n    ...\n}\n```\n\n### 2. Empty Compose 프로젝트 생성\n\n[File] - [New] - [New Project…] 를 눌러 새로운 프로젝트를 선택하고(Preview) Empty Compose Activity 를 선택한다.\n\n{% asset_img 1_5gfrQWfxyEC7Oq6b2xlJ9w.png [1_5gfrQWfxyEC7Oq6b2xlJ9w] %}\n\n선택 이후 Next를 클릭하고, Compose를 구현할 수 있는 최소 API 레벨인 21을 선택해야한다.\n\n프로젝트를 생성하면 아래와 같이 app/build.gradle에 의존성 설정 및 추가가 되어 있는것을 알 수 있다.\n\n```groovy\nandroid {\n    ...\n    kotlinOptions {\n        jvmTarget = '1.8'\n        useIR = true\n    }\n    buildFeatures {\n        compose true\n    }\n    composeOptions {\n        kotlinCompilerExtensionVersion compose_version\n    }\n}\n\ndependencies {\n    ...\n    implementation \"androidx.compose.ui:ui:$compose_version\"\n    implementation \"androidx.activity:activity-compose:1.3.0-alpha03\"\n    implementation \"androidx.compose.material:material:$compose_version\"\n    implementation \"androidx.compose.ui:ui-tooling:$compose_version\"\n    ...\n}\n```\n\n이때 composeOptions 설정에서 kotlinCompilerVersion 에 따라 compose 가 다르게 동작할 수 있음을 유의하자.\n\n프로젝트를 생성하면 아래와 같은 기본 파일들이 생성된다.\n\n**MainActivity.kt**\n```kotlin\nclass MainActivity : AppCompatActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContent {\n            MyFirstComposeApplicationTheme {\n                // A surface container using the 'background' color from the theme\n                Surface(color = MaterialTheme.colors.background) {\n                    Greeting(\"Android\")\n                }\n            }\n        }\n    }\n}\n\n@Composable\nfun Greeting(name: String) {\n    Text(text = \"Hello $name!\")\n}\n\n@Preview(showBackground = true)\n@Composable\nfun DefaultPreview() {\n    MyFirstComposeApplicationTheme {\n        Greeting(\"Android\")\n    }\n}\n```\n\n**ui/theme/Theme.kt**\n```kotlin\nprivate val DarkColorPalette = darkColors(\n    primary = Purple200,\n    primaryVariant = Purple700,\n    secondary = Teal200\n)\n\nprivate val LightColorPalette = lightColors(\n    primary = Purple500,\n    primaryVariant = Purple700,\n    secondary = Teal200*\n\n    /* Other default colors to override\n    background = Color.White,\n    surface = Color.White,\n    onPrimary = Color.White,\n    onSecondary = Color.Black,\n    onBackground = Color.Black,\n    onSurface = Color.Black,\n    */\n)\n\n@Composable\nfun MyFirstComposeApplicationTheme(darkTheme: Boolean = isSystemInDarkTheme(), content: @Composable () -> Unit) {\n    val colors = if (darkTheme) {\n        DarkColorPalette*\n    } else {\n        LightColorPalette*\n    }\n\n    MaterialTheme(\n        colors = colors,\n        typography = Typography,\n        shapes = Shapes,\n        content = content\n    )\n}\n```\n\n기본 생성된 코드를 보았을 때, Compose는 총 3가지의 구성 요소를 가지는 것으로 추측할 수 있다.\n\n1. 위젯을 포함하는 Composable 함수\n2. Preview를 하기 위한 Preview Composable 함수\n3. setContent 람다 표현식으로 실제 화면에 노출하는 코드\n\n일반적으로 우리가 아는 Activity의 라이프사이클 콜백 `onCreate()`에서   `setContentView(Int)` 함수를 호출하던것이 `setContent()` 함수로 바뀐것이 가장 큰 특징으로 보여진다.\n\n### 3. Composable Function\n\nComposable Function은 어노테이션을 이용한 기술이다. 함수위에 `@Composable` 어노테이션을 붙이게 되면 함수 안 다른 함수를 호출할 수 있게된다. 아래 코드를 보자.\n\n```kotlin\n@Composable\nfun Greeting(names: List<String>) {\n    for (name in names) {\n        Text(\"Hello $name\")\n    }\n}\n```\n\n단순하게 내부에는 Text라는 함수가 존재하는데, 이를 통해 UI계층 별 요구하는 컴포넌트를 생성해준다. 기본적으로 보이는 text 파라미터는 내부 속성에서 받는 일부 중 하나이다.\n\n### 4. TextView 만들기\n\n위 코드를 실행시켜보면 당연하게도 Hello로 시작하는 TextView가 화면에 그려질것을 암시한다.\n\n```kotlin\nsetContent {\n  BasicsCodelabTheme {\n    // A surface container using the 'background' color from the theme\n    Surface(color = MaterialTheme.colors.background) {\n      Greeting(\"Android\")\n    }\n  }\n}\n```\n\n{% asset_img aO6Jlsg.png [aO6Jlsg] %}\n\n### 5. `@Preview`\n\n말 그대로 어노테이션을 이용하여 IDE에서 Preview를하기 위한 용도이다. 아래 코드와 같이 @Preview 어노테이션을 추가하면 다음 결과를 볼 수 있다.\n\n```kotlin\n@Preview(\"Greeting Preview\")\n@Composable\nfun GreetingPreview() {\n    BasicsCodelabTheme {\n        Surface(color = MaterialTheme.colors.background) {\n            Greeting(\"Android\")\n        }\n    }\n}\n```\n\n{% asset_img WprDTs1.png [WprDTs1] %}\n\n### 6. setContent / Theme / Surface\n\n```kotlin\nsetContent {\n  BasicsCodelabTheme {\n    // A surface container using the 'background' color from the theme\n    Surface(color = MaterialTheme.colors.background) {\n      Greeting(\"Android\")\n    }\n  }\n}\n```\n\n기존에 onCreate시점에 화면을 그려주기 위한 필수적인 요소를 정리해보자면\n\n- **setContent** : Activity에서 setContentView함수를 사용하는 것과 동일한 동작을 하는 확장함수이다. 다만, setContent의 경우 (@Composable) -> Unit 타입의 컴포즈 UI를 구현해주어야한다.\n\n- **XXXTheme** : Theme정보를 의미한다. 해당 프로젝트에서는 Theme.kt에 여러 테마에 필요한 정보를 정리하고, 컴포즈 UI 구현을 위한 코드를 작성해두었다.\n\n```kotlin\nprivate val DarkColorPalette = darkColors(\n    primary = purple200,\n    primaryVariant = purple700,\n    secondary = teal200\n)\n\nprivate val LightColorPalette = lightColors(\n    primary = purple500,\n    primaryVariant = purple700,\n    secondary = teal200\n\n    /* Other default colors to override\n    background = Color.White,\n    surface = Color.White,\n    onPrimary = Color.White,\n    onSecondary = Color.Black,\n    onBackground = Color.Black,\n    onSurface = Color.Black,\n    */\n)\n\n@Composable\nfun BasicsCodelabTheme(\n    darkTheme: Boolean = isSystemInDarkTheme(),\n    content: @Composable () -> Unit\n) {\n    val colors = if (darkTheme) {\n        DarkColorPalette\n    } else {\n        LightColorPalette\n    }\n\n    MaterialTheme(\n        colors = colors,\n        typography = typography,\n        shapes = shapes,\n        content = content\n    )\n}\n```\n\n- **Surface** : Greeting을 감싸는 뷰에 해당한다. 여기서는 크기를 정하지 않고, background 색상을 정의하고 있다. 역시 람다 표현식이다. 색상에 대한 Paramter로 `color` 라는 값을 사용하여 부여가 가능하다. 내부코드를 보면\n\n```kotlin\n@Composable\nfun Surface(\n    modifier: Modifier = Modifier,\n    shape: Shape = RectangleShape,\n    color: Color = MaterialTheme.colors.surface,\n    contentColor: Color = contentColorFor(color),\n    border: BorderStroke? = null,\n    elevation: Dp = 0.dp,\n    content: @Composable () -> Unit\n) {\n    val elevationPx = with(LocalDensity.current) { elevation.toPx() }\n    val elevationOverlay = LocalElevationOverlay.current\n    val absoluteElevation = LocalAbsoluteElevation.current + elevation\n    val backgroundColor = if (color == MaterialTheme.colors.surface && elevationOverlay != null) {\n        elevationOverlay.apply(color, absoluteElevation)\n    } else {\n        color\n    }\n    CompositionLocalProvider(\n        LocalContentColor provides contentColor,\n        LocalAbsoluteElevation provides absoluteElevation\n    ) {\n        Box(\n            modifier.graphicsLayer(shadowElevation = elevationPx, shape = shape)\n                .then(if (border != null) Modifier.border(border, shape) else Modifier)\n                .background(\n                    color = backgroundColor,\n                    shape = shape\n                )\n                .clip(shape),\n            propagateMinConstraints = true\n        ) {\n            content()\n        }\n    }\n}\n```\n\n### 7. Declarative UI - 선언형 UI\n\n노란색 배경을 입혀 기존 TextView에 추가해보았다. 또한, Greeting에는 Modifier라는 것을 이용하여 Padding을 추가했다. 아래와 같은 결과가 나오게 되었다.\n\n```kotlin\nBasicsCodelabTheme {\n  // A surface container using the 'background' color from the theme\n  Surface(color = Color.Yellow) {\n    Greeting(\"Android\")\n  }\n}\n```\n\n```kotlin\n@Composable\nfun Greeting(name: String) {\n    var isSelected by remember { mutableStateOf(false) }\n    val backgroundColor by animateColorAsState(if (isSelected) Color.Red else Color.Transparent)\n\n    Text(\n        text = \"Hello $name!\",\n        modifier = Modifier\n            .padding(24.dp)\n            .background(color = backgroundColor)\n            .clickable(onClick = { isSelected = !isSelected })\n    )\n}\n```\n\n{% asset_img qgQ6oY4.png [qgQ6oY4] %}\n\n선언형 UI의 장점은 말 그대로 내가 UI를 정의한대로 시각적으로 표현이 가능하다는 장점이 있다. 기존에는 속성을 매번 On/Off와 같은 옵션을 통해 변경하는 것이 다반사였지만, 이제는 매번 속성에 변경이 생길때마다 새로 그려주게 되는것이다.\n\n\n### 8. 재사용\n\nCompose의 장점 중 하나는 재사용성이 뛰어난것인데, XML에서 우리가 include 태그를 통해 여러곳에서 갖다쓸 수 있던것처럼, 함수를 통해 여러곳에서 정의하여 사용이 가능하다.\n\n참고해야할 점은 Compose 컴포넌트 확장 시 `@Composable` 어노테이션을 붙여야 한다.\n\n### 9. Container 작성\n\nMyApp이라는 이름으로 컴포즈 컴포넌트를 구횬하여 여러곳에서 공통으로 사용할 수 있는 Composable을 구현하였다. 내부적으로 Container내 내가 원하는 컴포넌트를 넣어주려면 아래와 같이 인자로 `@Composable () -> Unit` 타입을 넘겨받아 처리해주면 된다.\n\n```kotlin\n@Composable\nfun MyApp(content: @Composable () -> Unit) {\n    BasicsCodelabTheme {\n        Surface(color = Color.Yellow) {\n            content()\n        }\n    }\n}\n```\n\n위 함수를 통해 이제는 어디서든 반복해서 사용할 수 있는 Container를 구현하게 되어 아래와 같이 코드를 활용할 수 있게되었다.\n\n```kotlin\nclass MainActivity : AppCompatActivity() {\n  override fun onCreate(savedInstanceState: Bundle?) {\n    super.onCreate(savedInstanceState)\n    setContent {\n      MyApp {\n        Greeting(\"Android\")\n      }\n    }\n    ...\n  }\n```\n\n### 10. 레이아웃을 활용한 Compose function의 다중 호출\n\n지금까지는 하나의 컴포넌트만을 갖고 사용했지만, 여러개의 컴포넌트를 넣는것도 가능하다.\n\n```kotlin\n@Composable\nfun MyScreenContent() {\n    Column {\n        Greeting(\"Android\")\n        Divider(color = Color.Black)\n        Greeting(\"there\")\n    }\n}\n```\n\n `Column`과 위에서부터 사용하던 `Greeting` 함수를 사용하고, 라인을 그어주기 위한 `Divider`를 추가한 결과물은 다음과 같다.\n\n{% asset_img VLTxB8C.png [VLTxB8C] %}\n\n위 컴포넌트 중 못보던 컴포저블이 있는데, 아래와 같이 설명이 가능하다.\n\n- Column : 항목을 순서대로 배치하기 위해 사용한다.\n- Divider : 선 긋기 가능한 Compose 함수이다.\n\n이를 리스트 형태로도 구현이 가능하다.\n\n```kotlin\n@Composable\nfun MyColumnScreen(names: List<String> = listOf(\"Line One\", \"Line Two\")) {\n    Column {\n        names.forEach {\n            Greeting(name = it)\n            Divider(color = Color.Black)\n        }\n    }\n}\n```\n\n### 11. State in Compose - Compose에서의 상태값 관리\n\n\n컴포넌트에 버튼을 클릭했을 때 클릭한 카운트를 집계하는 간단한 컴포넌트를 만들어보았다.\n\n```kotlin\n@Composable\nfun MyColumnScreen(names: List<String> = listOf(\"Line One\", \"Line Two\")) {\n    val counterState = remember { mutableStateOf(0) } // \n\n    Column {\n        names.forEach {\n            Greeting(name = it)\n            Divider(color = Color.Black)\n        }\n        Counter(\n            count = counterState.value,\n            updateCount = { newCount ->\n                counterState.value = newCount\n            }\n        )\n    }\n}\n```\n\nremember라는 함수를 사용하여 기존에 존재하는 컴포넌트의 상태값을 기억하게 하는 함수가 있다. \n\n`remember` 함수의 내부를 살펴보자.\n\n```kotlin\n/**\n * Remember the value produced by [calculation]. [calculation] will only be evaluated during the composition.\n * Recomposition will always return the value produced by composition.\n */\n@OptIn(ComposeCompilerApi::class)\n@Composable\ninline fun <T> remember(calculation: @DisallowComposableCalls () -> T): T =\n    currentComposer.cache(false, calculation)\n```\n\n매 호출마다 Recomposition(재조합)하게되는 경우 컴포넌트에 값을 다시 제공하는 것을 알 수 있다. @Composable 어노테이션에 들어간 함수는 매번 해당 상태를 구독하고, 상태가 변경될때마다 알림을 받아 기존 화면을 갱신해준다.\n\n그리고, 아래 Counter를 보면 Button을 이용하여 이벤트를 받아 처리하도록 했다.\n\n```kotlin\n@Composable\nfun Counter(count: Int, updateCount: (Int) -> Unit) {\n    Button(\n        onClick = { updateCount(count + 1) },\n        colors = ButtonDefaults.buttonColors(\n            backgroundColor = if (count > 5) Color.Green else Color.White\n        )\n    ) {\n        Text(\"I've been clicked $count times\")\n    }\n}\n```\n\n`updateCount(Int)` 함수릉 통해 매번 값을 업데이트 해주는데, 이를 통해 counterState에 값을 넣어주면서 해당 컴포넌트가 매번 변경이 되는것이다.\n\n따라서 결과를 보면, 다음과 같다. Count가 5가 넘어가면 초록색으로 바뀐다.\n\n{% asset_img Ju6BSg2.gif [Ju6BSg2] %}\n\n그 외에도 여러형태의 모양을 구성할수 있도록 옵션이 제공되어 있다. 자세한 정보는 나중에 [Codelabs](https://developer.android.com/codelabs/jetpack-compose-basics)에 더 나와 있으니 보도록하고, 이번에 setContent에 대한 동작원리를 함께 고민해보자.\n\n### 12. Activity에서의 View 생성 방식과의 비교\n\nCompose를 안드로이드 앱에서 사용하려면 Activity, Fragment와 같은곳에서 contentView로 뿌려줘야한다. 기존에 우리가 사용하던 함수를 보자.\n\n```java\n/**\n* Set the activity content from a layout resource.  The resource will be\n* inflated, adding all top-level views to the activity.\n*\n* @param layoutResID Resource ID to be inflated.\n*\n* @see #setContentView(android.view.View)\n* @see #setContentView(android.view.View, android.view.ViewGroup.LayoutParams)\n*/\npublic void setContentView(@LayoutRes int layoutResID) {\n  getWindow().setContentView(layoutResID);\n  initWindowDecorActionBar();\n}\n```\n\nUI 컴포넌트에서 화면을 붙일 수 있는 Window라는 녀석에서 Layout Resource Id를 통해 기존에 등록되어있던 Layout XML 파일을 로드하여 인플레이터에서 파싱하고, 이를통해 레이아웃 계층에 있는 뷰객체를 생성하여 순차적으로 ViewGroup, View를 만들어 넣어주게 된다.\n\n`PhoneWindow`를 보면 자세하게 알 수 있는데, Window를 구현한 setContentView에서 처음에 생성되는 최상위 레이아웃 그 위에 따로 없다면 `installDecor()` 함수를 통해 mContentParent(레이아웃 리소스가 붙게될 ViewGroup)를 생성하고, 하위에 넣어주게 된다.\n\n그러면 기존 방식은 이정도로 설명을하고, 이번엔 Compose에서 `setContent()` 라는 함수를 어떻게 사용하는지 보자.\n\n```kotlin\n/**\n * Composes the given composable into the given activity. The [content] will become the root view\n * of the given activity.\n *\n * This is roughly equivalent to calling [ComponentActivity.setContentView] with a [ComposeView]\n * i.e.:\n *\n * ```\n * setContentView(\n *   ComposeView(this).apply {\n *     setContent {\n *       MyComposableContent()\n *     }\n *   }\n * )\n * ```\n *\n * @param parent The parent composition reference to coordinate scheduling of composition updates\n * @param content A `@Composable` function declaring the UI contents\n */\npublic fun ComponentActivity.setContent(\n    parent: CompositionContext? = null,\n    content: @Composable () -> Unit\n) {\n    val existingComposeView = window.decorView\n        .findViewById<ViewGroup>(android.R.id.content)\n        .getChildAt(0) as? ComposeView\n\n    if (existingComposeView != null) with(existingComposeView) {\n        setParentCompositionContext(parent)\n        setContent(content)\n    } else ComposeView(this).apply {\n        // Set content and parent **before** setContentView\n        // to have ComposeView create the composition on attach\n        setParentCompositionContext(parent)\n        setContent(content)\n        // Set the view tree owners before setting the content view so that the inflation process\n        // and attach listeners will see them already present\n        setOwners()\n        setContentView(this, DefaultActivityContentLayoutParams)\n    }\n}\n```\n\n이녀석도 마찬가지로 `window.decorView.findViewById<ViewGroup>(android.R.id.content)`  함수를 호출하여 decorView를 가져온다. 만약 compose를 통해 만들어진 최상위 레이아웃이 존재하면, 기존에 inflator에서 ViewGroup, View를 생성해서 넣어주던것 처럼 `setContent()` => window가 Activity/Fragment에 붙으면 `createComposition()`를 호출하여 검증 후 `ensureCompsositionCreated()` 함수를 호출한다. 현재는 내부적으로 `ViewGroup.setContent()` 를 사용하고 있는데, 곧 교체 될 예정이라고 한다. 이코드도 보면 기존에 있는 ViewGroup에 확장함수로 구현한 녀석인데, 쉽게 말해 ViewGroup에 하위 View, ViewGroup에 Composable로 구현된 함수로 컴포넌트를 넣어줄 때 AndroidComposeView라는 객체를 꺼내오거나 없다면 새로 생성하여 넣어준다.\n\n```kotlin\n/**\n * Composes the given composable into the given view.\n *\n * The new composition can be logically \"linked\" to an existing one, by providing a\n * [parent]. This will ensure that invalidations and CompositionLocals will flow through\n * the two compositions as if they were not separate.\n *\n * Note that this [ViewGroup] should have an unique id for the saved instance state mechanism to\n * be able to save and restore the values used within the composition. See [View.setId].\n *\n * @param parent The [Recomposer] or parent composition reference.\n * @param content Composable that will be the content of the view.\n */\ninternal fun ViewGroup.setContent(\n    parent: CompositionContext,\n    content: @Composable () -> Unit\n): Composition {\n    GlobalSnapshotManager.ensureStarted()\n    val composeView =\n        if (childCount > 0) {\n            getChildAt(0) as? AndroidComposeView\n        } else {\n            removeAllViews(); null\n        } ?: AndroidComposeView(context).also { addView(it.view, DefaultLayoutParams) }\n    return doSetContent(composeView, parent, content)\n}\n```\n\n\n\n다시 돌아와서, ComposeView의 `setContent()` 이라는 녀석을 보자.\n\n```kotlin\n/**\n * A [android.view.View] that can host Jetpack Compose UI content.\n * Use [setContent] to supply the content composable function for the view.\n *\n * This [android.view.View] requires that the window it is attached to contains a\n * [ViewTreeLifecycleOwner]. This [androidx.lifecycle.LifecycleOwner] is used to\n * [dispose][androidx.compose.runtime.Composition.dispose] of the underlying composition\n * when the host [Lifecycle] is destroyed, permitting the view to be attached and\n * detached repeatedly while preserving the composition. Call [disposeComposition]\n * to dispose of the underlying composition earlier, or if the view is never initially\n * attached to a window. (The requirement to dispose of the composition explicitly\n * in the event that the view is never (re)attached is temporary.)\n */\nclass ComposeView @JvmOverloads constructor(\n    context: Context,\n    attrs: AttributeSet? = null,\n    defStyleAttr: Int = 0\n) : AbstractComposeView(context, attrs, defStyleAttr) {\n\n    private val content = mutableStateOf<(@Composable () -> Unit)?>(null)\n\n    @Suppress(\"RedundantVisibilityModifier\")\n    protected override var shouldCreateCompositionOnAttachedToWindow: Boolean = false\n        private set\n\n    @Composable\n    override fun Content() {\n        content.value?.invoke()\n    }\n\n    /**\n     * Set the Jetpack Compose UI content for this view.\n     * Initial composition will occur when the view becomes attached to a window or when\n     * [createComposition] is called, whichever comes first.\n     */\n    fun setContent(content: @Composable () -> Unit) {\n        shouldCreateCompositionOnAttachedToWindow = true\n        this.content.value = content\n        if (isAttachedToWindow) {\n            createComposition()\n        }\n    }\n}\n```\n\n결론적으로 `AbstractComposeView` 라는 녀석은 ViewGroup을 상속받은 녀석이며, 모든 composable의 상태가 변화 되었을 때 이를 감지하는 중요한 녀석이다.\n\n`setContent()`라는 함수는 위에서 설명했으니 넘어가고, 이번에는 `Content`라는 녀석을 보자. 이녀석은 추상 메소드로, `createComposition()` 이라는 함수가 호출 되었을 때, 가장 먼저 불리는 함수이다. 아까 언급되었던 `ensureCompsositionCreated()` 함수에서 tree계층의 ComposeView가 다 붙었다면, 이후에 즉시 Content함수가 호출이된다.\n\n```kotlin\n@Suppress(\"DEPRECATION\") // Still using ViewGroup.setContent for now\n    private fun ensureCompositionCreated() {\n        if (composition == null) {\n            try {\n                creatingComposition = true\n                composition = setContent(\n                    parentContext ?: findViewTreeCompositionContext() ?: windowRecomposer\n                ) {\n                    Content() // 이곳에서 뷰가 다 window에 붙게되면 콜백을 호출한다.\n                }\n            } finally {\n                creatingComposition = false\n            }\n        }\n    }\n```\n\n그러면 아래 `ComposeView`의 오버라이딩 된 Content가 호출되면서, 기존에 생성된 View에 UI속성과 같은 Content가 붙게된다.\n\n```kotlin\n/**\n* The Jetpack Compose UI content for this view.\n* Subclasses must implement this method to provide content. Initial composition will\n* occur when the view becomes attached to a window or when [createComposition] is called,\n* whichever comes first.\n*/\n@Composable\nabstract fun Content()\n```\n\nContent는 설명에서 보는것과 같이 `createComposition()` 함수 호출 후 View가 Window에 붙은 이후 즉시 호출된다.\n\n최종적으로 `ComponentActivity.setContent(CompositionContext?, @Composable () -> Unit)` 함수에서 구현된 ComposeView 인스턴스를 ContentLayout을 widht/height를 wrapContent크기로 정하여 ContentView를 Set해주게 된다.\n\n```kotlin\n/**\n * Composes the given composable into the given activity. The [content] will become the root view\n * of the given activity.\n *\n * This is roughly equivalent to calling [ComponentActivity.setContentView] with a [ComposeView]\n * i.e.:\n *\n * ```\n * setContentView(\n *   ComposeView(this).apply {\n *     setContent {\n *       MyComposableContent()\n *     }\n *   }\n * )\n * ```\n *\n * @param parent The parent composition reference to coordinate scheduling of composition updates\n * @param content A `@Composable` function declaring the UI contents\n */\npublic fun ComponentActivity.setContent(\n    parent: CompositionContext? = null,\n    content: @Composable () -> Unit\n) {\n  \t...\n\t\telse ComposeView(this).apply {\n        // Set content and parent **before** setContentView\n        // to have ComposeView create the composition on attach\n        setParentCompositionContext(parent)\n        setContent(content)\n        // Set the view tree owners before setting the content view so that the inflation process\n        // and attach listeners will see them already present\n        setOwners()\n        setContentView(this, DefaultActivityContentLayoutParams)\n    }\n}\n```\n\n### 13. ComposeView\n\nandroid.view.View 는 Jetpack Compose UI 콘텐츠를 사용할 수 있도록 해줍니다. setContent 를 사용하면 composable function content 를 뷰에 제공할 수 있다.\n\nCompose 의 계층 구조는 아래와 같으며. ComposeView 를 통해 androidx.compose.materia 에 정의된 다양한 컴포넌트를 조합하여 Composable function 콘텐츠를 구성할 수 있다.\n\n```\nkotlin.Any\n ↳ android.view.View\n   ↳ android.view.ViewGroup\n     ↳ androidx.compose.ui.platform.AbstractComposeView\n       ↳ androidx.compose.ui.platform.ComposeView\n```\n\n### 14. Compose Compiler / Compose Runtime\n\nCompose Compiler 는 `@Composable` 이 설정된 경우 Composable function 으로 코드 변환과 코틀린 컴파일러 플러그인과 함께 최적화를 활성화한다.\n\nCompose Runtime은 Compose의 프로그래밍 모델과 상태 관리, 그리고 Compose 컴파일러를 지정하기 위한 코어 런타임에 대한 기본 설정을 수행한다.\n\n\n```koltin\n@Composable\nfun Greeting(name: String) {\n    var greet by remember { mutableStateOf(\"Hello $name\") }\n    Text(text = greet, color = Color.Red)\n}\n```\n\n위의 코드는 Compose Compiler에 의해 `@Composeable`은 아래와 같이 변경된다.\n\n```kotlin\nfun Greeting(\n  $composer: Composer,\n  $static: Int,\n  name: String\n) {\n  $composer.start(123)\n  var greet by remember { mutableStateOf(\"Hello $name\") }\n  Text(text = greet, color = Color.Red)\n  $composer.end()\n}\n```\n\nCompose 는 `composer.start` 에서 고유의 키를 가지고 있고, 이는 Compose 의 state 가 변경될 때 해당 키를 가진 Compose 만 변경되도록 동작한다.\n\nstatic 은 상태(state)의 변경여부를 알 수 있는데 상태의 변화가 없는 경우, `composer.start` 와 `composer.end` 사이의 UI 의 변경을 하지 않는다.\n\n이때 데이터의 상태가 변경되어 UI 를 다시 구성하는 경우는 Recomposition 이라고 한다.","slug":"2021-04-07 Jetpack Compose Part 1","published":1,"updated":"2021-07-25T06:48:23.351Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cksagj7km00003lre8y9f5bri","content":"<article class=\"message message-immersive is-primary\">\n    <div class=\"message-body\">\n        <i class=\"fas fa-pen-fancy mr-2\"></i>Writers<br>\n        by 김남훈 @Naver<br>\n        by 배희성 @RocketPunch<br>\n        by 송시영 @SmartStudy<br>\n        by 이기정 @BankSalad\n    </div>\n</article>\n\n<span id=\"more\"></span>\n\n<h2 id=\"Jetpack-Compose란-무엇인가\"><a href=\"#Jetpack-Compose란-무엇인가\" class=\"headerlink\" title=\"Jetpack Compose란 무엇인가?\"></a>Jetpack Compose란 무엇인가?</h2><img src=\"/Team-Blog/2021/04/07/2021-04-07%20Jetpack%20Compose%20Part%201/compose_animation.gif\" class=\"\" title=\"[compose_animation]\">\n\n<blockquote>\n<p><strong>출처</strong> <a href=\"https://developer.android.com/jetpack/compose\">Android Developers#Jetpack Compse</a></p>\n</blockquote>\n<p>Compose는 Native UI를 코드레벨로 구현할 수 있는 최신 툴킷이다. </p>\n<p>기존의 뷰를 업데이트하는 방식과 달리 Compose를 사용하면 필요한 영역의 뷰를 다시 그려주는 방식으로 작업할 수 있다.</p>\n<p>아래는 아주 간단한 예제이다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Composable</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">Greeting</span><span class=\"params\">(name: <span class=\"type\">String</span>)</span></span> &#123;</span><br><span class=\"line\">\tText(<span class=\"string\">&quot;Hello <span class=\"variable\">$name</span>&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>위의 예제처럼 UI를 구성하는 것이 아니라 화면을 구성하는 뷰의 State 설명하는 것이므로 아무것도 반환하지 않는다.</p>\n<p>아래는 공식 서비스 소개 영상이다.</p>\n<div class=\"video-container\"><iframe src=\"https://www.youtube.com/embed/U5BwfqBpiWU\" frameborder=\"0\" loading=\"lazy\" allowfullscreen></iframe></div>\n\n<h3 id=\"Compose의-4가지-특징\"><a href=\"#Compose의-4가지-특징\" class=\"headerlink\" title=\"Compose의 4가지 특징\"></a>Compose의 4가지 특징</h3><p>구글에서 설명하는 Compose를 이용시 얻을 수 있는 장점은 아래와 같다.</p>\n<ul>\n<li><code>Less Code</code> - 코드 감소<ul>\n<li>적은 수의 코드로 더 많은 작업을 하고 전체 버그 클래스를 방지할 수 있으므로 코드가 간단하며 유지 관리하기 쉽습니다.</li>\n</ul>\n</li>\n<li><code>Intuitive</code> - 직관적<ul>\n<li>UI만 설명하면 나머지는 Compose에서 처리합니다. 앱 상태가 변경되면 UI가 자동으로 업데이트됩니다.</li>\n</ul>\n</li>\n<li><code>Accelerate Development</code> - 빠른 개발 과정<ul>\n<li>기존의 모든 코드와 호환되므로 언제 어디서든 원하는 대로 사용할 수 있습니다. 실시간 미리보기 및 완전한 Android 스튜디오 지원으로 빠르게 반복할 수 있습니다.</li>\n</ul>\n</li>\n<li><code>Powerful</code> - 강력한 성능<ul>\n<li>Android 플랫폼 API에 직접 액세스하고 머티리얼 디자인, 어두운 테마, 애니메이션 등을 기본적으로 지원하는 멋진 앱을 만들 수 있습니다.</li>\n</ul>\n</li>\n</ul>\n<p>늘 그렇듯 구글에서 말하는 설명만 보면 안 쓸 이유가 없어보이고, 대세가 된다면 Android 개발자에게 또 하나의 러닝커브로 작용할 것이다.</p>\n<h2 id=\"Codelab-Jetpack-Compose-basics\"><a href=\"#Codelab-Jetpack-Compose-basics\" class=\"headerlink\" title=\"Codelab - Jetpack Compose basics\"></a>Codelab - Jetpack Compose basics</h2><h3 id=\"1-시작하기전에\"><a href=\"#1-시작하기전에\" class=\"headerlink\" title=\"1. 시작하기전에\"></a>1. 시작하기전에</h3><p>Compose는 아직 정식으로 릴리즈되지 않은 기능이므로 Android Studio Canary에서 프로젝트를 구성하며 몇 가지 제한사항이 존재한다.</p>\n<ol>\n<li>Android Studio Canary </li>\n</ol>\n<p>Canary는 아래 링크에서 다운 받을 수 있다.</p>\n<blockquote>\n<p><a href=\"https://developer.android.com/studio/preview\">Android Studio Preview</a></p>\n</blockquote>\n<ol start=\"2\">\n<li>최신 버전의 Kotlin plugin </li>\n</ol>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ext.kotlin_version = <span class=\"string\">&#x27;1.4.31&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>buildFeatures 및 composeOption 활성화</li>\n</ol>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">android &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    buildFeatures &#123;</span><br><span class=\"line\">        compose <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    composeOptions &#123;</span><br><span class=\"line\">        kotlinCompilerExtensionVersion <span class=\"number\">1.0</span><span class=\"number\">.0</span>-beta02</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    implementation <span class=\"string\">&quot;androidx.compose.ui:ui:1.0.0-beta02&quot;</span></span><br><span class=\"line\">    implementation <span class=\"string\">&quot;androidx.activity:activity-compose:1.3.0-alpha03&quot;</span></span><br><span class=\"line\">    implementation <span class=\"string\">&quot;androidx.compose.material:material:1.0.0-beta02&quot;</span></span><br><span class=\"line\">    implementation <span class=\"string\">&quot;androidx.compose.ui:ui-tooling:1.0.0-beta02&quot;</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-Empty-Compose-프로젝트-생성\"><a href=\"#2-Empty-Compose-프로젝트-생성\" class=\"headerlink\" title=\"2. Empty Compose 프로젝트 생성\"></a>2. Empty Compose 프로젝트 생성</h3><p>[File] - [New] - [New Project…] 를 눌러 새로운 프로젝트를 선택하고(Preview) Empty Compose Activity 를 선택한다.</p>\n<img src=\"/Team-Blog/2021/04/07/2021-04-07%20Jetpack%20Compose%20Part%201/1_5gfrQWfxyEC7Oq6b2xlJ9w.png\" class=\"\" title=\"[1_5gfrQWfxyEC7Oq6b2xlJ9w]\">\n\n<p>선택 이후 Next를 클릭하고, Compose를 구현할 수 있는 최소 API 레벨인 21을 선택해야한다.</p>\n<p>프로젝트를 생성하면 아래와 같이 app/build.gradle에 의존성 설정 및 추가가 되어 있는것을 알 수 있다.</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">android &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    kotlinOptions &#123;</span><br><span class=\"line\">        jvmTarget = <span class=\"string\">&#x27;1.8&#x27;</span></span><br><span class=\"line\">        useIR = <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    buildFeatures &#123;</span><br><span class=\"line\">        compose <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    composeOptions &#123;</span><br><span class=\"line\">        kotlinCompilerExtensionVersion compose_version</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    implementation <span class=\"string\">&quot;androidx.compose.ui:ui:$compose_version&quot;</span></span><br><span class=\"line\">    implementation <span class=\"string\">&quot;androidx.activity:activity-compose:1.3.0-alpha03&quot;</span></span><br><span class=\"line\">    implementation <span class=\"string\">&quot;androidx.compose.material:material:$compose_version&quot;</span></span><br><span class=\"line\">    implementation <span class=\"string\">&quot;androidx.compose.ui:ui-tooling:$compose_version&quot;</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>이때 composeOptions 설정에서 kotlinCompilerVersion 에 따라 compose 가 다르게 동작할 수 있음을 유의하자.</p>\n<p>프로젝트를 생성하면 아래와 같은 기본 파일들이 생성된다.</p>\n<p><strong>MainActivity.kt</strong></p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MainActivity</span> : <span class=\"type\">AppCompatActivity</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onCreate</span><span class=\"params\">(savedInstanceState: <span class=\"type\">Bundle</span>?)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onCreate(savedInstanceState)</span><br><span class=\"line\">        setContent &#123;</span><br><span class=\"line\">            MyFirstComposeApplicationTheme &#123;</span><br><span class=\"line\">                <span class=\"comment\">// A surface container using the &#x27;background&#x27; color from the theme</span></span><br><span class=\"line\">                Surface(color = MaterialTheme.colors.background) &#123;</span><br><span class=\"line\">                    Greeting(<span class=\"string\">&quot;Android&quot;</span>)</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Composable</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">Greeting</span><span class=\"params\">(name: <span class=\"type\">String</span>)</span></span> &#123;</span><br><span class=\"line\">    Text(text = <span class=\"string\">&quot;Hello <span class=\"variable\">$name</span>!&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Preview(showBackground = true)</span></span><br><span class=\"line\"><span class=\"meta\">@Composable</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">DefaultPreview</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    MyFirstComposeApplicationTheme &#123;</span><br><span class=\"line\">        Greeting(<span class=\"string\">&quot;Android&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>ui/theme/Theme.kt</strong></p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">val</span> DarkColorPalette = darkColors(</span><br><span class=\"line\">    primary = Purple200,</span><br><span class=\"line\">    primaryVariant = Purple700,</span><br><span class=\"line\">    secondary = Teal200</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">val</span> LightColorPalette = lightColors(</span><br><span class=\"line\">    primary = Purple500,</span><br><span class=\"line\">    primaryVariant = Purple700,</span><br><span class=\"line\">    secondary = Teal200*</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Other default colors to override</span></span><br><span class=\"line\"><span class=\"comment\">    background = Color.White,</span></span><br><span class=\"line\"><span class=\"comment\">    surface = Color.White,</span></span><br><span class=\"line\"><span class=\"comment\">    onPrimary = Color.White,</span></span><br><span class=\"line\"><span class=\"comment\">    onSecondary = Color.Black,</span></span><br><span class=\"line\"><span class=\"comment\">    onBackground = Color.Black,</span></span><br><span class=\"line\"><span class=\"comment\">    onSurface = Color.Black,</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Composable</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">MyFirstComposeApplicationTheme</span><span class=\"params\">(darkTheme: <span class=\"type\">Boolean</span> = isSystemInDarkTheme()</span></span>, content: <span class=\"meta\">@Composable</span> () -&gt; <span class=\"built_in\">Unit</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> colors = <span class=\"keyword\">if</span> (darkTheme) &#123;</span><br><span class=\"line\">        DarkColorPalette*</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        LightColorPalette*</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    MaterialTheme(</span><br><span class=\"line\">        colors = colors,</span><br><span class=\"line\">        typography = Typography,</span><br><span class=\"line\">        shapes = Shapes,</span><br><span class=\"line\">        content = content</span><br><span class=\"line\">    )</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>기본 생성된 코드를 보았을 때, Compose는 총 3가지의 구성 요소를 가지는 것으로 추측할 수 있다.</p>\n<ol>\n<li>위젯을 포함하는 Composable 함수</li>\n<li>Preview를 하기 위한 Preview Composable 함수</li>\n<li>setContent 람다 표현식으로 실제 화면에 노출하는 코드</li>\n</ol>\n<p>일반적으로 우리가 아는 Activity의 라이프사이클 콜백 <code>onCreate()</code>에서   <code>setContentView(Int)</code> 함수를 호출하던것이 <code>setContent()</code> 함수로 바뀐것이 가장 큰 특징으로 보여진다.</p>\n<h3 id=\"3-Composable-Function\"><a href=\"#3-Composable-Function\" class=\"headerlink\" title=\"3. Composable Function\"></a>3. Composable Function</h3><p>Composable Function은 어노테이션을 이용한 기술이다. 함수위에 <code>@Composable</code> 어노테이션을 붙이게 되면 함수 안 다른 함수를 호출할 수 있게된다. 아래 코드를 보자.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Composable</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">Greeting</span><span class=\"params\">(names: <span class=\"type\">List</span>&lt;<span class=\"type\">String</span>&gt;)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (name <span class=\"keyword\">in</span> names) &#123;</span><br><span class=\"line\">        Text(<span class=\"string\">&quot;Hello <span class=\"variable\">$name</span>&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>단순하게 내부에는 Text라는 함수가 존재하는데, 이를 통해 UI계층 별 요구하는 컴포넌트를 생성해준다. 기본적으로 보이는 text 파라미터는 내부 속성에서 받는 일부 중 하나이다.</p>\n<h3 id=\"4-TextView-만들기\"><a href=\"#4-TextView-만들기\" class=\"headerlink\" title=\"4. TextView 만들기\"></a>4. TextView 만들기</h3><p>위 코드를 실행시켜보면 당연하게도 Hello로 시작하는 TextView가 화면에 그려질것을 암시한다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setContent &#123;</span><br><span class=\"line\">  BasicsCodelabTheme &#123;</span><br><span class=\"line\">    <span class=\"comment\">// A surface container using the &#x27;background&#x27; color from the theme</span></span><br><span class=\"line\">    Surface(color = MaterialTheme.colors.background) &#123;</span><br><span class=\"line\">      Greeting(<span class=\"string\">&quot;Android&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<img src=\"/Team-Blog/2021/04/07/2021-04-07%20Jetpack%20Compose%20Part%201/aO6Jlsg.png\" class=\"\" title=\"[aO6Jlsg]\">\n\n<h3 id=\"5-Preview\"><a href=\"#5-Preview\" class=\"headerlink\" title=\"5. @Preview\"></a>5. <code>@Preview</code></h3><p>말 그대로 어노테이션을 이용하여 IDE에서 Preview를하기 위한 용도이다. 아래 코드와 같이 @Preview 어노테이션을 추가하면 다음 결과를 볼 수 있다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Preview(<span class=\"meta-string\">&quot;Greeting Preview&quot;</span>)</span></span><br><span class=\"line\"><span class=\"meta\">@Composable</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">GreetingPreview</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    BasicsCodelabTheme &#123;</span><br><span class=\"line\">        Surface(color = MaterialTheme.colors.background) &#123;</span><br><span class=\"line\">            Greeting(<span class=\"string\">&quot;Android&quot;</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<img src=\"/Team-Blog/2021/04/07/2021-04-07%20Jetpack%20Compose%20Part%201/WprDTs1.png\" class=\"\" title=\"[WprDTs1]\">\n\n<h3 id=\"6-setContent-Theme-Surface\"><a href=\"#6-setContent-Theme-Surface\" class=\"headerlink\" title=\"6. setContent / Theme / Surface\"></a>6. setContent / Theme / Surface</h3><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setContent &#123;</span><br><span class=\"line\">  BasicsCodelabTheme &#123;</span><br><span class=\"line\">    <span class=\"comment\">// A surface container using the &#x27;background&#x27; color from the theme</span></span><br><span class=\"line\">    Surface(color = MaterialTheme.colors.background) &#123;</span><br><span class=\"line\">      Greeting(<span class=\"string\">&quot;Android&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>기존에 onCreate시점에 화면을 그려주기 위한 필수적인 요소를 정리해보자면</p>\n<ul>\n<li><p><strong>setContent</strong> : Activity에서 setContentView함수를 사용하는 것과 동일한 동작을 하는 확장함수이다. 다만, setContent의 경우 (@Composable) -&gt; Unit 타입의 컴포즈 UI를 구현해주어야한다.</p>\n</li>\n<li><p><strong>XXXTheme</strong> : Theme정보를 의미한다. 해당 프로젝트에서는 Theme.kt에 여러 테마에 필요한 정보를 정리하고, 컴포즈 UI 구현을 위한 코드를 작성해두었다.</p>\n</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">val</span> DarkColorPalette = darkColors(</span><br><span class=\"line\">    primary = purple200,</span><br><span class=\"line\">    primaryVariant = purple700,</span><br><span class=\"line\">    secondary = teal200</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">val</span> LightColorPalette = lightColors(</span><br><span class=\"line\">    primary = purple500,</span><br><span class=\"line\">    primaryVariant = purple700,</span><br><span class=\"line\">    secondary = teal200</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Other default colors to override</span></span><br><span class=\"line\"><span class=\"comment\">    background = Color.White,</span></span><br><span class=\"line\"><span class=\"comment\">    surface = Color.White,</span></span><br><span class=\"line\"><span class=\"comment\">    onPrimary = Color.White,</span></span><br><span class=\"line\"><span class=\"comment\">    onSecondary = Color.Black,</span></span><br><span class=\"line\"><span class=\"comment\">    onBackground = Color.Black,</span></span><br><span class=\"line\"><span class=\"comment\">    onSurface = Color.Black,</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Composable</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">BasicsCodelabTheme</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    darkTheme: <span class=\"type\">Boolean</span> = isSystemInDarkTheme()</span></span>,</span><br><span class=\"line\">    content: <span class=\"meta\">@Composable</span> () -&gt; <span class=\"built_in\">Unit</span></span><br><span class=\"line\">) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> colors = <span class=\"keyword\">if</span> (darkTheme) &#123;</span><br><span class=\"line\">        DarkColorPalette</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        LightColorPalette</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    MaterialTheme(</span><br><span class=\"line\">        colors = colors,</span><br><span class=\"line\">        typography = typography,</span><br><span class=\"line\">        shapes = shapes,</span><br><span class=\"line\">        content = content</span><br><span class=\"line\">    )</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>Surface</strong> : Greeting을 감싸는 뷰에 해당한다. 여기서는 크기를 정하지 않고, background 색상을 정의하고 있다. 역시 람다 표현식이다. 색상에 대한 Paramter로 <code>color</code> 라는 값을 사용하여 부여가 가능하다. 내부코드를 보면</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Composable</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">Surface</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    modifier: <span class=\"type\">Modifier</span> = Modifier,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    shape: <span class=\"type\">Shape</span> = RectangleShape,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    color: <span class=\"type\">Color</span> = MaterialTheme.colors.surface,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    contentColor: <span class=\"type\">Color</span> = contentColorFor(color)</span></span>,</span><br><span class=\"line\">    border: BorderStroke? = <span class=\"literal\">null</span>,</span><br><span class=\"line\">    elevation: Dp = <span class=\"number\">0.</span>dp,</span><br><span class=\"line\">    content: <span class=\"meta\">@Composable</span> () -&gt; <span class=\"built_in\">Unit</span></span><br><span class=\"line\">) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> elevationPx = with(LocalDensity.current) &#123; elevation.toPx() &#125;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> elevationOverlay = LocalElevationOverlay.current</span><br><span class=\"line\">    <span class=\"keyword\">val</span> absoluteElevation = LocalAbsoluteElevation.current + elevation</span><br><span class=\"line\">    <span class=\"keyword\">val</span> backgroundColor = <span class=\"keyword\">if</span> (color == MaterialTheme.colors.surface &amp;&amp; elevationOverlay != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        elevationOverlay.apply(color, absoluteElevation)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        color</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    CompositionLocalProvider(</span><br><span class=\"line\">        LocalContentColor provides contentColor,</span><br><span class=\"line\">        LocalAbsoluteElevation provides absoluteElevation</span><br><span class=\"line\">    ) &#123;</span><br><span class=\"line\">        Box(</span><br><span class=\"line\">            modifier.graphicsLayer(shadowElevation = elevationPx, shape = shape)</span><br><span class=\"line\">                .then(<span class=\"keyword\">if</span> (border != <span class=\"literal\">null</span>) Modifier.border(border, shape) <span class=\"keyword\">else</span> Modifier)</span><br><span class=\"line\">                .background(</span><br><span class=\"line\">                    color = backgroundColor,</span><br><span class=\"line\">                    shape = shape</span><br><span class=\"line\">                )</span><br><span class=\"line\">                .clip(shape),</span><br><span class=\"line\">            propagateMinConstraints = <span class=\"literal\">true</span></span><br><span class=\"line\">        ) &#123;</span><br><span class=\"line\">            content()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"7-Declarative-UI-선언형-UI\"><a href=\"#7-Declarative-UI-선언형-UI\" class=\"headerlink\" title=\"7. Declarative UI - 선언형 UI\"></a>7. Declarative UI - 선언형 UI</h3><p>노란색 배경을 입혀 기존 TextView에 추가해보았다. 또한, Greeting에는 Modifier라는 것을 이용하여 Padding을 추가했다. 아래와 같은 결과가 나오게 되었다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BasicsCodelabTheme &#123;</span><br><span class=\"line\">  <span class=\"comment\">// A surface container using the &#x27;background&#x27; color from the theme</span></span><br><span class=\"line\">  Surface(color = Color.Yellow) &#123;</span><br><span class=\"line\">    Greeting(<span class=\"string\">&quot;Android&quot;</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Composable</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">Greeting</span><span class=\"params\">(name: <span class=\"type\">String</span>)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> isSelected <span class=\"keyword\">by</span> remember &#123; mutableStateOf(<span class=\"literal\">false</span>) &#125;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> backgroundColor <span class=\"keyword\">by</span> animateColorAsState(<span class=\"keyword\">if</span> (isSelected) Color.Red <span class=\"keyword\">else</span> Color.Transparent)</span><br><span class=\"line\"></span><br><span class=\"line\">    Text(</span><br><span class=\"line\">        text = <span class=\"string\">&quot;Hello <span class=\"variable\">$name</span>!&quot;</span>,</span><br><span class=\"line\">        modifier = Modifier</span><br><span class=\"line\">            .padding(<span class=\"number\">24.</span>dp)</span><br><span class=\"line\">            .background(color = backgroundColor)</span><br><span class=\"line\">            .clickable(onClick = &#123; isSelected = !isSelected &#125;)</span><br><span class=\"line\">    )</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<img src=\"/Team-Blog/2021/04/07/2021-04-07%20Jetpack%20Compose%20Part%201/qgQ6oY4.png\" class=\"\" title=\"[qgQ6oY4]\">\n\n<p>선언형 UI의 장점은 말 그대로 내가 UI를 정의한대로 시각적으로 표현이 가능하다는 장점이 있다. 기존에는 속성을 매번 On/Off와 같은 옵션을 통해 변경하는 것이 다반사였지만, 이제는 매번 속성에 변경이 생길때마다 새로 그려주게 되는것이다.</p>\n<h3 id=\"8-재사용\"><a href=\"#8-재사용\" class=\"headerlink\" title=\"8. 재사용\"></a>8. 재사용</h3><p>Compose의 장점 중 하나는 재사용성이 뛰어난것인데, XML에서 우리가 include 태그를 통해 여러곳에서 갖다쓸 수 있던것처럼, 함수를 통해 여러곳에서 정의하여 사용이 가능하다.</p>\n<p>참고해야할 점은 Compose 컴포넌트 확장 시 <code>@Composable</code> 어노테이션을 붙여야 한다.</p>\n<h3 id=\"9-Container-작성\"><a href=\"#9-Container-작성\" class=\"headerlink\" title=\"9. Container 작성\"></a>9. Container 작성</h3><p>MyApp이라는 이름으로 컴포즈 컴포넌트를 구횬하여 여러곳에서 공통으로 사용할 수 있는 Composable을 구현하였다. 내부적으로 Container내 내가 원하는 컴포넌트를 넣어주려면 아래와 같이 인자로 <code>@Composable () -&gt; Unit</code> 타입을 넘겨받아 처리해주면 된다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Composable</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">MyApp</span><span class=\"params\">(content: @<span class=\"type\">Composable</span> () -&gt; <span class=\"type\">Unit</span>)</span></span> &#123;</span><br><span class=\"line\">    BasicsCodelabTheme &#123;</span><br><span class=\"line\">        Surface(color = Color.Yellow) &#123;</span><br><span class=\"line\">            content()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>위 함수를 통해 이제는 어디서든 반복해서 사용할 수 있는 Container를 구현하게 되어 아래와 같이 코드를 활용할 수 있게되었다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MainActivity</span> : <span class=\"type\">AppCompatActivity</span></span>() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onCreate</span><span class=\"params\">(savedInstanceState: <span class=\"type\">Bundle</span>?)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.onCreate(savedInstanceState)</span><br><span class=\"line\">    setContent &#123;</span><br><span class=\"line\">      MyApp &#123;</span><br><span class=\"line\">        Greeting(<span class=\"string\">&quot;Android&quot;</span>)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"10-레이아웃을-활용한-Compose-function의-다중-호출\"><a href=\"#10-레이아웃을-활용한-Compose-function의-다중-호출\" class=\"headerlink\" title=\"10. 레이아웃을 활용한 Compose function의 다중 호출\"></a>10. 레이아웃을 활용한 Compose function의 다중 호출</h3><p>지금까지는 하나의 컴포넌트만을 갖고 사용했지만, 여러개의 컴포넌트를 넣는것도 가능하다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Composable</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">MyScreenContent</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    Column &#123;</span><br><span class=\"line\">        Greeting(<span class=\"string\">&quot;Android&quot;</span>)</span><br><span class=\"line\">        Divider(color = Color.Black)</span><br><span class=\"line\">        Greeting(<span class=\"string\">&quot;there&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p> <code>Column</code>과 위에서부터 사용하던 <code>Greeting</code> 함수를 사용하고, 라인을 그어주기 위한 <code>Divider</code>를 추가한 결과물은 다음과 같다.</p>\n<img src=\"/Team-Blog/2021/04/07/2021-04-07%20Jetpack%20Compose%20Part%201/VLTxB8C.png\" class=\"\" title=\"[VLTxB8C]\">\n\n<p>위 컴포넌트 중 못보던 컴포저블이 있는데, 아래와 같이 설명이 가능하다.</p>\n<ul>\n<li>Column : 항목을 순서대로 배치하기 위해 사용한다.</li>\n<li>Divider : 선 긋기 가능한 Compose 함수이다.</li>\n</ul>\n<p>이를 리스트 형태로도 구현이 가능하다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Composable</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">MyColumnScreen</span><span class=\"params\">(names: <span class=\"type\">List</span>&lt;<span class=\"type\">String</span>&gt; = listOf(<span class=\"string\">&quot;Line One&quot;</span>, <span class=\"string\">&quot;Line Two&quot;</span>)</span></span>) &#123;</span><br><span class=\"line\">    Column &#123;</span><br><span class=\"line\">        names.forEach &#123;</span><br><span class=\"line\">            Greeting(name = it)</span><br><span class=\"line\">            Divider(color = Color.Black)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"11-State-in-Compose-Compose에서의-상태값-관리\"><a href=\"#11-State-in-Compose-Compose에서의-상태값-관리\" class=\"headerlink\" title=\"11. State in Compose - Compose에서의 상태값 관리\"></a>11. State in Compose - Compose에서의 상태값 관리</h3><p>컴포넌트에 버튼을 클릭했을 때 클릭한 카운트를 집계하는 간단한 컴포넌트를 만들어보았다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Composable</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">MyColumnScreen</span><span class=\"params\">(names: <span class=\"type\">List</span>&lt;<span class=\"type\">String</span>&gt; = listOf(<span class=\"string\">&quot;Line One&quot;</span>, <span class=\"string\">&quot;Line Two&quot;</span>)</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> counterState = remember &#123; mutableStateOf(<span class=\"number\">0</span>) &#125; <span class=\"comment\">// </span></span><br><span class=\"line\"></span><br><span class=\"line\">    Column &#123;</span><br><span class=\"line\">        names.forEach &#123;</span><br><span class=\"line\">            Greeting(name = it)</span><br><span class=\"line\">            Divider(color = Color.Black)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Counter(</span><br><span class=\"line\">            count = counterState.value,</span><br><span class=\"line\">            updateCount = &#123; newCount -&gt;</span><br><span class=\"line\">                counterState.value = newCount</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>remember라는 함수를 사용하여 기존에 존재하는 컴포넌트의 상태값을 기억하게 하는 함수가 있다. </p>\n<p><code>remember</code> 함수의 내부를 살펴보자.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Remember the value produced by [calculation]. [calculation] will only be evaluated during the composition.</span></span><br><span class=\"line\"><span class=\"comment\"> * Recomposition will always return the value produced by composition.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@OptIn(ComposeCompilerApi::class)</span></span><br><span class=\"line\"><span class=\"meta\">@Composable</span></span><br><span class=\"line\"><span class=\"keyword\">inline</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"type\">&lt;T&gt;</span> <span class=\"title\">remember</span><span class=\"params\">(calculation: @<span class=\"type\">DisallowComposableCalls</span> () -&gt; <span class=\"type\">T</span>)</span></span>: T =</span><br><span class=\"line\">    currentComposer.cache(<span class=\"literal\">false</span>, calculation)</span><br></pre></td></tr></table></figure>\n\n<p>매 호출마다 Recomposition(재조합)하게되는 경우 컴포넌트에 값을 다시 제공하는 것을 알 수 있다. @Composable 어노테이션에 들어간 함수는 매번 해당 상태를 구독하고, 상태가 변경될때마다 알림을 받아 기존 화면을 갱신해준다.</p>\n<p>그리고, 아래 Counter를 보면 Button을 이용하여 이벤트를 받아 처리하도록 했다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Composable</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">Counter</span><span class=\"params\">(count: <span class=\"type\">Int</span>, updateCount: (<span class=\"type\">Int</span>) -&gt; <span class=\"type\">Unit</span>)</span></span> &#123;</span><br><span class=\"line\">    Button(</span><br><span class=\"line\">        onClick = &#123; updateCount(count + <span class=\"number\">1</span>) &#125;,</span><br><span class=\"line\">        colors = ButtonDefaults.buttonColors(</span><br><span class=\"line\">            backgroundColor = <span class=\"keyword\">if</span> (count &gt; <span class=\"number\">5</span>) Color.Green <span class=\"keyword\">else</span> Color.White</span><br><span class=\"line\">        )</span><br><span class=\"line\">    ) &#123;</span><br><span class=\"line\">        Text(<span class=\"string\">&quot;I&#x27;ve been clicked <span class=\"variable\">$count</span> times&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>updateCount(Int)</code> 함수릉 통해 매번 값을 업데이트 해주는데, 이를 통해 counterState에 값을 넣어주면서 해당 컴포넌트가 매번 변경이 되는것이다.</p>\n<p>따라서 결과를 보면, 다음과 같다. Count가 5가 넘어가면 초록색으로 바뀐다.</p>\n\n\n<p>그 외에도 여러형태의 모양을 구성할수 있도록 옵션이 제공되어 있다. 자세한 정보는 나중에 <a href=\"https://developer.android.com/codelabs/jetpack-compose-basics\">Codelabs</a>에 더 나와 있으니 보도록하고, 이번에 setContent에 대한 동작원리를 함께 고민해보자.</p>\n<h3 id=\"12-Activity에서의-View-생성-방식과의-비교\"><a href=\"#12-Activity에서의-View-생성-방식과의-비교\" class=\"headerlink\" title=\"12. Activity에서의 View 생성 방식과의 비교\"></a>12. Activity에서의 View 생성 방식과의 비교</h3><p>Compose를 안드로이드 앱에서 사용하려면 Activity, Fragment와 같은곳에서 contentView로 뿌려줘야한다. 기존에 우리가 사용하던 함수를 보자.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* Set the activity content from a layout resource.  The resource will be</span></span><br><span class=\"line\"><span class=\"comment\">* inflated, adding all top-level views to the activity.</span></span><br><span class=\"line\"><span class=\"comment\">*</span></span><br><span class=\"line\"><span class=\"comment\">* <span class=\"doctag\">@param</span> layoutResID Resource ID to be inflated.</span></span><br><span class=\"line\"><span class=\"comment\">*</span></span><br><span class=\"line\"><span class=\"comment\">* <span class=\"doctag\">@see</span> #setContentView(android.view.View)</span></span><br><span class=\"line\"><span class=\"comment\">* <span class=\"doctag\">@see</span> #setContentView(android.view.View, android.view.ViewGroup.LayoutParams)</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setContentView</span><span class=\"params\">(<span class=\"meta\">@LayoutRes</span> <span class=\"keyword\">int</span> layoutResID)</span> </span>&#123;</span><br><span class=\"line\">  getWindow().setContentView(layoutResID);</span><br><span class=\"line\">  initWindowDecorActionBar();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>UI 컴포넌트에서 화면을 붙일 수 있는 Window라는 녀석에서 Layout Resource Id를 통해 기존에 등록되어있던 Layout XML 파일을 로드하여 인플레이터에서 파싱하고, 이를통해 레이아웃 계층에 있는 뷰객체를 생성하여 순차적으로 ViewGroup, View를 만들어 넣어주게 된다.</p>\n<p><code>PhoneWindow</code>를 보면 자세하게 알 수 있는데, Window를 구현한 setContentView에서 처음에 생성되는 최상위 레이아웃 그 위에 따로 없다면 <code>installDecor()</code> 함수를 통해 mContentParent(레이아웃 리소스가 붙게될 ViewGroup)를 생성하고, 하위에 넣어주게 된다.</p>\n<p>그러면 기존 방식은 이정도로 설명을하고, 이번엔 Compose에서 <code>setContent()</code> 라는 함수를 어떻게 사용하는지 보자.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Composes the given composable into the given activity. The [content] will become the root view</span></span><br><span class=\"line\"><span class=\"comment\"> * of the given activity.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * This is roughly equivalent to calling [ComponentActivity.setContentView] with a [ComposeView]</span></span><br><span class=\"line\"><span class=\"comment\"> * i.e.:</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * ```</span></span><br><span class=\"line\"><span class=\"comment\"> * setContentView(</span></span><br><span class=\"line\"><span class=\"comment\"> *   ComposeView(this).apply &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     setContent &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *       MyComposableContent()</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *   &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * )</span></span><br><span class=\"line\"><span class=\"comment\"> * ```</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> parent The parent composition reference to coordinate scheduling of composition updates</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> content A `<span class=\"doctag\">@Composable</span>` function declaring the UI contents</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">fun</span> ComponentActivity.<span class=\"title\">setContent</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    parent: <span class=\"type\">CompositionContext</span>? = <span class=\"literal\">null</span>,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    content: @<span class=\"type\">Composable</span> () -&gt; <span class=\"type\">Unit</span></span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> existingComposeView = window.decorView</span><br><span class=\"line\">        .findViewById&lt;ViewGroup&gt;(android.R.id.content)</span><br><span class=\"line\">        .getChildAt(<span class=\"number\">0</span>) <span class=\"keyword\">as</span>? ComposeView</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (existingComposeView != <span class=\"literal\">null</span>) with(existingComposeView) &#123;</span><br><span class=\"line\">        setParentCompositionContext(parent)</span><br><span class=\"line\">        setContent(content)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> ComposeView(<span class=\"keyword\">this</span>).apply &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Set content and parent **before** setContentView</span></span><br><span class=\"line\">        <span class=\"comment\">// to have ComposeView create the composition on attach</span></span><br><span class=\"line\">        setParentCompositionContext(parent)</span><br><span class=\"line\">        setContent(content)</span><br><span class=\"line\">        <span class=\"comment\">// Set the view tree owners before setting the content view so that the inflation process</span></span><br><span class=\"line\">        <span class=\"comment\">// and attach listeners will see them already present</span></span><br><span class=\"line\">        setOwners()</span><br><span class=\"line\">        setContentView(<span class=\"keyword\">this</span>, DefaultActivityContentLayoutParams)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>이녀석도 마찬가지로 <code>window.decorView.findViewById&lt;ViewGroup&gt;(android.R.id.content)</code>  함수를 호출하여 decorView를 가져온다. 만약 compose를 통해 만들어진 최상위 레이아웃이 존재하면, 기존에 inflator에서 ViewGroup, View를 생성해서 넣어주던것 처럼 <code>setContent()</code> =&gt; window가 Activity/Fragment에 붙으면 <code>createComposition()</code>를 호출하여 검증 후 <code>ensureCompsositionCreated()</code> 함수를 호출한다. 현재는 내부적으로 <code>ViewGroup.setContent()</code> 를 사용하고 있는데, 곧 교체 될 예정이라고 한다. 이코드도 보면 기존에 있는 ViewGroup에 확장함수로 구현한 녀석인데, 쉽게 말해 ViewGroup에 하위 View, ViewGroup에 Composable로 구현된 함수로 컴포넌트를 넣어줄 때 AndroidComposeView라는 객체를 꺼내오거나 없다면 새로 생성하여 넣어준다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Composes the given composable into the given view.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * The new composition can be logically &quot;linked&quot; to an existing one, by providing a</span></span><br><span class=\"line\"><span class=\"comment\"> * [parent]. This will ensure that invalidations and CompositionLocals will flow through</span></span><br><span class=\"line\"><span class=\"comment\"> * the two compositions as if they were not separate.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Note that this [ViewGroup] should have an unique id for the saved instance state mechanism to</span></span><br><span class=\"line\"><span class=\"comment\"> * be able to save and restore the values used within the composition. See [View.setId].</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> parent The [Recomposer] or parent composition reference.</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> content Composable that will be the content of the view.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">internal</span> <span class=\"function\"><span class=\"keyword\">fun</span> ViewGroup.<span class=\"title\">setContent</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    parent: <span class=\"type\">CompositionContext</span>,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    content: @<span class=\"type\">Composable</span> () -&gt; <span class=\"type\">Unit</span></span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">)</span></span>: Composition &#123;</span><br><span class=\"line\">    GlobalSnapshotManager.ensureStarted()</span><br><span class=\"line\">    <span class=\"keyword\">val</span> composeView =</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (childCount &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            getChildAt(<span class=\"number\">0</span>) <span class=\"keyword\">as</span>? AndroidComposeView</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            removeAllViews(); <span class=\"literal\">null</span></span><br><span class=\"line\">        &#125; ?: AndroidComposeView(context).also &#123; addView(it.view, DefaultLayoutParams) &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> doSetContent(composeView, parent, content)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>다시 돌아와서, ComposeView의 <code>setContent()</code> 이라는 녀석을 보자.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * A [android.view.View] that can host Jetpack Compose UI content.</span></span><br><span class=\"line\"><span class=\"comment\"> * Use [setContent] to supply the content composable function for the view.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * This [android.view.View] requires that the window it is attached to contains a</span></span><br><span class=\"line\"><span class=\"comment\"> * [ViewTreeLifecycleOwner]. This [androidx.lifecycle.LifecycleOwner] is used to</span></span><br><span class=\"line\"><span class=\"comment\"> * [dispose][androidx.compose.runtime.Composition.dispose] of the underlying composition</span></span><br><span class=\"line\"><span class=\"comment\"> * when the host [Lifecycle] is destroyed, permitting the view to be attached and</span></span><br><span class=\"line\"><span class=\"comment\"> * detached repeatedly while preserving the composition. Call [disposeComposition]</span></span><br><span class=\"line\"><span class=\"comment\"> * to dispose of the underlying composition earlier, or if the view is never initially</span></span><br><span class=\"line\"><span class=\"comment\"> * attached to a window. (The requirement to dispose of the composition explicitly</span></span><br><span class=\"line\"><span class=\"comment\"> * in the event that the view is never (re)attached is temporary.)</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ComposeView</span> <span class=\"meta\">@JvmOverloads</span> <span class=\"keyword\">constructor</span></span>(</span><br><span class=\"line\">    context: Context,</span><br><span class=\"line\">    attrs: AttributeSet? = <span class=\"literal\">null</span>,</span><br><span class=\"line\">    defStyleAttr: <span class=\"built_in\">Int</span> = <span class=\"number\">0</span></span><br><span class=\"line\">) : AbstractComposeView(context, attrs, defStyleAttr) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">val</span> content = mutableStateOf&lt;(<span class=\"meta\">@Composable</span> () -&gt; <span class=\"built_in\">Unit</span>)?&gt;(<span class=\"literal\">null</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Suppress(<span class=\"meta-string\">&quot;RedundantVisibilityModifier&quot;</span>)</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">override</span> <span class=\"keyword\">var</span> shouldCreateCompositionOnAttachedToWindow: <span class=\"built_in\">Boolean</span> = <span class=\"literal\">false</span></span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">set</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Composable</span></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">Content</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        content.value?.invoke()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Set the Jetpack Compose UI content for this view.</span></span><br><span class=\"line\"><span class=\"comment\">     * Initial composition will occur when the view becomes attached to a window or when</span></span><br><span class=\"line\"><span class=\"comment\">     * [createComposition] is called, whichever comes first.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">setContent</span><span class=\"params\">(content: @<span class=\"type\">Composable</span> () -&gt; <span class=\"type\">Unit</span>)</span></span> &#123;</span><br><span class=\"line\">        shouldCreateCompositionOnAttachedToWindow = <span class=\"literal\">true</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.content.value = content</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isAttachedToWindow) &#123;</span><br><span class=\"line\">            createComposition()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>결론적으로 <code>AbstractComposeView</code> 라는 녀석은 ViewGroup을 상속받은 녀석이며, 모든 composable의 상태가 변화 되었을 때 이를 감지하는 중요한 녀석이다.</p>\n<p><code>setContent()</code>라는 함수는 위에서 설명했으니 넘어가고, 이번에는 <code>Content</code>라는 녀석을 보자. 이녀석은 추상 메소드로, <code>createComposition()</code> 이라는 함수가 호출 되었을 때, 가장 먼저 불리는 함수이다. 아까 언급되었던 <code>ensureCompsositionCreated()</code> 함수에서 tree계층의 ComposeView가 다 붙었다면, 이후에 즉시 Content함수가 호출이된다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Suppress(<span class=\"meta-string\">&quot;DEPRECATION&quot;</span>)</span> <span class=\"comment\">// Still using ViewGroup.setContent for now</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">ensureCompositionCreated</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (composition == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                creatingComposition = <span class=\"literal\">true</span></span><br><span class=\"line\">                composition = setContent(</span><br><span class=\"line\">                    parentContext ?: findViewTreeCompositionContext() ?: windowRecomposer</span><br><span class=\"line\">                ) &#123;</span><br><span class=\"line\">                    Content() <span class=\"comment\">// 이곳에서 뷰가 다 window에 붙게되면 콜백을 호출한다.</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                creatingComposition = <span class=\"literal\">false</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>그러면 아래 <code>ComposeView</code>의 오버라이딩 된 Content가 호출되면서, 기존에 생성된 View에 UI속성과 같은 Content가 붙게된다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* The Jetpack Compose UI content for this view.</span></span><br><span class=\"line\"><span class=\"comment\">* Subclasses must implement this method to provide content. Initial composition will</span></span><br><span class=\"line\"><span class=\"comment\">* occur when the view becomes attached to a window or when [createComposition] is called,</span></span><br><span class=\"line\"><span class=\"comment\">* whichever comes first.</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"meta\">@Composable</span></span><br><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">Content</span><span class=\"params\">()</span></span></span><br></pre></td></tr></table></figure>\n\n<p>Content는 설명에서 보는것과 같이 <code>createComposition()</code> 함수 호출 후 View가 Window에 붙은 이후 즉시 호출된다.</p>\n<p>최종적으로 <code>ComponentActivity.setContent(CompositionContext?, @Composable () -&gt; Unit)</code> 함수에서 구현된 ComposeView 인스턴스를 ContentLayout을 widht/height를 wrapContent크기로 정하여 ContentView를 Set해주게 된다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Composes the given composable into the given activity. The [content] will become the root view</span></span><br><span class=\"line\"><span class=\"comment\"> * of the given activity.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * This is roughly equivalent to calling [ComponentActivity.setContentView] with a [ComposeView]</span></span><br><span class=\"line\"><span class=\"comment\"> * i.e.:</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * ```</span></span><br><span class=\"line\"><span class=\"comment\"> * setContentView(</span></span><br><span class=\"line\"><span class=\"comment\"> *   ComposeView(this).apply &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     setContent &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *       MyComposableContent()</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *   &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * )</span></span><br><span class=\"line\"><span class=\"comment\"> * ```</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> parent The parent composition reference to coordinate scheduling of composition updates</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> content A `<span class=\"doctag\">@Composable</span>` function declaring the UI contents</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">fun</span> ComponentActivity.<span class=\"title\">setContent</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    parent: <span class=\"type\">CompositionContext</span>? = <span class=\"literal\">null</span>,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    content: @<span class=\"type\">Composable</span> () -&gt; <span class=\"type\">Unit</span></span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">)</span></span> &#123;</span><br><span class=\"line\">  \t...</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> ComposeView(<span class=\"keyword\">this</span>).apply &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Set content and parent **before** setContentView</span></span><br><span class=\"line\">        <span class=\"comment\">// to have ComposeView create the composition on attach</span></span><br><span class=\"line\">        setParentCompositionContext(parent)</span><br><span class=\"line\">        setContent(content)</span><br><span class=\"line\">        <span class=\"comment\">// Set the view tree owners before setting the content view so that the inflation process</span></span><br><span class=\"line\">        <span class=\"comment\">// and attach listeners will see them already present</span></span><br><span class=\"line\">        setOwners()</span><br><span class=\"line\">        setContentView(<span class=\"keyword\">this</span>, DefaultActivityContentLayoutParams)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"13-ComposeView\"><a href=\"#13-ComposeView\" class=\"headerlink\" title=\"13. ComposeView\"></a>13. ComposeView</h3><p>android.view.View 는 Jetpack Compose UI 콘텐츠를 사용할 수 있도록 해줍니다. setContent 를 사용하면 composable function content 를 뷰에 제공할 수 있다.</p>\n<p>Compose 의 계층 구조는 아래와 같으며. ComposeView 를 통해 androidx.compose.materia 에 정의된 다양한 컴포넌트를 조합하여 Composable function 콘텐츠를 구성할 수 있다.</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kotlin.Any</span><br><span class=\"line\"> ↳ android.view.View</span><br><span class=\"line\">   ↳ android.view.ViewGroup</span><br><span class=\"line\">     ↳ androidx.compose.ui.platform.AbstractComposeView</span><br><span class=\"line\">       ↳ androidx.compose.ui.platform.ComposeView</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"14-Compose-Compiler-Compose-Runtime\"><a href=\"#14-Compose-Compiler-Compose-Runtime\" class=\"headerlink\" title=\"14. Compose Compiler / Compose Runtime\"></a>14. Compose Compiler / Compose Runtime</h3><p>Compose Compiler 는 <code>@Composable</code> 이 설정된 경우 Composable function 으로 코드 변환과 코틀린 컴파일러 플러그인과 함께 최적화를 활성화한다.</p>\n<p>Compose Runtime은 Compose의 프로그래밍 모델과 상태 관리, 그리고 Compose 컴파일러를 지정하기 위한 코어 런타임에 대한 기본 설정을 수행한다.</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Composable</span><br><span class=\"line\">fun Greeting(name: String) &#123;</span><br><span class=\"line\">    var greet by remember &#123; mutableStateOf(&quot;Hello $name&quot;) &#125;</span><br><span class=\"line\">    Text(text = greet, color = Color.Red)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>위의 코드는 Compose Compiler에 의해 <code>@Composeable</code>은 아래와 같이 변경된다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">Greeting</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">  $composer: <span class=\"type\">Composer</span>,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">  $static: <span class=\"type\">Int</span>,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">  name: <span class=\"type\">String</span></span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">)</span></span> &#123;</span><br><span class=\"line\">  $composer.start(<span class=\"number\">123</span>)</span><br><span class=\"line\">  <span class=\"keyword\">var</span> greet <span class=\"keyword\">by</span> remember &#123; mutableStateOf(<span class=\"string\">&quot;Hello <span class=\"variable\">$name</span>&quot;</span>) &#125;</span><br><span class=\"line\">  Text(text = greet, color = Color.Red)</span><br><span class=\"line\">  $composer.end()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Compose 는 <code>composer.start</code> 에서 고유의 키를 가지고 있고, 이는 Compose 의 state 가 변경될 때 해당 키를 가진 Compose 만 변경되도록 동작한다.</p>\n<p>static 은 상태(state)의 변경여부를 알 수 있는데 상태의 변화가 없는 경우, <code>composer.start</code> 와 <code>composer.end</code> 사이의 UI 의 변경을 하지 않는다.</p>\n<p>이때 데이터의 상태가 변경되어 UI 를 다시 구성하는 경우는 Recomposition 이라고 한다.</p>\n","site":{"data":{}},"excerpt":"<article class=\"message message-immersive is-primary\">\n    <div class=\"message-body\">\n        <i class=\"fas fa-pen-fancy mr-2\"></i>Writers<br>\n        by 김남훈 @Naver<br>\n        by 배희성 @RocketPunch<br>\n        by 송시영 @SmartStudy<br>\n        by 이기정 @BankSalad\n    </div>\n</article>","more":"<h2 id=\"Jetpack-Compose란-무엇인가\"><a href=\"#Jetpack-Compose란-무엇인가\" class=\"headerlink\" title=\"Jetpack Compose란 무엇인가?\"></a>Jetpack Compose란 무엇인가?</h2><img src=\"/Team-Blog/2021/04/07/2021-04-07%20Jetpack%20Compose%20Part%201/compose_animation.gif\" class=\"\" title=\"[compose_animation]\">\n\n<blockquote>\n<p><strong>출처</strong> <a href=\"https://developer.android.com/jetpack/compose\">Android Developers#Jetpack Compse</a></p>\n</blockquote>\n<p>Compose는 Native UI를 코드레벨로 구현할 수 있는 최신 툴킷이다. </p>\n<p>기존의 뷰를 업데이트하는 방식과 달리 Compose를 사용하면 필요한 영역의 뷰를 다시 그려주는 방식으로 작업할 수 있다.</p>\n<p>아래는 아주 간단한 예제이다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Composable</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">Greeting</span><span class=\"params\">(name: <span class=\"type\">String</span>)</span></span> &#123;</span><br><span class=\"line\">\tText(<span class=\"string\">&quot;Hello <span class=\"variable\">$name</span>&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>위의 예제처럼 UI를 구성하는 것이 아니라 화면을 구성하는 뷰의 State 설명하는 것이므로 아무것도 반환하지 않는다.</p>\n<p>아래는 공식 서비스 소개 영상이다.</p>\n<div class=\"video-container\"><iframe src=\"https://www.youtube.com/embed/U5BwfqBpiWU\" frameborder=\"0\" loading=\"lazy\" allowfullscreen></iframe></div>\n\n<h3 id=\"Compose의-4가지-특징\"><a href=\"#Compose의-4가지-특징\" class=\"headerlink\" title=\"Compose의 4가지 특징\"></a>Compose의 4가지 특징</h3><p>구글에서 설명하는 Compose를 이용시 얻을 수 있는 장점은 아래와 같다.</p>\n<ul>\n<li><code>Less Code</code> - 코드 감소<ul>\n<li>적은 수의 코드로 더 많은 작업을 하고 전체 버그 클래스를 방지할 수 있으므로 코드가 간단하며 유지 관리하기 쉽습니다.</li>\n</ul>\n</li>\n<li><code>Intuitive</code> - 직관적<ul>\n<li>UI만 설명하면 나머지는 Compose에서 처리합니다. 앱 상태가 변경되면 UI가 자동으로 업데이트됩니다.</li>\n</ul>\n</li>\n<li><code>Accelerate Development</code> - 빠른 개발 과정<ul>\n<li>기존의 모든 코드와 호환되므로 언제 어디서든 원하는 대로 사용할 수 있습니다. 실시간 미리보기 및 완전한 Android 스튜디오 지원으로 빠르게 반복할 수 있습니다.</li>\n</ul>\n</li>\n<li><code>Powerful</code> - 강력한 성능<ul>\n<li>Android 플랫폼 API에 직접 액세스하고 머티리얼 디자인, 어두운 테마, 애니메이션 등을 기본적으로 지원하는 멋진 앱을 만들 수 있습니다.</li>\n</ul>\n</li>\n</ul>\n<p>늘 그렇듯 구글에서 말하는 설명만 보면 안 쓸 이유가 없어보이고, 대세가 된다면 Android 개발자에게 또 하나의 러닝커브로 작용할 것이다.</p>\n<h2 id=\"Codelab-Jetpack-Compose-basics\"><a href=\"#Codelab-Jetpack-Compose-basics\" class=\"headerlink\" title=\"Codelab - Jetpack Compose basics\"></a>Codelab - Jetpack Compose basics</h2><h3 id=\"1-시작하기전에\"><a href=\"#1-시작하기전에\" class=\"headerlink\" title=\"1. 시작하기전에\"></a>1. 시작하기전에</h3><p>Compose는 아직 정식으로 릴리즈되지 않은 기능이므로 Android Studio Canary에서 프로젝트를 구성하며 몇 가지 제한사항이 존재한다.</p>\n<ol>\n<li>Android Studio Canary </li>\n</ol>\n<p>Canary는 아래 링크에서 다운 받을 수 있다.</p>\n<blockquote>\n<p><a href=\"https://developer.android.com/studio/preview\">Android Studio Preview</a></p>\n</blockquote>\n<ol start=\"2\">\n<li>최신 버전의 Kotlin plugin </li>\n</ol>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ext.kotlin_version = <span class=\"string\">&#x27;1.4.31&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>buildFeatures 및 composeOption 활성화</li>\n</ol>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">android &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    buildFeatures &#123;</span><br><span class=\"line\">        compose <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    composeOptions &#123;</span><br><span class=\"line\">        kotlinCompilerExtensionVersion <span class=\"number\">1.0</span><span class=\"number\">.0</span>-beta02</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    implementation <span class=\"string\">&quot;androidx.compose.ui:ui:1.0.0-beta02&quot;</span></span><br><span class=\"line\">    implementation <span class=\"string\">&quot;androidx.activity:activity-compose:1.3.0-alpha03&quot;</span></span><br><span class=\"line\">    implementation <span class=\"string\">&quot;androidx.compose.material:material:1.0.0-beta02&quot;</span></span><br><span class=\"line\">    implementation <span class=\"string\">&quot;androidx.compose.ui:ui-tooling:1.0.0-beta02&quot;</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-Empty-Compose-프로젝트-생성\"><a href=\"#2-Empty-Compose-프로젝트-생성\" class=\"headerlink\" title=\"2. Empty Compose 프로젝트 생성\"></a>2. Empty Compose 프로젝트 생성</h3><p>[File] - [New] - [New Project…] 를 눌러 새로운 프로젝트를 선택하고(Preview) Empty Compose Activity 를 선택한다.</p>\n<img src=\"/Team-Blog/2021/04/07/2021-04-07%20Jetpack%20Compose%20Part%201/1_5gfrQWfxyEC7Oq6b2xlJ9w.png\" class=\"\" title=\"[1_5gfrQWfxyEC7Oq6b2xlJ9w]\">\n\n<p>선택 이후 Next를 클릭하고, Compose를 구현할 수 있는 최소 API 레벨인 21을 선택해야한다.</p>\n<p>프로젝트를 생성하면 아래와 같이 app/build.gradle에 의존성 설정 및 추가가 되어 있는것을 알 수 있다.</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">android &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    kotlinOptions &#123;</span><br><span class=\"line\">        jvmTarget = <span class=\"string\">&#x27;1.8&#x27;</span></span><br><span class=\"line\">        useIR = <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    buildFeatures &#123;</span><br><span class=\"line\">        compose <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    composeOptions &#123;</span><br><span class=\"line\">        kotlinCompilerExtensionVersion compose_version</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    implementation <span class=\"string\">&quot;androidx.compose.ui:ui:$compose_version&quot;</span></span><br><span class=\"line\">    implementation <span class=\"string\">&quot;androidx.activity:activity-compose:1.3.0-alpha03&quot;</span></span><br><span class=\"line\">    implementation <span class=\"string\">&quot;androidx.compose.material:material:$compose_version&quot;</span></span><br><span class=\"line\">    implementation <span class=\"string\">&quot;androidx.compose.ui:ui-tooling:$compose_version&quot;</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>이때 composeOptions 설정에서 kotlinCompilerVersion 에 따라 compose 가 다르게 동작할 수 있음을 유의하자.</p>\n<p>프로젝트를 생성하면 아래와 같은 기본 파일들이 생성된다.</p>\n<p><strong>MainActivity.kt</strong></p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MainActivity</span> : <span class=\"type\">AppCompatActivity</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onCreate</span><span class=\"params\">(savedInstanceState: <span class=\"type\">Bundle</span>?)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onCreate(savedInstanceState)</span><br><span class=\"line\">        setContent &#123;</span><br><span class=\"line\">            MyFirstComposeApplicationTheme &#123;</span><br><span class=\"line\">                <span class=\"comment\">// A surface container using the &#x27;background&#x27; color from the theme</span></span><br><span class=\"line\">                Surface(color = MaterialTheme.colors.background) &#123;</span><br><span class=\"line\">                    Greeting(<span class=\"string\">&quot;Android&quot;</span>)</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Composable</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">Greeting</span><span class=\"params\">(name: <span class=\"type\">String</span>)</span></span> &#123;</span><br><span class=\"line\">    Text(text = <span class=\"string\">&quot;Hello <span class=\"variable\">$name</span>!&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Preview(showBackground = true)</span></span><br><span class=\"line\"><span class=\"meta\">@Composable</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">DefaultPreview</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    MyFirstComposeApplicationTheme &#123;</span><br><span class=\"line\">        Greeting(<span class=\"string\">&quot;Android&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>ui/theme/Theme.kt</strong></p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">val</span> DarkColorPalette = darkColors(</span><br><span class=\"line\">    primary = Purple200,</span><br><span class=\"line\">    primaryVariant = Purple700,</span><br><span class=\"line\">    secondary = Teal200</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">val</span> LightColorPalette = lightColors(</span><br><span class=\"line\">    primary = Purple500,</span><br><span class=\"line\">    primaryVariant = Purple700,</span><br><span class=\"line\">    secondary = Teal200*</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Other default colors to override</span></span><br><span class=\"line\"><span class=\"comment\">    background = Color.White,</span></span><br><span class=\"line\"><span class=\"comment\">    surface = Color.White,</span></span><br><span class=\"line\"><span class=\"comment\">    onPrimary = Color.White,</span></span><br><span class=\"line\"><span class=\"comment\">    onSecondary = Color.Black,</span></span><br><span class=\"line\"><span class=\"comment\">    onBackground = Color.Black,</span></span><br><span class=\"line\"><span class=\"comment\">    onSurface = Color.Black,</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Composable</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">MyFirstComposeApplicationTheme</span><span class=\"params\">(darkTheme: <span class=\"type\">Boolean</span> = isSystemInDarkTheme()</span></span>, content: <span class=\"meta\">@Composable</span> () -&gt; <span class=\"built_in\">Unit</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> colors = <span class=\"keyword\">if</span> (darkTheme) &#123;</span><br><span class=\"line\">        DarkColorPalette*</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        LightColorPalette*</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    MaterialTheme(</span><br><span class=\"line\">        colors = colors,</span><br><span class=\"line\">        typography = Typography,</span><br><span class=\"line\">        shapes = Shapes,</span><br><span class=\"line\">        content = content</span><br><span class=\"line\">    )</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>기본 생성된 코드를 보았을 때, Compose는 총 3가지의 구성 요소를 가지는 것으로 추측할 수 있다.</p>\n<ol>\n<li>위젯을 포함하는 Composable 함수</li>\n<li>Preview를 하기 위한 Preview Composable 함수</li>\n<li>setContent 람다 표현식으로 실제 화면에 노출하는 코드</li>\n</ol>\n<p>일반적으로 우리가 아는 Activity의 라이프사이클 콜백 <code>onCreate()</code>에서   <code>setContentView(Int)</code> 함수를 호출하던것이 <code>setContent()</code> 함수로 바뀐것이 가장 큰 특징으로 보여진다.</p>\n<h3 id=\"3-Composable-Function\"><a href=\"#3-Composable-Function\" class=\"headerlink\" title=\"3. Composable Function\"></a>3. Composable Function</h3><p>Composable Function은 어노테이션을 이용한 기술이다. 함수위에 <code>@Composable</code> 어노테이션을 붙이게 되면 함수 안 다른 함수를 호출할 수 있게된다. 아래 코드를 보자.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Composable</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">Greeting</span><span class=\"params\">(names: <span class=\"type\">List</span>&lt;<span class=\"type\">String</span>&gt;)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (name <span class=\"keyword\">in</span> names) &#123;</span><br><span class=\"line\">        Text(<span class=\"string\">&quot;Hello <span class=\"variable\">$name</span>&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>단순하게 내부에는 Text라는 함수가 존재하는데, 이를 통해 UI계층 별 요구하는 컴포넌트를 생성해준다. 기본적으로 보이는 text 파라미터는 내부 속성에서 받는 일부 중 하나이다.</p>\n<h3 id=\"4-TextView-만들기\"><a href=\"#4-TextView-만들기\" class=\"headerlink\" title=\"4. TextView 만들기\"></a>4. TextView 만들기</h3><p>위 코드를 실행시켜보면 당연하게도 Hello로 시작하는 TextView가 화면에 그려질것을 암시한다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setContent &#123;</span><br><span class=\"line\">  BasicsCodelabTheme &#123;</span><br><span class=\"line\">    <span class=\"comment\">// A surface container using the &#x27;background&#x27; color from the theme</span></span><br><span class=\"line\">    Surface(color = MaterialTheme.colors.background) &#123;</span><br><span class=\"line\">      Greeting(<span class=\"string\">&quot;Android&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<img src=\"/Team-Blog/2021/04/07/2021-04-07%20Jetpack%20Compose%20Part%201/aO6Jlsg.png\" class=\"\" title=\"[aO6Jlsg]\">\n\n<h3 id=\"5-Preview\"><a href=\"#5-Preview\" class=\"headerlink\" title=\"5. @Preview\"></a>5. <code>@Preview</code></h3><p>말 그대로 어노테이션을 이용하여 IDE에서 Preview를하기 위한 용도이다. 아래 코드와 같이 @Preview 어노테이션을 추가하면 다음 결과를 볼 수 있다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Preview(<span class=\"meta-string\">&quot;Greeting Preview&quot;</span>)</span></span><br><span class=\"line\"><span class=\"meta\">@Composable</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">GreetingPreview</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    BasicsCodelabTheme &#123;</span><br><span class=\"line\">        Surface(color = MaterialTheme.colors.background) &#123;</span><br><span class=\"line\">            Greeting(<span class=\"string\">&quot;Android&quot;</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<img src=\"/Team-Blog/2021/04/07/2021-04-07%20Jetpack%20Compose%20Part%201/WprDTs1.png\" class=\"\" title=\"[WprDTs1]\">\n\n<h3 id=\"6-setContent-Theme-Surface\"><a href=\"#6-setContent-Theme-Surface\" class=\"headerlink\" title=\"6. setContent / Theme / Surface\"></a>6. setContent / Theme / Surface</h3><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setContent &#123;</span><br><span class=\"line\">  BasicsCodelabTheme &#123;</span><br><span class=\"line\">    <span class=\"comment\">// A surface container using the &#x27;background&#x27; color from the theme</span></span><br><span class=\"line\">    Surface(color = MaterialTheme.colors.background) &#123;</span><br><span class=\"line\">      Greeting(<span class=\"string\">&quot;Android&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>기존에 onCreate시점에 화면을 그려주기 위한 필수적인 요소를 정리해보자면</p>\n<ul>\n<li><p><strong>setContent</strong> : Activity에서 setContentView함수를 사용하는 것과 동일한 동작을 하는 확장함수이다. 다만, setContent의 경우 (@Composable) -&gt; Unit 타입의 컴포즈 UI를 구현해주어야한다.</p>\n</li>\n<li><p><strong>XXXTheme</strong> : Theme정보를 의미한다. 해당 프로젝트에서는 Theme.kt에 여러 테마에 필요한 정보를 정리하고, 컴포즈 UI 구현을 위한 코드를 작성해두었다.</p>\n</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">val</span> DarkColorPalette = darkColors(</span><br><span class=\"line\">    primary = purple200,</span><br><span class=\"line\">    primaryVariant = purple700,</span><br><span class=\"line\">    secondary = teal200</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">val</span> LightColorPalette = lightColors(</span><br><span class=\"line\">    primary = purple500,</span><br><span class=\"line\">    primaryVariant = purple700,</span><br><span class=\"line\">    secondary = teal200</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Other default colors to override</span></span><br><span class=\"line\"><span class=\"comment\">    background = Color.White,</span></span><br><span class=\"line\"><span class=\"comment\">    surface = Color.White,</span></span><br><span class=\"line\"><span class=\"comment\">    onPrimary = Color.White,</span></span><br><span class=\"line\"><span class=\"comment\">    onSecondary = Color.Black,</span></span><br><span class=\"line\"><span class=\"comment\">    onBackground = Color.Black,</span></span><br><span class=\"line\"><span class=\"comment\">    onSurface = Color.Black,</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Composable</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">BasicsCodelabTheme</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    darkTheme: <span class=\"type\">Boolean</span> = isSystemInDarkTheme()</span></span>,</span><br><span class=\"line\">    content: <span class=\"meta\">@Composable</span> () -&gt; <span class=\"built_in\">Unit</span></span><br><span class=\"line\">) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> colors = <span class=\"keyword\">if</span> (darkTheme) &#123;</span><br><span class=\"line\">        DarkColorPalette</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        LightColorPalette</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    MaterialTheme(</span><br><span class=\"line\">        colors = colors,</span><br><span class=\"line\">        typography = typography,</span><br><span class=\"line\">        shapes = shapes,</span><br><span class=\"line\">        content = content</span><br><span class=\"line\">    )</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>Surface</strong> : Greeting을 감싸는 뷰에 해당한다. 여기서는 크기를 정하지 않고, background 색상을 정의하고 있다. 역시 람다 표현식이다. 색상에 대한 Paramter로 <code>color</code> 라는 값을 사용하여 부여가 가능하다. 내부코드를 보면</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Composable</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">Surface</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    modifier: <span class=\"type\">Modifier</span> = Modifier,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    shape: <span class=\"type\">Shape</span> = RectangleShape,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    color: <span class=\"type\">Color</span> = MaterialTheme.colors.surface,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    contentColor: <span class=\"type\">Color</span> = contentColorFor(color)</span></span>,</span><br><span class=\"line\">    border: BorderStroke? = <span class=\"literal\">null</span>,</span><br><span class=\"line\">    elevation: Dp = <span class=\"number\">0.</span>dp,</span><br><span class=\"line\">    content: <span class=\"meta\">@Composable</span> () -&gt; <span class=\"built_in\">Unit</span></span><br><span class=\"line\">) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> elevationPx = with(LocalDensity.current) &#123; elevation.toPx() &#125;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> elevationOverlay = LocalElevationOverlay.current</span><br><span class=\"line\">    <span class=\"keyword\">val</span> absoluteElevation = LocalAbsoluteElevation.current + elevation</span><br><span class=\"line\">    <span class=\"keyword\">val</span> backgroundColor = <span class=\"keyword\">if</span> (color == MaterialTheme.colors.surface &amp;&amp; elevationOverlay != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        elevationOverlay.apply(color, absoluteElevation)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        color</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    CompositionLocalProvider(</span><br><span class=\"line\">        LocalContentColor provides contentColor,</span><br><span class=\"line\">        LocalAbsoluteElevation provides absoluteElevation</span><br><span class=\"line\">    ) &#123;</span><br><span class=\"line\">        Box(</span><br><span class=\"line\">            modifier.graphicsLayer(shadowElevation = elevationPx, shape = shape)</span><br><span class=\"line\">                .then(<span class=\"keyword\">if</span> (border != <span class=\"literal\">null</span>) Modifier.border(border, shape) <span class=\"keyword\">else</span> Modifier)</span><br><span class=\"line\">                .background(</span><br><span class=\"line\">                    color = backgroundColor,</span><br><span class=\"line\">                    shape = shape</span><br><span class=\"line\">                )</span><br><span class=\"line\">                .clip(shape),</span><br><span class=\"line\">            propagateMinConstraints = <span class=\"literal\">true</span></span><br><span class=\"line\">        ) &#123;</span><br><span class=\"line\">            content()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"7-Declarative-UI-선언형-UI\"><a href=\"#7-Declarative-UI-선언형-UI\" class=\"headerlink\" title=\"7. Declarative UI - 선언형 UI\"></a>7. Declarative UI - 선언형 UI</h3><p>노란색 배경을 입혀 기존 TextView에 추가해보았다. 또한, Greeting에는 Modifier라는 것을 이용하여 Padding을 추가했다. 아래와 같은 결과가 나오게 되었다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BasicsCodelabTheme &#123;</span><br><span class=\"line\">  <span class=\"comment\">// A surface container using the &#x27;background&#x27; color from the theme</span></span><br><span class=\"line\">  Surface(color = Color.Yellow) &#123;</span><br><span class=\"line\">    Greeting(<span class=\"string\">&quot;Android&quot;</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Composable</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">Greeting</span><span class=\"params\">(name: <span class=\"type\">String</span>)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> isSelected <span class=\"keyword\">by</span> remember &#123; mutableStateOf(<span class=\"literal\">false</span>) &#125;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> backgroundColor <span class=\"keyword\">by</span> animateColorAsState(<span class=\"keyword\">if</span> (isSelected) Color.Red <span class=\"keyword\">else</span> Color.Transparent)</span><br><span class=\"line\"></span><br><span class=\"line\">    Text(</span><br><span class=\"line\">        text = <span class=\"string\">&quot;Hello <span class=\"variable\">$name</span>!&quot;</span>,</span><br><span class=\"line\">        modifier = Modifier</span><br><span class=\"line\">            .padding(<span class=\"number\">24.</span>dp)</span><br><span class=\"line\">            .background(color = backgroundColor)</span><br><span class=\"line\">            .clickable(onClick = &#123; isSelected = !isSelected &#125;)</span><br><span class=\"line\">    )</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<img src=\"/Team-Blog/2021/04/07/2021-04-07%20Jetpack%20Compose%20Part%201/qgQ6oY4.png\" class=\"\" title=\"[qgQ6oY4]\">\n\n<p>선언형 UI의 장점은 말 그대로 내가 UI를 정의한대로 시각적으로 표현이 가능하다는 장점이 있다. 기존에는 속성을 매번 On/Off와 같은 옵션을 통해 변경하는 것이 다반사였지만, 이제는 매번 속성에 변경이 생길때마다 새로 그려주게 되는것이다.</p>\n<h3 id=\"8-재사용\"><a href=\"#8-재사용\" class=\"headerlink\" title=\"8. 재사용\"></a>8. 재사용</h3><p>Compose의 장점 중 하나는 재사용성이 뛰어난것인데, XML에서 우리가 include 태그를 통해 여러곳에서 갖다쓸 수 있던것처럼, 함수를 통해 여러곳에서 정의하여 사용이 가능하다.</p>\n<p>참고해야할 점은 Compose 컴포넌트 확장 시 <code>@Composable</code> 어노테이션을 붙여야 한다.</p>\n<h3 id=\"9-Container-작성\"><a href=\"#9-Container-작성\" class=\"headerlink\" title=\"9. Container 작성\"></a>9. Container 작성</h3><p>MyApp이라는 이름으로 컴포즈 컴포넌트를 구횬하여 여러곳에서 공통으로 사용할 수 있는 Composable을 구현하였다. 내부적으로 Container내 내가 원하는 컴포넌트를 넣어주려면 아래와 같이 인자로 <code>@Composable () -&gt; Unit</code> 타입을 넘겨받아 처리해주면 된다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Composable</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">MyApp</span><span class=\"params\">(content: @<span class=\"type\">Composable</span> () -&gt; <span class=\"type\">Unit</span>)</span></span> &#123;</span><br><span class=\"line\">    BasicsCodelabTheme &#123;</span><br><span class=\"line\">        Surface(color = Color.Yellow) &#123;</span><br><span class=\"line\">            content()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>위 함수를 통해 이제는 어디서든 반복해서 사용할 수 있는 Container를 구현하게 되어 아래와 같이 코드를 활용할 수 있게되었다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MainActivity</span> : <span class=\"type\">AppCompatActivity</span></span>() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onCreate</span><span class=\"params\">(savedInstanceState: <span class=\"type\">Bundle</span>?)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.onCreate(savedInstanceState)</span><br><span class=\"line\">    setContent &#123;</span><br><span class=\"line\">      MyApp &#123;</span><br><span class=\"line\">        Greeting(<span class=\"string\">&quot;Android&quot;</span>)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"10-레이아웃을-활용한-Compose-function의-다중-호출\"><a href=\"#10-레이아웃을-활용한-Compose-function의-다중-호출\" class=\"headerlink\" title=\"10. 레이아웃을 활용한 Compose function의 다중 호출\"></a>10. 레이아웃을 활용한 Compose function의 다중 호출</h3><p>지금까지는 하나의 컴포넌트만을 갖고 사용했지만, 여러개의 컴포넌트를 넣는것도 가능하다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Composable</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">MyScreenContent</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    Column &#123;</span><br><span class=\"line\">        Greeting(<span class=\"string\">&quot;Android&quot;</span>)</span><br><span class=\"line\">        Divider(color = Color.Black)</span><br><span class=\"line\">        Greeting(<span class=\"string\">&quot;there&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p> <code>Column</code>과 위에서부터 사용하던 <code>Greeting</code> 함수를 사용하고, 라인을 그어주기 위한 <code>Divider</code>를 추가한 결과물은 다음과 같다.</p>\n<img src=\"/Team-Blog/2021/04/07/2021-04-07%20Jetpack%20Compose%20Part%201/VLTxB8C.png\" class=\"\" title=\"[VLTxB8C]\">\n\n<p>위 컴포넌트 중 못보던 컴포저블이 있는데, 아래와 같이 설명이 가능하다.</p>\n<ul>\n<li>Column : 항목을 순서대로 배치하기 위해 사용한다.</li>\n<li>Divider : 선 긋기 가능한 Compose 함수이다.</li>\n</ul>\n<p>이를 리스트 형태로도 구현이 가능하다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Composable</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">MyColumnScreen</span><span class=\"params\">(names: <span class=\"type\">List</span>&lt;<span class=\"type\">String</span>&gt; = listOf(<span class=\"string\">&quot;Line One&quot;</span>, <span class=\"string\">&quot;Line Two&quot;</span>)</span></span>) &#123;</span><br><span class=\"line\">    Column &#123;</span><br><span class=\"line\">        names.forEach &#123;</span><br><span class=\"line\">            Greeting(name = it)</span><br><span class=\"line\">            Divider(color = Color.Black)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"11-State-in-Compose-Compose에서의-상태값-관리\"><a href=\"#11-State-in-Compose-Compose에서의-상태값-관리\" class=\"headerlink\" title=\"11. State in Compose - Compose에서의 상태값 관리\"></a>11. State in Compose - Compose에서의 상태값 관리</h3><p>컴포넌트에 버튼을 클릭했을 때 클릭한 카운트를 집계하는 간단한 컴포넌트를 만들어보았다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Composable</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">MyColumnScreen</span><span class=\"params\">(names: <span class=\"type\">List</span>&lt;<span class=\"type\">String</span>&gt; = listOf(<span class=\"string\">&quot;Line One&quot;</span>, <span class=\"string\">&quot;Line Two&quot;</span>)</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> counterState = remember &#123; mutableStateOf(<span class=\"number\">0</span>) &#125; <span class=\"comment\">// </span></span><br><span class=\"line\"></span><br><span class=\"line\">    Column &#123;</span><br><span class=\"line\">        names.forEach &#123;</span><br><span class=\"line\">            Greeting(name = it)</span><br><span class=\"line\">            Divider(color = Color.Black)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Counter(</span><br><span class=\"line\">            count = counterState.value,</span><br><span class=\"line\">            updateCount = &#123; newCount -&gt;</span><br><span class=\"line\">                counterState.value = newCount</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>remember라는 함수를 사용하여 기존에 존재하는 컴포넌트의 상태값을 기억하게 하는 함수가 있다. </p>\n<p><code>remember</code> 함수의 내부를 살펴보자.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Remember the value produced by [calculation]. [calculation] will only be evaluated during the composition.</span></span><br><span class=\"line\"><span class=\"comment\"> * Recomposition will always return the value produced by composition.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@OptIn(ComposeCompilerApi::class)</span></span><br><span class=\"line\"><span class=\"meta\">@Composable</span></span><br><span class=\"line\"><span class=\"keyword\">inline</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"type\">&lt;T&gt;</span> <span class=\"title\">remember</span><span class=\"params\">(calculation: @<span class=\"type\">DisallowComposableCalls</span> () -&gt; <span class=\"type\">T</span>)</span></span>: T =</span><br><span class=\"line\">    currentComposer.cache(<span class=\"literal\">false</span>, calculation)</span><br></pre></td></tr></table></figure>\n\n<p>매 호출마다 Recomposition(재조합)하게되는 경우 컴포넌트에 값을 다시 제공하는 것을 알 수 있다. @Composable 어노테이션에 들어간 함수는 매번 해당 상태를 구독하고, 상태가 변경될때마다 알림을 받아 기존 화면을 갱신해준다.</p>\n<p>그리고, 아래 Counter를 보면 Button을 이용하여 이벤트를 받아 처리하도록 했다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Composable</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">Counter</span><span class=\"params\">(count: <span class=\"type\">Int</span>, updateCount: (<span class=\"type\">Int</span>) -&gt; <span class=\"type\">Unit</span>)</span></span> &#123;</span><br><span class=\"line\">    Button(</span><br><span class=\"line\">        onClick = &#123; updateCount(count + <span class=\"number\">1</span>) &#125;,</span><br><span class=\"line\">        colors = ButtonDefaults.buttonColors(</span><br><span class=\"line\">            backgroundColor = <span class=\"keyword\">if</span> (count &gt; <span class=\"number\">5</span>) Color.Green <span class=\"keyword\">else</span> Color.White</span><br><span class=\"line\">        )</span><br><span class=\"line\">    ) &#123;</span><br><span class=\"line\">        Text(<span class=\"string\">&quot;I&#x27;ve been clicked <span class=\"variable\">$count</span> times&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>updateCount(Int)</code> 함수릉 통해 매번 값을 업데이트 해주는데, 이를 통해 counterState에 값을 넣어주면서 해당 컴포넌트가 매번 변경이 되는것이다.</p>\n<p>따라서 결과를 보면, 다음과 같다. Count가 5가 넘어가면 초록색으로 바뀐다.</p>\n\n\n<p>그 외에도 여러형태의 모양을 구성할수 있도록 옵션이 제공되어 있다. 자세한 정보는 나중에 <a href=\"https://developer.android.com/codelabs/jetpack-compose-basics\">Codelabs</a>에 더 나와 있으니 보도록하고, 이번에 setContent에 대한 동작원리를 함께 고민해보자.</p>\n<h3 id=\"12-Activity에서의-View-생성-방식과의-비교\"><a href=\"#12-Activity에서의-View-생성-방식과의-비교\" class=\"headerlink\" title=\"12. Activity에서의 View 생성 방식과의 비교\"></a>12. Activity에서의 View 생성 방식과의 비교</h3><p>Compose를 안드로이드 앱에서 사용하려면 Activity, Fragment와 같은곳에서 contentView로 뿌려줘야한다. 기존에 우리가 사용하던 함수를 보자.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* Set the activity content from a layout resource.  The resource will be</span></span><br><span class=\"line\"><span class=\"comment\">* inflated, adding all top-level views to the activity.</span></span><br><span class=\"line\"><span class=\"comment\">*</span></span><br><span class=\"line\"><span class=\"comment\">* <span class=\"doctag\">@param</span> layoutResID Resource ID to be inflated.</span></span><br><span class=\"line\"><span class=\"comment\">*</span></span><br><span class=\"line\"><span class=\"comment\">* <span class=\"doctag\">@see</span> #setContentView(android.view.View)</span></span><br><span class=\"line\"><span class=\"comment\">* <span class=\"doctag\">@see</span> #setContentView(android.view.View, android.view.ViewGroup.LayoutParams)</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setContentView</span><span class=\"params\">(<span class=\"meta\">@LayoutRes</span> <span class=\"keyword\">int</span> layoutResID)</span> </span>&#123;</span><br><span class=\"line\">  getWindow().setContentView(layoutResID);</span><br><span class=\"line\">  initWindowDecorActionBar();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>UI 컴포넌트에서 화면을 붙일 수 있는 Window라는 녀석에서 Layout Resource Id를 통해 기존에 등록되어있던 Layout XML 파일을 로드하여 인플레이터에서 파싱하고, 이를통해 레이아웃 계층에 있는 뷰객체를 생성하여 순차적으로 ViewGroup, View를 만들어 넣어주게 된다.</p>\n<p><code>PhoneWindow</code>를 보면 자세하게 알 수 있는데, Window를 구현한 setContentView에서 처음에 생성되는 최상위 레이아웃 그 위에 따로 없다면 <code>installDecor()</code> 함수를 통해 mContentParent(레이아웃 리소스가 붙게될 ViewGroup)를 생성하고, 하위에 넣어주게 된다.</p>\n<p>그러면 기존 방식은 이정도로 설명을하고, 이번엔 Compose에서 <code>setContent()</code> 라는 함수를 어떻게 사용하는지 보자.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Composes the given composable into the given activity. The [content] will become the root view</span></span><br><span class=\"line\"><span class=\"comment\"> * of the given activity.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * This is roughly equivalent to calling [ComponentActivity.setContentView] with a [ComposeView]</span></span><br><span class=\"line\"><span class=\"comment\"> * i.e.:</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * ```</span></span><br><span class=\"line\"><span class=\"comment\"> * setContentView(</span></span><br><span class=\"line\"><span class=\"comment\"> *   ComposeView(this).apply &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     setContent &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *       MyComposableContent()</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *   &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * )</span></span><br><span class=\"line\"><span class=\"comment\"> * ```</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> parent The parent composition reference to coordinate scheduling of composition updates</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> content A `<span class=\"doctag\">@Composable</span>` function declaring the UI contents</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">fun</span> ComponentActivity.<span class=\"title\">setContent</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    parent: <span class=\"type\">CompositionContext</span>? = <span class=\"literal\">null</span>,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    content: @<span class=\"type\">Composable</span> () -&gt; <span class=\"type\">Unit</span></span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> existingComposeView = window.decorView</span><br><span class=\"line\">        .findViewById&lt;ViewGroup&gt;(android.R.id.content)</span><br><span class=\"line\">        .getChildAt(<span class=\"number\">0</span>) <span class=\"keyword\">as</span>? ComposeView</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (existingComposeView != <span class=\"literal\">null</span>) with(existingComposeView) &#123;</span><br><span class=\"line\">        setParentCompositionContext(parent)</span><br><span class=\"line\">        setContent(content)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> ComposeView(<span class=\"keyword\">this</span>).apply &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Set content and parent **before** setContentView</span></span><br><span class=\"line\">        <span class=\"comment\">// to have ComposeView create the composition on attach</span></span><br><span class=\"line\">        setParentCompositionContext(parent)</span><br><span class=\"line\">        setContent(content)</span><br><span class=\"line\">        <span class=\"comment\">// Set the view tree owners before setting the content view so that the inflation process</span></span><br><span class=\"line\">        <span class=\"comment\">// and attach listeners will see them already present</span></span><br><span class=\"line\">        setOwners()</span><br><span class=\"line\">        setContentView(<span class=\"keyword\">this</span>, DefaultActivityContentLayoutParams)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>이녀석도 마찬가지로 <code>window.decorView.findViewById&lt;ViewGroup&gt;(android.R.id.content)</code>  함수를 호출하여 decorView를 가져온다. 만약 compose를 통해 만들어진 최상위 레이아웃이 존재하면, 기존에 inflator에서 ViewGroup, View를 생성해서 넣어주던것 처럼 <code>setContent()</code> =&gt; window가 Activity/Fragment에 붙으면 <code>createComposition()</code>를 호출하여 검증 후 <code>ensureCompsositionCreated()</code> 함수를 호출한다. 현재는 내부적으로 <code>ViewGroup.setContent()</code> 를 사용하고 있는데, 곧 교체 될 예정이라고 한다. 이코드도 보면 기존에 있는 ViewGroup에 확장함수로 구현한 녀석인데, 쉽게 말해 ViewGroup에 하위 View, ViewGroup에 Composable로 구현된 함수로 컴포넌트를 넣어줄 때 AndroidComposeView라는 객체를 꺼내오거나 없다면 새로 생성하여 넣어준다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Composes the given composable into the given view.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * The new composition can be logically &quot;linked&quot; to an existing one, by providing a</span></span><br><span class=\"line\"><span class=\"comment\"> * [parent]. This will ensure that invalidations and CompositionLocals will flow through</span></span><br><span class=\"line\"><span class=\"comment\"> * the two compositions as if they were not separate.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Note that this [ViewGroup] should have an unique id for the saved instance state mechanism to</span></span><br><span class=\"line\"><span class=\"comment\"> * be able to save and restore the values used within the composition. See [View.setId].</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> parent The [Recomposer] or parent composition reference.</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> content Composable that will be the content of the view.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">internal</span> <span class=\"function\"><span class=\"keyword\">fun</span> ViewGroup.<span class=\"title\">setContent</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    parent: <span class=\"type\">CompositionContext</span>,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    content: @<span class=\"type\">Composable</span> () -&gt; <span class=\"type\">Unit</span></span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">)</span></span>: Composition &#123;</span><br><span class=\"line\">    GlobalSnapshotManager.ensureStarted()</span><br><span class=\"line\">    <span class=\"keyword\">val</span> composeView =</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (childCount &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            getChildAt(<span class=\"number\">0</span>) <span class=\"keyword\">as</span>? AndroidComposeView</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            removeAllViews(); <span class=\"literal\">null</span></span><br><span class=\"line\">        &#125; ?: AndroidComposeView(context).also &#123; addView(it.view, DefaultLayoutParams) &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> doSetContent(composeView, parent, content)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>다시 돌아와서, ComposeView의 <code>setContent()</code> 이라는 녀석을 보자.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * A [android.view.View] that can host Jetpack Compose UI content.</span></span><br><span class=\"line\"><span class=\"comment\"> * Use [setContent] to supply the content composable function for the view.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * This [android.view.View] requires that the window it is attached to contains a</span></span><br><span class=\"line\"><span class=\"comment\"> * [ViewTreeLifecycleOwner]. This [androidx.lifecycle.LifecycleOwner] is used to</span></span><br><span class=\"line\"><span class=\"comment\"> * [dispose][androidx.compose.runtime.Composition.dispose] of the underlying composition</span></span><br><span class=\"line\"><span class=\"comment\"> * when the host [Lifecycle] is destroyed, permitting the view to be attached and</span></span><br><span class=\"line\"><span class=\"comment\"> * detached repeatedly while preserving the composition. Call [disposeComposition]</span></span><br><span class=\"line\"><span class=\"comment\"> * to dispose of the underlying composition earlier, or if the view is never initially</span></span><br><span class=\"line\"><span class=\"comment\"> * attached to a window. (The requirement to dispose of the composition explicitly</span></span><br><span class=\"line\"><span class=\"comment\"> * in the event that the view is never (re)attached is temporary.)</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ComposeView</span> <span class=\"meta\">@JvmOverloads</span> <span class=\"keyword\">constructor</span></span>(</span><br><span class=\"line\">    context: Context,</span><br><span class=\"line\">    attrs: AttributeSet? = <span class=\"literal\">null</span>,</span><br><span class=\"line\">    defStyleAttr: <span class=\"built_in\">Int</span> = <span class=\"number\">0</span></span><br><span class=\"line\">) : AbstractComposeView(context, attrs, defStyleAttr) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">val</span> content = mutableStateOf&lt;(<span class=\"meta\">@Composable</span> () -&gt; <span class=\"built_in\">Unit</span>)?&gt;(<span class=\"literal\">null</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Suppress(<span class=\"meta-string\">&quot;RedundantVisibilityModifier&quot;</span>)</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">override</span> <span class=\"keyword\">var</span> shouldCreateCompositionOnAttachedToWindow: <span class=\"built_in\">Boolean</span> = <span class=\"literal\">false</span></span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">set</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Composable</span></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">Content</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        content.value?.invoke()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Set the Jetpack Compose UI content for this view.</span></span><br><span class=\"line\"><span class=\"comment\">     * Initial composition will occur when the view becomes attached to a window or when</span></span><br><span class=\"line\"><span class=\"comment\">     * [createComposition] is called, whichever comes first.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">setContent</span><span class=\"params\">(content: @<span class=\"type\">Composable</span> () -&gt; <span class=\"type\">Unit</span>)</span></span> &#123;</span><br><span class=\"line\">        shouldCreateCompositionOnAttachedToWindow = <span class=\"literal\">true</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.content.value = content</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isAttachedToWindow) &#123;</span><br><span class=\"line\">            createComposition()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>결론적으로 <code>AbstractComposeView</code> 라는 녀석은 ViewGroup을 상속받은 녀석이며, 모든 composable의 상태가 변화 되었을 때 이를 감지하는 중요한 녀석이다.</p>\n<p><code>setContent()</code>라는 함수는 위에서 설명했으니 넘어가고, 이번에는 <code>Content</code>라는 녀석을 보자. 이녀석은 추상 메소드로, <code>createComposition()</code> 이라는 함수가 호출 되었을 때, 가장 먼저 불리는 함수이다. 아까 언급되었던 <code>ensureCompsositionCreated()</code> 함수에서 tree계층의 ComposeView가 다 붙었다면, 이후에 즉시 Content함수가 호출이된다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Suppress(<span class=\"meta-string\">&quot;DEPRECATION&quot;</span>)</span> <span class=\"comment\">// Still using ViewGroup.setContent for now</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">ensureCompositionCreated</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (composition == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                creatingComposition = <span class=\"literal\">true</span></span><br><span class=\"line\">                composition = setContent(</span><br><span class=\"line\">                    parentContext ?: findViewTreeCompositionContext() ?: windowRecomposer</span><br><span class=\"line\">                ) &#123;</span><br><span class=\"line\">                    Content() <span class=\"comment\">// 이곳에서 뷰가 다 window에 붙게되면 콜백을 호출한다.</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                creatingComposition = <span class=\"literal\">false</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>그러면 아래 <code>ComposeView</code>의 오버라이딩 된 Content가 호출되면서, 기존에 생성된 View에 UI속성과 같은 Content가 붙게된다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* The Jetpack Compose UI content for this view.</span></span><br><span class=\"line\"><span class=\"comment\">* Subclasses must implement this method to provide content. Initial composition will</span></span><br><span class=\"line\"><span class=\"comment\">* occur when the view becomes attached to a window or when [createComposition] is called,</span></span><br><span class=\"line\"><span class=\"comment\">* whichever comes first.</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"meta\">@Composable</span></span><br><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">Content</span><span class=\"params\">()</span></span></span><br></pre></td></tr></table></figure>\n\n<p>Content는 설명에서 보는것과 같이 <code>createComposition()</code> 함수 호출 후 View가 Window에 붙은 이후 즉시 호출된다.</p>\n<p>최종적으로 <code>ComponentActivity.setContent(CompositionContext?, @Composable () -&gt; Unit)</code> 함수에서 구현된 ComposeView 인스턴스를 ContentLayout을 widht/height를 wrapContent크기로 정하여 ContentView를 Set해주게 된다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Composes the given composable into the given activity. The [content] will become the root view</span></span><br><span class=\"line\"><span class=\"comment\"> * of the given activity.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * This is roughly equivalent to calling [ComponentActivity.setContentView] with a [ComposeView]</span></span><br><span class=\"line\"><span class=\"comment\"> * i.e.:</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * ```</span></span><br><span class=\"line\"><span class=\"comment\"> * setContentView(</span></span><br><span class=\"line\"><span class=\"comment\"> *   ComposeView(this).apply &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     setContent &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *       MyComposableContent()</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *   &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * )</span></span><br><span class=\"line\"><span class=\"comment\"> * ```</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> parent The parent composition reference to coordinate scheduling of composition updates</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> content A `<span class=\"doctag\">@Composable</span>` function declaring the UI contents</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">fun</span> ComponentActivity.<span class=\"title\">setContent</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    parent: <span class=\"type\">CompositionContext</span>? = <span class=\"literal\">null</span>,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    content: @<span class=\"type\">Composable</span> () -&gt; <span class=\"type\">Unit</span></span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">)</span></span> &#123;</span><br><span class=\"line\">  \t...</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> ComposeView(<span class=\"keyword\">this</span>).apply &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Set content and parent **before** setContentView</span></span><br><span class=\"line\">        <span class=\"comment\">// to have ComposeView create the composition on attach</span></span><br><span class=\"line\">        setParentCompositionContext(parent)</span><br><span class=\"line\">        setContent(content)</span><br><span class=\"line\">        <span class=\"comment\">// Set the view tree owners before setting the content view so that the inflation process</span></span><br><span class=\"line\">        <span class=\"comment\">// and attach listeners will see them already present</span></span><br><span class=\"line\">        setOwners()</span><br><span class=\"line\">        setContentView(<span class=\"keyword\">this</span>, DefaultActivityContentLayoutParams)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"13-ComposeView\"><a href=\"#13-ComposeView\" class=\"headerlink\" title=\"13. ComposeView\"></a>13. ComposeView</h3><p>android.view.View 는 Jetpack Compose UI 콘텐츠를 사용할 수 있도록 해줍니다. setContent 를 사용하면 composable function content 를 뷰에 제공할 수 있다.</p>\n<p>Compose 의 계층 구조는 아래와 같으며. ComposeView 를 통해 androidx.compose.materia 에 정의된 다양한 컴포넌트를 조합하여 Composable function 콘텐츠를 구성할 수 있다.</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kotlin.Any</span><br><span class=\"line\"> ↳ android.view.View</span><br><span class=\"line\">   ↳ android.view.ViewGroup</span><br><span class=\"line\">     ↳ androidx.compose.ui.platform.AbstractComposeView</span><br><span class=\"line\">       ↳ androidx.compose.ui.platform.ComposeView</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"14-Compose-Compiler-Compose-Runtime\"><a href=\"#14-Compose-Compiler-Compose-Runtime\" class=\"headerlink\" title=\"14. Compose Compiler / Compose Runtime\"></a>14. Compose Compiler / Compose Runtime</h3><p>Compose Compiler 는 <code>@Composable</code> 이 설정된 경우 Composable function 으로 코드 변환과 코틀린 컴파일러 플러그인과 함께 최적화를 활성화한다.</p>\n<p>Compose Runtime은 Compose의 프로그래밍 모델과 상태 관리, 그리고 Compose 컴파일러를 지정하기 위한 코어 런타임에 대한 기본 설정을 수행한다.</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Composable</span><br><span class=\"line\">fun Greeting(name: String) &#123;</span><br><span class=\"line\">    var greet by remember &#123; mutableStateOf(&quot;Hello $name&quot;) &#125;</span><br><span class=\"line\">    Text(text = greet, color = Color.Red)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>위의 코드는 Compose Compiler에 의해 <code>@Composeable</code>은 아래와 같이 변경된다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">Greeting</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">  $composer: <span class=\"type\">Composer</span>,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">  $static: <span class=\"type\">Int</span>,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">  name: <span class=\"type\">String</span></span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">)</span></span> &#123;</span><br><span class=\"line\">  $composer.start(<span class=\"number\">123</span>)</span><br><span class=\"line\">  <span class=\"keyword\">var</span> greet <span class=\"keyword\">by</span> remember &#123; mutableStateOf(<span class=\"string\">&quot;Hello <span class=\"variable\">$name</span>&quot;</span>) &#125;</span><br><span class=\"line\">  Text(text = greet, color = Color.Red)</span><br><span class=\"line\">  $composer.end()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Compose 는 <code>composer.start</code> 에서 고유의 키를 가지고 있고, 이는 Compose 의 state 가 변경될 때 해당 키를 가진 Compose 만 변경되도록 동작한다.</p>\n<p>static 은 상태(state)의 변경여부를 알 수 있는데 상태의 변화가 없는 경우, <code>composer.start</code> 와 <code>composer.end</code> 사이의 UI 의 변경을 하지 않는다.</p>\n<p>이때 데이터의 상태가 변경되어 UI 를 다시 구성하는 경우는 Recomposition 이라고 한다.</p>"},{"title":"Jetpack Compose Part 2 - Preview / Layout / Decompile","date":"2021-04-06T17:00:00.000Z","cover":"https://androiddeepdive.github.io/Team-Blog/images/cover_jepack_compose.png","_content":"\n<article class=\"message message-immersive is-primary\">\n    <div class=\"message-body\">\n        <i class=\"fas fa-pen-fancy mr-2\"></i>Writers<br>\n        by 김남훈 @Naver<br>\n        by 배희성 @RocketPunch<br>\n        by 송시영 @SmartStudy<br>\n        by 이기정 @BankSalad\n    </div>\n</article>\n\n<!-- more -->\n\n## Android Studio의 Jetpack Compose\n\nAndroid Studio Preview를 사용해 Compose를 사용하다보면 Preview라 코드레벨에서 활성화되는 것을 알 수 있다.\n\n좀 더 자세히 살펴보자.\n\n### Preview의 기능들\n\nPreview 와 Compose 를 사용해서 아래와 같이 구성할 수 있다.\n\n{% asset_img 1_ybDWG4W2bPYNq79vr1gE8w.png [1_ybDWG4W2bPYNq79vr1gE8w] %}\n\nSplit(design/code) 을 선택에 따라 코드 및 디자인의 패널을 변경할 수도 있다.\n\n{% asset_img 1_XVvr-CB2pn88Te7Gg52GPA.png [1_XVvr-CB2pn88Te7Gg52GPA] %}\n\n미리보기에서 인터렉티브 모드를 설정할 수 있다. \n\n인터렉티브 모드를 설정하면 실제 디바이스처럼  클릭이나 드래그 등의 상호 작용을 확인해 볼 수 있다.\n\n다만, 네트워크나 파일에 접근 또는 일부 Context API 는 인터렉티브 모드를 지원하지 않고 있다.\n\n> 간헐적으로 interactive 모드가 작동하지 않는 경우가 있다.\n\n{% asset_img 1_9IA2k2s5hAS9pSyzpmQ6Pw.png [1_9IA2k2s5hAS9pSyzpmQ6Pw] %}\n\n미리보기에서 직접 디바이스 혹은 에뮬레이터로 배포하여 결과를 확인할 수도 있다.\n\n{% asset_img 1_5RZOM7sWV0sXctJtTPdshQ.png [1_5RZOM7sWV0sXctJtTPdshQ] %}\n\n\n### `@Preview` Annotation 분석\n\n위에서 언급했다시피 `@Preview`를 사용하면 디바이스나 에뮬레이터를 실행하지 않고 실시간으로 Compose UI 를 볼 수 있다.\n\n`@Preview`를는 아래와 같이 구성되어 있으며 설정에 따라서 미리보기를 다양하게 구성할 수 있다.\n\n```kotlin\nannotation class Preview(\n    val name: String = \"\",\n    val group: String = \"\",\n    @IntRange(from = 1) val apiLevel: Int = -1,\n    // TODO(mount): Make this Dp when they are inline classes\n    val widthDp: Int = -1,\n    // TODO(mount): Make this Dp when they are inline classes\n    val heightDp: Int = -1,\n    val locale: String = \"\",\n    @FloatRange(from = 0.01) val fontScale: Float = 1f,\n    val showSystemUi: Boolean = false,\n    val showBackground: Boolean = false,\n    val backgroundColor: Long = 0,\n    @UiMode val uiMode: Int = 0,\n    @Device val device: String = Devices.DEFAULT\n)\n```\n\n- **name** : Preview 의 이름을 지정하며, 기본 값은 function 이름으로 설정된다.\n- **group** : Preview 의 그룹을 지정한다, 기본 값은 function 이름으로 설정된다.\n- **apiLevel** : api level 설정에 따라 Composable 을 렌더링해준다.\n- **widthDp** : Preview 의 너비를 설정한다. (기본 단위는 dp)\n- **heightDp** : Preview 의 높이를 설정한다. (기본 단위는 dp)\n- **locale** : 사용자 locales 에 따라 보여지는 UI 를 테스트 하기 위해 사용한다.\n- **fontScale** : 기본 density 애 배율을 적용해서 폰트 사이즈를 변경할 수 있다.\n- **showSystemUi** : true 로 설정하면 status bar 와 action bar 를 노출한다.\n- **showBackground** : true 로 설정하면 기본 배경색상을 적용해준다.\n- **backgroundColor** : 미리보기의 배경색을 설정할 수 있으며, showBackground 설정에 따라 노출 유무를 결정한다.\n- **uiMode** : uiMode 를 설정한다.\n- **device** : 기존 정의된 디바이스를 프리뷰에 적용한다. Devices object 에 정의된 값을 선택해서 사용할 수 있습니다. (Devices.NEXUS_9)\n\n### Compose의 레이아웃 구성\n\n- **Column** : 아이템을 세로로 배치한다.\n\n```kotlin\n@Composable\nfun ComposeColumn() {\n    Column {\n        Text(text = \"My First Compose\")\n        Text(text = \"My First Compose\")\n    }\n}\n```\n\n{% asset_img 1_bSyX8yT7H2HevBNw9fbyYw.png [1_bSyX8yT7H2HevBNw9fbyYw] %}\n\n- **Row** : 아이템을 가로로 배치한다.\n\n```kotlin\n@Composable\nfun ComposeRow() {\n    Row {\n        Text(text = \"My First Compose\")\n        Text(text = \"My First Compose\")\n    }\n}\n```\n\n{% asset_img 1_T9Pww7JyPMPhCJ_6yU8fyQ.png [1_T9Pww7JyPMPhCJ_6yU8fyQ] %}\n\n- **Box** : 구성 요소를 다른 구성 요소 위에 배치한다.\n\n```kotlin\n@Composable\nfun ComposeBox() {\n    Box {\n        Text(text = \"My First Compose 1\")\n        Text(text = \"My First Compose 2\")\n    }\n}\n```\n\n{% asset_img 1_wFM4jF71V5aJog3lALaRKQ.png [1_wFM4jF71V5aJog3lALaRKQ] %}\n\n- **Modifier** : 구성 요소의 크기, 마진등을 변경하거나 클릭이나 스크롤 등의 이벤트를 제어할 수 있도록 한다.\n\n```kotlin\n@Composable\nfun ComposeModifier() {\n    Box(modifier = Modifier\n        .padding(5.dp)\n    ) {\n        Text(text = \"Compose Modifier\")\n    }\n}\n```\n\n{% asset_img 1_tPAf-Akf2IpDRrrZo1f1dg.png [1_tPAf-Akf2IpDRrrZo1f1dg] %}\n\n- **LazyColumn / LazyRow** : Recyclerview 유사하게 화면에 보여지는 구성 요소만을 렌더링한다. 큰 데이터셋을 다루기에 용이하다.\n\n```kotlin\n@Composable\nfun ComposeLazyColumn() {\n    val itemsList = (0..100).toList()\n\n    LazyColumn {\n        items(items = itemsList, itemContent = { item ->\n            Text(text = \"Item : $item\", style = TextStyle(fontSize = 80.sp))\n        })\n    }\n}\n```\n\n{% asset_img 1_m7mSalYCza-SoJjmlYeWdA.png [1_m7mSalYCza-SoJjmlYeWdA] %}\n\n- **ConstraintLayout** : 기존 ContraintLayout 과 같이 여러 제약 참조를 설정해서 사용할 수 있다.\n `createRefs` / `createRefFor` 를 통해 참조를 생성하며, constrainAs 를 통해 제약 조건을 설정한다.\n\n```kotlin\n@Composable\nfun ComposeConstraintLayout() {\n    ConstraintLayout(modifier = Modifier.size(100.dp, 200.dp)) {\n        val (text1, image, text3) = createRefs()\n\n        Text(\"Text Item 1\", Modifier.constrainAs(text1) {\n            top.linkTo(parent.top)\n            start.linkTo(parent.start)\n            end.linkTo(parent.end)\n        })\n\n        Image(\n            painterResource(R.drawable.ic_launcher_foreground),\n            contentDescription = \"\",\n            contentScale = ContentScale.Crop,\n            modifier = Modifier.fillMaxSize().constrainAs(image) {\n                top.linkTo(text1.bottom)\n                bottom.linkTo(text3.top)\n                start.linkTo(parent.start)\n                end.linkTo(parent.end)\n            }\n        )\n\n        Text(\"Text Item 3\", Modifier.constrainAs(text3) {\n            bottom.linkTo(parent.bottom)\n            start.linkTo(parent.start)\n            end.linkTo(parent.end)\n        })\n    }\n}\n```\n\nJetpack Compose 의 ConstraintLayout 을 사용하기 위해서는 아래 의존성을 추가해야 한다.\n\n```groovy\nimplementation \"androidx.constraintlayout:constraintlayout-compose:1.0.0-alpha05\"\n```\n\n{% asset_img 1_UoLVl1dbUjKh9kd4uY0ROA.png [1_UoLVl1dbUjKh9kd4uY0ROA] %}\n\n### Jetpack Compose의 동작 원리 파악을 위한 빌드 과정 추적\n\n##### 1. 프로젝트 생성\n\nCompose가 내부적으로 어떻게 동작하는 지 알아보기 위해 먼저 프로젝트를 빌드해보자.\n\n빌드 후 Kotlin > Byte Code > Decompiled Java 순서로 변환하여 살펴볼 것이다.\n\nAndroid Studio Preview에서 Empty Compose Activity로 프로젝트를 생성하면 아래와 같은 샘플 코드를 얻을 수 있다.\n\n프로젝트 생성 후 임의로 Hello World로 파라미터값을 변경하였다.\n\n\n```kotlin\nclass MainActivity : ComponentActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContent {\n            HelloWorldTheme {\n                // A surface container using the 'background' color from the theme\n                Surface(color = MaterialTheme.colors.background) {\n                    Greeting(\"World\")\n                }\n            }\n        }\n    }\n}\n\n@Composable\nfun Greeting(name: String) {\n    Text(text = \"Hello $name!\")\n}\n\n@Preview(showBackground = true)\n@Composable\nfun DefaultPreview() {\n    HelloWorldTheme {\n        Greeting(\"World\")\n    }\n}\n```\n\n부가적으로 `src` 폴더 내부에 `ui.theme` 패키지가 생성되고 `Color.kt`, `Shape.kt`, `Theme.kt`, `Type.kt` 파일도 생성된다.\n\n이 파일들은 필요한 경우 들여다 보도록 하자.\n\n생성 후 Preview에 아래와 같이 렌더링 된다.\n\n{% asset_img add_002_001.png [add_002_001] %}\n\n##### 2. MainActivity 디컴파일\n\n```java\n@Metadata(\n   mv = {1, 4, 2},\n   bv = {1, 0, 3},\n   k = 2,\n   d1 = {\"...\"},\n   d2 = {\"DefaultPreview\", \"\", \"Greeting\", \"name\", \"\", \"app_debug\"}\n)\npublic final class MainActivityKt {\n    @Composable\n    public static final void Greeting(@NotNull String name) {\n        Intrinsics.checkNotNullParameter(name, \"name\");\n        TextKt.Text-Vh6c2nE$default(\"Hello \" + name + '!', \n            (Modifier)null, \n            0L, \n            0L, \n            (FontStyle)null, \n            (FontWeight)null, \n            (FontFamily)null, \n            0L, \n            (TextDecoration)null, \n            (TextAlign)null, \n            0L, \n            (TextOverflow)null, \n            false, \n            0, \n            (Function1)null, \n            (TextStyle)null, \n            65534, \n            (Object)null\n        );\n    }\n\n   @Composable\n   public static final void DefaultPreview() {\n      ThemeKt.HelloWorldTheme$default(false, (Function0)null.INSTANCE, 1, (Object)null);\n   }\n}\n\n// MainActivity.java\n@Metadata(\n   mv = {1, 4, 2},\n   bv = {1, 0, 3},\n   k = 1,\n   d1 = {\"...\"},\n   d2 = {\"...\"}\n)\npublic final class MainActivity extends ComponentActivity {\n   protected void onCreate(@Nullable Bundle savedInstanceState) {\n      super.onCreate(savedInstanceState);\n      ComponentActivityKt.setContent$default(this, (CompositionContext)null, (Function0)null.INSTANCE, 1, (Object)null);\n   }\n}\n```\n\n`ComponentActivityKt.setContent()`의 구현체는 아래와 같다.\n\n```kotlin\npublic fun ComponentActivity.setContent(\n    parent: CompositionContext? = null,\n    content: @Composable () -> Unit\n) {\n    val existingComposeView = window.decorView\n        .findViewById<ViewGroup>(android.R.id.content)\n        .getChildAt(0) as? ComposeView\n\n    if (existingComposeView != null) with(existingComposeView) {\n        setParentCompositionContext(parent)\n        setContent(content)\n    } else ComposeView(this).apply {\n        // Set content and parent **before** setContentView\n        // to have ComposeView create the composition on attach\n        setParentCompositionContext(parent)\n        setContent(content)\n        setContentView(this, DefaultActivityContentLayoutParams)\n    }\n}\n```\n\n`CompositionContext` 파라미터는 null을 그대로 넘겨주었고, `(Function0)null.INSTANCE, 1, (Object)null`의 값으로 무언가를 넘겨주는데,\n\n이 값이 `@Composable` Annotation의 구현체이다.\n\n위의 코드 흔적을 술어로 표현해보면 **`@Composable` 구현체를 넘겨주면 이를 기반으로 `ComposeView` 객체를 생성하여 `Activity`의 `setContentView()`에 적용한다.** 가 되겠다.\n\n\n##### 3. `@Composable` 구현체 확인\n\n`Composable` Annotaion 클래스의 구현체는 아래와 같다.\n\n```kotlin\n@MustBeDocumented\n@Retention(AnnotationRetention.BINARY)\n@Target(\n    // function declarations\n    // @Composable fun Foo() { ... }\n    // lambda expressions\n    // val foo = @Composable { ... }\n    AnnotationTarget.FUNCTION,\n\n    // type declarations\n    // var foo: @Composable () -> Unit = { ... }\n    // parameter types\n    // foo: @Composable () -> Unit\n    AnnotationTarget.TYPE,\n\n    // composable types inside of type signatures\n    // foo: (@Composable () -> Unit) -> Unit\n    AnnotationTarget.TYPE_PARAMETER,\n\n    // composable property getters and setters\n    // val foo: Int @Composable get() { ... }\n    // var bar: Int\n    //   @Composable get() { ... }\n    AnnotationTarget.PROPERTY_GETTER\n)\nannotation class Composable\n```\n\nAnnotationTarget을 통해 메서드나 Lambda 객체를 넘겨서 뷰를 조립하는 방식인데, `View`와 `ViewGroup`처럼 내부적으로 트리 구조로 실행지점에 대한 정보를 저장하고 있다.\n\n파면 팔수록 Flutter의 Widget, React Native의 Component와 유사한 느낌을 준다.","source":"_posts/2021-04-07 Jetpack Compose Part 2.md","raw":"---\ntitle: Jetpack Compose Part 2 - Preview / Layout / Decompile\ndate: 2021-04-07 02:00\ncover: https://androiddeepdive.github.io/Team-Blog/images/cover_jepack_compose.png\ncategories:\n- Jetpack Compose\ntags:\n- Android\n- Jetpack\n- Compose\n---\n\n<article class=\"message message-immersive is-primary\">\n    <div class=\"message-body\">\n        <i class=\"fas fa-pen-fancy mr-2\"></i>Writers<br>\n        by 김남훈 @Naver<br>\n        by 배희성 @RocketPunch<br>\n        by 송시영 @SmartStudy<br>\n        by 이기정 @BankSalad\n    </div>\n</article>\n\n<!-- more -->\n\n## Android Studio의 Jetpack Compose\n\nAndroid Studio Preview를 사용해 Compose를 사용하다보면 Preview라 코드레벨에서 활성화되는 것을 알 수 있다.\n\n좀 더 자세히 살펴보자.\n\n### Preview의 기능들\n\nPreview 와 Compose 를 사용해서 아래와 같이 구성할 수 있다.\n\n{% asset_img 1_ybDWG4W2bPYNq79vr1gE8w.png [1_ybDWG4W2bPYNq79vr1gE8w] %}\n\nSplit(design/code) 을 선택에 따라 코드 및 디자인의 패널을 변경할 수도 있다.\n\n{% asset_img 1_XVvr-CB2pn88Te7Gg52GPA.png [1_XVvr-CB2pn88Te7Gg52GPA] %}\n\n미리보기에서 인터렉티브 모드를 설정할 수 있다. \n\n인터렉티브 모드를 설정하면 실제 디바이스처럼  클릭이나 드래그 등의 상호 작용을 확인해 볼 수 있다.\n\n다만, 네트워크나 파일에 접근 또는 일부 Context API 는 인터렉티브 모드를 지원하지 않고 있다.\n\n> 간헐적으로 interactive 모드가 작동하지 않는 경우가 있다.\n\n{% asset_img 1_9IA2k2s5hAS9pSyzpmQ6Pw.png [1_9IA2k2s5hAS9pSyzpmQ6Pw] %}\n\n미리보기에서 직접 디바이스 혹은 에뮬레이터로 배포하여 결과를 확인할 수도 있다.\n\n{% asset_img 1_5RZOM7sWV0sXctJtTPdshQ.png [1_5RZOM7sWV0sXctJtTPdshQ] %}\n\n\n### `@Preview` Annotation 분석\n\n위에서 언급했다시피 `@Preview`를 사용하면 디바이스나 에뮬레이터를 실행하지 않고 실시간으로 Compose UI 를 볼 수 있다.\n\n`@Preview`를는 아래와 같이 구성되어 있으며 설정에 따라서 미리보기를 다양하게 구성할 수 있다.\n\n```kotlin\nannotation class Preview(\n    val name: String = \"\",\n    val group: String = \"\",\n    @IntRange(from = 1) val apiLevel: Int = -1,\n    // TODO(mount): Make this Dp when they are inline classes\n    val widthDp: Int = -1,\n    // TODO(mount): Make this Dp when they are inline classes\n    val heightDp: Int = -1,\n    val locale: String = \"\",\n    @FloatRange(from = 0.01) val fontScale: Float = 1f,\n    val showSystemUi: Boolean = false,\n    val showBackground: Boolean = false,\n    val backgroundColor: Long = 0,\n    @UiMode val uiMode: Int = 0,\n    @Device val device: String = Devices.DEFAULT\n)\n```\n\n- **name** : Preview 의 이름을 지정하며, 기본 값은 function 이름으로 설정된다.\n- **group** : Preview 의 그룹을 지정한다, 기본 값은 function 이름으로 설정된다.\n- **apiLevel** : api level 설정에 따라 Composable 을 렌더링해준다.\n- **widthDp** : Preview 의 너비를 설정한다. (기본 단위는 dp)\n- **heightDp** : Preview 의 높이를 설정한다. (기본 단위는 dp)\n- **locale** : 사용자 locales 에 따라 보여지는 UI 를 테스트 하기 위해 사용한다.\n- **fontScale** : 기본 density 애 배율을 적용해서 폰트 사이즈를 변경할 수 있다.\n- **showSystemUi** : true 로 설정하면 status bar 와 action bar 를 노출한다.\n- **showBackground** : true 로 설정하면 기본 배경색상을 적용해준다.\n- **backgroundColor** : 미리보기의 배경색을 설정할 수 있으며, showBackground 설정에 따라 노출 유무를 결정한다.\n- **uiMode** : uiMode 를 설정한다.\n- **device** : 기존 정의된 디바이스를 프리뷰에 적용한다. Devices object 에 정의된 값을 선택해서 사용할 수 있습니다. (Devices.NEXUS_9)\n\n### Compose의 레이아웃 구성\n\n- **Column** : 아이템을 세로로 배치한다.\n\n```kotlin\n@Composable\nfun ComposeColumn() {\n    Column {\n        Text(text = \"My First Compose\")\n        Text(text = \"My First Compose\")\n    }\n}\n```\n\n{% asset_img 1_bSyX8yT7H2HevBNw9fbyYw.png [1_bSyX8yT7H2HevBNw9fbyYw] %}\n\n- **Row** : 아이템을 가로로 배치한다.\n\n```kotlin\n@Composable\nfun ComposeRow() {\n    Row {\n        Text(text = \"My First Compose\")\n        Text(text = \"My First Compose\")\n    }\n}\n```\n\n{% asset_img 1_T9Pww7JyPMPhCJ_6yU8fyQ.png [1_T9Pww7JyPMPhCJ_6yU8fyQ] %}\n\n- **Box** : 구성 요소를 다른 구성 요소 위에 배치한다.\n\n```kotlin\n@Composable\nfun ComposeBox() {\n    Box {\n        Text(text = \"My First Compose 1\")\n        Text(text = \"My First Compose 2\")\n    }\n}\n```\n\n{% asset_img 1_wFM4jF71V5aJog3lALaRKQ.png [1_wFM4jF71V5aJog3lALaRKQ] %}\n\n- **Modifier** : 구성 요소의 크기, 마진등을 변경하거나 클릭이나 스크롤 등의 이벤트를 제어할 수 있도록 한다.\n\n```kotlin\n@Composable\nfun ComposeModifier() {\n    Box(modifier = Modifier\n        .padding(5.dp)\n    ) {\n        Text(text = \"Compose Modifier\")\n    }\n}\n```\n\n{% asset_img 1_tPAf-Akf2IpDRrrZo1f1dg.png [1_tPAf-Akf2IpDRrrZo1f1dg] %}\n\n- **LazyColumn / LazyRow** : Recyclerview 유사하게 화면에 보여지는 구성 요소만을 렌더링한다. 큰 데이터셋을 다루기에 용이하다.\n\n```kotlin\n@Composable\nfun ComposeLazyColumn() {\n    val itemsList = (0..100).toList()\n\n    LazyColumn {\n        items(items = itemsList, itemContent = { item ->\n            Text(text = \"Item : $item\", style = TextStyle(fontSize = 80.sp))\n        })\n    }\n}\n```\n\n{% asset_img 1_m7mSalYCza-SoJjmlYeWdA.png [1_m7mSalYCza-SoJjmlYeWdA] %}\n\n- **ConstraintLayout** : 기존 ContraintLayout 과 같이 여러 제약 참조를 설정해서 사용할 수 있다.\n `createRefs` / `createRefFor` 를 통해 참조를 생성하며, constrainAs 를 통해 제약 조건을 설정한다.\n\n```kotlin\n@Composable\nfun ComposeConstraintLayout() {\n    ConstraintLayout(modifier = Modifier.size(100.dp, 200.dp)) {\n        val (text1, image, text3) = createRefs()\n\n        Text(\"Text Item 1\", Modifier.constrainAs(text1) {\n            top.linkTo(parent.top)\n            start.linkTo(parent.start)\n            end.linkTo(parent.end)\n        })\n\n        Image(\n            painterResource(R.drawable.ic_launcher_foreground),\n            contentDescription = \"\",\n            contentScale = ContentScale.Crop,\n            modifier = Modifier.fillMaxSize().constrainAs(image) {\n                top.linkTo(text1.bottom)\n                bottom.linkTo(text3.top)\n                start.linkTo(parent.start)\n                end.linkTo(parent.end)\n            }\n        )\n\n        Text(\"Text Item 3\", Modifier.constrainAs(text3) {\n            bottom.linkTo(parent.bottom)\n            start.linkTo(parent.start)\n            end.linkTo(parent.end)\n        })\n    }\n}\n```\n\nJetpack Compose 의 ConstraintLayout 을 사용하기 위해서는 아래 의존성을 추가해야 한다.\n\n```groovy\nimplementation \"androidx.constraintlayout:constraintlayout-compose:1.0.0-alpha05\"\n```\n\n{% asset_img 1_UoLVl1dbUjKh9kd4uY0ROA.png [1_UoLVl1dbUjKh9kd4uY0ROA] %}\n\n### Jetpack Compose의 동작 원리 파악을 위한 빌드 과정 추적\n\n##### 1. 프로젝트 생성\n\nCompose가 내부적으로 어떻게 동작하는 지 알아보기 위해 먼저 프로젝트를 빌드해보자.\n\n빌드 후 Kotlin > Byte Code > Decompiled Java 순서로 변환하여 살펴볼 것이다.\n\nAndroid Studio Preview에서 Empty Compose Activity로 프로젝트를 생성하면 아래와 같은 샘플 코드를 얻을 수 있다.\n\n프로젝트 생성 후 임의로 Hello World로 파라미터값을 변경하였다.\n\n\n```kotlin\nclass MainActivity : ComponentActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContent {\n            HelloWorldTheme {\n                // A surface container using the 'background' color from the theme\n                Surface(color = MaterialTheme.colors.background) {\n                    Greeting(\"World\")\n                }\n            }\n        }\n    }\n}\n\n@Composable\nfun Greeting(name: String) {\n    Text(text = \"Hello $name!\")\n}\n\n@Preview(showBackground = true)\n@Composable\nfun DefaultPreview() {\n    HelloWorldTheme {\n        Greeting(\"World\")\n    }\n}\n```\n\n부가적으로 `src` 폴더 내부에 `ui.theme` 패키지가 생성되고 `Color.kt`, `Shape.kt`, `Theme.kt`, `Type.kt` 파일도 생성된다.\n\n이 파일들은 필요한 경우 들여다 보도록 하자.\n\n생성 후 Preview에 아래와 같이 렌더링 된다.\n\n{% asset_img add_002_001.png [add_002_001] %}\n\n##### 2. MainActivity 디컴파일\n\n```java\n@Metadata(\n   mv = {1, 4, 2},\n   bv = {1, 0, 3},\n   k = 2,\n   d1 = {\"...\"},\n   d2 = {\"DefaultPreview\", \"\", \"Greeting\", \"name\", \"\", \"app_debug\"}\n)\npublic final class MainActivityKt {\n    @Composable\n    public static final void Greeting(@NotNull String name) {\n        Intrinsics.checkNotNullParameter(name, \"name\");\n        TextKt.Text-Vh6c2nE$default(\"Hello \" + name + '!', \n            (Modifier)null, \n            0L, \n            0L, \n            (FontStyle)null, \n            (FontWeight)null, \n            (FontFamily)null, \n            0L, \n            (TextDecoration)null, \n            (TextAlign)null, \n            0L, \n            (TextOverflow)null, \n            false, \n            0, \n            (Function1)null, \n            (TextStyle)null, \n            65534, \n            (Object)null\n        );\n    }\n\n   @Composable\n   public static final void DefaultPreview() {\n      ThemeKt.HelloWorldTheme$default(false, (Function0)null.INSTANCE, 1, (Object)null);\n   }\n}\n\n// MainActivity.java\n@Metadata(\n   mv = {1, 4, 2},\n   bv = {1, 0, 3},\n   k = 1,\n   d1 = {\"...\"},\n   d2 = {\"...\"}\n)\npublic final class MainActivity extends ComponentActivity {\n   protected void onCreate(@Nullable Bundle savedInstanceState) {\n      super.onCreate(savedInstanceState);\n      ComponentActivityKt.setContent$default(this, (CompositionContext)null, (Function0)null.INSTANCE, 1, (Object)null);\n   }\n}\n```\n\n`ComponentActivityKt.setContent()`의 구현체는 아래와 같다.\n\n```kotlin\npublic fun ComponentActivity.setContent(\n    parent: CompositionContext? = null,\n    content: @Composable () -> Unit\n) {\n    val existingComposeView = window.decorView\n        .findViewById<ViewGroup>(android.R.id.content)\n        .getChildAt(0) as? ComposeView\n\n    if (existingComposeView != null) with(existingComposeView) {\n        setParentCompositionContext(parent)\n        setContent(content)\n    } else ComposeView(this).apply {\n        // Set content and parent **before** setContentView\n        // to have ComposeView create the composition on attach\n        setParentCompositionContext(parent)\n        setContent(content)\n        setContentView(this, DefaultActivityContentLayoutParams)\n    }\n}\n```\n\n`CompositionContext` 파라미터는 null을 그대로 넘겨주었고, `(Function0)null.INSTANCE, 1, (Object)null`의 값으로 무언가를 넘겨주는데,\n\n이 값이 `@Composable` Annotation의 구현체이다.\n\n위의 코드 흔적을 술어로 표현해보면 **`@Composable` 구현체를 넘겨주면 이를 기반으로 `ComposeView` 객체를 생성하여 `Activity`의 `setContentView()`에 적용한다.** 가 되겠다.\n\n\n##### 3. `@Composable` 구현체 확인\n\n`Composable` Annotaion 클래스의 구현체는 아래와 같다.\n\n```kotlin\n@MustBeDocumented\n@Retention(AnnotationRetention.BINARY)\n@Target(\n    // function declarations\n    // @Composable fun Foo() { ... }\n    // lambda expressions\n    // val foo = @Composable { ... }\n    AnnotationTarget.FUNCTION,\n\n    // type declarations\n    // var foo: @Composable () -> Unit = { ... }\n    // parameter types\n    // foo: @Composable () -> Unit\n    AnnotationTarget.TYPE,\n\n    // composable types inside of type signatures\n    // foo: (@Composable () -> Unit) -> Unit\n    AnnotationTarget.TYPE_PARAMETER,\n\n    // composable property getters and setters\n    // val foo: Int @Composable get() { ... }\n    // var bar: Int\n    //   @Composable get() { ... }\n    AnnotationTarget.PROPERTY_GETTER\n)\nannotation class Composable\n```\n\nAnnotationTarget을 통해 메서드나 Lambda 객체를 넘겨서 뷰를 조립하는 방식인데, `View`와 `ViewGroup`처럼 내부적으로 트리 구조로 실행지점에 대한 정보를 저장하고 있다.\n\n파면 팔수록 Flutter의 Widget, React Native의 Component와 유사한 느낌을 준다.","slug":"2021-04-07 Jetpack Compose Part 2","published":1,"updated":"2021-07-25T07:16:12.124Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cksagj7kt00013lree18reuhl","content":"<article class=\"message message-immersive is-primary\">\n    <div class=\"message-body\">\n        <i class=\"fas fa-pen-fancy mr-2\"></i>Writers<br>\n        by 김남훈 @Naver<br>\n        by 배희성 @RocketPunch<br>\n        by 송시영 @SmartStudy<br>\n        by 이기정 @BankSalad\n    </div>\n</article>\n\n<span id=\"more\"></span>\n\n<h2 id=\"Android-Studio의-Jetpack-Compose\"><a href=\"#Android-Studio의-Jetpack-Compose\" class=\"headerlink\" title=\"Android Studio의 Jetpack Compose\"></a>Android Studio의 Jetpack Compose</h2><p>Android Studio Preview를 사용해 Compose를 사용하다보면 Preview라 코드레벨에서 활성화되는 것을 알 수 있다.</p>\n<p>좀 더 자세히 살펴보자.</p>\n<h3 id=\"Preview의-기능들\"><a href=\"#Preview의-기능들\" class=\"headerlink\" title=\"Preview의 기능들\"></a>Preview의 기능들</h3><p>Preview 와 Compose 를 사용해서 아래와 같이 구성할 수 있다.</p>\n<img src=\"/Team-Blog/2021/04/07/2021-04-07%20Jetpack%20Compose%20Part%202/1_ybDWG4W2bPYNq79vr1gE8w.png\" class=\"\" title=\"[1_ybDWG4W2bPYNq79vr1gE8w]\">\n\n<p>Split(design/code) 을 선택에 따라 코드 및 디자인의 패널을 변경할 수도 있다.</p>\n<img src=\"/Team-Blog/2021/04/07/2021-04-07%20Jetpack%20Compose%20Part%202/1_XVvr-CB2pn88Te7Gg52GPA.png\" class=\"\" title=\"[1_XVvr-CB2pn88Te7Gg52GPA]\">\n\n<p>미리보기에서 인터렉티브 모드를 설정할 수 있다. </p>\n<p>인터렉티브 모드를 설정하면 실제 디바이스처럼  클릭이나 드래그 등의 상호 작용을 확인해 볼 수 있다.</p>\n<p>다만, 네트워크나 파일에 접근 또는 일부 Context API 는 인터렉티브 모드를 지원하지 않고 있다.</p>\n<blockquote>\n<p>간헐적으로 interactive 모드가 작동하지 않는 경우가 있다.</p>\n</blockquote>\n<img src=\"/Team-Blog/2021/04/07/2021-04-07%20Jetpack%20Compose%20Part%202/1_9IA2k2s5hAS9pSyzpmQ6Pw.png\" class=\"\" title=\"[1_9IA2k2s5hAS9pSyzpmQ6Pw]\">\n\n<p>미리보기에서 직접 디바이스 혹은 에뮬레이터로 배포하여 결과를 확인할 수도 있다.</p>\n<img src=\"/Team-Blog/2021/04/07/2021-04-07%20Jetpack%20Compose%20Part%202/1_5RZOM7sWV0sXctJtTPdshQ.png\" class=\"\" title=\"[1_5RZOM7sWV0sXctJtTPdshQ]\">\n\n\n<h3 id=\"Preview-Annotation-분석\"><a href=\"#Preview-Annotation-분석\" class=\"headerlink\" title=\"@Preview Annotation 분석\"></a><code>@Preview</code> Annotation 분석</h3><p>위에서 언급했다시피 <code>@Preview</code>를 사용하면 디바이스나 에뮬레이터를 실행하지 않고 실시간으로 Compose UI 를 볼 수 있다.</p>\n<p><code>@Preview</code>를는 아래와 같이 구성되어 있으며 설정에 따라서 미리보기를 다양하게 구성할 수 있다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">annotation</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Preview</span></span>(</span><br><span class=\"line\">    <span class=\"keyword\">val</span> name: String = <span class=\"string\">&quot;&quot;</span>,</span><br><span class=\"line\">    <span class=\"keyword\">val</span> group: String = <span class=\"string\">&quot;&quot;</span>,</span><br><span class=\"line\">    <span class=\"meta\">@IntRange(from = 1)</span> <span class=\"keyword\">val</span> apiLevel: <span class=\"built_in\">Int</span> = -<span class=\"number\">1</span>,</span><br><span class=\"line\">    <span class=\"comment\">// TODO(mount): Make this Dp when they are inline classes</span></span><br><span class=\"line\">    <span class=\"keyword\">val</span> widthDp: <span class=\"built_in\">Int</span> = -<span class=\"number\">1</span>,</span><br><span class=\"line\">    <span class=\"comment\">// TODO(mount): Make this Dp when they are inline classes</span></span><br><span class=\"line\">    <span class=\"keyword\">val</span> heightDp: <span class=\"built_in\">Int</span> = -<span class=\"number\">1</span>,</span><br><span class=\"line\">    <span class=\"keyword\">val</span> locale: String = <span class=\"string\">&quot;&quot;</span>,</span><br><span class=\"line\">    <span class=\"meta\">@FloatRange(from = 0.01)</span> <span class=\"keyword\">val</span> fontScale: <span class=\"built_in\">Float</span> = <span class=\"number\">1f</span>,</span><br><span class=\"line\">    <span class=\"keyword\">val</span> showSystemUi: <span class=\"built_in\">Boolean</span> = <span class=\"literal\">false</span>,</span><br><span class=\"line\">    <span class=\"keyword\">val</span> showBackground: <span class=\"built_in\">Boolean</span> = <span class=\"literal\">false</span>,</span><br><span class=\"line\">    <span class=\"keyword\">val</span> backgroundColor: <span class=\"built_in\">Long</span> = <span class=\"number\">0</span>,</span><br><span class=\"line\">    <span class=\"meta\">@UiMode</span> <span class=\"keyword\">val</span> uiMode: <span class=\"built_in\">Int</span> = <span class=\"number\">0</span>,</span><br><span class=\"line\">    <span class=\"meta\">@Device</span> <span class=\"keyword\">val</span> device: String = Devices.DEFAULT</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>name</strong> : Preview 의 이름을 지정하며, 기본 값은 function 이름으로 설정된다.</li>\n<li><strong>group</strong> : Preview 의 그룹을 지정한다, 기본 값은 function 이름으로 설정된다.</li>\n<li><strong>apiLevel</strong> : api level 설정에 따라 Composable 을 렌더링해준다.</li>\n<li><strong>widthDp</strong> : Preview 의 너비를 설정한다. (기본 단위는 dp)</li>\n<li><strong>heightDp</strong> : Preview 의 높이를 설정한다. (기본 단위는 dp)</li>\n<li><strong>locale</strong> : 사용자 locales 에 따라 보여지는 UI 를 테스트 하기 위해 사용한다.</li>\n<li><strong>fontScale</strong> : 기본 density 애 배율을 적용해서 폰트 사이즈를 변경할 수 있다.</li>\n<li><strong>showSystemUi</strong> : true 로 설정하면 status bar 와 action bar 를 노출한다.</li>\n<li><strong>showBackground</strong> : true 로 설정하면 기본 배경색상을 적용해준다.</li>\n<li><strong>backgroundColor</strong> : 미리보기의 배경색을 설정할 수 있으며, showBackground 설정에 따라 노출 유무를 결정한다.</li>\n<li><strong>uiMode</strong> : uiMode 를 설정한다.</li>\n<li><strong>device</strong> : 기존 정의된 디바이스를 프리뷰에 적용한다. Devices object 에 정의된 값을 선택해서 사용할 수 있습니다. (Devices.NEXUS_9)</li>\n</ul>\n<h3 id=\"Compose의-레이아웃-구성\"><a href=\"#Compose의-레이아웃-구성\" class=\"headerlink\" title=\"Compose의 레이아웃 구성\"></a>Compose의 레이아웃 구성</h3><ul>\n<li><strong>Column</strong> : 아이템을 세로로 배치한다.</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Composable</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">ComposeColumn</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    Column &#123;</span><br><span class=\"line\">        Text(text = <span class=\"string\">&quot;My First Compose&quot;</span>)</span><br><span class=\"line\">        Text(text = <span class=\"string\">&quot;My First Compose&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<img src=\"/Team-Blog/2021/04/07/2021-04-07%20Jetpack%20Compose%20Part%202/1_bSyX8yT7H2HevBNw9fbyYw.png\" class=\"\" title=\"[1_bSyX8yT7H2HevBNw9fbyYw]\">\n\n<ul>\n<li><strong>Row</strong> : 아이템을 가로로 배치한다.</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Composable</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">ComposeRow</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    Row &#123;</span><br><span class=\"line\">        Text(text = <span class=\"string\">&quot;My First Compose&quot;</span>)</span><br><span class=\"line\">        Text(text = <span class=\"string\">&quot;My First Compose&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<img src=\"/Team-Blog/2021/04/07/2021-04-07%20Jetpack%20Compose%20Part%202/1_T9Pww7JyPMPhCJ_6yU8fyQ.png\" class=\"\" title=\"[1_T9Pww7JyPMPhCJ_6yU8fyQ]\">\n\n<ul>\n<li><strong>Box</strong> : 구성 요소를 다른 구성 요소 위에 배치한다.</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Composable</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">ComposeBox</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    Box &#123;</span><br><span class=\"line\">        Text(text = <span class=\"string\">&quot;My First Compose 1&quot;</span>)</span><br><span class=\"line\">        Text(text = <span class=\"string\">&quot;My First Compose 2&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<img src=\"/Team-Blog/2021/04/07/2021-04-07%20Jetpack%20Compose%20Part%202/1_wFM4jF71V5aJog3lALaRKQ.png\" class=\"\" title=\"[1_wFM4jF71V5aJog3lALaRKQ]\">\n\n<ul>\n<li><strong>Modifier</strong> : 구성 요소의 크기, 마진등을 변경하거나 클릭이나 스크롤 등의 이벤트를 제어할 수 있도록 한다.</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Composable</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">ComposeModifier</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    Box(modifier = Modifier</span><br><span class=\"line\">        .padding(<span class=\"number\">5.</span>dp)</span><br><span class=\"line\">    ) &#123;</span><br><span class=\"line\">        Text(text = <span class=\"string\">&quot;Compose Modifier&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<img src=\"/Team-Blog/2021/04/07/2021-04-07%20Jetpack%20Compose%20Part%202/1_tPAf-Akf2IpDRrrZo1f1dg.png\" class=\"\" title=\"[1_tPAf-Akf2IpDRrrZo1f1dg]\">\n\n<ul>\n<li><strong>LazyColumn / LazyRow</strong> : Recyclerview 유사하게 화면에 보여지는 구성 요소만을 렌더링한다. 큰 데이터셋을 다루기에 용이하다.</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Composable</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">ComposeLazyColumn</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> itemsList = (<span class=\"number\">0.</span><span class=\"number\">.100</span>).toList()</span><br><span class=\"line\"></span><br><span class=\"line\">    LazyColumn &#123;</span><br><span class=\"line\">        items(items = itemsList, itemContent = &#123; item -&gt;</span><br><span class=\"line\">            Text(text = <span class=\"string\">&quot;Item : <span class=\"variable\">$item</span>&quot;</span>, style = TextStyle(fontSize = <span class=\"number\">80.</span>sp))</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<img src=\"/Team-Blog/2021/04/07/2021-04-07%20Jetpack%20Compose%20Part%202/1_m7mSalYCza-SoJjmlYeWdA.png\" class=\"\" title=\"[1_m7mSalYCza-SoJjmlYeWdA]\">\n\n<ul>\n<li><strong>ConstraintLayout</strong> : 기존 ContraintLayout 과 같이 여러 제약 참조를 설정해서 사용할 수 있다.<br><code>createRefs</code> / <code>createRefFor</code> 를 통해 참조를 생성하며, constrainAs 를 통해 제약 조건을 설정한다.</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Composable</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">ComposeConstraintLayout</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    ConstraintLayout(modifier = Modifier.size(<span class=\"number\">100.</span>dp, <span class=\"number\">200.</span>dp)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">val</span> (text1, image, text3) = createRefs()</span><br><span class=\"line\"></span><br><span class=\"line\">        Text(<span class=\"string\">&quot;Text Item 1&quot;</span>, Modifier.constrainAs(text1) &#123;</span><br><span class=\"line\">            top.linkTo(parent.top)</span><br><span class=\"line\">            start.linkTo(parent.start)</span><br><span class=\"line\">            end.linkTo(parent.end)</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">        Image(</span><br><span class=\"line\">            painterResource(R.drawable.ic_launcher_foreground),</span><br><span class=\"line\">            contentDescription = <span class=\"string\">&quot;&quot;</span>,</span><br><span class=\"line\">            contentScale = ContentScale.Crop,</span><br><span class=\"line\">            modifier = Modifier.fillMaxSize().constrainAs(image) &#123;</span><br><span class=\"line\">                top.linkTo(text1.bottom)</span><br><span class=\"line\">                bottom.linkTo(text3.top)</span><br><span class=\"line\">                start.linkTo(parent.start)</span><br><span class=\"line\">                end.linkTo(parent.end)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        )</span><br><span class=\"line\"></span><br><span class=\"line\">        Text(<span class=\"string\">&quot;Text Item 3&quot;</span>, Modifier.constrainAs(text3) &#123;</span><br><span class=\"line\">            bottom.linkTo(parent.bottom)</span><br><span class=\"line\">            start.linkTo(parent.start)</span><br><span class=\"line\">            end.linkTo(parent.end)</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Jetpack Compose 의 ConstraintLayout 을 사용하기 위해서는 아래 의존성을 추가해야 한다.</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">implementation <span class=\"string\">&quot;androidx.constraintlayout:constraintlayout-compose:1.0.0-alpha05&quot;</span></span><br></pre></td></tr></table></figure>\n\n<img src=\"/Team-Blog/2021/04/07/2021-04-07%20Jetpack%20Compose%20Part%202/1_UoLVl1dbUjKh9kd4uY0ROA.png\" class=\"\" title=\"[1_UoLVl1dbUjKh9kd4uY0ROA]\">\n\n<h3 id=\"Jetpack-Compose의-동작-원리-파악을-위한-빌드-과정-추적\"><a href=\"#Jetpack-Compose의-동작-원리-파악을-위한-빌드-과정-추적\" class=\"headerlink\" title=\"Jetpack Compose의 동작 원리 파악을 위한 빌드 과정 추적\"></a>Jetpack Compose의 동작 원리 파악을 위한 빌드 과정 추적</h3><h5 id=\"1-프로젝트-생성\"><a href=\"#1-프로젝트-생성\" class=\"headerlink\" title=\"1. 프로젝트 생성\"></a>1. 프로젝트 생성</h5><p>Compose가 내부적으로 어떻게 동작하는 지 알아보기 위해 먼저 프로젝트를 빌드해보자.</p>\n<p>빌드 후 Kotlin &gt; Byte Code &gt; Decompiled Java 순서로 변환하여 살펴볼 것이다.</p>\n<p>Android Studio Preview에서 Empty Compose Activity로 프로젝트를 생성하면 아래와 같은 샘플 코드를 얻을 수 있다.</p>\n<p>프로젝트 생성 후 임의로 Hello World로 파라미터값을 변경하였다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MainActivity</span> : <span class=\"type\">ComponentActivity</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onCreate</span><span class=\"params\">(savedInstanceState: <span class=\"type\">Bundle</span>?)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onCreate(savedInstanceState)</span><br><span class=\"line\">        setContent &#123;</span><br><span class=\"line\">            HelloWorldTheme &#123;</span><br><span class=\"line\">                <span class=\"comment\">// A surface container using the &#x27;background&#x27; color from the theme</span></span><br><span class=\"line\">                Surface(color = MaterialTheme.colors.background) &#123;</span><br><span class=\"line\">                    Greeting(<span class=\"string\">&quot;World&quot;</span>)</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Composable</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">Greeting</span><span class=\"params\">(name: <span class=\"type\">String</span>)</span></span> &#123;</span><br><span class=\"line\">    Text(text = <span class=\"string\">&quot;Hello <span class=\"variable\">$name</span>!&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Preview(showBackground = true)</span></span><br><span class=\"line\"><span class=\"meta\">@Composable</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">DefaultPreview</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    HelloWorldTheme &#123;</span><br><span class=\"line\">        Greeting(<span class=\"string\">&quot;World&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>부가적으로 <code>src</code> 폴더 내부에 <code>ui.theme</code> 패키지가 생성되고 <code>Color.kt</code>, <code>Shape.kt</code>, <code>Theme.kt</code>, <code>Type.kt</code> 파일도 생성된다.</p>\n<p>이 파일들은 필요한 경우 들여다 보도록 하자.</p>\n<p>생성 후 Preview에 아래와 같이 렌더링 된다.</p>\n<img src=\"/Team-Blog/2021/04/07/2021-04-07%20Jetpack%20Compose%20Part%202/add_002_001.png\" class=\"\" title=\"[add_002_001]\">\n\n<h5 id=\"2-MainActivity-디컴파일\"><a href=\"#2-MainActivity-디컴파일\" class=\"headerlink\" title=\"2. MainActivity 디컴파일\"></a>2. MainActivity 디컴파일</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Metadata(</span></span><br><span class=\"line\"><span class=\"meta\">   mv = &#123;1, 4, 2&#125;,</span></span><br><span class=\"line\"><span class=\"meta\">   bv = &#123;1, 0, 3&#125;,</span></span><br><span class=\"line\"><span class=\"meta\">   k = 2,</span></span><br><span class=\"line\"><span class=\"meta\">   d1 = &#123;&quot;...&quot;&#125;,</span></span><br><span class=\"line\"><span class=\"meta\">   d2 = &#123;&quot;DefaultPreview&quot;, &quot;&quot;, &quot;Greeting&quot;, &quot;name&quot;, &quot;&quot;, &quot;app_debug&quot;&#125;</span></span><br><span class=\"line\"><span class=\"meta\">)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MainActivityKt</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Composable</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">Greeting</span><span class=\"params\">(<span class=\"meta\">@NotNull</span> String name)</span> </span>&#123;</span><br><span class=\"line\">        Intrinsics.checkNotNullParameter(name, <span class=\"string\">&quot;name&quot;</span>);</span><br><span class=\"line\">        TextKt.Text-Vh6c2nE$<span class=\"keyword\">default</span>(<span class=\"string\">&quot;Hello &quot;</span> + name + <span class=\"string\">&#x27;!&#x27;</span>, </span><br><span class=\"line\">            (Modifier)<span class=\"keyword\">null</span>, </span><br><span class=\"line\">            <span class=\"number\">0L</span>, </span><br><span class=\"line\">            <span class=\"number\">0L</span>, </span><br><span class=\"line\">            (FontStyle)<span class=\"keyword\">null</span>, </span><br><span class=\"line\">            (FontWeight)<span class=\"keyword\">null</span>, </span><br><span class=\"line\">            (FontFamily)<span class=\"keyword\">null</span>, </span><br><span class=\"line\">            <span class=\"number\">0L</span>, </span><br><span class=\"line\">            (TextDecoration)<span class=\"keyword\">null</span>, </span><br><span class=\"line\">            (TextAlign)<span class=\"keyword\">null</span>, </span><br><span class=\"line\">            <span class=\"number\">0L</span>, </span><br><span class=\"line\">            (TextOverflow)<span class=\"keyword\">null</span>, </span><br><span class=\"line\">            <span class=\"keyword\">false</span>, </span><br><span class=\"line\">            <span class=\"number\">0</span>, </span><br><span class=\"line\">            (Function1)<span class=\"keyword\">null</span>, </span><br><span class=\"line\">            (TextStyle)<span class=\"keyword\">null</span>, </span><br><span class=\"line\">            <span class=\"number\">65534</span>, </span><br><span class=\"line\">            (Object)<span class=\"keyword\">null</span></span><br><span class=\"line\">        );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"meta\">@Composable</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">DefaultPreview</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      ThemeKt.HelloWorldTheme$<span class=\"keyword\">default</span>(<span class=\"keyword\">false</span>, (Function0)<span class=\"keyword\">null</span>.INSTANCE, <span class=\"number\">1</span>, (Object)<span class=\"keyword\">null</span>);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// MainActivity.java</span></span><br><span class=\"line\"><span class=\"meta\">@Metadata(</span></span><br><span class=\"line\"><span class=\"meta\">   mv = &#123;1, 4, 2&#125;,</span></span><br><span class=\"line\"><span class=\"meta\">   bv = &#123;1, 0, 3&#125;,</span></span><br><span class=\"line\"><span class=\"meta\">   k = 1,</span></span><br><span class=\"line\"><span class=\"meta\">   d1 = &#123;&quot;...&quot;&#125;,</span></span><br><span class=\"line\"><span class=\"meta\">   d2 = &#123;&quot;...&quot;&#125;</span></span><br><span class=\"line\"><span class=\"meta\">)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MainActivity</span> <span class=\"keyword\">extends</span> <span class=\"title\">ComponentActivity</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(<span class=\"meta\">@Nullable</span> Bundle savedInstanceState)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">super</span>.onCreate(savedInstanceState);</span><br><span class=\"line\">      ComponentActivityKt.setContent$<span class=\"keyword\">default</span>(<span class=\"keyword\">this</span>, (CompositionContext)<span class=\"keyword\">null</span>, (Function0)<span class=\"keyword\">null</span>.INSTANCE, <span class=\"number\">1</span>, (Object)<span class=\"keyword\">null</span>);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>ComponentActivityKt.setContent()</code>의 구현체는 아래와 같다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">fun</span> ComponentActivity.<span class=\"title\">setContent</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    parent: <span class=\"type\">CompositionContext</span>? = <span class=\"literal\">null</span>,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    content: @<span class=\"type\">Composable</span> () -&gt; <span class=\"type\">Unit</span></span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> existingComposeView = window.decorView</span><br><span class=\"line\">        .findViewById&lt;ViewGroup&gt;(android.R.id.content)</span><br><span class=\"line\">        .getChildAt(<span class=\"number\">0</span>) <span class=\"keyword\">as</span>? ComposeView</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (existingComposeView != <span class=\"literal\">null</span>) with(existingComposeView) &#123;</span><br><span class=\"line\">        setParentCompositionContext(parent)</span><br><span class=\"line\">        setContent(content)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> ComposeView(<span class=\"keyword\">this</span>).apply &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Set content and parent **before** setContentView</span></span><br><span class=\"line\">        <span class=\"comment\">// to have ComposeView create the composition on attach</span></span><br><span class=\"line\">        setParentCompositionContext(parent)</span><br><span class=\"line\">        setContent(content)</span><br><span class=\"line\">        setContentView(<span class=\"keyword\">this</span>, DefaultActivityContentLayoutParams)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>CompositionContext</code> 파라미터는 null을 그대로 넘겨주었고, <code>(Function0)null.INSTANCE, 1, (Object)null</code>의 값으로 무언가를 넘겨주는데,</p>\n<p>이 값이 <code>@Composable</code> Annotation의 구현체이다.</p>\n<p>위의 코드 흔적을 술어로 표현해보면 <strong><code>@Composable</code> 구현체를 넘겨주면 이를 기반으로 <code>ComposeView</code> 객체를 생성하여 <code>Activity</code>의 <code>setContentView()</code>에 적용한다.</strong> 가 되겠다.</p>\n<h5 id=\"3-Composable-구현체-확인\"><a href=\"#3-Composable-구현체-확인\" class=\"headerlink\" title=\"3. @Composable 구현체 확인\"></a>3. <code>@Composable</code> 구현체 확인</h5><p><code>Composable</code> Annotaion 클래스의 구현체는 아래와 같다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@MustBeDocumented</span></span><br><span class=\"line\"><span class=\"meta\">@Retention(AnnotationRetention.BINARY)</span></span><br><span class=\"line\"><span class=\"meta\">@Target(</span></span><br><span class=\"line\"><span class=\"meta\">    // function declarations</span></span><br><span class=\"line\"><span class=\"meta\">    // @Composable fun Foo()</span> &#123; ... &#125;</span><br><span class=\"line\">    <span class=\"comment\">// lambda expressions</span></span><br><span class=\"line\">    <span class=\"comment\">// val foo = @Composable &#123; ... &#125;</span></span><br><span class=\"line\">    AnnotationTarget.FUNCTION,</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// type declarations</span></span><br><span class=\"line\">    <span class=\"comment\">// var foo: @Composable () -&gt; Unit = &#123; ... &#125;</span></span><br><span class=\"line\">    <span class=\"comment\">// parameter types</span></span><br><span class=\"line\">    <span class=\"comment\">// foo: @Composable () -&gt; Unit</span></span><br><span class=\"line\">    AnnotationTarget.TYPE,</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// composable types inside of type signatures</span></span><br><span class=\"line\">    <span class=\"comment\">// foo: (@Composable () -&gt; Unit) -&gt; Unit</span></span><br><span class=\"line\">    AnnotationTarget.TYPE_PARAMETER,</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// composable property getters and setters</span></span><br><span class=\"line\">    <span class=\"comment\">// val foo: Int @Composable get() &#123; ... &#125;</span></span><br><span class=\"line\">    <span class=\"comment\">// var bar: Int</span></span><br><span class=\"line\">    <span class=\"comment\">//   @Composable get() &#123; ... &#125;</span></span><br><span class=\"line\">    AnnotationTarget.PROPERTY_GETTER</span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"keyword\">annotation</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Composable</span></span></span><br></pre></td></tr></table></figure>\n\n<p>AnnotationTarget을 통해 메서드나 Lambda 객체를 넘겨서 뷰를 조립하는 방식인데, <code>View</code>와 <code>ViewGroup</code>처럼 내부적으로 트리 구조로 실행지점에 대한 정보를 저장하고 있다.</p>\n<p>파면 팔수록 Flutter의 Widget, React Native의 Component와 유사한 느낌을 준다.</p>\n","site":{"data":{}},"excerpt":"<article class=\"message message-immersive is-primary\">\n    <div class=\"message-body\">\n        <i class=\"fas fa-pen-fancy mr-2\"></i>Writers<br>\n        by 김남훈 @Naver<br>\n        by 배희성 @RocketPunch<br>\n        by 송시영 @SmartStudy<br>\n        by 이기정 @BankSalad\n    </div>\n</article>","more":"<h2 id=\"Android-Studio의-Jetpack-Compose\"><a href=\"#Android-Studio의-Jetpack-Compose\" class=\"headerlink\" title=\"Android Studio의 Jetpack Compose\"></a>Android Studio의 Jetpack Compose</h2><p>Android Studio Preview를 사용해 Compose를 사용하다보면 Preview라 코드레벨에서 활성화되는 것을 알 수 있다.</p>\n<p>좀 더 자세히 살펴보자.</p>\n<h3 id=\"Preview의-기능들\"><a href=\"#Preview의-기능들\" class=\"headerlink\" title=\"Preview의 기능들\"></a>Preview의 기능들</h3><p>Preview 와 Compose 를 사용해서 아래와 같이 구성할 수 있다.</p>\n<img src=\"/Team-Blog/2021/04/07/2021-04-07%20Jetpack%20Compose%20Part%202/1_ybDWG4W2bPYNq79vr1gE8w.png\" class=\"\" title=\"[1_ybDWG4W2bPYNq79vr1gE8w]\">\n\n<p>Split(design/code) 을 선택에 따라 코드 및 디자인의 패널을 변경할 수도 있다.</p>\n<img src=\"/Team-Blog/2021/04/07/2021-04-07%20Jetpack%20Compose%20Part%202/1_XVvr-CB2pn88Te7Gg52GPA.png\" class=\"\" title=\"[1_XVvr-CB2pn88Te7Gg52GPA]\">\n\n<p>미리보기에서 인터렉티브 모드를 설정할 수 있다. </p>\n<p>인터렉티브 모드를 설정하면 실제 디바이스처럼  클릭이나 드래그 등의 상호 작용을 확인해 볼 수 있다.</p>\n<p>다만, 네트워크나 파일에 접근 또는 일부 Context API 는 인터렉티브 모드를 지원하지 않고 있다.</p>\n<blockquote>\n<p>간헐적으로 interactive 모드가 작동하지 않는 경우가 있다.</p>\n</blockquote>\n<img src=\"/Team-Blog/2021/04/07/2021-04-07%20Jetpack%20Compose%20Part%202/1_9IA2k2s5hAS9pSyzpmQ6Pw.png\" class=\"\" title=\"[1_9IA2k2s5hAS9pSyzpmQ6Pw]\">\n\n<p>미리보기에서 직접 디바이스 혹은 에뮬레이터로 배포하여 결과를 확인할 수도 있다.</p>\n<img src=\"/Team-Blog/2021/04/07/2021-04-07%20Jetpack%20Compose%20Part%202/1_5RZOM7sWV0sXctJtTPdshQ.png\" class=\"\" title=\"[1_5RZOM7sWV0sXctJtTPdshQ]\">\n\n\n<h3 id=\"Preview-Annotation-분석\"><a href=\"#Preview-Annotation-분석\" class=\"headerlink\" title=\"@Preview Annotation 분석\"></a><code>@Preview</code> Annotation 분석</h3><p>위에서 언급했다시피 <code>@Preview</code>를 사용하면 디바이스나 에뮬레이터를 실행하지 않고 실시간으로 Compose UI 를 볼 수 있다.</p>\n<p><code>@Preview</code>를는 아래와 같이 구성되어 있으며 설정에 따라서 미리보기를 다양하게 구성할 수 있다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">annotation</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Preview</span></span>(</span><br><span class=\"line\">    <span class=\"keyword\">val</span> name: String = <span class=\"string\">&quot;&quot;</span>,</span><br><span class=\"line\">    <span class=\"keyword\">val</span> group: String = <span class=\"string\">&quot;&quot;</span>,</span><br><span class=\"line\">    <span class=\"meta\">@IntRange(from = 1)</span> <span class=\"keyword\">val</span> apiLevel: <span class=\"built_in\">Int</span> = -<span class=\"number\">1</span>,</span><br><span class=\"line\">    <span class=\"comment\">// TODO(mount): Make this Dp when they are inline classes</span></span><br><span class=\"line\">    <span class=\"keyword\">val</span> widthDp: <span class=\"built_in\">Int</span> = -<span class=\"number\">1</span>,</span><br><span class=\"line\">    <span class=\"comment\">// TODO(mount): Make this Dp when they are inline classes</span></span><br><span class=\"line\">    <span class=\"keyword\">val</span> heightDp: <span class=\"built_in\">Int</span> = -<span class=\"number\">1</span>,</span><br><span class=\"line\">    <span class=\"keyword\">val</span> locale: String = <span class=\"string\">&quot;&quot;</span>,</span><br><span class=\"line\">    <span class=\"meta\">@FloatRange(from = 0.01)</span> <span class=\"keyword\">val</span> fontScale: <span class=\"built_in\">Float</span> = <span class=\"number\">1f</span>,</span><br><span class=\"line\">    <span class=\"keyword\">val</span> showSystemUi: <span class=\"built_in\">Boolean</span> = <span class=\"literal\">false</span>,</span><br><span class=\"line\">    <span class=\"keyword\">val</span> showBackground: <span class=\"built_in\">Boolean</span> = <span class=\"literal\">false</span>,</span><br><span class=\"line\">    <span class=\"keyword\">val</span> backgroundColor: <span class=\"built_in\">Long</span> = <span class=\"number\">0</span>,</span><br><span class=\"line\">    <span class=\"meta\">@UiMode</span> <span class=\"keyword\">val</span> uiMode: <span class=\"built_in\">Int</span> = <span class=\"number\">0</span>,</span><br><span class=\"line\">    <span class=\"meta\">@Device</span> <span class=\"keyword\">val</span> device: String = Devices.DEFAULT</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>name</strong> : Preview 의 이름을 지정하며, 기본 값은 function 이름으로 설정된다.</li>\n<li><strong>group</strong> : Preview 의 그룹을 지정한다, 기본 값은 function 이름으로 설정된다.</li>\n<li><strong>apiLevel</strong> : api level 설정에 따라 Composable 을 렌더링해준다.</li>\n<li><strong>widthDp</strong> : Preview 의 너비를 설정한다. (기본 단위는 dp)</li>\n<li><strong>heightDp</strong> : Preview 의 높이를 설정한다. (기본 단위는 dp)</li>\n<li><strong>locale</strong> : 사용자 locales 에 따라 보여지는 UI 를 테스트 하기 위해 사용한다.</li>\n<li><strong>fontScale</strong> : 기본 density 애 배율을 적용해서 폰트 사이즈를 변경할 수 있다.</li>\n<li><strong>showSystemUi</strong> : true 로 설정하면 status bar 와 action bar 를 노출한다.</li>\n<li><strong>showBackground</strong> : true 로 설정하면 기본 배경색상을 적용해준다.</li>\n<li><strong>backgroundColor</strong> : 미리보기의 배경색을 설정할 수 있으며, showBackground 설정에 따라 노출 유무를 결정한다.</li>\n<li><strong>uiMode</strong> : uiMode 를 설정한다.</li>\n<li><strong>device</strong> : 기존 정의된 디바이스를 프리뷰에 적용한다. Devices object 에 정의된 값을 선택해서 사용할 수 있습니다. (Devices.NEXUS_9)</li>\n</ul>\n<h3 id=\"Compose의-레이아웃-구성\"><a href=\"#Compose의-레이아웃-구성\" class=\"headerlink\" title=\"Compose의 레이아웃 구성\"></a>Compose의 레이아웃 구성</h3><ul>\n<li><strong>Column</strong> : 아이템을 세로로 배치한다.</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Composable</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">ComposeColumn</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    Column &#123;</span><br><span class=\"line\">        Text(text = <span class=\"string\">&quot;My First Compose&quot;</span>)</span><br><span class=\"line\">        Text(text = <span class=\"string\">&quot;My First Compose&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<img src=\"/Team-Blog/2021/04/07/2021-04-07%20Jetpack%20Compose%20Part%202/1_bSyX8yT7H2HevBNw9fbyYw.png\" class=\"\" title=\"[1_bSyX8yT7H2HevBNw9fbyYw]\">\n\n<ul>\n<li><strong>Row</strong> : 아이템을 가로로 배치한다.</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Composable</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">ComposeRow</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    Row &#123;</span><br><span class=\"line\">        Text(text = <span class=\"string\">&quot;My First Compose&quot;</span>)</span><br><span class=\"line\">        Text(text = <span class=\"string\">&quot;My First Compose&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<img src=\"/Team-Blog/2021/04/07/2021-04-07%20Jetpack%20Compose%20Part%202/1_T9Pww7JyPMPhCJ_6yU8fyQ.png\" class=\"\" title=\"[1_T9Pww7JyPMPhCJ_6yU8fyQ]\">\n\n<ul>\n<li><strong>Box</strong> : 구성 요소를 다른 구성 요소 위에 배치한다.</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Composable</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">ComposeBox</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    Box &#123;</span><br><span class=\"line\">        Text(text = <span class=\"string\">&quot;My First Compose 1&quot;</span>)</span><br><span class=\"line\">        Text(text = <span class=\"string\">&quot;My First Compose 2&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<img src=\"/Team-Blog/2021/04/07/2021-04-07%20Jetpack%20Compose%20Part%202/1_wFM4jF71V5aJog3lALaRKQ.png\" class=\"\" title=\"[1_wFM4jF71V5aJog3lALaRKQ]\">\n\n<ul>\n<li><strong>Modifier</strong> : 구성 요소의 크기, 마진등을 변경하거나 클릭이나 스크롤 등의 이벤트를 제어할 수 있도록 한다.</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Composable</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">ComposeModifier</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    Box(modifier = Modifier</span><br><span class=\"line\">        .padding(<span class=\"number\">5.</span>dp)</span><br><span class=\"line\">    ) &#123;</span><br><span class=\"line\">        Text(text = <span class=\"string\">&quot;Compose Modifier&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<img src=\"/Team-Blog/2021/04/07/2021-04-07%20Jetpack%20Compose%20Part%202/1_tPAf-Akf2IpDRrrZo1f1dg.png\" class=\"\" title=\"[1_tPAf-Akf2IpDRrrZo1f1dg]\">\n\n<ul>\n<li><strong>LazyColumn / LazyRow</strong> : Recyclerview 유사하게 화면에 보여지는 구성 요소만을 렌더링한다. 큰 데이터셋을 다루기에 용이하다.</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Composable</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">ComposeLazyColumn</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> itemsList = (<span class=\"number\">0.</span><span class=\"number\">.100</span>).toList()</span><br><span class=\"line\"></span><br><span class=\"line\">    LazyColumn &#123;</span><br><span class=\"line\">        items(items = itemsList, itemContent = &#123; item -&gt;</span><br><span class=\"line\">            Text(text = <span class=\"string\">&quot;Item : <span class=\"variable\">$item</span>&quot;</span>, style = TextStyle(fontSize = <span class=\"number\">80.</span>sp))</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<img src=\"/Team-Blog/2021/04/07/2021-04-07%20Jetpack%20Compose%20Part%202/1_m7mSalYCza-SoJjmlYeWdA.png\" class=\"\" title=\"[1_m7mSalYCza-SoJjmlYeWdA]\">\n\n<ul>\n<li><strong>ConstraintLayout</strong> : 기존 ContraintLayout 과 같이 여러 제약 참조를 설정해서 사용할 수 있다.<br><code>createRefs</code> / <code>createRefFor</code> 를 통해 참조를 생성하며, constrainAs 를 통해 제약 조건을 설정한다.</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Composable</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">ComposeConstraintLayout</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    ConstraintLayout(modifier = Modifier.size(<span class=\"number\">100.</span>dp, <span class=\"number\">200.</span>dp)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">val</span> (text1, image, text3) = createRefs()</span><br><span class=\"line\"></span><br><span class=\"line\">        Text(<span class=\"string\">&quot;Text Item 1&quot;</span>, Modifier.constrainAs(text1) &#123;</span><br><span class=\"line\">            top.linkTo(parent.top)</span><br><span class=\"line\">            start.linkTo(parent.start)</span><br><span class=\"line\">            end.linkTo(parent.end)</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">        Image(</span><br><span class=\"line\">            painterResource(R.drawable.ic_launcher_foreground),</span><br><span class=\"line\">            contentDescription = <span class=\"string\">&quot;&quot;</span>,</span><br><span class=\"line\">            contentScale = ContentScale.Crop,</span><br><span class=\"line\">            modifier = Modifier.fillMaxSize().constrainAs(image) &#123;</span><br><span class=\"line\">                top.linkTo(text1.bottom)</span><br><span class=\"line\">                bottom.linkTo(text3.top)</span><br><span class=\"line\">                start.linkTo(parent.start)</span><br><span class=\"line\">                end.linkTo(parent.end)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        )</span><br><span class=\"line\"></span><br><span class=\"line\">        Text(<span class=\"string\">&quot;Text Item 3&quot;</span>, Modifier.constrainAs(text3) &#123;</span><br><span class=\"line\">            bottom.linkTo(parent.bottom)</span><br><span class=\"line\">            start.linkTo(parent.start)</span><br><span class=\"line\">            end.linkTo(parent.end)</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Jetpack Compose 의 ConstraintLayout 을 사용하기 위해서는 아래 의존성을 추가해야 한다.</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">implementation <span class=\"string\">&quot;androidx.constraintlayout:constraintlayout-compose:1.0.0-alpha05&quot;</span></span><br></pre></td></tr></table></figure>\n\n<img src=\"/Team-Blog/2021/04/07/2021-04-07%20Jetpack%20Compose%20Part%202/1_UoLVl1dbUjKh9kd4uY0ROA.png\" class=\"\" title=\"[1_UoLVl1dbUjKh9kd4uY0ROA]\">\n\n<h3 id=\"Jetpack-Compose의-동작-원리-파악을-위한-빌드-과정-추적\"><a href=\"#Jetpack-Compose의-동작-원리-파악을-위한-빌드-과정-추적\" class=\"headerlink\" title=\"Jetpack Compose의 동작 원리 파악을 위한 빌드 과정 추적\"></a>Jetpack Compose의 동작 원리 파악을 위한 빌드 과정 추적</h3><h5 id=\"1-프로젝트-생성\"><a href=\"#1-프로젝트-생성\" class=\"headerlink\" title=\"1. 프로젝트 생성\"></a>1. 프로젝트 생성</h5><p>Compose가 내부적으로 어떻게 동작하는 지 알아보기 위해 먼저 프로젝트를 빌드해보자.</p>\n<p>빌드 후 Kotlin &gt; Byte Code &gt; Decompiled Java 순서로 변환하여 살펴볼 것이다.</p>\n<p>Android Studio Preview에서 Empty Compose Activity로 프로젝트를 생성하면 아래와 같은 샘플 코드를 얻을 수 있다.</p>\n<p>프로젝트 생성 후 임의로 Hello World로 파라미터값을 변경하였다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MainActivity</span> : <span class=\"type\">ComponentActivity</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onCreate</span><span class=\"params\">(savedInstanceState: <span class=\"type\">Bundle</span>?)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onCreate(savedInstanceState)</span><br><span class=\"line\">        setContent &#123;</span><br><span class=\"line\">            HelloWorldTheme &#123;</span><br><span class=\"line\">                <span class=\"comment\">// A surface container using the &#x27;background&#x27; color from the theme</span></span><br><span class=\"line\">                Surface(color = MaterialTheme.colors.background) &#123;</span><br><span class=\"line\">                    Greeting(<span class=\"string\">&quot;World&quot;</span>)</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Composable</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">Greeting</span><span class=\"params\">(name: <span class=\"type\">String</span>)</span></span> &#123;</span><br><span class=\"line\">    Text(text = <span class=\"string\">&quot;Hello <span class=\"variable\">$name</span>!&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Preview(showBackground = true)</span></span><br><span class=\"line\"><span class=\"meta\">@Composable</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">DefaultPreview</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    HelloWorldTheme &#123;</span><br><span class=\"line\">        Greeting(<span class=\"string\">&quot;World&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>부가적으로 <code>src</code> 폴더 내부에 <code>ui.theme</code> 패키지가 생성되고 <code>Color.kt</code>, <code>Shape.kt</code>, <code>Theme.kt</code>, <code>Type.kt</code> 파일도 생성된다.</p>\n<p>이 파일들은 필요한 경우 들여다 보도록 하자.</p>\n<p>생성 후 Preview에 아래와 같이 렌더링 된다.</p>\n<img src=\"/Team-Blog/2021/04/07/2021-04-07%20Jetpack%20Compose%20Part%202/add_002_001.png\" class=\"\" title=\"[add_002_001]\">\n\n<h5 id=\"2-MainActivity-디컴파일\"><a href=\"#2-MainActivity-디컴파일\" class=\"headerlink\" title=\"2. MainActivity 디컴파일\"></a>2. MainActivity 디컴파일</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Metadata(</span></span><br><span class=\"line\"><span class=\"meta\">   mv = &#123;1, 4, 2&#125;,</span></span><br><span class=\"line\"><span class=\"meta\">   bv = &#123;1, 0, 3&#125;,</span></span><br><span class=\"line\"><span class=\"meta\">   k = 2,</span></span><br><span class=\"line\"><span class=\"meta\">   d1 = &#123;&quot;...&quot;&#125;,</span></span><br><span class=\"line\"><span class=\"meta\">   d2 = &#123;&quot;DefaultPreview&quot;, &quot;&quot;, &quot;Greeting&quot;, &quot;name&quot;, &quot;&quot;, &quot;app_debug&quot;&#125;</span></span><br><span class=\"line\"><span class=\"meta\">)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MainActivityKt</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Composable</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">Greeting</span><span class=\"params\">(<span class=\"meta\">@NotNull</span> String name)</span> </span>&#123;</span><br><span class=\"line\">        Intrinsics.checkNotNullParameter(name, <span class=\"string\">&quot;name&quot;</span>);</span><br><span class=\"line\">        TextKt.Text-Vh6c2nE$<span class=\"keyword\">default</span>(<span class=\"string\">&quot;Hello &quot;</span> + name + <span class=\"string\">&#x27;!&#x27;</span>, </span><br><span class=\"line\">            (Modifier)<span class=\"keyword\">null</span>, </span><br><span class=\"line\">            <span class=\"number\">0L</span>, </span><br><span class=\"line\">            <span class=\"number\">0L</span>, </span><br><span class=\"line\">            (FontStyle)<span class=\"keyword\">null</span>, </span><br><span class=\"line\">            (FontWeight)<span class=\"keyword\">null</span>, </span><br><span class=\"line\">            (FontFamily)<span class=\"keyword\">null</span>, </span><br><span class=\"line\">            <span class=\"number\">0L</span>, </span><br><span class=\"line\">            (TextDecoration)<span class=\"keyword\">null</span>, </span><br><span class=\"line\">            (TextAlign)<span class=\"keyword\">null</span>, </span><br><span class=\"line\">            <span class=\"number\">0L</span>, </span><br><span class=\"line\">            (TextOverflow)<span class=\"keyword\">null</span>, </span><br><span class=\"line\">            <span class=\"keyword\">false</span>, </span><br><span class=\"line\">            <span class=\"number\">0</span>, </span><br><span class=\"line\">            (Function1)<span class=\"keyword\">null</span>, </span><br><span class=\"line\">            (TextStyle)<span class=\"keyword\">null</span>, </span><br><span class=\"line\">            <span class=\"number\">65534</span>, </span><br><span class=\"line\">            (Object)<span class=\"keyword\">null</span></span><br><span class=\"line\">        );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"meta\">@Composable</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">DefaultPreview</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      ThemeKt.HelloWorldTheme$<span class=\"keyword\">default</span>(<span class=\"keyword\">false</span>, (Function0)<span class=\"keyword\">null</span>.INSTANCE, <span class=\"number\">1</span>, (Object)<span class=\"keyword\">null</span>);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// MainActivity.java</span></span><br><span class=\"line\"><span class=\"meta\">@Metadata(</span></span><br><span class=\"line\"><span class=\"meta\">   mv = &#123;1, 4, 2&#125;,</span></span><br><span class=\"line\"><span class=\"meta\">   bv = &#123;1, 0, 3&#125;,</span></span><br><span class=\"line\"><span class=\"meta\">   k = 1,</span></span><br><span class=\"line\"><span class=\"meta\">   d1 = &#123;&quot;...&quot;&#125;,</span></span><br><span class=\"line\"><span class=\"meta\">   d2 = &#123;&quot;...&quot;&#125;</span></span><br><span class=\"line\"><span class=\"meta\">)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MainActivity</span> <span class=\"keyword\">extends</span> <span class=\"title\">ComponentActivity</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(<span class=\"meta\">@Nullable</span> Bundle savedInstanceState)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">super</span>.onCreate(savedInstanceState);</span><br><span class=\"line\">      ComponentActivityKt.setContent$<span class=\"keyword\">default</span>(<span class=\"keyword\">this</span>, (CompositionContext)<span class=\"keyword\">null</span>, (Function0)<span class=\"keyword\">null</span>.INSTANCE, <span class=\"number\">1</span>, (Object)<span class=\"keyword\">null</span>);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>ComponentActivityKt.setContent()</code>의 구현체는 아래와 같다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">fun</span> ComponentActivity.<span class=\"title\">setContent</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    parent: <span class=\"type\">CompositionContext</span>? = <span class=\"literal\">null</span>,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    content: @<span class=\"type\">Composable</span> () -&gt; <span class=\"type\">Unit</span></span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> existingComposeView = window.decorView</span><br><span class=\"line\">        .findViewById&lt;ViewGroup&gt;(android.R.id.content)</span><br><span class=\"line\">        .getChildAt(<span class=\"number\">0</span>) <span class=\"keyword\">as</span>? ComposeView</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (existingComposeView != <span class=\"literal\">null</span>) with(existingComposeView) &#123;</span><br><span class=\"line\">        setParentCompositionContext(parent)</span><br><span class=\"line\">        setContent(content)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> ComposeView(<span class=\"keyword\">this</span>).apply &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Set content and parent **before** setContentView</span></span><br><span class=\"line\">        <span class=\"comment\">// to have ComposeView create the composition on attach</span></span><br><span class=\"line\">        setParentCompositionContext(parent)</span><br><span class=\"line\">        setContent(content)</span><br><span class=\"line\">        setContentView(<span class=\"keyword\">this</span>, DefaultActivityContentLayoutParams)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>CompositionContext</code> 파라미터는 null을 그대로 넘겨주었고, <code>(Function0)null.INSTANCE, 1, (Object)null</code>의 값으로 무언가를 넘겨주는데,</p>\n<p>이 값이 <code>@Composable</code> Annotation의 구현체이다.</p>\n<p>위의 코드 흔적을 술어로 표현해보면 <strong><code>@Composable</code> 구현체를 넘겨주면 이를 기반으로 <code>ComposeView</code> 객체를 생성하여 <code>Activity</code>의 <code>setContentView()</code>에 적용한다.</strong> 가 되겠다.</p>\n<h5 id=\"3-Composable-구현체-확인\"><a href=\"#3-Composable-구현체-확인\" class=\"headerlink\" title=\"3. @Composable 구현체 확인\"></a>3. <code>@Composable</code> 구현체 확인</h5><p><code>Composable</code> Annotaion 클래스의 구현체는 아래와 같다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@MustBeDocumented</span></span><br><span class=\"line\"><span class=\"meta\">@Retention(AnnotationRetention.BINARY)</span></span><br><span class=\"line\"><span class=\"meta\">@Target(</span></span><br><span class=\"line\"><span class=\"meta\">    // function declarations</span></span><br><span class=\"line\"><span class=\"meta\">    // @Composable fun Foo()</span> &#123; ... &#125;</span><br><span class=\"line\">    <span class=\"comment\">// lambda expressions</span></span><br><span class=\"line\">    <span class=\"comment\">// val foo = @Composable &#123; ... &#125;</span></span><br><span class=\"line\">    AnnotationTarget.FUNCTION,</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// type declarations</span></span><br><span class=\"line\">    <span class=\"comment\">// var foo: @Composable () -&gt; Unit = &#123; ... &#125;</span></span><br><span class=\"line\">    <span class=\"comment\">// parameter types</span></span><br><span class=\"line\">    <span class=\"comment\">// foo: @Composable () -&gt; Unit</span></span><br><span class=\"line\">    AnnotationTarget.TYPE,</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// composable types inside of type signatures</span></span><br><span class=\"line\">    <span class=\"comment\">// foo: (@Composable () -&gt; Unit) -&gt; Unit</span></span><br><span class=\"line\">    AnnotationTarget.TYPE_PARAMETER,</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// composable property getters and setters</span></span><br><span class=\"line\">    <span class=\"comment\">// val foo: Int @Composable get() &#123; ... &#125;</span></span><br><span class=\"line\">    <span class=\"comment\">// var bar: Int</span></span><br><span class=\"line\">    <span class=\"comment\">//   @Composable get() &#123; ... &#125;</span></span><br><span class=\"line\">    AnnotationTarget.PROPERTY_GETTER</span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"keyword\">annotation</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Composable</span></span></span><br></pre></td></tr></table></figure>\n\n<p>AnnotationTarget을 통해 메서드나 Lambda 객체를 넘겨서 뷰를 조립하는 방식인데, <code>View</code>와 <code>ViewGroup</code>처럼 내부적으로 트리 구조로 실행지점에 대한 정보를 저장하고 있다.</p>\n<p>파면 팔수록 Flutter의 Widget, React Native의 Component와 유사한 느낌을 준다.</p>"},{"title":"Jetpack Compose Part 3 - Retrospect","date":"2021-04-06T18:00:00.000Z","cover":"https://androiddeepdive.github.io/Team-Blog/images/cover_jepack_compose.png","_content":"\n<article class=\"message message-immersive is-primary\">\n    <div class=\"message-body\">\n        <i class=\"fas fa-pen-fancy mr-2\"></i>Writers<br>\n        by 김남훈 @Naver<br>\n        by 배희성 @RocketPunch<br>\n        by 송시영 @SmartStudy<br>\n        by 이기정 @BankSalad\n    </div>\n</article>\n\n<!-- more -->\n\n### Jetpack Compose의 Coupling과 Cohesion\n\n비단 Android 애플리케이션뿐만 아니라, 소프트웨어를 잘 개발하기 위해 지켜야할 원칙 중 하나는 **관심사의 분리(Separation of concerns)** 라는 개념이다.\n\n흔히 복잡성을 극복하기 위해 여러가지 디자인 패턴을 적용하여 View와 Controller를 분리하기 위해 애쓰는 사람들이 많은 것도 결국 프로덕트의 복잡성을 (완전히 없앨 수는 있을까?) 최소화하기 위해서이다.\n\nCompose 또한 이 복잡성의 극복을 위해 나온 도구라고 봐도 무방할 것이다.\n\n따라서 Compose를 적용하면서 계속 머릿속에 캐시해두어야할 개념은 **Coupling** 과 **Cohesion** 이다.\n\n흔히들 커플링이 심하다라고 표현하긴 하는데, 굳이 한글로 번역하자면 각각, 어떠한 컴포넌트들간의 **결속** 과 분리된 각 모듈 내부의 **응집** 을 뜻한다고 볼 수 있다.\n\n{% asset_img add_002_002.png [add_002_002] %}\n\n> **출처** [How Cohesion and Coupling Correlate](https://blog.ttulka.com/how-cohesion-and-coupling-correlate)\n\n위의 세 그림을 아래 개념을 뜻한다.\n\n- A : Low cohesion, tight coupling\n- B : High cohesion, tight coupling\n- C : High cohesion, loose coupling\n\n결국 Compose를 잘 쓴다는 것은 UI/UX 입장에서 뷰를 잘 분리하여 재사용을 통해 우리가 개발하려는 프로덕트가 C의 구조가 되게끔 작성하는 것이다.\n\n### Compose 사용시 주의사항\n\n- 최대한 재사용성이 높게 설계되어야 한다.\n- 뷰 모델과 비지니스 모델 분리가 필요하다.\n  - 지속적으로 재사용하는데 ViewModel과 같은 비지니스 모델이 수행되면 무거워지기 때문\n  - 매개변수나 람다를 이용하자.\n- 호출 순서가 보장되지 않으므로, 각 함수는 독립적으로 설계해야 한다.\n\n### Compose의 State\n\n**remember**\n- 예약어를 통해 메모리에 단일 객체를 저장 가능하다.\n- 상위 컴포넌트가 재구성되기 전까지 상태를 가지고 있다.\n\n**Stateless**\n- Satateless Composable은 말그대로 상태값을 가지고 있지 않다.\n- 외부에서 매개변수나 람다를 통해 상태를 받아 사용한다.\n\n**Stateful**\n- 상태 값을 가지고 있는 Composable\n- `State<T>` 객체를 통해 관찰가능한 값을 가지고 있으므로 사용이 권장된다.\n- Runtime시 통합된다.\n- 이전 상태를 복원하기 위해서는 `rememberSaveable` 키워드를 사용한다.\n- `Bundle`에 데이터가 자동으로 저장된다.\n\n#### Compose Samples\n\n코드랩 뿐만 아니라 다양한 Compose 샘플들을 구글이 모아두었다.\n\n아래 링크를 참조하자.\n\n> [Github#Android Compose Samples](https://github.com/android/compose-samples)\n\n현재 작업하고 있는 뷰와 제일 유사한 것들을 통해 Compose를 이해하는 것도 하나의 방법이 될 수 있다.\n\n### 마무리하며\n\n- 뷰를 제작함에 있어서 선언형 프로그래밍은 좋은 효율을 낼 수 있을 것 같다\n  - Flutter나 SwiftUI를 사용해보면 뷰 제작 속도가 얼마나 다른지 알 수 있다. (개개인의 차이가 있을 수 있음)\n\n- 요즘 제일 많이 사용하는 MVVM 아키텍처도 적용 가능하지만 이게 적합한지는 잘 모르겠다.\n  - MVI 같은 아키텍처가 오히려 더 잘 맞을 수 있다고 생각한다.\n\n- 안드로이드에서 전혀 생각지도 못한 선언형 프로그래밍 방식을 도입할 수 있던 것이 신선하다고 생각한다.\n  - 선언형 프로그래밍도 결국 유행하지않을까?\n  - 기존에 React나 Flutter를 통해 선언형 프로그래밍을 쉽게 접했던 개발자들은 더 쉽게 안드로이드 개발을 도전해보지 않을까 싶다. \n  - 오히려 반대로 기존에 XML로 레이아웃 코드를 짜던 개발자들은 생소한 방식이라 적응하는데 시간이 꽤나 걸릴 것이다.\n\n- 다만, 아직도 alpha버전이라 바뀔 수 있는 것이 너무나도 많은 상황이다.\n  - 앞으로 좋은 예시들이 나오고, 좀 더 기존 안드로이드 개발자들이 익숙해 할만한 컴포넌트로 제공이 되면, 좀 더 많은 개발자들이 선언형 프로그래밍으로 넘어갈 수 있지 않을까 싶다.\n- 당장 기존에 있던 코드와 공존하면서 쓰기에는 여간 불편할것 같다.\n  - Flutter의 경우 선언형 프로그래밍 방식으로 렌더링을 지원하기 때문에 처음부터 개발을 선언형으로 하게되니, 굳이 이럴바에는 Flutter로 서비스를 따로 구현하는 게 낫지 않을까라는 생각이 들었다.\n\n\n## References\n\n### Members of Study\n- https://namhoon.kim/2021/03/14/android_deep_dive/001/\n- https://namhoon.kim/2021/03/21/android_deep_dive/002/\n- https://sysys.medium.com/jetpack-compose-%EC%B2%B4%ED%97%98%EA%B8%B0-8f90aff89f47\n- https://soda1127.github.io/introduce-jetpack-compose/\n\n### Official\n- [Android Developers#Jetpack Compose](https://developer.android.com/jetpack/compose/)\n- [Android Developers#Compose 이해](https://developer.android.com/jetpack/compose/mental-model?hl=ko)\n- [Android Developers#Compose Cource](https://developer.android.com/courses/pathways/compose)\n- [Android#Compose Samples](https://github.com/android/compose-samples)\n\n### Etc\n- [Understanding Jetpack Compose - part 1 of 2](https://medium.com/androiddevelopers/understanding-jetpack-compose-part-1-of-2-ca316fe39050)\n- [Understanding Jetpack Compose - part 2 of 2](https://medium.com/androiddevelopers/under-the-hood-of-jetpack-compose-part-2-of-2-37b2c20c6cdd)\n- [foso.github.io](https://foso.github.io/Jetpack-Compose-Playground/)","source":"_posts/2021-04-07 Jetpack Compose Part 3.md","raw":"---\ntitle: Jetpack Compose Part 3 - Retrospect\ndate: 2021-04-07 03:00\ncover: https://androiddeepdive.github.io/Team-Blog/images/cover_jepack_compose.png\ncategories:\n- Jetpack Compose\ntags:\n- Android\n- Jetpack\n- Compose\n---\n\n<article class=\"message message-immersive is-primary\">\n    <div class=\"message-body\">\n        <i class=\"fas fa-pen-fancy mr-2\"></i>Writers<br>\n        by 김남훈 @Naver<br>\n        by 배희성 @RocketPunch<br>\n        by 송시영 @SmartStudy<br>\n        by 이기정 @BankSalad\n    </div>\n</article>\n\n<!-- more -->\n\n### Jetpack Compose의 Coupling과 Cohesion\n\n비단 Android 애플리케이션뿐만 아니라, 소프트웨어를 잘 개발하기 위해 지켜야할 원칙 중 하나는 **관심사의 분리(Separation of concerns)** 라는 개념이다.\n\n흔히 복잡성을 극복하기 위해 여러가지 디자인 패턴을 적용하여 View와 Controller를 분리하기 위해 애쓰는 사람들이 많은 것도 결국 프로덕트의 복잡성을 (완전히 없앨 수는 있을까?) 최소화하기 위해서이다.\n\nCompose 또한 이 복잡성의 극복을 위해 나온 도구라고 봐도 무방할 것이다.\n\n따라서 Compose를 적용하면서 계속 머릿속에 캐시해두어야할 개념은 **Coupling** 과 **Cohesion** 이다.\n\n흔히들 커플링이 심하다라고 표현하긴 하는데, 굳이 한글로 번역하자면 각각, 어떠한 컴포넌트들간의 **결속** 과 분리된 각 모듈 내부의 **응집** 을 뜻한다고 볼 수 있다.\n\n{% asset_img add_002_002.png [add_002_002] %}\n\n> **출처** [How Cohesion and Coupling Correlate](https://blog.ttulka.com/how-cohesion-and-coupling-correlate)\n\n위의 세 그림을 아래 개념을 뜻한다.\n\n- A : Low cohesion, tight coupling\n- B : High cohesion, tight coupling\n- C : High cohesion, loose coupling\n\n결국 Compose를 잘 쓴다는 것은 UI/UX 입장에서 뷰를 잘 분리하여 재사용을 통해 우리가 개발하려는 프로덕트가 C의 구조가 되게끔 작성하는 것이다.\n\n### Compose 사용시 주의사항\n\n- 최대한 재사용성이 높게 설계되어야 한다.\n- 뷰 모델과 비지니스 모델 분리가 필요하다.\n  - 지속적으로 재사용하는데 ViewModel과 같은 비지니스 모델이 수행되면 무거워지기 때문\n  - 매개변수나 람다를 이용하자.\n- 호출 순서가 보장되지 않으므로, 각 함수는 독립적으로 설계해야 한다.\n\n### Compose의 State\n\n**remember**\n- 예약어를 통해 메모리에 단일 객체를 저장 가능하다.\n- 상위 컴포넌트가 재구성되기 전까지 상태를 가지고 있다.\n\n**Stateless**\n- Satateless Composable은 말그대로 상태값을 가지고 있지 않다.\n- 외부에서 매개변수나 람다를 통해 상태를 받아 사용한다.\n\n**Stateful**\n- 상태 값을 가지고 있는 Composable\n- `State<T>` 객체를 통해 관찰가능한 값을 가지고 있으므로 사용이 권장된다.\n- Runtime시 통합된다.\n- 이전 상태를 복원하기 위해서는 `rememberSaveable` 키워드를 사용한다.\n- `Bundle`에 데이터가 자동으로 저장된다.\n\n#### Compose Samples\n\n코드랩 뿐만 아니라 다양한 Compose 샘플들을 구글이 모아두었다.\n\n아래 링크를 참조하자.\n\n> [Github#Android Compose Samples](https://github.com/android/compose-samples)\n\n현재 작업하고 있는 뷰와 제일 유사한 것들을 통해 Compose를 이해하는 것도 하나의 방법이 될 수 있다.\n\n### 마무리하며\n\n- 뷰를 제작함에 있어서 선언형 프로그래밍은 좋은 효율을 낼 수 있을 것 같다\n  - Flutter나 SwiftUI를 사용해보면 뷰 제작 속도가 얼마나 다른지 알 수 있다. (개개인의 차이가 있을 수 있음)\n\n- 요즘 제일 많이 사용하는 MVVM 아키텍처도 적용 가능하지만 이게 적합한지는 잘 모르겠다.\n  - MVI 같은 아키텍처가 오히려 더 잘 맞을 수 있다고 생각한다.\n\n- 안드로이드에서 전혀 생각지도 못한 선언형 프로그래밍 방식을 도입할 수 있던 것이 신선하다고 생각한다.\n  - 선언형 프로그래밍도 결국 유행하지않을까?\n  - 기존에 React나 Flutter를 통해 선언형 프로그래밍을 쉽게 접했던 개발자들은 더 쉽게 안드로이드 개발을 도전해보지 않을까 싶다. \n  - 오히려 반대로 기존에 XML로 레이아웃 코드를 짜던 개발자들은 생소한 방식이라 적응하는데 시간이 꽤나 걸릴 것이다.\n\n- 다만, 아직도 alpha버전이라 바뀔 수 있는 것이 너무나도 많은 상황이다.\n  - 앞으로 좋은 예시들이 나오고, 좀 더 기존 안드로이드 개발자들이 익숙해 할만한 컴포넌트로 제공이 되면, 좀 더 많은 개발자들이 선언형 프로그래밍으로 넘어갈 수 있지 않을까 싶다.\n- 당장 기존에 있던 코드와 공존하면서 쓰기에는 여간 불편할것 같다.\n  - Flutter의 경우 선언형 프로그래밍 방식으로 렌더링을 지원하기 때문에 처음부터 개발을 선언형으로 하게되니, 굳이 이럴바에는 Flutter로 서비스를 따로 구현하는 게 낫지 않을까라는 생각이 들었다.\n\n\n## References\n\n### Members of Study\n- https://namhoon.kim/2021/03/14/android_deep_dive/001/\n- https://namhoon.kim/2021/03/21/android_deep_dive/002/\n- https://sysys.medium.com/jetpack-compose-%EC%B2%B4%ED%97%98%EA%B8%B0-8f90aff89f47\n- https://soda1127.github.io/introduce-jetpack-compose/\n\n### Official\n- [Android Developers#Jetpack Compose](https://developer.android.com/jetpack/compose/)\n- [Android Developers#Compose 이해](https://developer.android.com/jetpack/compose/mental-model?hl=ko)\n- [Android Developers#Compose Cource](https://developer.android.com/courses/pathways/compose)\n- [Android#Compose Samples](https://github.com/android/compose-samples)\n\n### Etc\n- [Understanding Jetpack Compose - part 1 of 2](https://medium.com/androiddevelopers/understanding-jetpack-compose-part-1-of-2-ca316fe39050)\n- [Understanding Jetpack Compose - part 2 of 2](https://medium.com/androiddevelopers/under-the-hood-of-jetpack-compose-part-2-of-2-37b2c20c6cdd)\n- [foso.github.io](https://foso.github.io/Jetpack-Compose-Playground/)","slug":"2021-04-07 Jetpack Compose Part 3","published":1,"updated":"2021-07-25T07:18:42.912Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cksagj7kw00043lre9kn363in","content":"<article class=\"message message-immersive is-primary\">\n    <div class=\"message-body\">\n        <i class=\"fas fa-pen-fancy mr-2\"></i>Writers<br>\n        by 김남훈 @Naver<br>\n        by 배희성 @RocketPunch<br>\n        by 송시영 @SmartStudy<br>\n        by 이기정 @BankSalad\n    </div>\n</article>\n\n<span id=\"more\"></span>\n\n<h3 id=\"Jetpack-Compose의-Coupling과-Cohesion\"><a href=\"#Jetpack-Compose의-Coupling과-Cohesion\" class=\"headerlink\" title=\"Jetpack Compose의 Coupling과 Cohesion\"></a>Jetpack Compose의 Coupling과 Cohesion</h3><p>비단 Android 애플리케이션뿐만 아니라, 소프트웨어를 잘 개발하기 위해 지켜야할 원칙 중 하나는 <strong>관심사의 분리(Separation of concerns)</strong> 라는 개념이다.</p>\n<p>흔히 복잡성을 극복하기 위해 여러가지 디자인 패턴을 적용하여 View와 Controller를 분리하기 위해 애쓰는 사람들이 많은 것도 결국 프로덕트의 복잡성을 (완전히 없앨 수는 있을까?) 최소화하기 위해서이다.</p>\n<p>Compose 또한 이 복잡성의 극복을 위해 나온 도구라고 봐도 무방할 것이다.</p>\n<p>따라서 Compose를 적용하면서 계속 머릿속에 캐시해두어야할 개념은 <strong>Coupling</strong> 과 <strong>Cohesion</strong> 이다.</p>\n<p>흔히들 커플링이 심하다라고 표현하긴 하는데, 굳이 한글로 번역하자면 각각, 어떠한 컴포넌트들간의 <strong>결속</strong> 과 분리된 각 모듈 내부의 <strong>응집</strong> 을 뜻한다고 볼 수 있다.</p>\n<img src=\"/Team-Blog/2021/04/07/2021-04-07%20Jetpack%20Compose%20Part%203/add_002_002.png\" class=\"\" title=\"[add_002_002]\">\n\n<blockquote>\n<p><strong>출처</strong> <a href=\"https://blog.ttulka.com/how-cohesion-and-coupling-correlate\">How Cohesion and Coupling Correlate</a></p>\n</blockquote>\n<p>위의 세 그림을 아래 개념을 뜻한다.</p>\n<ul>\n<li>A : Low cohesion, tight coupling</li>\n<li>B : High cohesion, tight coupling</li>\n<li>C : High cohesion, loose coupling</li>\n</ul>\n<p>결국 Compose를 잘 쓴다는 것은 UI/UX 입장에서 뷰를 잘 분리하여 재사용을 통해 우리가 개발하려는 프로덕트가 C의 구조가 되게끔 작성하는 것이다.</p>\n<h3 id=\"Compose-사용시-주의사항\"><a href=\"#Compose-사용시-주의사항\" class=\"headerlink\" title=\"Compose 사용시 주의사항\"></a>Compose 사용시 주의사항</h3><ul>\n<li>최대한 재사용성이 높게 설계되어야 한다.</li>\n<li>뷰 모델과 비지니스 모델 분리가 필요하다.<ul>\n<li>지속적으로 재사용하는데 ViewModel과 같은 비지니스 모델이 수행되면 무거워지기 때문</li>\n<li>매개변수나 람다를 이용하자.</li>\n</ul>\n</li>\n<li>호출 순서가 보장되지 않으므로, 각 함수는 독립적으로 설계해야 한다.</li>\n</ul>\n<h3 id=\"Compose의-State\"><a href=\"#Compose의-State\" class=\"headerlink\" title=\"Compose의 State\"></a>Compose의 State</h3><p><strong>remember</strong></p>\n<ul>\n<li>예약어를 통해 메모리에 단일 객체를 저장 가능하다.</li>\n<li>상위 컴포넌트가 재구성되기 전까지 상태를 가지고 있다.</li>\n</ul>\n<p><strong>Stateless</strong></p>\n<ul>\n<li>Satateless Composable은 말그대로 상태값을 가지고 있지 않다.</li>\n<li>외부에서 매개변수나 람다를 통해 상태를 받아 사용한다.</li>\n</ul>\n<p><strong>Stateful</strong></p>\n<ul>\n<li>상태 값을 가지고 있는 Composable</li>\n<li><code>State&lt;T&gt;</code> 객체를 통해 관찰가능한 값을 가지고 있으므로 사용이 권장된다.</li>\n<li>Runtime시 통합된다.</li>\n<li>이전 상태를 복원하기 위해서는 <code>rememberSaveable</code> 키워드를 사용한다.</li>\n<li><code>Bundle</code>에 데이터가 자동으로 저장된다.</li>\n</ul>\n<h4 id=\"Compose-Samples\"><a href=\"#Compose-Samples\" class=\"headerlink\" title=\"Compose Samples\"></a>Compose Samples</h4><p>코드랩 뿐만 아니라 다양한 Compose 샘플들을 구글이 모아두었다.</p>\n<p>아래 링크를 참조하자.</p>\n<blockquote>\n<p><a href=\"https://github.com/android/compose-samples\">Github#Android Compose Samples</a></p>\n</blockquote>\n<p>현재 작업하고 있는 뷰와 제일 유사한 것들을 통해 Compose를 이해하는 것도 하나의 방법이 될 수 있다.</p>\n<h3 id=\"마무리하며\"><a href=\"#마무리하며\" class=\"headerlink\" title=\"마무리하며\"></a>마무리하며</h3><ul>\n<li><p>뷰를 제작함에 있어서 선언형 프로그래밍은 좋은 효율을 낼 수 있을 것 같다</p>\n<ul>\n<li>Flutter나 SwiftUI를 사용해보면 뷰 제작 속도가 얼마나 다른지 알 수 있다. (개개인의 차이가 있을 수 있음)</li>\n</ul>\n</li>\n<li><p>요즘 제일 많이 사용하는 MVVM 아키텍처도 적용 가능하지만 이게 적합한지는 잘 모르겠다.</p>\n<ul>\n<li>MVI 같은 아키텍처가 오히려 더 잘 맞을 수 있다고 생각한다.</li>\n</ul>\n</li>\n<li><p>안드로이드에서 전혀 생각지도 못한 선언형 프로그래밍 방식을 도입할 수 있던 것이 신선하다고 생각한다.</p>\n<ul>\n<li>선언형 프로그래밍도 결국 유행하지않을까?</li>\n<li>기존에 React나 Flutter를 통해 선언형 프로그래밍을 쉽게 접했던 개발자들은 더 쉽게 안드로이드 개발을 도전해보지 않을까 싶다. </li>\n<li>오히려 반대로 기존에 XML로 레이아웃 코드를 짜던 개발자들은 생소한 방식이라 적응하는데 시간이 꽤나 걸릴 것이다.</li>\n</ul>\n</li>\n<li><p>다만, 아직도 alpha버전이라 바뀔 수 있는 것이 너무나도 많은 상황이다.</p>\n<ul>\n<li>앞으로 좋은 예시들이 나오고, 좀 더 기존 안드로이드 개발자들이 익숙해 할만한 컴포넌트로 제공이 되면, 좀 더 많은 개발자들이 선언형 프로그래밍으로 넘어갈 수 있지 않을까 싶다.</li>\n</ul>\n</li>\n<li><p>당장 기존에 있던 코드와 공존하면서 쓰기에는 여간 불편할것 같다.</p>\n<ul>\n<li>Flutter의 경우 선언형 프로그래밍 방식으로 렌더링을 지원하기 때문에 처음부터 개발을 선언형으로 하게되니, 굳이 이럴바에는 Flutter로 서비스를 따로 구현하는 게 낫지 않을까라는 생각이 들었다.</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"References\"><a href=\"#References\" class=\"headerlink\" title=\"References\"></a>References</h2><h3 id=\"Members-of-Study\"><a href=\"#Members-of-Study\" class=\"headerlink\" title=\"Members of Study\"></a>Members of Study</h3><ul>\n<li><a href=\"https://namhoon.kim/2021/03/14/android_deep_dive/001/\">https://namhoon.kim/2021/03/14/android_deep_dive/001/</a></li>\n<li><a href=\"https://namhoon.kim/2021/03/21/android_deep_dive/002/\">https://namhoon.kim/2021/03/21/android_deep_dive/002/</a></li>\n<li><a href=\"https://sysys.medium.com/jetpack-compose-%EC%B2%B4%ED%97%98%EA%B8%B0-8f90aff89f47\">https://sysys.medium.com/jetpack-compose-%EC%B2%B4%ED%97%98%EA%B8%B0-8f90aff89f47</a></li>\n<li><a href=\"https://soda1127.github.io/introduce-jetpack-compose/\">https://soda1127.github.io/introduce-jetpack-compose/</a></li>\n</ul>\n<h3 id=\"Official\"><a href=\"#Official\" class=\"headerlink\" title=\"Official\"></a>Official</h3><ul>\n<li><a href=\"https://developer.android.com/jetpack/compose/\">Android Developers#Jetpack Compose</a></li>\n<li><a href=\"https://developer.android.com/jetpack/compose/mental-model?hl=ko\">Android Developers#Compose 이해</a></li>\n<li><a href=\"https://developer.android.com/courses/pathways/compose\">Android Developers#Compose Cource</a></li>\n<li><a href=\"https://github.com/android/compose-samples\">Android#Compose Samples</a></li>\n</ul>\n<h3 id=\"Etc\"><a href=\"#Etc\" class=\"headerlink\" title=\"Etc\"></a>Etc</h3><ul>\n<li><a href=\"https://medium.com/androiddevelopers/understanding-jetpack-compose-part-1-of-2-ca316fe39050\">Understanding Jetpack Compose - part 1 of 2</a></li>\n<li><a href=\"https://medium.com/androiddevelopers/under-the-hood-of-jetpack-compose-part-2-of-2-37b2c20c6cdd\">Understanding Jetpack Compose - part 2 of 2</a></li>\n<li><a href=\"https://foso.github.io/Jetpack-Compose-Playground/\">foso.github.io</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<article class=\"message message-immersive is-primary\">\n    <div class=\"message-body\">\n        <i class=\"fas fa-pen-fancy mr-2\"></i>Writers<br>\n        by 김남훈 @Naver<br>\n        by 배희성 @RocketPunch<br>\n        by 송시영 @SmartStudy<br>\n        by 이기정 @BankSalad\n    </div>\n</article>","more":"<h3 id=\"Jetpack-Compose의-Coupling과-Cohesion\"><a href=\"#Jetpack-Compose의-Coupling과-Cohesion\" class=\"headerlink\" title=\"Jetpack Compose의 Coupling과 Cohesion\"></a>Jetpack Compose의 Coupling과 Cohesion</h3><p>비단 Android 애플리케이션뿐만 아니라, 소프트웨어를 잘 개발하기 위해 지켜야할 원칙 중 하나는 <strong>관심사의 분리(Separation of concerns)</strong> 라는 개념이다.</p>\n<p>흔히 복잡성을 극복하기 위해 여러가지 디자인 패턴을 적용하여 View와 Controller를 분리하기 위해 애쓰는 사람들이 많은 것도 결국 프로덕트의 복잡성을 (완전히 없앨 수는 있을까?) 최소화하기 위해서이다.</p>\n<p>Compose 또한 이 복잡성의 극복을 위해 나온 도구라고 봐도 무방할 것이다.</p>\n<p>따라서 Compose를 적용하면서 계속 머릿속에 캐시해두어야할 개념은 <strong>Coupling</strong> 과 <strong>Cohesion</strong> 이다.</p>\n<p>흔히들 커플링이 심하다라고 표현하긴 하는데, 굳이 한글로 번역하자면 각각, 어떠한 컴포넌트들간의 <strong>결속</strong> 과 분리된 각 모듈 내부의 <strong>응집</strong> 을 뜻한다고 볼 수 있다.</p>\n<img src=\"/Team-Blog/2021/04/07/2021-04-07%20Jetpack%20Compose%20Part%203/add_002_002.png\" class=\"\" title=\"[add_002_002]\">\n\n<blockquote>\n<p><strong>출처</strong> <a href=\"https://blog.ttulka.com/how-cohesion-and-coupling-correlate\">How Cohesion and Coupling Correlate</a></p>\n</blockquote>\n<p>위의 세 그림을 아래 개념을 뜻한다.</p>\n<ul>\n<li>A : Low cohesion, tight coupling</li>\n<li>B : High cohesion, tight coupling</li>\n<li>C : High cohesion, loose coupling</li>\n</ul>\n<p>결국 Compose를 잘 쓴다는 것은 UI/UX 입장에서 뷰를 잘 분리하여 재사용을 통해 우리가 개발하려는 프로덕트가 C의 구조가 되게끔 작성하는 것이다.</p>\n<h3 id=\"Compose-사용시-주의사항\"><a href=\"#Compose-사용시-주의사항\" class=\"headerlink\" title=\"Compose 사용시 주의사항\"></a>Compose 사용시 주의사항</h3><ul>\n<li>최대한 재사용성이 높게 설계되어야 한다.</li>\n<li>뷰 모델과 비지니스 모델 분리가 필요하다.<ul>\n<li>지속적으로 재사용하는데 ViewModel과 같은 비지니스 모델이 수행되면 무거워지기 때문</li>\n<li>매개변수나 람다를 이용하자.</li>\n</ul>\n</li>\n<li>호출 순서가 보장되지 않으므로, 각 함수는 독립적으로 설계해야 한다.</li>\n</ul>\n<h3 id=\"Compose의-State\"><a href=\"#Compose의-State\" class=\"headerlink\" title=\"Compose의 State\"></a>Compose의 State</h3><p><strong>remember</strong></p>\n<ul>\n<li>예약어를 통해 메모리에 단일 객체를 저장 가능하다.</li>\n<li>상위 컴포넌트가 재구성되기 전까지 상태를 가지고 있다.</li>\n</ul>\n<p><strong>Stateless</strong></p>\n<ul>\n<li>Satateless Composable은 말그대로 상태값을 가지고 있지 않다.</li>\n<li>외부에서 매개변수나 람다를 통해 상태를 받아 사용한다.</li>\n</ul>\n<p><strong>Stateful</strong></p>\n<ul>\n<li>상태 값을 가지고 있는 Composable</li>\n<li><code>State&lt;T&gt;</code> 객체를 통해 관찰가능한 값을 가지고 있으므로 사용이 권장된다.</li>\n<li>Runtime시 통합된다.</li>\n<li>이전 상태를 복원하기 위해서는 <code>rememberSaveable</code> 키워드를 사용한다.</li>\n<li><code>Bundle</code>에 데이터가 자동으로 저장된다.</li>\n</ul>\n<h4 id=\"Compose-Samples\"><a href=\"#Compose-Samples\" class=\"headerlink\" title=\"Compose Samples\"></a>Compose Samples</h4><p>코드랩 뿐만 아니라 다양한 Compose 샘플들을 구글이 모아두었다.</p>\n<p>아래 링크를 참조하자.</p>\n<blockquote>\n<p><a href=\"https://github.com/android/compose-samples\">Github#Android Compose Samples</a></p>\n</blockquote>\n<p>현재 작업하고 있는 뷰와 제일 유사한 것들을 통해 Compose를 이해하는 것도 하나의 방법이 될 수 있다.</p>\n<h3 id=\"마무리하며\"><a href=\"#마무리하며\" class=\"headerlink\" title=\"마무리하며\"></a>마무리하며</h3><ul>\n<li><p>뷰를 제작함에 있어서 선언형 프로그래밍은 좋은 효율을 낼 수 있을 것 같다</p>\n<ul>\n<li>Flutter나 SwiftUI를 사용해보면 뷰 제작 속도가 얼마나 다른지 알 수 있다. (개개인의 차이가 있을 수 있음)</li>\n</ul>\n</li>\n<li><p>요즘 제일 많이 사용하는 MVVM 아키텍처도 적용 가능하지만 이게 적합한지는 잘 모르겠다.</p>\n<ul>\n<li>MVI 같은 아키텍처가 오히려 더 잘 맞을 수 있다고 생각한다.</li>\n</ul>\n</li>\n<li><p>안드로이드에서 전혀 생각지도 못한 선언형 프로그래밍 방식을 도입할 수 있던 것이 신선하다고 생각한다.</p>\n<ul>\n<li>선언형 프로그래밍도 결국 유행하지않을까?</li>\n<li>기존에 React나 Flutter를 통해 선언형 프로그래밍을 쉽게 접했던 개발자들은 더 쉽게 안드로이드 개발을 도전해보지 않을까 싶다. </li>\n<li>오히려 반대로 기존에 XML로 레이아웃 코드를 짜던 개발자들은 생소한 방식이라 적응하는데 시간이 꽤나 걸릴 것이다.</li>\n</ul>\n</li>\n<li><p>다만, 아직도 alpha버전이라 바뀔 수 있는 것이 너무나도 많은 상황이다.</p>\n<ul>\n<li>앞으로 좋은 예시들이 나오고, 좀 더 기존 안드로이드 개발자들이 익숙해 할만한 컴포넌트로 제공이 되면, 좀 더 많은 개발자들이 선언형 프로그래밍으로 넘어갈 수 있지 않을까 싶다.</li>\n</ul>\n</li>\n<li><p>당장 기존에 있던 코드와 공존하면서 쓰기에는 여간 불편할것 같다.</p>\n<ul>\n<li>Flutter의 경우 선언형 프로그래밍 방식으로 렌더링을 지원하기 때문에 처음부터 개발을 선언형으로 하게되니, 굳이 이럴바에는 Flutter로 서비스를 따로 구현하는 게 낫지 않을까라는 생각이 들었다.</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"References\"><a href=\"#References\" class=\"headerlink\" title=\"References\"></a>References</h2><h3 id=\"Members-of-Study\"><a href=\"#Members-of-Study\" class=\"headerlink\" title=\"Members of Study\"></a>Members of Study</h3><ul>\n<li><a href=\"https://namhoon.kim/2021/03/14/android_deep_dive/001/\">https://namhoon.kim/2021/03/14/android_deep_dive/001/</a></li>\n<li><a href=\"https://namhoon.kim/2021/03/21/android_deep_dive/002/\">https://namhoon.kim/2021/03/21/android_deep_dive/002/</a></li>\n<li><a href=\"https://sysys.medium.com/jetpack-compose-%EC%B2%B4%ED%97%98%EA%B8%B0-8f90aff89f47\">https://sysys.medium.com/jetpack-compose-%EC%B2%B4%ED%97%98%EA%B8%B0-8f90aff89f47</a></li>\n<li><a href=\"https://soda1127.github.io/introduce-jetpack-compose/\">https://soda1127.github.io/introduce-jetpack-compose/</a></li>\n</ul>\n<h3 id=\"Official\"><a href=\"#Official\" class=\"headerlink\" title=\"Official\"></a>Official</h3><ul>\n<li><a href=\"https://developer.android.com/jetpack/compose/\">Android Developers#Jetpack Compose</a></li>\n<li><a href=\"https://developer.android.com/jetpack/compose/mental-model?hl=ko\">Android Developers#Compose 이해</a></li>\n<li><a href=\"https://developer.android.com/courses/pathways/compose\">Android Developers#Compose Cource</a></li>\n<li><a href=\"https://github.com/android/compose-samples\">Android#Compose Samples</a></li>\n</ul>\n<h3 id=\"Etc\"><a href=\"#Etc\" class=\"headerlink\" title=\"Etc\"></a>Etc</h3><ul>\n<li><a href=\"https://medium.com/androiddevelopers/understanding-jetpack-compose-part-1-of-2-ca316fe39050\">Understanding Jetpack Compose - part 1 of 2</a></li>\n<li><a href=\"https://medium.com/androiddevelopers/under-the-hood-of-jetpack-compose-part-2-of-2-37b2c20c6cdd\">Understanding Jetpack Compose - part 2 of 2</a></li>\n<li><a href=\"https://foso.github.io/Jetpack-Compose-Playground/\">foso.github.io</a></li>\n</ul>"},{"title":"Introduce Android UI Rendering Principle and View Optimization Part 1","date":"2021-05-18T16:00:00.000Z","cover":"https://androiddeepdive.github.io/Team-Blog/images/cover_ui_rendering.png","_content":"\n<article class=\"message message-immersive is-primary\">\n    <div class=\"message-body\">\n        <i class=\"fas fa-pen-fancy mr-2\"></i>Writers<br>\n        by 김남훈 @Naver<br>\n        by 배희성 @RocketPunch<br>\n        by 송시영 @SmartStudy<br>\n        by 이기정 @BankSalad<br>\n        by 정세희 @BankSalad<br>\n        by 최소영 @BankSalad\n    </div>\n</article>\n\n\n<!-- more -->\n\n우리는 안드로이드 개발자로 있으면서 기본적인 것들을 놓치곤한다. 안드로이드에서 가장 중요한것은 사용자에게 보여지는 UI와 UX이다. 이를 위해서 안드로이드 개발자가 해야할 일은 UI를 이쁘게 요구사항에 맞게 그리고, 지연없는 UI로딩을 통해 UI를 그리는 것이다.\n\n글을 작성하다 보니 문득 든 생각이 있었다. 과연 우리가 안드로이드에서 UI를 그릴 때 정확하게 방법을 알고 View를 그리는 코드를 작성하고 있었을까? 나 스스로도 그렇지 않다라는 생각이 들었고, 궁금증이 생겨 ADD 멤버분들과 함께 글을 정리해보았다.\n\n## Android View\n\n안드로이드 개발자라면 한번쯤은 들어봤을 법한, 컴포넌트들이 있다. 바로 아래의 녀석들이다.\n\n{% asset_img 7AGranC.png [Android Views] %}\n\n안드로이드의 다양한 컴포넌트들은 다음과 같이 **View**라는 녀석을 상속받아서 만들어졌다. \n\n\n\n### View & ViewGroup\n\n간단히 개념만 잡고 넘어가보도록 해보자. 안드로이드에서 화면을 나누는 두가지 부류는 View와 ViewGroup 두가지로 나눌 수 있다.\n\n{% asset_img EzHZMUm.png [View & ViewGroup] %}\n\n**View**는 Activity, 즉 한 화면에서 화면을 구성하는 최소 단위의 개념이다. 또다른 말로는 위젯이라고 하는데, 이 View를 상속받아 구현되는 수많은 요소들이 존재한다. 대표적으로 ImageView, TextView, Button과 같은 녀석이 있다. 위젯이나 노티피케이션 위젯과 같이 사용성이 특수한 경우 RemoteView를 이용하여 구현을 해야하는 경우도 있는데, 여기서는 이에 대한 설명은 생략하겠다.\n\n**ViewGroup**은 View를 상속받아 구현된 클래스이다. 다른말로는 레이아웃이라고 하며, View를 N개 담을 수 있는 녀석이다. 대표적으로 LinearLayout, FrameLayout, RelativeLayout, ConsraintLayout이 있다.\n\n이러한 방식으로 View, ViewGroup은 Java, 또는 Kotlin코드로 구성될 수 있지만, 더 쉬운 방법으로 Mark-Up 랭귀지를 이용하여 구성도 가능하다. 안드로이드 프로그래밍에서는 XML이라는 마크업 랭귀지를 이용하는데, 결국 이도 XML Parser를 통해 파싱되어 Java코드로 변환되어진다.\n\n안드로이드 개발자들은 어플리케이션의 좋은 성능을 낼 수 있는 방법과, 올바른 방법으로 개발을 하기 위해서라도 View가 그려지는 과정과 생명주기에 대해 잘 알고 있어야 한다. 이를 위해서 먼저 View가 어떤 생명주기를 갖는지 보도록하자.\n\n\n\n## View Life-Cycle\n\n상용화 하는 어플리케이션을 만들수록, 우리가 만들어나가는 View는 고도화 될 필요가 있다. 특히 View, ViewGroup을 기반으로 한 컴포넌트를 구성하게 될 때, 우리는 `커스텀 뷰`라는 것을만들게 된다. 커스텀 뷰를 만들게 될 때, 만들면 만들수록 점점 뷰를 그려지는 방식은 복잡해지고, 성능적인 부분을 충족하기 위해 최적화할 수 있는 방법을 고민해야한다. 이를 위해서는 View의 생명주기에 대해서도 잘 알고 있어야 한다.\n\n안드로이드 컴포넌트, Fragment와 마찬가지로 View도 생명주기를 갖고있다.\n\nView의 생명주기는 아래와 같이 도식화 하여 표현 가능하다,\n\n\n{% asset_img qu5Mr6x.png [View Life Cycle] %}\n\n\n생명주기에 대해 몇 가지 특징적으로 나눌 수 있는 부분이 있다.\n\n\n\n### Constructors\n\nProgrammatically하게 View를 생성하는 방법이다. View를 생성하는 방법은 여러가지가 존재하지만, 가장 직관적인 방법 중 하나이다.\n\n생성자의 종류는 여러가지가 존재한다.\n\n- `View(Context context) `\n- `View(Context context, @Nullable AttributeSet attrs) `\n- `View(Context context, @Nullable AttributeSet attrs, int defStyleAttr) `\n- `View(Context context, @Nullable AttributeSet attrs, int defStyleAttr, int defStyleRes)`\n\n\n\n### Attachment / Detachment\n\n- **Attachment**는 Window에서 붙었음을 의미한다.\n- **Detachment**는 Window에서 떼어졌음을 의미한다.\n\n위 동작이 수행되었음을 받을 수 있는 Callback Function으로 두가지 함수를 각각 제공한다.\n\n\n\n### onAttachedToWindow()\n\nView가 Window에 붙었을 때 호출된다. 이때부터는 View가 Active하다고 판단되며, 이때부터는 리소스 할당, 파라미터에 대한 계산, 리스너를 부착할 수 있는 준비가 된다.\n\n\n\n### onDetachedFromWindow() \n\nView가 Window에 떼어졌을 때 호출된다. Window상에서 더 이상 존재하지 않으므로, Inactive하며, 기존에 View에 할당된 리소스를 해제해주어야한다. 해당 콜백함수가 불리는 케이스로는 두가지가 있다.\n\n- ViewGroup에서 View가 제거될 때\n- Activity가 `finish()` 함수를 호출하여 Activity가 Destroyed될 때\n\n\n\n### onMeasure()\n\nView의 크기를 계산한다. ViewGroup은 하위 노드인 View에 대한 크기를 측정하고, 관계성을 파악 후 자신의 크기를 계산한다. 따라서, 하위 노드가 ViewGroup에 올바르게 붙었는지 확인해야한다.\n\n```java\n/**\n * \n * 기본적으로 View의 크기를 측정할 때는 Background의 Dimension Size를 보고 결정한다.\n * \n * 현재 계산된 크기를 비교하여 Background크기보다 작은경우, Background크기를 반환하여 크기를 반환한다.\n * @param widthMeasureSpec 부모뷰에 의해 적용된 수평 공간\n * @param heightMeasureSpec 부모뷰에 의해 적용된 수직 공간\n *\n */\nprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n  setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),\n                       getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));\n}\n```\n\n\n\n### MeasureSpec\n\nViewGroup의 하위 컴포넌트인 View에서는 크기에 대한 제약을 정하기 위해 스펙을 정하게 되는데, 이를 MeasureSpec을 통해 해결한다. MeasureSpec은 Width, Height에 대한 스펙이며, 크기와 모드로 나뉜다.\n\n그리고 세가지의 값으로 나뉜다.\n\n- **MeasureSpec.EXACTLY** : 부모뷰가 자식뷰의 정확한 크기를 결정한다. 자식뷰의 사이즈와 관계없이 주어진 경계내에서 사이즈가 결정된다.\n\n- **MeasureSpec.AT_MOST** : 자식뷰는 지정된 크기까지 원하는 만큼 커질 수 있다.\n\n- **MeasureSpec.UNSPECIFIED** : 부모뷰가 자식뷰에 제한을 두지 않기 때문에, 자식뷰는 원하는 크기가 될 수 있다.\n\n아래와 같은 코드로 체크할 수 있다.\n\n```java\n@Override\npublic void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n  int mode = MeasureSpec.getMode(heightMeasureSpec)\n    if (mode != MeasureSpec.EXACTLY) {\n      // Logic\n    }\n}\n```\n\n\n\n### onLayout()\n\n계산이 된 이후에는 onLayout 함수를 통해 계산된 View를 Window에 배치한다. \n\nView와 같은 경우 아래 코드를 기반으로 상속받아 처리한다.\n\n```java\nprotected void onLayout(boolean changed, int left, int top, int right, int bottom)\n```\n\n\n\n### onDraw()\n\nonLayout에서 View에 대한 크기 계산 및 배치가 완료되었으므로, 이를 기반으로 onDraw에서는 Canvas라는 인스턴스를 넘겨주며, 해당 Canvas 인스턴스는 DisplayList에 그릴 데이터를 담아서 넘겨준다. onDraw는 한프레임을 그리는 함수기 때문에 반복적으로 호출이된다. 특이하게 여러번 호출되고 CPU연산이 되는 곳이기 떄문에, 객체를 만들어서 사용하는 것은 금기시한다.\n\nView가 draw를 하는 기준은 두가지로 나눌 수 있다.\n\n- View의 모양이 변형이 생겼을 때 - invalidate()\n- View의 경계에 변화가 생겼을 때 - requestLayout()\n\n### Invalidate()\n\ninvalidate 함수는 직접적으로도 호출이 가능하지만, 상위에서 View에서 여러 View내에 상태가 변형이 되었을 때 호출을한다.\n\n직접 코드를 까보는 것이 아무래도 좋으니, 본인이 확인한 invalidate를 호출하는 시점을 리스트업 해본다.\n\n- **drawableStateChanged** - Background, 포커스 되었을 때 나타다는 하이라이트, Foreground Drawable에 대해 변경점을 체크하며, 상태가 존재하면 변경된 것으로 판단\n- **setDefaultFocusHighlight** - 포커스 되었을 때 하이라이트를 기본적으로 세팅해줌. 무조건 새로 그림\n- **setForeground**\n- **setScrollIndicators** - indicator의 색상과 마스크를 설정한다. 기존 마스크와 머지하고, 플래그를 체크하여 업데이트 된 경우 새로 그린다.\n- **setAutoFilled**\n- **requestAccessibilityFocus** - 포커스를 쓸 수 있는 권한을 요청할 때  View에대한 포커스에 대해서 달라진 점이 생기면 플래그로 비교하여 처리\n- **setForceDarkAllowed** - 어둡게 처리시 필요한 함수\n- **onDrawScrollBars** - 스크롤바에 움직임이 생길 시\n- **setLayerPaint** - 색상에 대한 변형이 있을 때 처리한다. (alpha, Xfermode, colorFilter)\n\n### requestLayout()\n\n뷰의 경계가 변경되면 무조건 호출돼야하는 함수이다. 이를 통해 재 계산을 거쳐 onMeasure => onLayout을 거친다.\n\n## View State Save/Restore\n\nView는 Activity의 상태에 따라 상태를 저장/복원해야 할 필요가있다. 이를 위한 두가지의 함수를 제공한다.\n\n### onSaveInstanceState() -> Parcelable\n\n상태를 저장하기 위한 함수에서는 상태를 저장할 때 각 View에 대한 고유 ID를 필요로한다. 저장을 할때는 Bundle 인스턴스를 생성하여 저장하면 된다.\n\nBundle은 Parcelable을 구현한 클래스로, 적절하게 저장하여 처리할 수 있다.\n\n아래 코드를 참고하자.\n\n```java\n@Override\npublic Parcelable onSaveInstanceState() {\n  Bundle bundle = new Bundle();\n  // The vars you want to save - in this instance a string and a boolean\n  String someString = \"something\";\n  boolean someBoolean = true;\n  State state = new State(super.onSaveInstanceState(), someString, someBoolean);\n  bundle.putParcelable(State.STATE, state);\n  return bundle;\n}\n```\n\nState라는 녀석이 보이는데, 해당 State는 직접 구현해주어야 하는 클래스가 될 수 있다. View에대한 상태를 저장할 수 있는 어떤것이든 상관없다.\n\n### onRestoreInstanceState(Parcelable state)\n\n해당함수를 오버라이딩하면 다시 Paracleable로 된 인스턴스를 받아서 처리가 가능하다. Parcelable을 그대로 쓸수는 없으니, 구현체에 해당하는 인스턴스로 캐스팅하여 처리하면 된다.\n\n아래는 예시이다.\n\n```java\n@Override\npublic void onRestoreInstanceState(Parcelable state) {\n  if (state instanceof Bundle) {\n    Bundle bundle = (Bundle) state;\n    State customViewState = (State) bundle.getParcelable(State.STATE);\n    // The vars you saved - do whatever you want with them\n    String someString = customViewState.getText();\n    boolean someBoolean = customViewState.isSomethingShowing());\n    super.onRestoreInstanceState(customViewState.getSuperState());\n    return;\n  }\n  // Stops a bug with the wrong state being passed to the super\n  super.onRestoreInstanceState(BaseSavedState.EMPTY_STATE); \n}\n```\n\n\n\n## View가 그려지는 순서\n\nView가 렌더링 될 때, 상위수준의 `ViewGroup` 에서부터 하위 자식인 `View` 로 내려가면서 `Measure -> Layout -> Draw` 를 거치게 된다.\n\n### Measure Pass\n\n측정 패스는 measure(int, int) 로 구현되며 뷰 트리의 탑-다운으로 순회한다. 각 뷰는 트리를 재귀하는 동안 측정한 수치를 트리 아래로 보낸다.\n\n측정이 모두 끝나면 모든 뷰는 측정한 값을 가지게 된다. 두번째 단계 또한 탑-다운으로 layout(int, int, int) 에서 일어난다. 각각의 부모는 측정단계에서 계산된 사이즈를 사용해서 자신의 모든 자식을 배치한다.\n\nView 의 크기는 2가지로 정의될 수 있다.\n\n- **measured width & measured height** : 뷰가 부모뷰 크기의 범위 내에서 가지고 싶어하는 너비와 높이이다.\n- **drawing width & drawing height** : 뷰의 실제 너비와 높이로 뷰를 그리기 위해서 사용한다.\n\nView의 Padding, Margin 등을 고려하면 원하는 크기에서 Padding 및 Margin 값을 빼야 하기 때문에 Measured Width, Measured Height 는 Drawing Width, Drawing Height 와 다를 수 있다.\n\n\n\n### Layout Pass\n\n레이아웃을 시작하려면, requestLayout() 를 호출한다. 일반적으로 현재 범위내에 더이상 맞지 않을때 자체적으로 뷰에 의해 호출된다.  이 과정에서도 top-down 형식의 탐색이 일어나게 되는데, 이 때는 각각의 ViewGroup이 Measure 단계에서 측정된 크기를 이용해서 하위속성들의 위치를 결정한다.\n\n\n\n### Draw Pass\n\nGPU에게 명령을 내려주는 단계이다. 그려야 할 객체들의 리스트를 GPU에게 보내기 위해 View Tree에서 각 객체의 대한 Canvas 객체가 생성된다. 이 때, 이전 1,2단계를 거쳐 결정된 객체들의 크기와 위치에 대한 정보가 들어가게 된다.\n\n만약 View가 변할 때, 시스템에게 알려주기 위한 2가지 방법이 존재하는데, `Invaliadate()`가 호출 될 때에는 draw부터 다시 작업이 시행되고, `requestLayout()`이 호출될 때에는 measure -> layout -> draw 단계를 다시 거치게 된다.\n\n\n\n코드로 보면서 어떤식으로 View가 그려지는지 한번 보도록하자.\n\n\n\n### 실험을 통한 View Rendering Process 관찰\n\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<androidx.constraintlayout.widget.ConstraintLayout\n    android:id=\"@+id/root1\"\n    xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    xmlns:tools=\"http://schemas.android.com/tools\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    tools:context=\".MainActivity\">\n\n    <androidx.constraintlayout.widget.ConstraintLayout\n        android:id=\"@+id/constraintContainer2\"\n        android:layout_width=\"400dp\"\n        android:layout_height=\"400dp\"\n        android:background=\"@color/teal_200\"\n        app:layout_constraintTop_toTopOf=\"parent\"\n        app:layout_constraintStart_toStartOf=\"parent\"\n        app:layout_constraintEnd_toEndOf=\"parent\"\n        app:layout_constraintBottom_toBottomOf=\"parent\">\n\n        <TextView\n            android:id=\"@+id/constraintTextView3\"\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:text=\"First TextView\"\n            app:layout_constraintTop_toTopOf=\"parent\"\n            app:layout_constraintStart_toStartOf=\"parent\" />\n\n        <LinearLayout\n            android:id=\"@+id/linearContainer4\"\n            android:layout_width=\"200dp\"\n            android:layout_height=\"200dp\"\n            android:orientation=\"vertical\"\n            app:layout_constraintTop_toTopOf=\"parent\"\n            app:layout_constraintEnd_toEndOf=\"parent\">\n\n            <ImageView\n                android:id=\"@+id/linearImageView5\"\n                android:layout_width=\"wrap_content\"\n                android:layout_height=\"wrap_content\"\n                android:background=\"@drawable/ic_launcher_foreground\"/>\n\n            <TextView\n                android:id=\"@+id/linearTextView5\"\n                android:layout_width=\"wrap_content\"\n                android:layout_height=\"wrap_content\"\n                android:text=\"Second TextView\"/>\n\n            <RelativeLayout\n                android:id=\"@+id/relativeContainer5\"\n                android:layout_width=\"wrap_content\"\n                android:layout_height=\"wrap_content\"\n                android:background=\"@color/purple_500\">\n\n                <TextView\n                    android:id=\"@+id/relativeTextView6\"\n                    android:layout_width=\"wrap_content\"\n                    android:layout_height=\"wrap_content\"\n                    android:text=\"Thired TextView\"/>\n\n            </RelativeLayout>\n\n        </LinearLayout>\n\n    </androidx.constraintlayout.widget.ConstraintLayout>\n\n    <FrameLayout\n        android:id=\"@+id/frameContainer2\"\n        android:layout_width=\"100dp\"\n        android:layout_height=\"100dp\"\n        android:background=\"@color/teal_200_30\"\n        app:layout_constraintEnd_toEndOf=\"parent\"\n        app:layout_constraintBottom_toBottomOf=\"parent\" />\n\n</androidx.constraintlayout.widget.ConstraintLayout>\n```\n\nroot Container 를 부모 레이아웃으로 삼아 다양한 depth 의 View 가 쌓여져 있고, 이는 아래처럼 그래프로 나타낼 수 있다.\n\n{% asset_img UntitledDiagram.png [View Tree Example] %}\n\n각각의 View, ViewGroup에 onLayout 시점을 포착할 수 있는 코드를 구현해, 어느 순서로 View 가 그려지는지 확인해보자.\n\n> doOnLayout, doOnDraw, doOnXXX 등을 통해 원하는 라이프사이클 시점을 포착할 수 있다.\n\n### OnLayout 호출로 순서 보기\n\n```kotlin\nlinearContainer4.doOnLayout {\n    println(\"linearContainer4 doOnLayout\")\n}\n\nconstraintContainer2.doOnLayout {\n    println(\"ConstraintContainer2 doOnLayout\")\n}\n\nconstraintTextView3.doOnLayout {\n    println(\"constraintTextView3 doOnLayout\")\n}\n\nroot1.doOnLayout {\n    println(\"root1 doOnLayout\")\n}\n\nrelativeContainer5.doOnLayout {\n    println(\"relativeContainer5 doOnLayout\")\n}\n\nrelativeTextView6.doOnLayout {\n    println(\"relativeTextView6 doOnLayout\")\n}\n\nlinearImageView5.doOnLayout {\n    println(\"linearImageView5 doOnLayout\")\n}\n\nlinearTextView5.doOnLayout {\n    println(\"linearTextView5 doOnLayout\")\n}\n\nframeContainer2.doOnLayout {\n    println(\"frameContainer2 doOnLayout\")\n}\n```\n\n{% asset_img image.png [onLayout Log] %}\n\nonLayout 시점에는 트리구조로 이루어진 View & ViewGroup 이 **후위순회**를 하며 **측정이 된다**는 것을 알 수 있다.\n\n\n### 실험을 통해 알게 된 결론\n\nLayout 내에 존재하는 Chile View가 lifecycle 를 거치면서 크기가 측정되는 순서와, 그려지는 순서는 다르다. \n\n1. Child View 들의 크기가 정해지고 Parent View 가 그 측정값을 알아야지 자신의 크기를 정할 수 있는 것이고, `(Layout 단계)`\n2. 도화지가 준비되어야 그림을 그릴 수 있듯이, Parent View 가 먼저 그려져야 Child View 가 그려질 수 있기 때문이다. `(Draw 단계)`\n\n## Extra Info\n\n### **`layout_weight` 의 배신**\n\nLinear Layout 의 layout_weight 속성을 사용하는 경우 자식 뷰는 두번의 Measure pass가 필요하기 때문에 많은 비용이 소모된다. \n\nlayout_weight는 단순히 비율을 나누어 공간을 차지하는 것이 아닌, 부모의 View가 그려지고 나서 남은 공간이 얼마만큼인지, 다른 View들이 그려지고 나서 다시한번 남은공간도 계산하고 나서 자기 자신을 그리기 때문에 지속적인 계산이 일어나게 된다. \n\n복잡한 View의 계산을 피하기 위해 Releative Layout & Constraint Layout을 권하는 것이다.\n\n### **Overdraw 를 피하는 방법**\n\nOverDraw를 피하는 방법 중, **사용자에게 보여지지 않는 Layout의 Background 색을 제거**하면 성능 향상에 도움이 된다는 글이 많이 존재한다. \n\n하지만 어째서 배경 색을 지우는 것만으로도 성능이 크게 향상될 수 있다는 것일까?\n\nLayout에 Background를 제거한 후 디버깅을 해보면 View **Lifecycle의 onDraw를 거치지 않음**을 알 수 있다. UI 렌더링 시 가장 비용이 많이 드는 부분이 onDraw(GPU에 업로드 하는 과정) 인데, 이 부분이 skip 되니 성능이 향상되는건 당연한 부분일 것이다. \n\n---\n\n여기까지 View의 생명주기, View가 그려지는 과정에 대해 알아보았다. \n\n다음 글에서는 View 상위에서 그려지는 요소인 Window, Surface, Canvas에 대해 소개하고, 소프트웨어 레벨에서 어떻게 하드웨어 레벨까지 동기화 되는지 분석하고, 현재 사용하는 하드웨어 모델 기반 렌더링에 대해 소개하도록 하겠다.\n","source":"_posts/2021-05-19 Android UI Rendering Optimization Part 1.md","raw":"---\ntitle: Introduce Android UI Rendering Principle and View Optimization Part 1\ndate: 2021-05-19 01:00\ncover: https://androiddeepdive.github.io/Team-Blog/images/cover_ui_rendering.png\ncategories:\n- User Interface\ntags:\n- Android\n- Rendering\n- Principle\n- Optimize\n- UI\n---\n\n<article class=\"message message-immersive is-primary\">\n    <div class=\"message-body\">\n        <i class=\"fas fa-pen-fancy mr-2\"></i>Writers<br>\n        by 김남훈 @Naver<br>\n        by 배희성 @RocketPunch<br>\n        by 송시영 @SmartStudy<br>\n        by 이기정 @BankSalad<br>\n        by 정세희 @BankSalad<br>\n        by 최소영 @BankSalad\n    </div>\n</article>\n\n\n<!-- more -->\n\n우리는 안드로이드 개발자로 있으면서 기본적인 것들을 놓치곤한다. 안드로이드에서 가장 중요한것은 사용자에게 보여지는 UI와 UX이다. 이를 위해서 안드로이드 개발자가 해야할 일은 UI를 이쁘게 요구사항에 맞게 그리고, 지연없는 UI로딩을 통해 UI를 그리는 것이다.\n\n글을 작성하다 보니 문득 든 생각이 있었다. 과연 우리가 안드로이드에서 UI를 그릴 때 정확하게 방법을 알고 View를 그리는 코드를 작성하고 있었을까? 나 스스로도 그렇지 않다라는 생각이 들었고, 궁금증이 생겨 ADD 멤버분들과 함께 글을 정리해보았다.\n\n## Android View\n\n안드로이드 개발자라면 한번쯤은 들어봤을 법한, 컴포넌트들이 있다. 바로 아래의 녀석들이다.\n\n{% asset_img 7AGranC.png [Android Views] %}\n\n안드로이드의 다양한 컴포넌트들은 다음과 같이 **View**라는 녀석을 상속받아서 만들어졌다. \n\n\n\n### View & ViewGroup\n\n간단히 개념만 잡고 넘어가보도록 해보자. 안드로이드에서 화면을 나누는 두가지 부류는 View와 ViewGroup 두가지로 나눌 수 있다.\n\n{% asset_img EzHZMUm.png [View & ViewGroup] %}\n\n**View**는 Activity, 즉 한 화면에서 화면을 구성하는 최소 단위의 개념이다. 또다른 말로는 위젯이라고 하는데, 이 View를 상속받아 구현되는 수많은 요소들이 존재한다. 대표적으로 ImageView, TextView, Button과 같은 녀석이 있다. 위젯이나 노티피케이션 위젯과 같이 사용성이 특수한 경우 RemoteView를 이용하여 구현을 해야하는 경우도 있는데, 여기서는 이에 대한 설명은 생략하겠다.\n\n**ViewGroup**은 View를 상속받아 구현된 클래스이다. 다른말로는 레이아웃이라고 하며, View를 N개 담을 수 있는 녀석이다. 대표적으로 LinearLayout, FrameLayout, RelativeLayout, ConsraintLayout이 있다.\n\n이러한 방식으로 View, ViewGroup은 Java, 또는 Kotlin코드로 구성될 수 있지만, 더 쉬운 방법으로 Mark-Up 랭귀지를 이용하여 구성도 가능하다. 안드로이드 프로그래밍에서는 XML이라는 마크업 랭귀지를 이용하는데, 결국 이도 XML Parser를 통해 파싱되어 Java코드로 변환되어진다.\n\n안드로이드 개발자들은 어플리케이션의 좋은 성능을 낼 수 있는 방법과, 올바른 방법으로 개발을 하기 위해서라도 View가 그려지는 과정과 생명주기에 대해 잘 알고 있어야 한다. 이를 위해서 먼저 View가 어떤 생명주기를 갖는지 보도록하자.\n\n\n\n## View Life-Cycle\n\n상용화 하는 어플리케이션을 만들수록, 우리가 만들어나가는 View는 고도화 될 필요가 있다. 특히 View, ViewGroup을 기반으로 한 컴포넌트를 구성하게 될 때, 우리는 `커스텀 뷰`라는 것을만들게 된다. 커스텀 뷰를 만들게 될 때, 만들면 만들수록 점점 뷰를 그려지는 방식은 복잡해지고, 성능적인 부분을 충족하기 위해 최적화할 수 있는 방법을 고민해야한다. 이를 위해서는 View의 생명주기에 대해서도 잘 알고 있어야 한다.\n\n안드로이드 컴포넌트, Fragment와 마찬가지로 View도 생명주기를 갖고있다.\n\nView의 생명주기는 아래와 같이 도식화 하여 표현 가능하다,\n\n\n{% asset_img qu5Mr6x.png [View Life Cycle] %}\n\n\n생명주기에 대해 몇 가지 특징적으로 나눌 수 있는 부분이 있다.\n\n\n\n### Constructors\n\nProgrammatically하게 View를 생성하는 방법이다. View를 생성하는 방법은 여러가지가 존재하지만, 가장 직관적인 방법 중 하나이다.\n\n생성자의 종류는 여러가지가 존재한다.\n\n- `View(Context context) `\n- `View(Context context, @Nullable AttributeSet attrs) `\n- `View(Context context, @Nullable AttributeSet attrs, int defStyleAttr) `\n- `View(Context context, @Nullable AttributeSet attrs, int defStyleAttr, int defStyleRes)`\n\n\n\n### Attachment / Detachment\n\n- **Attachment**는 Window에서 붙었음을 의미한다.\n- **Detachment**는 Window에서 떼어졌음을 의미한다.\n\n위 동작이 수행되었음을 받을 수 있는 Callback Function으로 두가지 함수를 각각 제공한다.\n\n\n\n### onAttachedToWindow()\n\nView가 Window에 붙었을 때 호출된다. 이때부터는 View가 Active하다고 판단되며, 이때부터는 리소스 할당, 파라미터에 대한 계산, 리스너를 부착할 수 있는 준비가 된다.\n\n\n\n### onDetachedFromWindow() \n\nView가 Window에 떼어졌을 때 호출된다. Window상에서 더 이상 존재하지 않으므로, Inactive하며, 기존에 View에 할당된 리소스를 해제해주어야한다. 해당 콜백함수가 불리는 케이스로는 두가지가 있다.\n\n- ViewGroup에서 View가 제거될 때\n- Activity가 `finish()` 함수를 호출하여 Activity가 Destroyed될 때\n\n\n\n### onMeasure()\n\nView의 크기를 계산한다. ViewGroup은 하위 노드인 View에 대한 크기를 측정하고, 관계성을 파악 후 자신의 크기를 계산한다. 따라서, 하위 노드가 ViewGroup에 올바르게 붙었는지 확인해야한다.\n\n```java\n/**\n * \n * 기본적으로 View의 크기를 측정할 때는 Background의 Dimension Size를 보고 결정한다.\n * \n * 현재 계산된 크기를 비교하여 Background크기보다 작은경우, Background크기를 반환하여 크기를 반환한다.\n * @param widthMeasureSpec 부모뷰에 의해 적용된 수평 공간\n * @param heightMeasureSpec 부모뷰에 의해 적용된 수직 공간\n *\n */\nprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n  setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),\n                       getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));\n}\n```\n\n\n\n### MeasureSpec\n\nViewGroup의 하위 컴포넌트인 View에서는 크기에 대한 제약을 정하기 위해 스펙을 정하게 되는데, 이를 MeasureSpec을 통해 해결한다. MeasureSpec은 Width, Height에 대한 스펙이며, 크기와 모드로 나뉜다.\n\n그리고 세가지의 값으로 나뉜다.\n\n- **MeasureSpec.EXACTLY** : 부모뷰가 자식뷰의 정확한 크기를 결정한다. 자식뷰의 사이즈와 관계없이 주어진 경계내에서 사이즈가 결정된다.\n\n- **MeasureSpec.AT_MOST** : 자식뷰는 지정된 크기까지 원하는 만큼 커질 수 있다.\n\n- **MeasureSpec.UNSPECIFIED** : 부모뷰가 자식뷰에 제한을 두지 않기 때문에, 자식뷰는 원하는 크기가 될 수 있다.\n\n아래와 같은 코드로 체크할 수 있다.\n\n```java\n@Override\npublic void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n  int mode = MeasureSpec.getMode(heightMeasureSpec)\n    if (mode != MeasureSpec.EXACTLY) {\n      // Logic\n    }\n}\n```\n\n\n\n### onLayout()\n\n계산이 된 이후에는 onLayout 함수를 통해 계산된 View를 Window에 배치한다. \n\nView와 같은 경우 아래 코드를 기반으로 상속받아 처리한다.\n\n```java\nprotected void onLayout(boolean changed, int left, int top, int right, int bottom)\n```\n\n\n\n### onDraw()\n\nonLayout에서 View에 대한 크기 계산 및 배치가 완료되었으므로, 이를 기반으로 onDraw에서는 Canvas라는 인스턴스를 넘겨주며, 해당 Canvas 인스턴스는 DisplayList에 그릴 데이터를 담아서 넘겨준다. onDraw는 한프레임을 그리는 함수기 때문에 반복적으로 호출이된다. 특이하게 여러번 호출되고 CPU연산이 되는 곳이기 떄문에, 객체를 만들어서 사용하는 것은 금기시한다.\n\nView가 draw를 하는 기준은 두가지로 나눌 수 있다.\n\n- View의 모양이 변형이 생겼을 때 - invalidate()\n- View의 경계에 변화가 생겼을 때 - requestLayout()\n\n### Invalidate()\n\ninvalidate 함수는 직접적으로도 호출이 가능하지만, 상위에서 View에서 여러 View내에 상태가 변형이 되었을 때 호출을한다.\n\n직접 코드를 까보는 것이 아무래도 좋으니, 본인이 확인한 invalidate를 호출하는 시점을 리스트업 해본다.\n\n- **drawableStateChanged** - Background, 포커스 되었을 때 나타다는 하이라이트, Foreground Drawable에 대해 변경점을 체크하며, 상태가 존재하면 변경된 것으로 판단\n- **setDefaultFocusHighlight** - 포커스 되었을 때 하이라이트를 기본적으로 세팅해줌. 무조건 새로 그림\n- **setForeground**\n- **setScrollIndicators** - indicator의 색상과 마스크를 설정한다. 기존 마스크와 머지하고, 플래그를 체크하여 업데이트 된 경우 새로 그린다.\n- **setAutoFilled**\n- **requestAccessibilityFocus** - 포커스를 쓸 수 있는 권한을 요청할 때  View에대한 포커스에 대해서 달라진 점이 생기면 플래그로 비교하여 처리\n- **setForceDarkAllowed** - 어둡게 처리시 필요한 함수\n- **onDrawScrollBars** - 스크롤바에 움직임이 생길 시\n- **setLayerPaint** - 색상에 대한 변형이 있을 때 처리한다. (alpha, Xfermode, colorFilter)\n\n### requestLayout()\n\n뷰의 경계가 변경되면 무조건 호출돼야하는 함수이다. 이를 통해 재 계산을 거쳐 onMeasure => onLayout을 거친다.\n\n## View State Save/Restore\n\nView는 Activity의 상태에 따라 상태를 저장/복원해야 할 필요가있다. 이를 위한 두가지의 함수를 제공한다.\n\n### onSaveInstanceState() -> Parcelable\n\n상태를 저장하기 위한 함수에서는 상태를 저장할 때 각 View에 대한 고유 ID를 필요로한다. 저장을 할때는 Bundle 인스턴스를 생성하여 저장하면 된다.\n\nBundle은 Parcelable을 구현한 클래스로, 적절하게 저장하여 처리할 수 있다.\n\n아래 코드를 참고하자.\n\n```java\n@Override\npublic Parcelable onSaveInstanceState() {\n  Bundle bundle = new Bundle();\n  // The vars you want to save - in this instance a string and a boolean\n  String someString = \"something\";\n  boolean someBoolean = true;\n  State state = new State(super.onSaveInstanceState(), someString, someBoolean);\n  bundle.putParcelable(State.STATE, state);\n  return bundle;\n}\n```\n\nState라는 녀석이 보이는데, 해당 State는 직접 구현해주어야 하는 클래스가 될 수 있다. View에대한 상태를 저장할 수 있는 어떤것이든 상관없다.\n\n### onRestoreInstanceState(Parcelable state)\n\n해당함수를 오버라이딩하면 다시 Paracleable로 된 인스턴스를 받아서 처리가 가능하다. Parcelable을 그대로 쓸수는 없으니, 구현체에 해당하는 인스턴스로 캐스팅하여 처리하면 된다.\n\n아래는 예시이다.\n\n```java\n@Override\npublic void onRestoreInstanceState(Parcelable state) {\n  if (state instanceof Bundle) {\n    Bundle bundle = (Bundle) state;\n    State customViewState = (State) bundle.getParcelable(State.STATE);\n    // The vars you saved - do whatever you want with them\n    String someString = customViewState.getText();\n    boolean someBoolean = customViewState.isSomethingShowing());\n    super.onRestoreInstanceState(customViewState.getSuperState());\n    return;\n  }\n  // Stops a bug with the wrong state being passed to the super\n  super.onRestoreInstanceState(BaseSavedState.EMPTY_STATE); \n}\n```\n\n\n\n## View가 그려지는 순서\n\nView가 렌더링 될 때, 상위수준의 `ViewGroup` 에서부터 하위 자식인 `View` 로 내려가면서 `Measure -> Layout -> Draw` 를 거치게 된다.\n\n### Measure Pass\n\n측정 패스는 measure(int, int) 로 구현되며 뷰 트리의 탑-다운으로 순회한다. 각 뷰는 트리를 재귀하는 동안 측정한 수치를 트리 아래로 보낸다.\n\n측정이 모두 끝나면 모든 뷰는 측정한 값을 가지게 된다. 두번째 단계 또한 탑-다운으로 layout(int, int, int) 에서 일어난다. 각각의 부모는 측정단계에서 계산된 사이즈를 사용해서 자신의 모든 자식을 배치한다.\n\nView 의 크기는 2가지로 정의될 수 있다.\n\n- **measured width & measured height** : 뷰가 부모뷰 크기의 범위 내에서 가지고 싶어하는 너비와 높이이다.\n- **drawing width & drawing height** : 뷰의 실제 너비와 높이로 뷰를 그리기 위해서 사용한다.\n\nView의 Padding, Margin 등을 고려하면 원하는 크기에서 Padding 및 Margin 값을 빼야 하기 때문에 Measured Width, Measured Height 는 Drawing Width, Drawing Height 와 다를 수 있다.\n\n\n\n### Layout Pass\n\n레이아웃을 시작하려면, requestLayout() 를 호출한다. 일반적으로 현재 범위내에 더이상 맞지 않을때 자체적으로 뷰에 의해 호출된다.  이 과정에서도 top-down 형식의 탐색이 일어나게 되는데, 이 때는 각각의 ViewGroup이 Measure 단계에서 측정된 크기를 이용해서 하위속성들의 위치를 결정한다.\n\n\n\n### Draw Pass\n\nGPU에게 명령을 내려주는 단계이다. 그려야 할 객체들의 리스트를 GPU에게 보내기 위해 View Tree에서 각 객체의 대한 Canvas 객체가 생성된다. 이 때, 이전 1,2단계를 거쳐 결정된 객체들의 크기와 위치에 대한 정보가 들어가게 된다.\n\n만약 View가 변할 때, 시스템에게 알려주기 위한 2가지 방법이 존재하는데, `Invaliadate()`가 호출 될 때에는 draw부터 다시 작업이 시행되고, `requestLayout()`이 호출될 때에는 measure -> layout -> draw 단계를 다시 거치게 된다.\n\n\n\n코드로 보면서 어떤식으로 View가 그려지는지 한번 보도록하자.\n\n\n\n### 실험을 통한 View Rendering Process 관찰\n\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<androidx.constraintlayout.widget.ConstraintLayout\n    android:id=\"@+id/root1\"\n    xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    xmlns:tools=\"http://schemas.android.com/tools\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    tools:context=\".MainActivity\">\n\n    <androidx.constraintlayout.widget.ConstraintLayout\n        android:id=\"@+id/constraintContainer2\"\n        android:layout_width=\"400dp\"\n        android:layout_height=\"400dp\"\n        android:background=\"@color/teal_200\"\n        app:layout_constraintTop_toTopOf=\"parent\"\n        app:layout_constraintStart_toStartOf=\"parent\"\n        app:layout_constraintEnd_toEndOf=\"parent\"\n        app:layout_constraintBottom_toBottomOf=\"parent\">\n\n        <TextView\n            android:id=\"@+id/constraintTextView3\"\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:text=\"First TextView\"\n            app:layout_constraintTop_toTopOf=\"parent\"\n            app:layout_constraintStart_toStartOf=\"parent\" />\n\n        <LinearLayout\n            android:id=\"@+id/linearContainer4\"\n            android:layout_width=\"200dp\"\n            android:layout_height=\"200dp\"\n            android:orientation=\"vertical\"\n            app:layout_constraintTop_toTopOf=\"parent\"\n            app:layout_constraintEnd_toEndOf=\"parent\">\n\n            <ImageView\n                android:id=\"@+id/linearImageView5\"\n                android:layout_width=\"wrap_content\"\n                android:layout_height=\"wrap_content\"\n                android:background=\"@drawable/ic_launcher_foreground\"/>\n\n            <TextView\n                android:id=\"@+id/linearTextView5\"\n                android:layout_width=\"wrap_content\"\n                android:layout_height=\"wrap_content\"\n                android:text=\"Second TextView\"/>\n\n            <RelativeLayout\n                android:id=\"@+id/relativeContainer5\"\n                android:layout_width=\"wrap_content\"\n                android:layout_height=\"wrap_content\"\n                android:background=\"@color/purple_500\">\n\n                <TextView\n                    android:id=\"@+id/relativeTextView6\"\n                    android:layout_width=\"wrap_content\"\n                    android:layout_height=\"wrap_content\"\n                    android:text=\"Thired TextView\"/>\n\n            </RelativeLayout>\n\n        </LinearLayout>\n\n    </androidx.constraintlayout.widget.ConstraintLayout>\n\n    <FrameLayout\n        android:id=\"@+id/frameContainer2\"\n        android:layout_width=\"100dp\"\n        android:layout_height=\"100dp\"\n        android:background=\"@color/teal_200_30\"\n        app:layout_constraintEnd_toEndOf=\"parent\"\n        app:layout_constraintBottom_toBottomOf=\"parent\" />\n\n</androidx.constraintlayout.widget.ConstraintLayout>\n```\n\nroot Container 를 부모 레이아웃으로 삼아 다양한 depth 의 View 가 쌓여져 있고, 이는 아래처럼 그래프로 나타낼 수 있다.\n\n{% asset_img UntitledDiagram.png [View Tree Example] %}\n\n각각의 View, ViewGroup에 onLayout 시점을 포착할 수 있는 코드를 구현해, 어느 순서로 View 가 그려지는지 확인해보자.\n\n> doOnLayout, doOnDraw, doOnXXX 등을 통해 원하는 라이프사이클 시점을 포착할 수 있다.\n\n### OnLayout 호출로 순서 보기\n\n```kotlin\nlinearContainer4.doOnLayout {\n    println(\"linearContainer4 doOnLayout\")\n}\n\nconstraintContainer2.doOnLayout {\n    println(\"ConstraintContainer2 doOnLayout\")\n}\n\nconstraintTextView3.doOnLayout {\n    println(\"constraintTextView3 doOnLayout\")\n}\n\nroot1.doOnLayout {\n    println(\"root1 doOnLayout\")\n}\n\nrelativeContainer5.doOnLayout {\n    println(\"relativeContainer5 doOnLayout\")\n}\n\nrelativeTextView6.doOnLayout {\n    println(\"relativeTextView6 doOnLayout\")\n}\n\nlinearImageView5.doOnLayout {\n    println(\"linearImageView5 doOnLayout\")\n}\n\nlinearTextView5.doOnLayout {\n    println(\"linearTextView5 doOnLayout\")\n}\n\nframeContainer2.doOnLayout {\n    println(\"frameContainer2 doOnLayout\")\n}\n```\n\n{% asset_img image.png [onLayout Log] %}\n\nonLayout 시점에는 트리구조로 이루어진 View & ViewGroup 이 **후위순회**를 하며 **측정이 된다**는 것을 알 수 있다.\n\n\n### 실험을 통해 알게 된 결론\n\nLayout 내에 존재하는 Chile View가 lifecycle 를 거치면서 크기가 측정되는 순서와, 그려지는 순서는 다르다. \n\n1. Child View 들의 크기가 정해지고 Parent View 가 그 측정값을 알아야지 자신의 크기를 정할 수 있는 것이고, `(Layout 단계)`\n2. 도화지가 준비되어야 그림을 그릴 수 있듯이, Parent View 가 먼저 그려져야 Child View 가 그려질 수 있기 때문이다. `(Draw 단계)`\n\n## Extra Info\n\n### **`layout_weight` 의 배신**\n\nLinear Layout 의 layout_weight 속성을 사용하는 경우 자식 뷰는 두번의 Measure pass가 필요하기 때문에 많은 비용이 소모된다. \n\nlayout_weight는 단순히 비율을 나누어 공간을 차지하는 것이 아닌, 부모의 View가 그려지고 나서 남은 공간이 얼마만큼인지, 다른 View들이 그려지고 나서 다시한번 남은공간도 계산하고 나서 자기 자신을 그리기 때문에 지속적인 계산이 일어나게 된다. \n\n복잡한 View의 계산을 피하기 위해 Releative Layout & Constraint Layout을 권하는 것이다.\n\n### **Overdraw 를 피하는 방법**\n\nOverDraw를 피하는 방법 중, **사용자에게 보여지지 않는 Layout의 Background 색을 제거**하면 성능 향상에 도움이 된다는 글이 많이 존재한다. \n\n하지만 어째서 배경 색을 지우는 것만으로도 성능이 크게 향상될 수 있다는 것일까?\n\nLayout에 Background를 제거한 후 디버깅을 해보면 View **Lifecycle의 onDraw를 거치지 않음**을 알 수 있다. UI 렌더링 시 가장 비용이 많이 드는 부분이 onDraw(GPU에 업로드 하는 과정) 인데, 이 부분이 skip 되니 성능이 향상되는건 당연한 부분일 것이다. \n\n---\n\n여기까지 View의 생명주기, View가 그려지는 과정에 대해 알아보았다. \n\n다음 글에서는 View 상위에서 그려지는 요소인 Window, Surface, Canvas에 대해 소개하고, 소프트웨어 레벨에서 어떻게 하드웨어 레벨까지 동기화 되는지 분석하고, 현재 사용하는 하드웨어 모델 기반 렌더링에 대해 소개하도록 하겠다.\n","slug":"2021-05-19 Android UI Rendering Optimization Part 1","published":1,"updated":"2021-07-25T13:28:20.235Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cksagj7kx00053lre02i6f7pq","content":"<article class=\"message message-immersive is-primary\">\n    <div class=\"message-body\">\n        <i class=\"fas fa-pen-fancy mr-2\"></i>Writers<br>\n        by 김남훈 @Naver<br>\n        by 배희성 @RocketPunch<br>\n        by 송시영 @SmartStudy<br>\n        by 이기정 @BankSalad<br>\n        by 정세희 @BankSalad<br>\n        by 최소영 @BankSalad\n    </div>\n</article>\n\n\n<span id=\"more\"></span>\n\n<p>우리는 안드로이드 개발자로 있으면서 기본적인 것들을 놓치곤한다. 안드로이드에서 가장 중요한것은 사용자에게 보여지는 UI와 UX이다. 이를 위해서 안드로이드 개발자가 해야할 일은 UI를 이쁘게 요구사항에 맞게 그리고, 지연없는 UI로딩을 통해 UI를 그리는 것이다.</p>\n<p>글을 작성하다 보니 문득 든 생각이 있었다. 과연 우리가 안드로이드에서 UI를 그릴 때 정확하게 방법을 알고 View를 그리는 코드를 작성하고 있었을까? 나 스스로도 그렇지 않다라는 생각이 들었고, 궁금증이 생겨 ADD 멤버분들과 함께 글을 정리해보았다.</p>\n<h2 id=\"Android-View\"><a href=\"#Android-View\" class=\"headerlink\" title=\"Android View\"></a>Android View</h2><p>안드로이드 개발자라면 한번쯤은 들어봤을 법한, 컴포넌트들이 있다. 바로 아래의 녀석들이다.</p>\n<img src=\"/Team-Blog/2021/05/19/2021-05-19%20Android%20UI%20Rendering%20Optimization%20Part%201/7AGranC.png\" class=\"\" title=\"[Android Views]\">\n\n<p>안드로이드의 다양한 컴포넌트들은 다음과 같이 <strong>View</strong>라는 녀석을 상속받아서 만들어졌다. </p>\n<h3 id=\"View-amp-ViewGroup\"><a href=\"#View-amp-ViewGroup\" class=\"headerlink\" title=\"View &amp; ViewGroup\"></a>View &amp; ViewGroup</h3><p>간단히 개념만 잡고 넘어가보도록 해보자. 안드로이드에서 화면을 나누는 두가지 부류는 View와 ViewGroup 두가지로 나눌 수 있다.</p>\n<img src=\"/Team-Blog/2021/05/19/2021-05-19%20Android%20UI%20Rendering%20Optimization%20Part%201/EzHZMUm.png\" class=\"\" title=\"[View &amp; ViewGroup]\">\n\n<p><strong>View</strong>는 Activity, 즉 한 화면에서 화면을 구성하는 최소 단위의 개념이다. 또다른 말로는 위젯이라고 하는데, 이 View를 상속받아 구현되는 수많은 요소들이 존재한다. 대표적으로 ImageView, TextView, Button과 같은 녀석이 있다. 위젯이나 노티피케이션 위젯과 같이 사용성이 특수한 경우 RemoteView를 이용하여 구현을 해야하는 경우도 있는데, 여기서는 이에 대한 설명은 생략하겠다.</p>\n<p><strong>ViewGroup</strong>은 View를 상속받아 구현된 클래스이다. 다른말로는 레이아웃이라고 하며, View를 N개 담을 수 있는 녀석이다. 대표적으로 LinearLayout, FrameLayout, RelativeLayout, ConsraintLayout이 있다.</p>\n<p>이러한 방식으로 View, ViewGroup은 Java, 또는 Kotlin코드로 구성될 수 있지만, 더 쉬운 방법으로 Mark-Up 랭귀지를 이용하여 구성도 가능하다. 안드로이드 프로그래밍에서는 XML이라는 마크업 랭귀지를 이용하는데, 결국 이도 XML Parser를 통해 파싱되어 Java코드로 변환되어진다.</p>\n<p>안드로이드 개발자들은 어플리케이션의 좋은 성능을 낼 수 있는 방법과, 올바른 방법으로 개발을 하기 위해서라도 View가 그려지는 과정과 생명주기에 대해 잘 알고 있어야 한다. 이를 위해서 먼저 View가 어떤 생명주기를 갖는지 보도록하자.</p>\n<h2 id=\"View-Life-Cycle\"><a href=\"#View-Life-Cycle\" class=\"headerlink\" title=\"View Life-Cycle\"></a>View Life-Cycle</h2><p>상용화 하는 어플리케이션을 만들수록, 우리가 만들어나가는 View는 고도화 될 필요가 있다. 특히 View, ViewGroup을 기반으로 한 컴포넌트를 구성하게 될 때, 우리는 <code>커스텀 뷰</code>라는 것을만들게 된다. 커스텀 뷰를 만들게 될 때, 만들면 만들수록 점점 뷰를 그려지는 방식은 복잡해지고, 성능적인 부분을 충족하기 위해 최적화할 수 있는 방법을 고민해야한다. 이를 위해서는 View의 생명주기에 대해서도 잘 알고 있어야 한다.</p>\n<p>안드로이드 컴포넌트, Fragment와 마찬가지로 View도 생명주기를 갖고있다.</p>\n<p>View의 생명주기는 아래와 같이 도식화 하여 표현 가능하다,</p>\n<img src=\"/Team-Blog/2021/05/19/2021-05-19%20Android%20UI%20Rendering%20Optimization%20Part%201/qu5Mr6x.png\" class=\"\" title=\"[View Life Cycle]\">\n\n\n<p>생명주기에 대해 몇 가지 특징적으로 나눌 수 있는 부분이 있다.</p>\n<h3 id=\"Constructors\"><a href=\"#Constructors\" class=\"headerlink\" title=\"Constructors\"></a>Constructors</h3><p>Programmatically하게 View를 생성하는 방법이다. View를 생성하는 방법은 여러가지가 존재하지만, 가장 직관적인 방법 중 하나이다.</p>\n<p>생성자의 종류는 여러가지가 존재한다.</p>\n<ul>\n<li><code>View(Context context) </code></li>\n<li><code>View(Context context, @Nullable AttributeSet attrs) </code></li>\n<li><code>View(Context context, @Nullable AttributeSet attrs, int defStyleAttr) </code></li>\n<li><code>View(Context context, @Nullable AttributeSet attrs, int defStyleAttr, int defStyleRes)</code></li>\n</ul>\n<h3 id=\"Attachment-Detachment\"><a href=\"#Attachment-Detachment\" class=\"headerlink\" title=\"Attachment / Detachment\"></a>Attachment / Detachment</h3><ul>\n<li><strong>Attachment</strong>는 Window에서 붙었음을 의미한다.</li>\n<li><strong>Detachment</strong>는 Window에서 떼어졌음을 의미한다.</li>\n</ul>\n<p>위 동작이 수행되었음을 받을 수 있는 Callback Function으로 두가지 함수를 각각 제공한다.</p>\n<h3 id=\"onAttachedToWindow\"><a href=\"#onAttachedToWindow\" class=\"headerlink\" title=\"onAttachedToWindow()\"></a>onAttachedToWindow()</h3><p>View가 Window에 붙었을 때 호출된다. 이때부터는 View가 Active하다고 판단되며, 이때부터는 리소스 할당, 파라미터에 대한 계산, 리스너를 부착할 수 있는 준비가 된다.</p>\n<h3 id=\"onDetachedFromWindow\"><a href=\"#onDetachedFromWindow\" class=\"headerlink\" title=\"onDetachedFromWindow()\"></a>onDetachedFromWindow()</h3><p>View가 Window에 떼어졌을 때 호출된다. Window상에서 더 이상 존재하지 않으므로, Inactive하며, 기존에 View에 할당된 리소스를 해제해주어야한다. 해당 콜백함수가 불리는 케이스로는 두가지가 있다.</p>\n<ul>\n<li>ViewGroup에서 View가 제거될 때</li>\n<li>Activity가 <code>finish()</code> 함수를 호출하여 Activity가 Destroyed될 때</li>\n</ul>\n<h3 id=\"onMeasure\"><a href=\"#onMeasure\" class=\"headerlink\" title=\"onMeasure()\"></a>onMeasure()</h3><p>View의 크기를 계산한다. ViewGroup은 하위 노드인 View에 대한 크기를 측정하고, 관계성을 파악 후 자신의 크기를 계산한다. 따라서, 하위 노드가 ViewGroup에 올바르게 붙었는지 확인해야한다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> * 기본적으로 View의 크기를 측정할 때는 Background의 Dimension Size를 보고 결정한다.</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> * 현재 계산된 크기를 비교하여 Background크기보다 작은경우, Background크기를 반환하여 크기를 반환한다.</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> widthMeasureSpec 부모뷰에 의해 적용된 수평 공간</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> heightMeasureSpec 부모뷰에 의해 적용된 수직 공간</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onMeasure</span><span class=\"params\">(<span class=\"keyword\">int</span> widthMeasureSpec, <span class=\"keyword\">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class=\"line\">  setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),</span><br><span class=\"line\">                       getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"MeasureSpec\"><a href=\"#MeasureSpec\" class=\"headerlink\" title=\"MeasureSpec\"></a>MeasureSpec</h3><p>ViewGroup의 하위 컴포넌트인 View에서는 크기에 대한 제약을 정하기 위해 스펙을 정하게 되는데, 이를 MeasureSpec을 통해 해결한다. MeasureSpec은 Width, Height에 대한 스펙이며, 크기와 모드로 나뉜다.</p>\n<p>그리고 세가지의 값으로 나뉜다.</p>\n<ul>\n<li><p><strong>MeasureSpec.EXACTLY</strong> : 부모뷰가 자식뷰의 정확한 크기를 결정한다. 자식뷰의 사이즈와 관계없이 주어진 경계내에서 사이즈가 결정된다.</p>\n</li>\n<li><p><strong>MeasureSpec.AT_MOST</strong> : 자식뷰는 지정된 크기까지 원하는 만큼 커질 수 있다.</p>\n</li>\n<li><p><strong>MeasureSpec.UNSPECIFIED</strong> : 부모뷰가 자식뷰에 제한을 두지 않기 때문에, 자식뷰는 원하는 크기가 될 수 있다.</p>\n</li>\n</ul>\n<p>아래와 같은 코드로 체크할 수 있다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onMeasure</span><span class=\"params\">(<span class=\"keyword\">int</span> widthMeasureSpec, <span class=\"keyword\">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> mode = MeasureSpec.getMode(heightMeasureSpec)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mode != MeasureSpec.EXACTLY) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// Logic</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"onLayout\"><a href=\"#onLayout\" class=\"headerlink\" title=\"onLayout()\"></a>onLayout()</h3><p>계산이 된 이후에는 onLayout 함수를 통해 계산된 View를 Window에 배치한다. </p>\n<p>View와 같은 경우 아래 코드를 기반으로 상속받아 처리한다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onLayout</span><span class=\"params\">(<span class=\"keyword\">boolean</span> changed, <span class=\"keyword\">int</span> left, <span class=\"keyword\">int</span> top, <span class=\"keyword\">int</span> right, <span class=\"keyword\">int</span> bottom)</span></span></span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"onDraw\"><a href=\"#onDraw\" class=\"headerlink\" title=\"onDraw()\"></a>onDraw()</h3><p>onLayout에서 View에 대한 크기 계산 및 배치가 완료되었으므로, 이를 기반으로 onDraw에서는 Canvas라는 인스턴스를 넘겨주며, 해당 Canvas 인스턴스는 DisplayList에 그릴 데이터를 담아서 넘겨준다. onDraw는 한프레임을 그리는 함수기 때문에 반복적으로 호출이된다. 특이하게 여러번 호출되고 CPU연산이 되는 곳이기 떄문에, 객체를 만들어서 사용하는 것은 금기시한다.</p>\n<p>View가 draw를 하는 기준은 두가지로 나눌 수 있다.</p>\n<ul>\n<li>View의 모양이 변형이 생겼을 때 - invalidate()</li>\n<li>View의 경계에 변화가 생겼을 때 - requestLayout()</li>\n</ul>\n<h3 id=\"Invalidate\"><a href=\"#Invalidate\" class=\"headerlink\" title=\"Invalidate()\"></a>Invalidate()</h3><p>invalidate 함수는 직접적으로도 호출이 가능하지만, 상위에서 View에서 여러 View내에 상태가 변형이 되었을 때 호출을한다.</p>\n<p>직접 코드를 까보는 것이 아무래도 좋으니, 본인이 확인한 invalidate를 호출하는 시점을 리스트업 해본다.</p>\n<ul>\n<li><strong>drawableStateChanged</strong> - Background, 포커스 되었을 때 나타다는 하이라이트, Foreground Drawable에 대해 변경점을 체크하며, 상태가 존재하면 변경된 것으로 판단</li>\n<li><strong>setDefaultFocusHighlight</strong> - 포커스 되었을 때 하이라이트를 기본적으로 세팅해줌. 무조건 새로 그림</li>\n<li><strong>setForeground</strong></li>\n<li><strong>setScrollIndicators</strong> - indicator의 색상과 마스크를 설정한다. 기존 마스크와 머지하고, 플래그를 체크하여 업데이트 된 경우 새로 그린다.</li>\n<li><strong>setAutoFilled</strong></li>\n<li><strong>requestAccessibilityFocus</strong> - 포커스를 쓸 수 있는 권한을 요청할 때  View에대한 포커스에 대해서 달라진 점이 생기면 플래그로 비교하여 처리</li>\n<li><strong>setForceDarkAllowed</strong> - 어둡게 처리시 필요한 함수</li>\n<li><strong>onDrawScrollBars</strong> - 스크롤바에 움직임이 생길 시</li>\n<li><strong>setLayerPaint</strong> - 색상에 대한 변형이 있을 때 처리한다. (alpha, Xfermode, colorFilter)</li>\n</ul>\n<h3 id=\"requestLayout\"><a href=\"#requestLayout\" class=\"headerlink\" title=\"requestLayout()\"></a>requestLayout()</h3><p>뷰의 경계가 변경되면 무조건 호출돼야하는 함수이다. 이를 통해 재 계산을 거쳐 onMeasure =&gt; onLayout을 거친다.</p>\n<h2 id=\"View-State-Save-Restore\"><a href=\"#View-State-Save-Restore\" class=\"headerlink\" title=\"View State Save/Restore\"></a>View State Save/Restore</h2><p>View는 Activity의 상태에 따라 상태를 저장/복원해야 할 필요가있다. 이를 위한 두가지의 함수를 제공한다.</p>\n<h3 id=\"onSaveInstanceState-gt-Parcelable\"><a href=\"#onSaveInstanceState-gt-Parcelable\" class=\"headerlink\" title=\"onSaveInstanceState() -&gt; Parcelable\"></a>onSaveInstanceState() -&gt; Parcelable</h3><p>상태를 저장하기 위한 함수에서는 상태를 저장할 때 각 View에 대한 고유 ID를 필요로한다. 저장을 할때는 Bundle 인스턴스를 생성하여 저장하면 된다.</p>\n<p>Bundle은 Parcelable을 구현한 클래스로, 적절하게 저장하여 처리할 수 있다.</p>\n<p>아래 코드를 참고하자.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Parcelable <span class=\"title\">onSaveInstanceState</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  Bundle bundle = <span class=\"keyword\">new</span> Bundle();</span><br><span class=\"line\">  <span class=\"comment\">// The vars you want to save - in this instance a string and a boolean</span></span><br><span class=\"line\">  String someString = <span class=\"string\">&quot;something&quot;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">boolean</span> someBoolean = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">  State state = <span class=\"keyword\">new</span> State(<span class=\"keyword\">super</span>.onSaveInstanceState(), someString, someBoolean);</span><br><span class=\"line\">  bundle.putParcelable(State.STATE, state);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> bundle;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>State라는 녀석이 보이는데, 해당 State는 직접 구현해주어야 하는 클래스가 될 수 있다. View에대한 상태를 저장할 수 있는 어떤것이든 상관없다.</p>\n<h3 id=\"onRestoreInstanceState-Parcelable-state\"><a href=\"#onRestoreInstanceState-Parcelable-state\" class=\"headerlink\" title=\"onRestoreInstanceState(Parcelable state)\"></a>onRestoreInstanceState(Parcelable state)</h3><p>해당함수를 오버라이딩하면 다시 Paracleable로 된 인스턴스를 받아서 처리가 가능하다. Parcelable을 그대로 쓸수는 없으니, 구현체에 해당하는 인스턴스로 캐스팅하여 처리하면 된다.</p>\n<p>아래는 예시이다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onRestoreInstanceState</span><span class=\"params\">(Parcelable state)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (state <span class=\"keyword\">instanceof</span> Bundle) &#123;</span><br><span class=\"line\">    Bundle bundle = (Bundle) state;</span><br><span class=\"line\">    State customViewState = (State) bundle.getParcelable(State.STATE);</span><br><span class=\"line\">    <span class=\"comment\">// The vars you saved - do whatever you want with them</span></span><br><span class=\"line\">    String someString = customViewState.getText();</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> someBoolean = customViewState.isSomethingShowing());</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.onRestoreInstanceState(customViewState.getSuperState());</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// Stops a bug with the wrong state being passed to the super</span></span><br><span class=\"line\">  <span class=\"keyword\">super</span>.onRestoreInstanceState(BaseSavedState.EMPTY_STATE); </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"View가-그려지는-순서\"><a href=\"#View가-그려지는-순서\" class=\"headerlink\" title=\"View가 그려지는 순서\"></a>View가 그려지는 순서</h2><p>View가 렌더링 될 때, 상위수준의 <code>ViewGroup</code> 에서부터 하위 자식인 <code>View</code> 로 내려가면서 <code>Measure -&gt; Layout -&gt; Draw</code> 를 거치게 된다.</p>\n<h3 id=\"Measure-Pass\"><a href=\"#Measure-Pass\" class=\"headerlink\" title=\"Measure Pass\"></a>Measure Pass</h3><p>측정 패스는 measure(int, int) 로 구현되며 뷰 트리의 탑-다운으로 순회한다. 각 뷰는 트리를 재귀하는 동안 측정한 수치를 트리 아래로 보낸다.</p>\n<p>측정이 모두 끝나면 모든 뷰는 측정한 값을 가지게 된다. 두번째 단계 또한 탑-다운으로 layout(int, int, int) 에서 일어난다. 각각의 부모는 측정단계에서 계산된 사이즈를 사용해서 자신의 모든 자식을 배치한다.</p>\n<p>View 의 크기는 2가지로 정의될 수 있다.</p>\n<ul>\n<li><strong>measured width &amp; measured height</strong> : 뷰가 부모뷰 크기의 범위 내에서 가지고 싶어하는 너비와 높이이다.</li>\n<li><strong>drawing width &amp; drawing height</strong> : 뷰의 실제 너비와 높이로 뷰를 그리기 위해서 사용한다.</li>\n</ul>\n<p>View의 Padding, Margin 등을 고려하면 원하는 크기에서 Padding 및 Margin 값을 빼야 하기 때문에 Measured Width, Measured Height 는 Drawing Width, Drawing Height 와 다를 수 있다.</p>\n<h3 id=\"Layout-Pass\"><a href=\"#Layout-Pass\" class=\"headerlink\" title=\"Layout Pass\"></a>Layout Pass</h3><p>레이아웃을 시작하려면, requestLayout() 를 호출한다. 일반적으로 현재 범위내에 더이상 맞지 않을때 자체적으로 뷰에 의해 호출된다.  이 과정에서도 top-down 형식의 탐색이 일어나게 되는데, 이 때는 각각의 ViewGroup이 Measure 단계에서 측정된 크기를 이용해서 하위속성들의 위치를 결정한다.</p>\n<h3 id=\"Draw-Pass\"><a href=\"#Draw-Pass\" class=\"headerlink\" title=\"Draw Pass\"></a>Draw Pass</h3><p>GPU에게 명령을 내려주는 단계이다. 그려야 할 객체들의 리스트를 GPU에게 보내기 위해 View Tree에서 각 객체의 대한 Canvas 객체가 생성된다. 이 때, 이전 1,2단계를 거쳐 결정된 객체들의 크기와 위치에 대한 정보가 들어가게 된다.</p>\n<p>만약 View가 변할 때, 시스템에게 알려주기 위한 2가지 방법이 존재하는데, <code>Invaliadate()</code>가 호출 될 때에는 draw부터 다시 작업이 시행되고, <code>requestLayout()</code>이 호출될 때에는 measure -&gt; layout -&gt; draw 단계를 다시 거치게 된다.</p>\n<p>코드로 보면서 어떤식으로 View가 그려지는지 한번 보도록하자.</p>\n<h3 id=\"실험을-통한-View-Rendering-Process-관찰\"><a href=\"#실험을-통한-View-Rendering-Process-관찰\" class=\"headerlink\" title=\"실험을 통한 View Rendering Process 관찰\"></a>실험을 통한 View Rendering Process 관찰</h3><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">androidx.constraintlayout.widget.ConstraintLayout</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:id</span>=<span class=\"string\">&quot;@+id/root1&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">xmlns:android</span>=<span class=\"string\">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">xmlns:app</span>=<span class=\"string\">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">xmlns:tools</span>=<span class=\"string\">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:layout_width</span>=<span class=\"string\">&quot;match_parent&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:layout_height</span>=<span class=\"string\">&quot;match_parent&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">tools:context</span>=<span class=\"string\">&quot;.MainActivity&quot;</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">androidx.constraintlayout.widget.ConstraintLayout</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:id</span>=<span class=\"string\">&quot;@+id/constraintContainer2&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:layout_width</span>=<span class=\"string\">&quot;400dp&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:layout_height</span>=<span class=\"string\">&quot;400dp&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:background</span>=<span class=\"string\">&quot;@color/teal_200&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">app:layout_constraintTop_toTopOf</span>=<span class=\"string\">&quot;parent&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">app:layout_constraintStart_toStartOf</span>=<span class=\"string\">&quot;parent&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">app:layout_constraintEnd_toEndOf</span>=<span class=\"string\">&quot;parent&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">app:layout_constraintBottom_toBottomOf</span>=<span class=\"string\">&quot;parent&quot;</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">TextView</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">android:id</span>=<span class=\"string\">&quot;@+id/constraintTextView3&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">android:layout_width</span>=<span class=\"string\">&quot;wrap_content&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">android:layout_height</span>=<span class=\"string\">&quot;wrap_content&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">android:text</span>=<span class=\"string\">&quot;First TextView&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">app:layout_constraintTop_toTopOf</span>=<span class=\"string\">&quot;parent&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">app:layout_constraintStart_toStartOf</span>=<span class=\"string\">&quot;parent&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">LinearLayout</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">android:id</span>=<span class=\"string\">&quot;@+id/linearContainer4&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">android:layout_width</span>=<span class=\"string\">&quot;200dp&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">android:layout_height</span>=<span class=\"string\">&quot;200dp&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">android:orientation</span>=<span class=\"string\">&quot;vertical&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">app:layout_constraintTop_toTopOf</span>=<span class=\"string\">&quot;parent&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">app:layout_constraintEnd_toEndOf</span>=<span class=\"string\">&quot;parent&quot;</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">ImageView</span></span></span><br><span class=\"line\"><span class=\"tag\">                <span class=\"attr\">android:id</span>=<span class=\"string\">&quot;@+id/linearImageView5&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                <span class=\"attr\">android:layout_width</span>=<span class=\"string\">&quot;wrap_content&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                <span class=\"attr\">android:layout_height</span>=<span class=\"string\">&quot;wrap_content&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                <span class=\"attr\">android:background</span>=<span class=\"string\">&quot;@drawable/ic_launcher_foreground&quot;</span>/&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">TextView</span></span></span><br><span class=\"line\"><span class=\"tag\">                <span class=\"attr\">android:id</span>=<span class=\"string\">&quot;@+id/linearTextView5&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                <span class=\"attr\">android:layout_width</span>=<span class=\"string\">&quot;wrap_content&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                <span class=\"attr\">android:layout_height</span>=<span class=\"string\">&quot;wrap_content&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                <span class=\"attr\">android:text</span>=<span class=\"string\">&quot;Second TextView&quot;</span>/&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">RelativeLayout</span></span></span><br><span class=\"line\"><span class=\"tag\">                <span class=\"attr\">android:id</span>=<span class=\"string\">&quot;@+id/relativeContainer5&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                <span class=\"attr\">android:layout_width</span>=<span class=\"string\">&quot;wrap_content&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                <span class=\"attr\">android:layout_height</span>=<span class=\"string\">&quot;wrap_content&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                <span class=\"attr\">android:background</span>=<span class=\"string\">&quot;@color/purple_500&quot;</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">TextView</span></span></span><br><span class=\"line\"><span class=\"tag\">                    <span class=\"attr\">android:id</span>=<span class=\"string\">&quot;@+id/relativeTextView6&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                    <span class=\"attr\">android:layout_width</span>=<span class=\"string\">&quot;wrap_content&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                    <span class=\"attr\">android:layout_height</span>=<span class=\"string\">&quot;wrap_content&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                    <span class=\"attr\">android:text</span>=<span class=\"string\">&quot;Thired TextView&quot;</span>/&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">RelativeLayout</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">LinearLayout</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">androidx.constraintlayout.widget.ConstraintLayout</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">FrameLayout</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:id</span>=<span class=\"string\">&quot;@+id/frameContainer2&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:layout_width</span>=<span class=\"string\">&quot;100dp&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:layout_height</span>=<span class=\"string\">&quot;100dp&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:background</span>=<span class=\"string\">&quot;@color/teal_200_30&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">app:layout_constraintEnd_toEndOf</span>=<span class=\"string\">&quot;parent&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">app:layout_constraintBottom_toBottomOf</span>=<span class=\"string\">&quot;parent&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">androidx.constraintlayout.widget.ConstraintLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>root Container 를 부모 레이아웃으로 삼아 다양한 depth 의 View 가 쌓여져 있고, 이는 아래처럼 그래프로 나타낼 수 있다.</p>\n<img src=\"/Team-Blog/2021/05/19/2021-05-19%20Android%20UI%20Rendering%20Optimization%20Part%201/UntitledDiagram.png\" class=\"\" title=\"[View Tree Example]\">\n\n<p>각각의 View, ViewGroup에 onLayout 시점을 포착할 수 있는 코드를 구현해, 어느 순서로 View 가 그려지는지 확인해보자.</p>\n<blockquote>\n<p>doOnLayout, doOnDraw, doOnXXX 등을 통해 원하는 라이프사이클 시점을 포착할 수 있다.</p>\n</blockquote>\n<h3 id=\"OnLayout-호출로-순서-보기\"><a href=\"#OnLayout-호출로-순서-보기\" class=\"headerlink\" title=\"OnLayout 호출로 순서 보기\"></a>OnLayout 호출로 순서 보기</h3><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">linearContainer4.doOnLayout &#123;</span><br><span class=\"line\">    println(<span class=\"string\">&quot;linearContainer4 doOnLayout&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">constraintContainer2.doOnLayout &#123;</span><br><span class=\"line\">    println(<span class=\"string\">&quot;ConstraintContainer2 doOnLayout&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">constraintTextView3.doOnLayout &#123;</span><br><span class=\"line\">    println(<span class=\"string\">&quot;constraintTextView3 doOnLayout&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">root1.doOnLayout &#123;</span><br><span class=\"line\">    println(<span class=\"string\">&quot;root1 doOnLayout&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">relativeContainer5.doOnLayout &#123;</span><br><span class=\"line\">    println(<span class=\"string\">&quot;relativeContainer5 doOnLayout&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">relativeTextView6.doOnLayout &#123;</span><br><span class=\"line\">    println(<span class=\"string\">&quot;relativeTextView6 doOnLayout&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">linearImageView5.doOnLayout &#123;</span><br><span class=\"line\">    println(<span class=\"string\">&quot;linearImageView5 doOnLayout&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">linearTextView5.doOnLayout &#123;</span><br><span class=\"line\">    println(<span class=\"string\">&quot;linearTextView5 doOnLayout&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">frameContainer2.doOnLayout &#123;</span><br><span class=\"line\">    println(<span class=\"string\">&quot;frameContainer2 doOnLayout&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<img src=\"/Team-Blog/2021/05/19/2021-05-19%20Android%20UI%20Rendering%20Optimization%20Part%201/image.png\" class=\"\" title=\"[onLayout Log]\">\n\n<p>onLayout 시점에는 트리구조로 이루어진 View &amp; ViewGroup 이 <strong>후위순회</strong>를 하며 <strong>측정이 된다</strong>는 것을 알 수 있다.</p>\n<h3 id=\"실험을-통해-알게-된-결론\"><a href=\"#실험을-통해-알게-된-결론\" class=\"headerlink\" title=\"실험을 통해 알게 된 결론\"></a>실험을 통해 알게 된 결론</h3><p>Layout 내에 존재하는 Chile View가 lifecycle 를 거치면서 크기가 측정되는 순서와, 그려지는 순서는 다르다. </p>\n<ol>\n<li>Child View 들의 크기가 정해지고 Parent View 가 그 측정값을 알아야지 자신의 크기를 정할 수 있는 것이고, <code>(Layout 단계)</code></li>\n<li>도화지가 준비되어야 그림을 그릴 수 있듯이, Parent View 가 먼저 그려져야 Child View 가 그려질 수 있기 때문이다. <code>(Draw 단계)</code></li>\n</ol>\n<h2 id=\"Extra-Info\"><a href=\"#Extra-Info\" class=\"headerlink\" title=\"Extra Info\"></a>Extra Info</h2><h3 id=\"layout-weight-의-배신\"><a href=\"#layout-weight-의-배신\" class=\"headerlink\" title=\"layout_weight 의 배신\"></a><strong><code>layout_weight</code> 의 배신</strong></h3><p>Linear Layout 의 layout_weight 속성을 사용하는 경우 자식 뷰는 두번의 Measure pass가 필요하기 때문에 많은 비용이 소모된다. </p>\n<p>layout_weight는 단순히 비율을 나누어 공간을 차지하는 것이 아닌, 부모의 View가 그려지고 나서 남은 공간이 얼마만큼인지, 다른 View들이 그려지고 나서 다시한번 남은공간도 계산하고 나서 자기 자신을 그리기 때문에 지속적인 계산이 일어나게 된다. </p>\n<p>복잡한 View의 계산을 피하기 위해 Releative Layout &amp; Constraint Layout을 권하는 것이다.</p>\n<h3 id=\"Overdraw-를-피하는-방법\"><a href=\"#Overdraw-를-피하는-방법\" class=\"headerlink\" title=\"Overdraw 를 피하는 방법\"></a><strong>Overdraw 를 피하는 방법</strong></h3><p>OverDraw를 피하는 방법 중, <strong>사용자에게 보여지지 않는 Layout의 Background 색을 제거</strong>하면 성능 향상에 도움이 된다는 글이 많이 존재한다. </p>\n<p>하지만 어째서 배경 색을 지우는 것만으로도 성능이 크게 향상될 수 있다는 것일까?</p>\n<p>Layout에 Background를 제거한 후 디버깅을 해보면 View <strong>Lifecycle의 onDraw를 거치지 않음</strong>을 알 수 있다. UI 렌더링 시 가장 비용이 많이 드는 부분이 onDraw(GPU에 업로드 하는 과정) 인데, 이 부분이 skip 되니 성능이 향상되는건 당연한 부분일 것이다. </p>\n<hr>\n<p>여기까지 View의 생명주기, View가 그려지는 과정에 대해 알아보았다. </p>\n<p>다음 글에서는 View 상위에서 그려지는 요소인 Window, Surface, Canvas에 대해 소개하고, 소프트웨어 레벨에서 어떻게 하드웨어 레벨까지 동기화 되는지 분석하고, 현재 사용하는 하드웨어 모델 기반 렌더링에 대해 소개하도록 하겠다.</p>\n","site":{"data":{}},"excerpt":"<article class=\"message message-immersive is-primary\">\n    <div class=\"message-body\">\n        <i class=\"fas fa-pen-fancy mr-2\"></i>Writers<br>\n        by 김남훈 @Naver<br>\n        by 배희성 @RocketPunch<br>\n        by 송시영 @SmartStudy<br>\n        by 이기정 @BankSalad<br>\n        by 정세희 @BankSalad<br>\n        by 최소영 @BankSalad\n    </div>\n</article>","more":"<p>우리는 안드로이드 개발자로 있으면서 기본적인 것들을 놓치곤한다. 안드로이드에서 가장 중요한것은 사용자에게 보여지는 UI와 UX이다. 이를 위해서 안드로이드 개발자가 해야할 일은 UI를 이쁘게 요구사항에 맞게 그리고, 지연없는 UI로딩을 통해 UI를 그리는 것이다.</p>\n<p>글을 작성하다 보니 문득 든 생각이 있었다. 과연 우리가 안드로이드에서 UI를 그릴 때 정확하게 방법을 알고 View를 그리는 코드를 작성하고 있었을까? 나 스스로도 그렇지 않다라는 생각이 들었고, 궁금증이 생겨 ADD 멤버분들과 함께 글을 정리해보았다.</p>\n<h2 id=\"Android-View\"><a href=\"#Android-View\" class=\"headerlink\" title=\"Android View\"></a>Android View</h2><p>안드로이드 개발자라면 한번쯤은 들어봤을 법한, 컴포넌트들이 있다. 바로 아래의 녀석들이다.</p>\n<img src=\"/Team-Blog/2021/05/19/2021-05-19%20Android%20UI%20Rendering%20Optimization%20Part%201/7AGranC.png\" class=\"\" title=\"[Android Views]\">\n\n<p>안드로이드의 다양한 컴포넌트들은 다음과 같이 <strong>View</strong>라는 녀석을 상속받아서 만들어졌다. </p>\n<h3 id=\"View-amp-ViewGroup\"><a href=\"#View-amp-ViewGroup\" class=\"headerlink\" title=\"View &amp; ViewGroup\"></a>View &amp; ViewGroup</h3><p>간단히 개념만 잡고 넘어가보도록 해보자. 안드로이드에서 화면을 나누는 두가지 부류는 View와 ViewGroup 두가지로 나눌 수 있다.</p>\n<img src=\"/Team-Blog/2021/05/19/2021-05-19%20Android%20UI%20Rendering%20Optimization%20Part%201/EzHZMUm.png\" class=\"\" title=\"[View &amp; ViewGroup]\">\n\n<p><strong>View</strong>는 Activity, 즉 한 화면에서 화면을 구성하는 최소 단위의 개념이다. 또다른 말로는 위젯이라고 하는데, 이 View를 상속받아 구현되는 수많은 요소들이 존재한다. 대표적으로 ImageView, TextView, Button과 같은 녀석이 있다. 위젯이나 노티피케이션 위젯과 같이 사용성이 특수한 경우 RemoteView를 이용하여 구현을 해야하는 경우도 있는데, 여기서는 이에 대한 설명은 생략하겠다.</p>\n<p><strong>ViewGroup</strong>은 View를 상속받아 구현된 클래스이다. 다른말로는 레이아웃이라고 하며, View를 N개 담을 수 있는 녀석이다. 대표적으로 LinearLayout, FrameLayout, RelativeLayout, ConsraintLayout이 있다.</p>\n<p>이러한 방식으로 View, ViewGroup은 Java, 또는 Kotlin코드로 구성될 수 있지만, 더 쉬운 방법으로 Mark-Up 랭귀지를 이용하여 구성도 가능하다. 안드로이드 프로그래밍에서는 XML이라는 마크업 랭귀지를 이용하는데, 결국 이도 XML Parser를 통해 파싱되어 Java코드로 변환되어진다.</p>\n<p>안드로이드 개발자들은 어플리케이션의 좋은 성능을 낼 수 있는 방법과, 올바른 방법으로 개발을 하기 위해서라도 View가 그려지는 과정과 생명주기에 대해 잘 알고 있어야 한다. 이를 위해서 먼저 View가 어떤 생명주기를 갖는지 보도록하자.</p>\n<h2 id=\"View-Life-Cycle\"><a href=\"#View-Life-Cycle\" class=\"headerlink\" title=\"View Life-Cycle\"></a>View Life-Cycle</h2><p>상용화 하는 어플리케이션을 만들수록, 우리가 만들어나가는 View는 고도화 될 필요가 있다. 특히 View, ViewGroup을 기반으로 한 컴포넌트를 구성하게 될 때, 우리는 <code>커스텀 뷰</code>라는 것을만들게 된다. 커스텀 뷰를 만들게 될 때, 만들면 만들수록 점점 뷰를 그려지는 방식은 복잡해지고, 성능적인 부분을 충족하기 위해 최적화할 수 있는 방법을 고민해야한다. 이를 위해서는 View의 생명주기에 대해서도 잘 알고 있어야 한다.</p>\n<p>안드로이드 컴포넌트, Fragment와 마찬가지로 View도 생명주기를 갖고있다.</p>\n<p>View의 생명주기는 아래와 같이 도식화 하여 표현 가능하다,</p>\n<img src=\"/Team-Blog/2021/05/19/2021-05-19%20Android%20UI%20Rendering%20Optimization%20Part%201/qu5Mr6x.png\" class=\"\" title=\"[View Life Cycle]\">\n\n\n<p>생명주기에 대해 몇 가지 특징적으로 나눌 수 있는 부분이 있다.</p>\n<h3 id=\"Constructors\"><a href=\"#Constructors\" class=\"headerlink\" title=\"Constructors\"></a>Constructors</h3><p>Programmatically하게 View를 생성하는 방법이다. View를 생성하는 방법은 여러가지가 존재하지만, 가장 직관적인 방법 중 하나이다.</p>\n<p>생성자의 종류는 여러가지가 존재한다.</p>\n<ul>\n<li><code>View(Context context) </code></li>\n<li><code>View(Context context, @Nullable AttributeSet attrs) </code></li>\n<li><code>View(Context context, @Nullable AttributeSet attrs, int defStyleAttr) </code></li>\n<li><code>View(Context context, @Nullable AttributeSet attrs, int defStyleAttr, int defStyleRes)</code></li>\n</ul>\n<h3 id=\"Attachment-Detachment\"><a href=\"#Attachment-Detachment\" class=\"headerlink\" title=\"Attachment / Detachment\"></a>Attachment / Detachment</h3><ul>\n<li><strong>Attachment</strong>는 Window에서 붙었음을 의미한다.</li>\n<li><strong>Detachment</strong>는 Window에서 떼어졌음을 의미한다.</li>\n</ul>\n<p>위 동작이 수행되었음을 받을 수 있는 Callback Function으로 두가지 함수를 각각 제공한다.</p>\n<h3 id=\"onAttachedToWindow\"><a href=\"#onAttachedToWindow\" class=\"headerlink\" title=\"onAttachedToWindow()\"></a>onAttachedToWindow()</h3><p>View가 Window에 붙었을 때 호출된다. 이때부터는 View가 Active하다고 판단되며, 이때부터는 리소스 할당, 파라미터에 대한 계산, 리스너를 부착할 수 있는 준비가 된다.</p>\n<h3 id=\"onDetachedFromWindow\"><a href=\"#onDetachedFromWindow\" class=\"headerlink\" title=\"onDetachedFromWindow()\"></a>onDetachedFromWindow()</h3><p>View가 Window에 떼어졌을 때 호출된다. Window상에서 더 이상 존재하지 않으므로, Inactive하며, 기존에 View에 할당된 리소스를 해제해주어야한다. 해당 콜백함수가 불리는 케이스로는 두가지가 있다.</p>\n<ul>\n<li>ViewGroup에서 View가 제거될 때</li>\n<li>Activity가 <code>finish()</code> 함수를 호출하여 Activity가 Destroyed될 때</li>\n</ul>\n<h3 id=\"onMeasure\"><a href=\"#onMeasure\" class=\"headerlink\" title=\"onMeasure()\"></a>onMeasure()</h3><p>View의 크기를 계산한다. ViewGroup은 하위 노드인 View에 대한 크기를 측정하고, 관계성을 파악 후 자신의 크기를 계산한다. 따라서, 하위 노드가 ViewGroup에 올바르게 붙었는지 확인해야한다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> * 기본적으로 View의 크기를 측정할 때는 Background의 Dimension Size를 보고 결정한다.</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> * 현재 계산된 크기를 비교하여 Background크기보다 작은경우, Background크기를 반환하여 크기를 반환한다.</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> widthMeasureSpec 부모뷰에 의해 적용된 수평 공간</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> heightMeasureSpec 부모뷰에 의해 적용된 수직 공간</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onMeasure</span><span class=\"params\">(<span class=\"keyword\">int</span> widthMeasureSpec, <span class=\"keyword\">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class=\"line\">  setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),</span><br><span class=\"line\">                       getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"MeasureSpec\"><a href=\"#MeasureSpec\" class=\"headerlink\" title=\"MeasureSpec\"></a>MeasureSpec</h3><p>ViewGroup의 하위 컴포넌트인 View에서는 크기에 대한 제약을 정하기 위해 스펙을 정하게 되는데, 이를 MeasureSpec을 통해 해결한다. MeasureSpec은 Width, Height에 대한 스펙이며, 크기와 모드로 나뉜다.</p>\n<p>그리고 세가지의 값으로 나뉜다.</p>\n<ul>\n<li><p><strong>MeasureSpec.EXACTLY</strong> : 부모뷰가 자식뷰의 정확한 크기를 결정한다. 자식뷰의 사이즈와 관계없이 주어진 경계내에서 사이즈가 결정된다.</p>\n</li>\n<li><p><strong>MeasureSpec.AT_MOST</strong> : 자식뷰는 지정된 크기까지 원하는 만큼 커질 수 있다.</p>\n</li>\n<li><p><strong>MeasureSpec.UNSPECIFIED</strong> : 부모뷰가 자식뷰에 제한을 두지 않기 때문에, 자식뷰는 원하는 크기가 될 수 있다.</p>\n</li>\n</ul>\n<p>아래와 같은 코드로 체크할 수 있다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onMeasure</span><span class=\"params\">(<span class=\"keyword\">int</span> widthMeasureSpec, <span class=\"keyword\">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> mode = MeasureSpec.getMode(heightMeasureSpec)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mode != MeasureSpec.EXACTLY) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// Logic</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"onLayout\"><a href=\"#onLayout\" class=\"headerlink\" title=\"onLayout()\"></a>onLayout()</h3><p>계산이 된 이후에는 onLayout 함수를 통해 계산된 View를 Window에 배치한다. </p>\n<p>View와 같은 경우 아래 코드를 기반으로 상속받아 처리한다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onLayout</span><span class=\"params\">(<span class=\"keyword\">boolean</span> changed, <span class=\"keyword\">int</span> left, <span class=\"keyword\">int</span> top, <span class=\"keyword\">int</span> right, <span class=\"keyword\">int</span> bottom)</span></span></span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"onDraw\"><a href=\"#onDraw\" class=\"headerlink\" title=\"onDraw()\"></a>onDraw()</h3><p>onLayout에서 View에 대한 크기 계산 및 배치가 완료되었으므로, 이를 기반으로 onDraw에서는 Canvas라는 인스턴스를 넘겨주며, 해당 Canvas 인스턴스는 DisplayList에 그릴 데이터를 담아서 넘겨준다. onDraw는 한프레임을 그리는 함수기 때문에 반복적으로 호출이된다. 특이하게 여러번 호출되고 CPU연산이 되는 곳이기 떄문에, 객체를 만들어서 사용하는 것은 금기시한다.</p>\n<p>View가 draw를 하는 기준은 두가지로 나눌 수 있다.</p>\n<ul>\n<li>View의 모양이 변형이 생겼을 때 - invalidate()</li>\n<li>View의 경계에 변화가 생겼을 때 - requestLayout()</li>\n</ul>\n<h3 id=\"Invalidate\"><a href=\"#Invalidate\" class=\"headerlink\" title=\"Invalidate()\"></a>Invalidate()</h3><p>invalidate 함수는 직접적으로도 호출이 가능하지만, 상위에서 View에서 여러 View내에 상태가 변형이 되었을 때 호출을한다.</p>\n<p>직접 코드를 까보는 것이 아무래도 좋으니, 본인이 확인한 invalidate를 호출하는 시점을 리스트업 해본다.</p>\n<ul>\n<li><strong>drawableStateChanged</strong> - Background, 포커스 되었을 때 나타다는 하이라이트, Foreground Drawable에 대해 변경점을 체크하며, 상태가 존재하면 변경된 것으로 판단</li>\n<li><strong>setDefaultFocusHighlight</strong> - 포커스 되었을 때 하이라이트를 기본적으로 세팅해줌. 무조건 새로 그림</li>\n<li><strong>setForeground</strong></li>\n<li><strong>setScrollIndicators</strong> - indicator의 색상과 마스크를 설정한다. 기존 마스크와 머지하고, 플래그를 체크하여 업데이트 된 경우 새로 그린다.</li>\n<li><strong>setAutoFilled</strong></li>\n<li><strong>requestAccessibilityFocus</strong> - 포커스를 쓸 수 있는 권한을 요청할 때  View에대한 포커스에 대해서 달라진 점이 생기면 플래그로 비교하여 처리</li>\n<li><strong>setForceDarkAllowed</strong> - 어둡게 처리시 필요한 함수</li>\n<li><strong>onDrawScrollBars</strong> - 스크롤바에 움직임이 생길 시</li>\n<li><strong>setLayerPaint</strong> - 색상에 대한 변형이 있을 때 처리한다. (alpha, Xfermode, colorFilter)</li>\n</ul>\n<h3 id=\"requestLayout\"><a href=\"#requestLayout\" class=\"headerlink\" title=\"requestLayout()\"></a>requestLayout()</h3><p>뷰의 경계가 변경되면 무조건 호출돼야하는 함수이다. 이를 통해 재 계산을 거쳐 onMeasure =&gt; onLayout을 거친다.</p>\n<h2 id=\"View-State-Save-Restore\"><a href=\"#View-State-Save-Restore\" class=\"headerlink\" title=\"View State Save/Restore\"></a>View State Save/Restore</h2><p>View는 Activity의 상태에 따라 상태를 저장/복원해야 할 필요가있다. 이를 위한 두가지의 함수를 제공한다.</p>\n<h3 id=\"onSaveInstanceState-gt-Parcelable\"><a href=\"#onSaveInstanceState-gt-Parcelable\" class=\"headerlink\" title=\"onSaveInstanceState() -&gt; Parcelable\"></a>onSaveInstanceState() -&gt; Parcelable</h3><p>상태를 저장하기 위한 함수에서는 상태를 저장할 때 각 View에 대한 고유 ID를 필요로한다. 저장을 할때는 Bundle 인스턴스를 생성하여 저장하면 된다.</p>\n<p>Bundle은 Parcelable을 구현한 클래스로, 적절하게 저장하여 처리할 수 있다.</p>\n<p>아래 코드를 참고하자.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Parcelable <span class=\"title\">onSaveInstanceState</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  Bundle bundle = <span class=\"keyword\">new</span> Bundle();</span><br><span class=\"line\">  <span class=\"comment\">// The vars you want to save - in this instance a string and a boolean</span></span><br><span class=\"line\">  String someString = <span class=\"string\">&quot;something&quot;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">boolean</span> someBoolean = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">  State state = <span class=\"keyword\">new</span> State(<span class=\"keyword\">super</span>.onSaveInstanceState(), someString, someBoolean);</span><br><span class=\"line\">  bundle.putParcelable(State.STATE, state);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> bundle;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>State라는 녀석이 보이는데, 해당 State는 직접 구현해주어야 하는 클래스가 될 수 있다. View에대한 상태를 저장할 수 있는 어떤것이든 상관없다.</p>\n<h3 id=\"onRestoreInstanceState-Parcelable-state\"><a href=\"#onRestoreInstanceState-Parcelable-state\" class=\"headerlink\" title=\"onRestoreInstanceState(Parcelable state)\"></a>onRestoreInstanceState(Parcelable state)</h3><p>해당함수를 오버라이딩하면 다시 Paracleable로 된 인스턴스를 받아서 처리가 가능하다. Parcelable을 그대로 쓸수는 없으니, 구현체에 해당하는 인스턴스로 캐스팅하여 처리하면 된다.</p>\n<p>아래는 예시이다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onRestoreInstanceState</span><span class=\"params\">(Parcelable state)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (state <span class=\"keyword\">instanceof</span> Bundle) &#123;</span><br><span class=\"line\">    Bundle bundle = (Bundle) state;</span><br><span class=\"line\">    State customViewState = (State) bundle.getParcelable(State.STATE);</span><br><span class=\"line\">    <span class=\"comment\">// The vars you saved - do whatever you want with them</span></span><br><span class=\"line\">    String someString = customViewState.getText();</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> someBoolean = customViewState.isSomethingShowing());</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.onRestoreInstanceState(customViewState.getSuperState());</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// Stops a bug with the wrong state being passed to the super</span></span><br><span class=\"line\">  <span class=\"keyword\">super</span>.onRestoreInstanceState(BaseSavedState.EMPTY_STATE); </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"View가-그려지는-순서\"><a href=\"#View가-그려지는-순서\" class=\"headerlink\" title=\"View가 그려지는 순서\"></a>View가 그려지는 순서</h2><p>View가 렌더링 될 때, 상위수준의 <code>ViewGroup</code> 에서부터 하위 자식인 <code>View</code> 로 내려가면서 <code>Measure -&gt; Layout -&gt; Draw</code> 를 거치게 된다.</p>\n<h3 id=\"Measure-Pass\"><a href=\"#Measure-Pass\" class=\"headerlink\" title=\"Measure Pass\"></a>Measure Pass</h3><p>측정 패스는 measure(int, int) 로 구현되며 뷰 트리의 탑-다운으로 순회한다. 각 뷰는 트리를 재귀하는 동안 측정한 수치를 트리 아래로 보낸다.</p>\n<p>측정이 모두 끝나면 모든 뷰는 측정한 값을 가지게 된다. 두번째 단계 또한 탑-다운으로 layout(int, int, int) 에서 일어난다. 각각의 부모는 측정단계에서 계산된 사이즈를 사용해서 자신의 모든 자식을 배치한다.</p>\n<p>View 의 크기는 2가지로 정의될 수 있다.</p>\n<ul>\n<li><strong>measured width &amp; measured height</strong> : 뷰가 부모뷰 크기의 범위 내에서 가지고 싶어하는 너비와 높이이다.</li>\n<li><strong>drawing width &amp; drawing height</strong> : 뷰의 실제 너비와 높이로 뷰를 그리기 위해서 사용한다.</li>\n</ul>\n<p>View의 Padding, Margin 등을 고려하면 원하는 크기에서 Padding 및 Margin 값을 빼야 하기 때문에 Measured Width, Measured Height 는 Drawing Width, Drawing Height 와 다를 수 있다.</p>\n<h3 id=\"Layout-Pass\"><a href=\"#Layout-Pass\" class=\"headerlink\" title=\"Layout Pass\"></a>Layout Pass</h3><p>레이아웃을 시작하려면, requestLayout() 를 호출한다. 일반적으로 현재 범위내에 더이상 맞지 않을때 자체적으로 뷰에 의해 호출된다.  이 과정에서도 top-down 형식의 탐색이 일어나게 되는데, 이 때는 각각의 ViewGroup이 Measure 단계에서 측정된 크기를 이용해서 하위속성들의 위치를 결정한다.</p>\n<h3 id=\"Draw-Pass\"><a href=\"#Draw-Pass\" class=\"headerlink\" title=\"Draw Pass\"></a>Draw Pass</h3><p>GPU에게 명령을 내려주는 단계이다. 그려야 할 객체들의 리스트를 GPU에게 보내기 위해 View Tree에서 각 객체의 대한 Canvas 객체가 생성된다. 이 때, 이전 1,2단계를 거쳐 결정된 객체들의 크기와 위치에 대한 정보가 들어가게 된다.</p>\n<p>만약 View가 변할 때, 시스템에게 알려주기 위한 2가지 방법이 존재하는데, <code>Invaliadate()</code>가 호출 될 때에는 draw부터 다시 작업이 시행되고, <code>requestLayout()</code>이 호출될 때에는 measure -&gt; layout -&gt; draw 단계를 다시 거치게 된다.</p>\n<p>코드로 보면서 어떤식으로 View가 그려지는지 한번 보도록하자.</p>\n<h3 id=\"실험을-통한-View-Rendering-Process-관찰\"><a href=\"#실험을-통한-View-Rendering-Process-관찰\" class=\"headerlink\" title=\"실험을 통한 View Rendering Process 관찰\"></a>실험을 통한 View Rendering Process 관찰</h3><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">androidx.constraintlayout.widget.ConstraintLayout</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:id</span>=<span class=\"string\">&quot;@+id/root1&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">xmlns:android</span>=<span class=\"string\">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">xmlns:app</span>=<span class=\"string\">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">xmlns:tools</span>=<span class=\"string\">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:layout_width</span>=<span class=\"string\">&quot;match_parent&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:layout_height</span>=<span class=\"string\">&quot;match_parent&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">tools:context</span>=<span class=\"string\">&quot;.MainActivity&quot;</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">androidx.constraintlayout.widget.ConstraintLayout</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:id</span>=<span class=\"string\">&quot;@+id/constraintContainer2&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:layout_width</span>=<span class=\"string\">&quot;400dp&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:layout_height</span>=<span class=\"string\">&quot;400dp&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:background</span>=<span class=\"string\">&quot;@color/teal_200&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">app:layout_constraintTop_toTopOf</span>=<span class=\"string\">&quot;parent&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">app:layout_constraintStart_toStartOf</span>=<span class=\"string\">&quot;parent&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">app:layout_constraintEnd_toEndOf</span>=<span class=\"string\">&quot;parent&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">app:layout_constraintBottom_toBottomOf</span>=<span class=\"string\">&quot;parent&quot;</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">TextView</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">android:id</span>=<span class=\"string\">&quot;@+id/constraintTextView3&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">android:layout_width</span>=<span class=\"string\">&quot;wrap_content&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">android:layout_height</span>=<span class=\"string\">&quot;wrap_content&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">android:text</span>=<span class=\"string\">&quot;First TextView&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">app:layout_constraintTop_toTopOf</span>=<span class=\"string\">&quot;parent&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">app:layout_constraintStart_toStartOf</span>=<span class=\"string\">&quot;parent&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">LinearLayout</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">android:id</span>=<span class=\"string\">&quot;@+id/linearContainer4&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">android:layout_width</span>=<span class=\"string\">&quot;200dp&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">android:layout_height</span>=<span class=\"string\">&quot;200dp&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">android:orientation</span>=<span class=\"string\">&quot;vertical&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">app:layout_constraintTop_toTopOf</span>=<span class=\"string\">&quot;parent&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">app:layout_constraintEnd_toEndOf</span>=<span class=\"string\">&quot;parent&quot;</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">ImageView</span></span></span><br><span class=\"line\"><span class=\"tag\">                <span class=\"attr\">android:id</span>=<span class=\"string\">&quot;@+id/linearImageView5&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                <span class=\"attr\">android:layout_width</span>=<span class=\"string\">&quot;wrap_content&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                <span class=\"attr\">android:layout_height</span>=<span class=\"string\">&quot;wrap_content&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                <span class=\"attr\">android:background</span>=<span class=\"string\">&quot;@drawable/ic_launcher_foreground&quot;</span>/&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">TextView</span></span></span><br><span class=\"line\"><span class=\"tag\">                <span class=\"attr\">android:id</span>=<span class=\"string\">&quot;@+id/linearTextView5&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                <span class=\"attr\">android:layout_width</span>=<span class=\"string\">&quot;wrap_content&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                <span class=\"attr\">android:layout_height</span>=<span class=\"string\">&quot;wrap_content&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                <span class=\"attr\">android:text</span>=<span class=\"string\">&quot;Second TextView&quot;</span>/&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">RelativeLayout</span></span></span><br><span class=\"line\"><span class=\"tag\">                <span class=\"attr\">android:id</span>=<span class=\"string\">&quot;@+id/relativeContainer5&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                <span class=\"attr\">android:layout_width</span>=<span class=\"string\">&quot;wrap_content&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                <span class=\"attr\">android:layout_height</span>=<span class=\"string\">&quot;wrap_content&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                <span class=\"attr\">android:background</span>=<span class=\"string\">&quot;@color/purple_500&quot;</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">TextView</span></span></span><br><span class=\"line\"><span class=\"tag\">                    <span class=\"attr\">android:id</span>=<span class=\"string\">&quot;@+id/relativeTextView6&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                    <span class=\"attr\">android:layout_width</span>=<span class=\"string\">&quot;wrap_content&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                    <span class=\"attr\">android:layout_height</span>=<span class=\"string\">&quot;wrap_content&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                    <span class=\"attr\">android:text</span>=<span class=\"string\">&quot;Thired TextView&quot;</span>/&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">RelativeLayout</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">LinearLayout</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">androidx.constraintlayout.widget.ConstraintLayout</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">FrameLayout</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:id</span>=<span class=\"string\">&quot;@+id/frameContainer2&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:layout_width</span>=<span class=\"string\">&quot;100dp&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:layout_height</span>=<span class=\"string\">&quot;100dp&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:background</span>=<span class=\"string\">&quot;@color/teal_200_30&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">app:layout_constraintEnd_toEndOf</span>=<span class=\"string\">&quot;parent&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">app:layout_constraintBottom_toBottomOf</span>=<span class=\"string\">&quot;parent&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">androidx.constraintlayout.widget.ConstraintLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>root Container 를 부모 레이아웃으로 삼아 다양한 depth 의 View 가 쌓여져 있고, 이는 아래처럼 그래프로 나타낼 수 있다.</p>\n<img src=\"/Team-Blog/2021/05/19/2021-05-19%20Android%20UI%20Rendering%20Optimization%20Part%201/UntitledDiagram.png\" class=\"\" title=\"[View Tree Example]\">\n\n<p>각각의 View, ViewGroup에 onLayout 시점을 포착할 수 있는 코드를 구현해, 어느 순서로 View 가 그려지는지 확인해보자.</p>\n<blockquote>\n<p>doOnLayout, doOnDraw, doOnXXX 등을 통해 원하는 라이프사이클 시점을 포착할 수 있다.</p>\n</blockquote>\n<h3 id=\"OnLayout-호출로-순서-보기\"><a href=\"#OnLayout-호출로-순서-보기\" class=\"headerlink\" title=\"OnLayout 호출로 순서 보기\"></a>OnLayout 호출로 순서 보기</h3><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">linearContainer4.doOnLayout &#123;</span><br><span class=\"line\">    println(<span class=\"string\">&quot;linearContainer4 doOnLayout&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">constraintContainer2.doOnLayout &#123;</span><br><span class=\"line\">    println(<span class=\"string\">&quot;ConstraintContainer2 doOnLayout&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">constraintTextView3.doOnLayout &#123;</span><br><span class=\"line\">    println(<span class=\"string\">&quot;constraintTextView3 doOnLayout&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">root1.doOnLayout &#123;</span><br><span class=\"line\">    println(<span class=\"string\">&quot;root1 doOnLayout&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">relativeContainer5.doOnLayout &#123;</span><br><span class=\"line\">    println(<span class=\"string\">&quot;relativeContainer5 doOnLayout&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">relativeTextView6.doOnLayout &#123;</span><br><span class=\"line\">    println(<span class=\"string\">&quot;relativeTextView6 doOnLayout&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">linearImageView5.doOnLayout &#123;</span><br><span class=\"line\">    println(<span class=\"string\">&quot;linearImageView5 doOnLayout&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">linearTextView5.doOnLayout &#123;</span><br><span class=\"line\">    println(<span class=\"string\">&quot;linearTextView5 doOnLayout&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">frameContainer2.doOnLayout &#123;</span><br><span class=\"line\">    println(<span class=\"string\">&quot;frameContainer2 doOnLayout&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<img src=\"/Team-Blog/2021/05/19/2021-05-19%20Android%20UI%20Rendering%20Optimization%20Part%201/image.png\" class=\"\" title=\"[onLayout Log]\">\n\n<p>onLayout 시점에는 트리구조로 이루어진 View &amp; ViewGroup 이 <strong>후위순회</strong>를 하며 <strong>측정이 된다</strong>는 것을 알 수 있다.</p>\n<h3 id=\"실험을-통해-알게-된-결론\"><a href=\"#실험을-통해-알게-된-결론\" class=\"headerlink\" title=\"실험을 통해 알게 된 결론\"></a>실험을 통해 알게 된 결론</h3><p>Layout 내에 존재하는 Chile View가 lifecycle 를 거치면서 크기가 측정되는 순서와, 그려지는 순서는 다르다. </p>\n<ol>\n<li>Child View 들의 크기가 정해지고 Parent View 가 그 측정값을 알아야지 자신의 크기를 정할 수 있는 것이고, <code>(Layout 단계)</code></li>\n<li>도화지가 준비되어야 그림을 그릴 수 있듯이, Parent View 가 먼저 그려져야 Child View 가 그려질 수 있기 때문이다. <code>(Draw 단계)</code></li>\n</ol>\n<h2 id=\"Extra-Info\"><a href=\"#Extra-Info\" class=\"headerlink\" title=\"Extra Info\"></a>Extra Info</h2><h3 id=\"layout-weight-의-배신\"><a href=\"#layout-weight-의-배신\" class=\"headerlink\" title=\"layout_weight 의 배신\"></a><strong><code>layout_weight</code> 의 배신</strong></h3><p>Linear Layout 의 layout_weight 속성을 사용하는 경우 자식 뷰는 두번의 Measure pass가 필요하기 때문에 많은 비용이 소모된다. </p>\n<p>layout_weight는 단순히 비율을 나누어 공간을 차지하는 것이 아닌, 부모의 View가 그려지고 나서 남은 공간이 얼마만큼인지, 다른 View들이 그려지고 나서 다시한번 남은공간도 계산하고 나서 자기 자신을 그리기 때문에 지속적인 계산이 일어나게 된다. </p>\n<p>복잡한 View의 계산을 피하기 위해 Releative Layout &amp; Constraint Layout을 권하는 것이다.</p>\n<h3 id=\"Overdraw-를-피하는-방법\"><a href=\"#Overdraw-를-피하는-방법\" class=\"headerlink\" title=\"Overdraw 를 피하는 방법\"></a><strong>Overdraw 를 피하는 방법</strong></h3><p>OverDraw를 피하는 방법 중, <strong>사용자에게 보여지지 않는 Layout의 Background 색을 제거</strong>하면 성능 향상에 도움이 된다는 글이 많이 존재한다. </p>\n<p>하지만 어째서 배경 색을 지우는 것만으로도 성능이 크게 향상될 수 있다는 것일까?</p>\n<p>Layout에 Background를 제거한 후 디버깅을 해보면 View <strong>Lifecycle의 onDraw를 거치지 않음</strong>을 알 수 있다. UI 렌더링 시 가장 비용이 많이 드는 부분이 onDraw(GPU에 업로드 하는 과정) 인데, 이 부분이 skip 되니 성능이 향상되는건 당연한 부분일 것이다. </p>\n<hr>\n<p>여기까지 View의 생명주기, View가 그려지는 과정에 대해 알아보았다. </p>\n<p>다음 글에서는 View 상위에서 그려지는 요소인 Window, Surface, Canvas에 대해 소개하고, 소프트웨어 레벨에서 어떻게 하드웨어 레벨까지 동기화 되는지 분석하고, 현재 사용하는 하드웨어 모델 기반 렌더링에 대해 소개하도록 하겠다.</p>"},{"title":"Introduce Android UI Rendering Principle and View Optimization Part 2","date":"2021-05-18T17:00:00.000Z","cover":"https://androiddeepdive.github.io/Team-Blog/images/cover_ui_rendering.png","_content":"\n<article class=\"message message-immersive is-primary\">\n    <div class=\"message-body\">\n        <i class=\"fas fa-pen-fancy mr-2\"></i>Writers<br>\n        by 김남훈 @Naver<br>\n        by 배희성 @RocketPunch<br>\n        by 송시영 @SmartStudy<br>\n        by 이기정 @BankSalad<br>\n        by 정세희 @BankSalad<br>\n        by 최소영 @BankSalad\n    </div>\n</article>\n\n\n<!-- more -->\n\n저번 포스트에서는 View와 ViewGroup 개념, UI가 그려지는 과정, UI가 그려질 때 View의 생명주기에 대해 보았다. 이번시간에는 UI Rendering 시 화면에 보여질 때 어떤 과정을 거치는지 알아보자.\n\n## UI Rendering\n\n아래 내용은 Google Android Source Document의 [그래픽 아키텍쳐](https://source.android.com/devices/graphics/architecture) 내용을 참고하여 작성되었다.\n\n위와 같은 최적화가 내부적으로 일어나기 위해서는 화면을 그리는 필수요소로, **Window, Surface, Canvas, View** 레이어로 나눠서 처리하게 된다.\n\n### Window\n\n무언가를 **그릴 수 있는 창**(Window)이다. 이 영역에서는 그릴 수 있는 Surface를 들고 있고, 애플리케이션은 WindowManager와 상호작용을 통해 Window를 만들고, Window위에 올려진 Surface를 통해 UI를 그린다.\n\n하나의 화면에서는 여러개의 Window를 가지며, WindowManager를 통해 관리받게 된다. \n\n대표적으로 PhoneWindowManager, DialogWindowManager와 같은 요소가 있다.\n\n## Surface and SurfacHolder\n\n기본적으로 안드로이드에서 모든 화면에 그려지는 요소들은, **Surface**를 통해 처리된다. 안드로이드에서는 Surface와 SurfaceHolder를 통해 그려지는 영역을 제어한다.\n\n### Surface\n\nSurface는 화면에 표시하는 이미지를 앱이 렌더링 할 수 있도록 해준다. 해당 클래스는 Android 1.0 초창기부터 API에 내장되어 있었으며, 안드로이드 온라인 도움말 사이트에는 **Surface** 클래스에 대해서 **Screen Compositor**가 관리하는 하나의 Raw 버퍼를 가리키는 핸들이라고 설명한다.\n\n잘 이해가 안갈테니, 이미지를 함께 보면서 이해 해보도록 하자.\n\n{% asset_img ptHtNno.png [Surface & Surface Flinger] %}\n\n하나의 애플리케이션은 기본적으로 하나의 **Surface**를 가진다.  **BufferQueue**는 그래픽 데이터의 버퍼를 생성하는 요소(생산자)를 표시 데이터 또는 추가 처리를 허용하는 요소(소비자)에 연결한다.\n\n**Suface**는 자주 사용되는 **BufferQueue**를 생성하고(Producer), 버퍼에 데이터를 담아 **SurfaceFlinger**(Consumer)로 전달하여 출력한다. 이를 통해 화면에 drawing을 하여 Application과 상호작용하게 된다.\n\n각 Surface는 **이중 버퍼 렌더링**을 위한 1개 이상 (보통 2개)의 버퍼를 가진다.\n\n#### 이중 버퍼 렌더링(Double Buffer Rendering)\n\n스크린에 출력될 화면 데이터는 **프레임 버퍼**에 저장되는데, 하나의 버퍼만 가지는 경우 이미지가 반복해서 그려지게 되거나, 이미지가 다 그려지지 않아도 화면 주사율 때문에 렌더링을 해야할 때, 다 그려지지 않은 프레임 버퍼가 렌더링이 되어서 이미지가 깜빡이는 Flicker 현상이 나타날 수 있다.\n\n이를 해결하기 위해 프레임 버퍼에 바로 렌더링 하지 않고, 다른 버퍼를 만들어서 그 버퍼에 렌더링을 완료 하고, 다음 프레임 버퍼에 옮기는 방식을 사용하여 Flicker 현상을 해결한다.\n\n### SurfaceFlinger\n\nSurfaceFlinger는 버퍼를 받아들이고 버퍼를 구성하며 버퍼를 디스플레이로 보내는 역할을 한다. SurfaceFlinger는 BufferQueue 및 SurfaceControl을 통해 버퍼를 처리할 수 있다.\n\n 안드로이드 10부터는 **ASurfaceControl**라는 것을 통해 버퍼를 받아들인다.\n\n자세한 내용은 Google Android Source Document의 [SurfaceFlinger 및 WindowManager](https://source.android.com/devices/graphics/surfaceflinger-windowmanager)를 참고하자.\n\n### SurfaceHolder\n\nSurfaceHolder 인터페이스는 앱이 Surface을 수정하고 제어할 수 있게 해준다. 일부 서비스에서는 제어가 필요한 케이스가 있는데, 대표적으로 **SurfaceView, GLSurfaceView**를 사용한 기능이다. 영상처리나 카메라 미리보기 화면을 렌더링할 때 특히 많이 사용한다. 일반 VIew와 달리 onDraw를 호출하는 것이 아닌, Thread를 이용하여 화면에 강제로 그려 처리한다.\n\n### Canvas Rendering\n\n안드로이드에서 모든 그려지는 UI 요소는 대부분은 [OpenGL ES](https://source.android.com/devices/graphics/arch-egl-opengl) 또는 [Vulkan](https://source.android.com/devices/graphics/arch-vulkan)을 사용하여 View를 렌더링한다.\n\n하지만, 예외 요소도 있기 마련이다. 예를들면 2D게임을 구현한다던지, 스트리밍 컨텐츠를 보여주는 플레이어라던지, 카메라 등에서는 캔버스 API를 통해 뷰를 그리는 작업이 이뤄진다. 이를 **Canvas Rendering**이라 한다.\n\nCanvas가 가지는 특징을 정리하면 아래와 같다.\n\n- **onDraw() 재정의**\n- Canvas(그리는 내용) => Paint(그리기 방법)\n- 직접 구현도 가능하고, Drawable를 상속한  BitmapDrawable를 이용하여 그릴 수 있다.\n- 프로젝트에 저장된 이미지 리소스(비트맵 파일)를 확장한다.\n- Drawable 속성을 정의하는  **XML** 리소스(우리가 아는 벡터 파일 변환도 여기 해당!)\n- 도형 Drawable(라운딩 처리 된 사각형, 동그라미 등등등..)\n- NinePatch 드로어블\n- 최종적으로는 SKIA를 통해 캔버스 c++ native API를 호출하여 그린다.\n\n\n\n예전에는 모든 렌더링은 소프트웨어 레벨에서 처리되었다. 지금은 하드웨어 레벨에서 처리되어 최적화되어 구현이 가능하지만, 이러한 방식으로 수동적으로 처리가 가능하다.\n\n안드로이드의 경우 일반적으로 그리기를 프레임워크에 맡겨서 Rendering Process를 거치지만(우리가 알고 있는 `onDraw()` 함수를 통해 그리는 것을 말함), 위에서 언급한 Canvas Rendering의 경우 쓰레드를 이용해 화면에 강제로 그려 원하는 시점에 화면에 그릴 수 있다.\n\n캔버스 구현은 [Skia 그래픽 라이브러리](https://skia.org/)에서 제공한다. 직사각형을 그리고 싶은 경우 적절히 버퍼에 바이트를 설정하는 캔버스 API를 호출한다.\n\nCanvas 인스턴스를 생성할 때는 이에 바탕이 되는 Bitmap 인스턴스를 생성하여 처리한다.\n\nSurface까지 도달하기 위해 어떤 흐름을 타는지 알아보자.\n\n{% asset_img JNfYVx7.png [android canvas drawing] %}\n\n예를 들어, 우리가 View에서 직접 Rect를 생성하여 사각형을 그리고 싶다면, Skia 라이브러리를 호출하여 처리할 수 있다. Skia는 바이트들을 적절하게 버퍼의 형태로 구성한다. 그리고 버퍼가 두 클라이언트에 의해 한번에 업데이트 되는 것을 방지하기 위해, 버퍼에 액세스 하기 위해서는 락을 사용해야 한다. **lockCanvas()**는 버퍼에 락을 걸고 드로잉을 처리하기 위한 Canvas를 리턴한다. 그리고 **unlockCanvasAnsPost()**는 버퍼에 락을 해제하고, 그것을 compositor로 전달한다.\n\n그 과정에서 일어나는 매커니즘은 매우 복잡하지만, 결론은 Surface로 전달 된다.\n\n과거에는 View를 캔버스로 처리했지만, 현재는 범용 3D 엔진을 탑재한 기기들이 늘어나면서, 안드로이드에서 모든 그려지는 UI 요소는 대부분은 [OpenGL ES](https://source.android.com/devices/graphics/arch-egl-opengl) 또는 [Vulkan](https://source.android.com/devices/graphics/arch-vulkan)을 사용하여 View를 렌더링하도록 구성된다. 하지만 이전에 사용하던 API와의 호환성이 중요하기 때문에, 하드웨어 가속 Canvas API가 만들어지게 되었다.\n\n---\n\n지금까지는 그래픽 데이터를 처리하는 과정 및 요소에 대한 내용을 보았다면, 이번에는 해당 데이터를 화면에 직접 보여지는 과정에서 어떤 요소들이 필요하고 어떻게 동작하는지 보도록 하겠다.\n\n## Surface Flinger and Harware Composer\n\n해당글은 [Android Drawing Process 1(App surface, SF Layer)](https://lastyouth.tistory.com/24)를 참고하여 작성하였다.\n\n앞에서 언급했던 **SyrfaceFlinger**에서는 **HWComposer(Hardware Composer)**를 통해 그래픽 데이터를 디바이스 디스플레이에 전송한다.\n\n이를 도식화 하면, 아래와 같이 표현 가능하다.\n\n{% asset_img cK00ybR.png [Surface Flinger and Harware Composer] %}\n\n### Layer Management\n\n여기서 Layer Management는 우리가 앞서 언급한 각 어플리케이션이 갖는 Surface에서 SufraceFlinger에 의해 Layer 형태로 관리된다. 도식화 하면 아래와 같다.\n\n{% asset_img 7990Bf0.png [Layer Management] %}\n\n### Screen Refreshing\n\n디바이스 디스플레이는 특정 주기로 리프레시되며, 일반적으로는 폰이나 테블릿에서는 초당 60프레임의 속도로 리프레시된다. 요즘 나오는 디바이스의 경우 90hz, 120hz 등 고주사율 디스플레이를 탑재하면서, 게임이 아닌 일반적인 애플리케이션은 높은 fps를 지원하게 되었다.\n\n일반적인 디스플레이 주사율을 기준으로 했을 때, 60 FPS(1초에 60프레임)을 지원하며, 이를 바꿔부르면, 16ms안에 화면을 갱신하면 사용자에게 있어 자연스러운 화면전환을 제공할 수 있기 때문에, 16ms 안에 draw가 완료되어야 한다.\n\n안드로이드 4.0 - ICS(아이스크림 샌드위치) 버전까지는 Screen Refershing과정에서 Framebuffer 출력이 SurfaceFligner의 Thread 동작 주기로 임으로 출력이 출력이 되어 프레임이 일정하지 않았다.\n\n만약 16ms 이상 걸리게 된다면 어떻게 될까? View 렌더링 과정이 지체되어 사용자 경험에 좋지 않을 것이고, 애니메이션이 매끄럽게 보이지 않으며, 앱이 정상적으로 작동되지 않는 것처럼 보이게 될 것이다. 흔히 \"렉 걸린다\" 라는 표현을 주로 하는데, 이를 `Frame Drop` 이라고 부른다. `Frame Drop` 이 발생하는 원인은 오랜 시간동안 뷰의 계층구조를 새로 그리거나, 유저가 볼 수 없는 화면에 공을 들여 색칠하는 경우 CPU & GPU 에 과부하를 일으키게 된다.\n\n만약 디스플레이 컨텐츠가 UI 리프레시 도중에 업데이트가 된다면, **티어링(tearing)** / **프레임 드롭(Frame Drop)** 현상이 나타날 것이다. \n\n{% asset_img image.png [Frame Drop] %}\n\n### Project Butter\n\n{% asset_img n6fsbPA.png [Proejct Butter] %}\n\n이러한 문제를 해결하기 위해 Android 4.1JB(젤리빈) 버전부터는 **Project Butter**를 발표하여 60hz디스플레이에 온전하게 60 FPS를 애플리케이션에서 지원하도록 하였다.\n\n그래서 각 리프레시 주기 동안에 컨텐츠 업데이트를 마무리 하는 것이 중요하다.\n\nProejct Butter에서는 매끄러운 화면 출력을 위해 **VSync** 기술과 **Choreographer**를 도입하였다.\n\n### Vsync Processing\n\n**VSync**는 Vertical Synchronization(수직 동기화)의 약자이다. \n\n{% asset_img ha7Eriy.png [Drawing with VSync] %}\n\n**VSync**는 화면의 출력되는 정보가 변경이 되었을 때 이를 동기화하고, 지속적으로 갱신해주는 기능이다. 쉽게 설명하면, GPU의 Rendering Rate, 즉 fps와 Device Presenting Rate, 즉 hz사이의 간극이 있을 때 이를 조정한다.\n\n예를들면, GPU가 그리는 프레임은 100fps(초 당 100개의 프레임을 그림), Device Screen의 주사율은 60hz(초 당 60개의 화면을 그림)라면, GPU에서 그리는 것을 그대로 Device Screen에 뿌리게 되면 계속 지연(Delay)이 생길 수 있다.\n\n이 때, VSync가 GPU 프레임과 Device 화면간의 시간차(Time Gap)를 계산하여 필요한 프레임만 만 그려주어 최적화를 해준다. VSync에 대한 Detail한 원리에 대해서 잘 소개된 영상은 [Android Performance Patterns: Understanding VSYNC](https://www.youtube.com/watch?v=1iaHxmfZGGc) 영상을 참고하라.\n\n\n\n### Choreographer\n\nSurfaceFlinger에서 송신되는 Vsync Event를 요청/수신하여 아래 작업을 처리한다.\n\n- **Input Event Handling**\n- **Self-Invalidation**\n- **Animation**\n\n\n\n### ViewRootImpl\n\n**ViewRootImpl**은 DecorView와 **Choreographer**를 연결해주는 일종의 핸들러 역할을 하는 객체로써, DecorView와 Choreographer 사이에서 둘의 요청을 처리하고 중계한다.\n\n\n\n### Rendering Flow\n\n최종적으로 **Vsync Process**에서는 아래 과정으로 처리된다.\n\n{% asset_img 1ZQEOg0.png [Rendering Flow] %}\n\n실제 그리기는 현재 foreground에 표시되고 있는 어플리케이션에서 그릴 것이 생김으로써 시작한다.\n\n1. 특정 변화가 생겨 `Invalidate`를 호출하게 되면 ViewRootImpl에  `scheduleTraversal()` 함수를 호출한다. \n\n   `scheduleTraversal()` 메서드 내부에서는 **Choreographer** 객체에게 다음 Vsync를 예약해달라는 요청을 보내게 된다. 이 작업이 위 그림에서 Invalidate와 Vsync scheduling에 해당한다.\n\n2. Choreographer에 VSync 스케쥴링을 요청하여 Frame Render를 Screen Rate에 맞춘다. Vsync 예약 요청을 받은 Choreographer는 SurfaceFlinger로 하여금 다음 Vsync 도착 시 알려달라고 요청한다.\n\n3. 다음 Vsync signal이 도착하여 Choreographer에서 받게된다.\n\n4. Choreographer는 ViewRootImpl의 `performTraversal()` 메서드를 호출한다. performTraversal 메서드 내부에서는 다시 그려야 될 부분을 `measure()`하고, 레이아웃을 재구성한다.\n\n5. 마지막으로 `performDraw()` 메서드를 호출하여 그리기를 수행한다.\n\n\n\n## Software Rendering Model V.S. Hardare Rendering Model\n\n안드로이드의 렌더링 모델은 안드로이드3.0((API 레벨 11, 허니컴))버전을 기준으로 나뉜다. 이전까지는 소프트웨어 모델을 기반으로 렌더링이 되었다.\n\n### Software Rendering Model\n\nSoftware Rendering Model은 Android 3.0 전 버전까지 사용되던 방식이다.\n\nCPU 연산기반으로 동작하였으며, 아래 두단계로 그려진다.\n\n1. 계층 구조 무효화\n2. 계층 구조 그리기\n\n\n\n### Hardare Rendering Model (By using GPU)\n\nAndroid 3.0부터 Android 2D 렌더링 파이프라인 하드웨어에서는 가속화를 지원하므로, `View`의 캔버스에서 실행되는 모든 그리기 작업에서 GPU를 사용한다.\n\n하드웨어 가속을 사용하려면 필요한 리소스가 늘어나므로 앱에서 더 많은 RAM을 사용한다.\n\nAndroid 시스템에서는 여전히 `invalidate()` 및 `draw()`를 사용하여 화면을 업데이트하고 보기를 렌더링하지만, 실제 그리기는 다르게 처리한다.\n\nAndroid 시스템에서는 즉시 그리기 명령을 실행하지 않고, 보기 계층 구조의 그리기 코드 출력을 포함하는 표시 목록에 기록한다.\n\n또한 Android 시스템에서 `invalidate()` 호출을 통해 더티로 표시된 보기의 표시 목록을 기록하고 업데이트만 하면 되도록 최적화한다.\n\n무효화되지 않은 보기는 단순히 이전에 기록된 표시 목록을 다시 실행하여 다시 그릴 수 있습니다. 새 그리기 모델에는 다음 세 단계가 포함된다.\n\n1. 계층 구조 무효화\n2. 표시 목록 기록 및 업데이트\n3. 표시 목록 그리기\n\n### Internal UI Rendering Optimization\n\n우리가 사용하는 `상위 수준의 객체`들(Button, TextView, etc.)은 아래의 과정을 거쳐 화면의 픽셀로 나타낼 수 있다.\n\n{% asset_img image-1.png [View Rendering Principle] %}\n\n- CPU Level에서 상위 수준의 객체들을 가져오고, 이 객체를 그리기 위한 집합인 `displaylist` 로 바꾸어준다.\n- GPU는 높은 수준의 객체들을 가져와 텍스처 또는 화면에서 픽셀로 바꾸어주는 `Rasterization`기능을 수행한다. CPU에서 만들어진 명령어들은 OpenGL-ES api를 이용해 GPU에 업로드 되며, 픽셀화에 이용된다. 한번 업로드되면 displaylist 객체는 캐싱되는데, 이는 우리가 다시 displaylist를 통해 그리고 싶다면 다시 새로 생성할 필요없이 기존에 존재하는 것을 다시 그리기 때문에 비용이 훨씬 더 저렴하다.\n\nUI 렌더링이 진행될 때, CPU에서 displaylist 를 생성하고 GPU에 업로드 하는 과정은 매우 고비용(High Cost)적이기 때문에, 효율적인 개선안을 찾아야한다.\n\n## Extra Info\n### Displaylist란 ?\n\n{% asset_img 4.png [Displaylist] %}\n\n안드로이드 3.0 이전에는 View의 변경사항이 일어나면, ViewRoot까지 전파하도록 설계되었다. View에서 ViewGroup, ViewRoot를 거쳐 다시 View 까지 내려와야하는 과정이 많은 코드를 접근하기 때문에 비효율적이었다.\n\n이러한 대안에 Displaylist가 나오게 되었는데, 이는 UI 요소를 그리기 위한 정보를 리스트로 모아둔 것이다. UI요소의 변경이 일어났을 때, 다시 View Tree 를 탈 필요가 없이 리스트를 확인하고 사용하면 된다는 이점이 있다.\n\n---\n\n이번시간에는 Window, Surface, Canvas에 대해 소개하고, 소프트웨어 레벨에서 어떻게 하드웨어 레벨까지 동기화 되는지 정리해보았다. 또한 View가 렌더링 될 때 두가지 방식으로 어떻게 동작하는지 개념 설명 및 원리 설명을 했다.\n\n다음 포스트에서는 하드웨어 가속을 사용하는 GPU 렌더링 체계의 경우 어떤 문제가 있고, 어떻게 프로파일링 하고, 어떻게 모니터링하는지 알아보도록 하겠다. 그리고 어떻게 최적화 할 수 있을지 방법을 소개하도록 하겠다.\n\n\n","source":"_posts/2021-05-19 Android UI Rendering Optimization Part 2.md","raw":"---\ntitle: Introduce Android UI Rendering Principle and View Optimization Part 2\ndate: 2021-05-19 02:00\ncover: https://androiddeepdive.github.io/Team-Blog/images/cover_ui_rendering.png\ncategories:\n- User Interface\ntags:\n- Android\n- Rendering\n- Principle\n- Optimize\n- UI\n---\n\n<article class=\"message message-immersive is-primary\">\n    <div class=\"message-body\">\n        <i class=\"fas fa-pen-fancy mr-2\"></i>Writers<br>\n        by 김남훈 @Naver<br>\n        by 배희성 @RocketPunch<br>\n        by 송시영 @SmartStudy<br>\n        by 이기정 @BankSalad<br>\n        by 정세희 @BankSalad<br>\n        by 최소영 @BankSalad\n    </div>\n</article>\n\n\n<!-- more -->\n\n저번 포스트에서는 View와 ViewGroup 개념, UI가 그려지는 과정, UI가 그려질 때 View의 생명주기에 대해 보았다. 이번시간에는 UI Rendering 시 화면에 보여질 때 어떤 과정을 거치는지 알아보자.\n\n## UI Rendering\n\n아래 내용은 Google Android Source Document의 [그래픽 아키텍쳐](https://source.android.com/devices/graphics/architecture) 내용을 참고하여 작성되었다.\n\n위와 같은 최적화가 내부적으로 일어나기 위해서는 화면을 그리는 필수요소로, **Window, Surface, Canvas, View** 레이어로 나눠서 처리하게 된다.\n\n### Window\n\n무언가를 **그릴 수 있는 창**(Window)이다. 이 영역에서는 그릴 수 있는 Surface를 들고 있고, 애플리케이션은 WindowManager와 상호작용을 통해 Window를 만들고, Window위에 올려진 Surface를 통해 UI를 그린다.\n\n하나의 화면에서는 여러개의 Window를 가지며, WindowManager를 통해 관리받게 된다. \n\n대표적으로 PhoneWindowManager, DialogWindowManager와 같은 요소가 있다.\n\n## Surface and SurfacHolder\n\n기본적으로 안드로이드에서 모든 화면에 그려지는 요소들은, **Surface**를 통해 처리된다. 안드로이드에서는 Surface와 SurfaceHolder를 통해 그려지는 영역을 제어한다.\n\n### Surface\n\nSurface는 화면에 표시하는 이미지를 앱이 렌더링 할 수 있도록 해준다. 해당 클래스는 Android 1.0 초창기부터 API에 내장되어 있었으며, 안드로이드 온라인 도움말 사이트에는 **Surface** 클래스에 대해서 **Screen Compositor**가 관리하는 하나의 Raw 버퍼를 가리키는 핸들이라고 설명한다.\n\n잘 이해가 안갈테니, 이미지를 함께 보면서 이해 해보도록 하자.\n\n{% asset_img ptHtNno.png [Surface & Surface Flinger] %}\n\n하나의 애플리케이션은 기본적으로 하나의 **Surface**를 가진다.  **BufferQueue**는 그래픽 데이터의 버퍼를 생성하는 요소(생산자)를 표시 데이터 또는 추가 처리를 허용하는 요소(소비자)에 연결한다.\n\n**Suface**는 자주 사용되는 **BufferQueue**를 생성하고(Producer), 버퍼에 데이터를 담아 **SurfaceFlinger**(Consumer)로 전달하여 출력한다. 이를 통해 화면에 drawing을 하여 Application과 상호작용하게 된다.\n\n각 Surface는 **이중 버퍼 렌더링**을 위한 1개 이상 (보통 2개)의 버퍼를 가진다.\n\n#### 이중 버퍼 렌더링(Double Buffer Rendering)\n\n스크린에 출력될 화면 데이터는 **프레임 버퍼**에 저장되는데, 하나의 버퍼만 가지는 경우 이미지가 반복해서 그려지게 되거나, 이미지가 다 그려지지 않아도 화면 주사율 때문에 렌더링을 해야할 때, 다 그려지지 않은 프레임 버퍼가 렌더링이 되어서 이미지가 깜빡이는 Flicker 현상이 나타날 수 있다.\n\n이를 해결하기 위해 프레임 버퍼에 바로 렌더링 하지 않고, 다른 버퍼를 만들어서 그 버퍼에 렌더링을 완료 하고, 다음 프레임 버퍼에 옮기는 방식을 사용하여 Flicker 현상을 해결한다.\n\n### SurfaceFlinger\n\nSurfaceFlinger는 버퍼를 받아들이고 버퍼를 구성하며 버퍼를 디스플레이로 보내는 역할을 한다. SurfaceFlinger는 BufferQueue 및 SurfaceControl을 통해 버퍼를 처리할 수 있다.\n\n 안드로이드 10부터는 **ASurfaceControl**라는 것을 통해 버퍼를 받아들인다.\n\n자세한 내용은 Google Android Source Document의 [SurfaceFlinger 및 WindowManager](https://source.android.com/devices/graphics/surfaceflinger-windowmanager)를 참고하자.\n\n### SurfaceHolder\n\nSurfaceHolder 인터페이스는 앱이 Surface을 수정하고 제어할 수 있게 해준다. 일부 서비스에서는 제어가 필요한 케이스가 있는데, 대표적으로 **SurfaceView, GLSurfaceView**를 사용한 기능이다. 영상처리나 카메라 미리보기 화면을 렌더링할 때 특히 많이 사용한다. 일반 VIew와 달리 onDraw를 호출하는 것이 아닌, Thread를 이용하여 화면에 강제로 그려 처리한다.\n\n### Canvas Rendering\n\n안드로이드에서 모든 그려지는 UI 요소는 대부분은 [OpenGL ES](https://source.android.com/devices/graphics/arch-egl-opengl) 또는 [Vulkan](https://source.android.com/devices/graphics/arch-vulkan)을 사용하여 View를 렌더링한다.\n\n하지만, 예외 요소도 있기 마련이다. 예를들면 2D게임을 구현한다던지, 스트리밍 컨텐츠를 보여주는 플레이어라던지, 카메라 등에서는 캔버스 API를 통해 뷰를 그리는 작업이 이뤄진다. 이를 **Canvas Rendering**이라 한다.\n\nCanvas가 가지는 특징을 정리하면 아래와 같다.\n\n- **onDraw() 재정의**\n- Canvas(그리는 내용) => Paint(그리기 방법)\n- 직접 구현도 가능하고, Drawable를 상속한  BitmapDrawable를 이용하여 그릴 수 있다.\n- 프로젝트에 저장된 이미지 리소스(비트맵 파일)를 확장한다.\n- Drawable 속성을 정의하는  **XML** 리소스(우리가 아는 벡터 파일 변환도 여기 해당!)\n- 도형 Drawable(라운딩 처리 된 사각형, 동그라미 등등등..)\n- NinePatch 드로어블\n- 최종적으로는 SKIA를 통해 캔버스 c++ native API를 호출하여 그린다.\n\n\n\n예전에는 모든 렌더링은 소프트웨어 레벨에서 처리되었다. 지금은 하드웨어 레벨에서 처리되어 최적화되어 구현이 가능하지만, 이러한 방식으로 수동적으로 처리가 가능하다.\n\n안드로이드의 경우 일반적으로 그리기를 프레임워크에 맡겨서 Rendering Process를 거치지만(우리가 알고 있는 `onDraw()` 함수를 통해 그리는 것을 말함), 위에서 언급한 Canvas Rendering의 경우 쓰레드를 이용해 화면에 강제로 그려 원하는 시점에 화면에 그릴 수 있다.\n\n캔버스 구현은 [Skia 그래픽 라이브러리](https://skia.org/)에서 제공한다. 직사각형을 그리고 싶은 경우 적절히 버퍼에 바이트를 설정하는 캔버스 API를 호출한다.\n\nCanvas 인스턴스를 생성할 때는 이에 바탕이 되는 Bitmap 인스턴스를 생성하여 처리한다.\n\nSurface까지 도달하기 위해 어떤 흐름을 타는지 알아보자.\n\n{% asset_img JNfYVx7.png [android canvas drawing] %}\n\n예를 들어, 우리가 View에서 직접 Rect를 생성하여 사각형을 그리고 싶다면, Skia 라이브러리를 호출하여 처리할 수 있다. Skia는 바이트들을 적절하게 버퍼의 형태로 구성한다. 그리고 버퍼가 두 클라이언트에 의해 한번에 업데이트 되는 것을 방지하기 위해, 버퍼에 액세스 하기 위해서는 락을 사용해야 한다. **lockCanvas()**는 버퍼에 락을 걸고 드로잉을 처리하기 위한 Canvas를 리턴한다. 그리고 **unlockCanvasAnsPost()**는 버퍼에 락을 해제하고, 그것을 compositor로 전달한다.\n\n그 과정에서 일어나는 매커니즘은 매우 복잡하지만, 결론은 Surface로 전달 된다.\n\n과거에는 View를 캔버스로 처리했지만, 현재는 범용 3D 엔진을 탑재한 기기들이 늘어나면서, 안드로이드에서 모든 그려지는 UI 요소는 대부분은 [OpenGL ES](https://source.android.com/devices/graphics/arch-egl-opengl) 또는 [Vulkan](https://source.android.com/devices/graphics/arch-vulkan)을 사용하여 View를 렌더링하도록 구성된다. 하지만 이전에 사용하던 API와의 호환성이 중요하기 때문에, 하드웨어 가속 Canvas API가 만들어지게 되었다.\n\n---\n\n지금까지는 그래픽 데이터를 처리하는 과정 및 요소에 대한 내용을 보았다면, 이번에는 해당 데이터를 화면에 직접 보여지는 과정에서 어떤 요소들이 필요하고 어떻게 동작하는지 보도록 하겠다.\n\n## Surface Flinger and Harware Composer\n\n해당글은 [Android Drawing Process 1(App surface, SF Layer)](https://lastyouth.tistory.com/24)를 참고하여 작성하였다.\n\n앞에서 언급했던 **SyrfaceFlinger**에서는 **HWComposer(Hardware Composer)**를 통해 그래픽 데이터를 디바이스 디스플레이에 전송한다.\n\n이를 도식화 하면, 아래와 같이 표현 가능하다.\n\n{% asset_img cK00ybR.png [Surface Flinger and Harware Composer] %}\n\n### Layer Management\n\n여기서 Layer Management는 우리가 앞서 언급한 각 어플리케이션이 갖는 Surface에서 SufraceFlinger에 의해 Layer 형태로 관리된다. 도식화 하면 아래와 같다.\n\n{% asset_img 7990Bf0.png [Layer Management] %}\n\n### Screen Refreshing\n\n디바이스 디스플레이는 특정 주기로 리프레시되며, 일반적으로는 폰이나 테블릿에서는 초당 60프레임의 속도로 리프레시된다. 요즘 나오는 디바이스의 경우 90hz, 120hz 등 고주사율 디스플레이를 탑재하면서, 게임이 아닌 일반적인 애플리케이션은 높은 fps를 지원하게 되었다.\n\n일반적인 디스플레이 주사율을 기준으로 했을 때, 60 FPS(1초에 60프레임)을 지원하며, 이를 바꿔부르면, 16ms안에 화면을 갱신하면 사용자에게 있어 자연스러운 화면전환을 제공할 수 있기 때문에, 16ms 안에 draw가 완료되어야 한다.\n\n안드로이드 4.0 - ICS(아이스크림 샌드위치) 버전까지는 Screen Refershing과정에서 Framebuffer 출력이 SurfaceFligner의 Thread 동작 주기로 임으로 출력이 출력이 되어 프레임이 일정하지 않았다.\n\n만약 16ms 이상 걸리게 된다면 어떻게 될까? View 렌더링 과정이 지체되어 사용자 경험에 좋지 않을 것이고, 애니메이션이 매끄럽게 보이지 않으며, 앱이 정상적으로 작동되지 않는 것처럼 보이게 될 것이다. 흔히 \"렉 걸린다\" 라는 표현을 주로 하는데, 이를 `Frame Drop` 이라고 부른다. `Frame Drop` 이 발생하는 원인은 오랜 시간동안 뷰의 계층구조를 새로 그리거나, 유저가 볼 수 없는 화면에 공을 들여 색칠하는 경우 CPU & GPU 에 과부하를 일으키게 된다.\n\n만약 디스플레이 컨텐츠가 UI 리프레시 도중에 업데이트가 된다면, **티어링(tearing)** / **프레임 드롭(Frame Drop)** 현상이 나타날 것이다. \n\n{% asset_img image.png [Frame Drop] %}\n\n### Project Butter\n\n{% asset_img n6fsbPA.png [Proejct Butter] %}\n\n이러한 문제를 해결하기 위해 Android 4.1JB(젤리빈) 버전부터는 **Project Butter**를 발표하여 60hz디스플레이에 온전하게 60 FPS를 애플리케이션에서 지원하도록 하였다.\n\n그래서 각 리프레시 주기 동안에 컨텐츠 업데이트를 마무리 하는 것이 중요하다.\n\nProejct Butter에서는 매끄러운 화면 출력을 위해 **VSync** 기술과 **Choreographer**를 도입하였다.\n\n### Vsync Processing\n\n**VSync**는 Vertical Synchronization(수직 동기화)의 약자이다. \n\n{% asset_img ha7Eriy.png [Drawing with VSync] %}\n\n**VSync**는 화면의 출력되는 정보가 변경이 되었을 때 이를 동기화하고, 지속적으로 갱신해주는 기능이다. 쉽게 설명하면, GPU의 Rendering Rate, 즉 fps와 Device Presenting Rate, 즉 hz사이의 간극이 있을 때 이를 조정한다.\n\n예를들면, GPU가 그리는 프레임은 100fps(초 당 100개의 프레임을 그림), Device Screen의 주사율은 60hz(초 당 60개의 화면을 그림)라면, GPU에서 그리는 것을 그대로 Device Screen에 뿌리게 되면 계속 지연(Delay)이 생길 수 있다.\n\n이 때, VSync가 GPU 프레임과 Device 화면간의 시간차(Time Gap)를 계산하여 필요한 프레임만 만 그려주어 최적화를 해준다. VSync에 대한 Detail한 원리에 대해서 잘 소개된 영상은 [Android Performance Patterns: Understanding VSYNC](https://www.youtube.com/watch?v=1iaHxmfZGGc) 영상을 참고하라.\n\n\n\n### Choreographer\n\nSurfaceFlinger에서 송신되는 Vsync Event를 요청/수신하여 아래 작업을 처리한다.\n\n- **Input Event Handling**\n- **Self-Invalidation**\n- **Animation**\n\n\n\n### ViewRootImpl\n\n**ViewRootImpl**은 DecorView와 **Choreographer**를 연결해주는 일종의 핸들러 역할을 하는 객체로써, DecorView와 Choreographer 사이에서 둘의 요청을 처리하고 중계한다.\n\n\n\n### Rendering Flow\n\n최종적으로 **Vsync Process**에서는 아래 과정으로 처리된다.\n\n{% asset_img 1ZQEOg0.png [Rendering Flow] %}\n\n실제 그리기는 현재 foreground에 표시되고 있는 어플리케이션에서 그릴 것이 생김으로써 시작한다.\n\n1. 특정 변화가 생겨 `Invalidate`를 호출하게 되면 ViewRootImpl에  `scheduleTraversal()` 함수를 호출한다. \n\n   `scheduleTraversal()` 메서드 내부에서는 **Choreographer** 객체에게 다음 Vsync를 예약해달라는 요청을 보내게 된다. 이 작업이 위 그림에서 Invalidate와 Vsync scheduling에 해당한다.\n\n2. Choreographer에 VSync 스케쥴링을 요청하여 Frame Render를 Screen Rate에 맞춘다. Vsync 예약 요청을 받은 Choreographer는 SurfaceFlinger로 하여금 다음 Vsync 도착 시 알려달라고 요청한다.\n\n3. 다음 Vsync signal이 도착하여 Choreographer에서 받게된다.\n\n4. Choreographer는 ViewRootImpl의 `performTraversal()` 메서드를 호출한다. performTraversal 메서드 내부에서는 다시 그려야 될 부분을 `measure()`하고, 레이아웃을 재구성한다.\n\n5. 마지막으로 `performDraw()` 메서드를 호출하여 그리기를 수행한다.\n\n\n\n## Software Rendering Model V.S. Hardare Rendering Model\n\n안드로이드의 렌더링 모델은 안드로이드3.0((API 레벨 11, 허니컴))버전을 기준으로 나뉜다. 이전까지는 소프트웨어 모델을 기반으로 렌더링이 되었다.\n\n### Software Rendering Model\n\nSoftware Rendering Model은 Android 3.0 전 버전까지 사용되던 방식이다.\n\nCPU 연산기반으로 동작하였으며, 아래 두단계로 그려진다.\n\n1. 계층 구조 무효화\n2. 계층 구조 그리기\n\n\n\n### Hardare Rendering Model (By using GPU)\n\nAndroid 3.0부터 Android 2D 렌더링 파이프라인 하드웨어에서는 가속화를 지원하므로, `View`의 캔버스에서 실행되는 모든 그리기 작업에서 GPU를 사용한다.\n\n하드웨어 가속을 사용하려면 필요한 리소스가 늘어나므로 앱에서 더 많은 RAM을 사용한다.\n\nAndroid 시스템에서는 여전히 `invalidate()` 및 `draw()`를 사용하여 화면을 업데이트하고 보기를 렌더링하지만, 실제 그리기는 다르게 처리한다.\n\nAndroid 시스템에서는 즉시 그리기 명령을 실행하지 않고, 보기 계층 구조의 그리기 코드 출력을 포함하는 표시 목록에 기록한다.\n\n또한 Android 시스템에서 `invalidate()` 호출을 통해 더티로 표시된 보기의 표시 목록을 기록하고 업데이트만 하면 되도록 최적화한다.\n\n무효화되지 않은 보기는 단순히 이전에 기록된 표시 목록을 다시 실행하여 다시 그릴 수 있습니다. 새 그리기 모델에는 다음 세 단계가 포함된다.\n\n1. 계층 구조 무효화\n2. 표시 목록 기록 및 업데이트\n3. 표시 목록 그리기\n\n### Internal UI Rendering Optimization\n\n우리가 사용하는 `상위 수준의 객체`들(Button, TextView, etc.)은 아래의 과정을 거쳐 화면의 픽셀로 나타낼 수 있다.\n\n{% asset_img image-1.png [View Rendering Principle] %}\n\n- CPU Level에서 상위 수준의 객체들을 가져오고, 이 객체를 그리기 위한 집합인 `displaylist` 로 바꾸어준다.\n- GPU는 높은 수준의 객체들을 가져와 텍스처 또는 화면에서 픽셀로 바꾸어주는 `Rasterization`기능을 수행한다. CPU에서 만들어진 명령어들은 OpenGL-ES api를 이용해 GPU에 업로드 되며, 픽셀화에 이용된다. 한번 업로드되면 displaylist 객체는 캐싱되는데, 이는 우리가 다시 displaylist를 통해 그리고 싶다면 다시 새로 생성할 필요없이 기존에 존재하는 것을 다시 그리기 때문에 비용이 훨씬 더 저렴하다.\n\nUI 렌더링이 진행될 때, CPU에서 displaylist 를 생성하고 GPU에 업로드 하는 과정은 매우 고비용(High Cost)적이기 때문에, 효율적인 개선안을 찾아야한다.\n\n## Extra Info\n### Displaylist란 ?\n\n{% asset_img 4.png [Displaylist] %}\n\n안드로이드 3.0 이전에는 View의 변경사항이 일어나면, ViewRoot까지 전파하도록 설계되었다. View에서 ViewGroup, ViewRoot를 거쳐 다시 View 까지 내려와야하는 과정이 많은 코드를 접근하기 때문에 비효율적이었다.\n\n이러한 대안에 Displaylist가 나오게 되었는데, 이는 UI 요소를 그리기 위한 정보를 리스트로 모아둔 것이다. UI요소의 변경이 일어났을 때, 다시 View Tree 를 탈 필요가 없이 리스트를 확인하고 사용하면 된다는 이점이 있다.\n\n---\n\n이번시간에는 Window, Surface, Canvas에 대해 소개하고, 소프트웨어 레벨에서 어떻게 하드웨어 레벨까지 동기화 되는지 정리해보았다. 또한 View가 렌더링 될 때 두가지 방식으로 어떻게 동작하는지 개념 설명 및 원리 설명을 했다.\n\n다음 포스트에서는 하드웨어 가속을 사용하는 GPU 렌더링 체계의 경우 어떤 문제가 있고, 어떻게 프로파일링 하고, 어떻게 모니터링하는지 알아보도록 하겠다. 그리고 어떻게 최적화 할 수 있을지 방법을 소개하도록 하겠다.\n\n\n","slug":"2021-05-19 Android UI Rendering Optimization Part 2","published":1,"updated":"2021-07-25T13:28:24.789Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cksagj7ky00063lreddjqc1bt","content":"<article class=\"message message-immersive is-primary\">\n    <div class=\"message-body\">\n        <i class=\"fas fa-pen-fancy mr-2\"></i>Writers<br>\n        by 김남훈 @Naver<br>\n        by 배희성 @RocketPunch<br>\n        by 송시영 @SmartStudy<br>\n        by 이기정 @BankSalad<br>\n        by 정세희 @BankSalad<br>\n        by 최소영 @BankSalad\n    </div>\n</article>\n\n\n<span id=\"more\"></span>\n\n<p>저번 포스트에서는 View와 ViewGroup 개념, UI가 그려지는 과정, UI가 그려질 때 View의 생명주기에 대해 보았다. 이번시간에는 UI Rendering 시 화면에 보여질 때 어떤 과정을 거치는지 알아보자.</p>\n<h2 id=\"UI-Rendering\"><a href=\"#UI-Rendering\" class=\"headerlink\" title=\"UI Rendering\"></a>UI Rendering</h2><p>아래 내용은 Google Android Source Document의 <a href=\"https://source.android.com/devices/graphics/architecture\">그래픽 아키텍쳐</a> 내용을 참고하여 작성되었다.</p>\n<p>위와 같은 최적화가 내부적으로 일어나기 위해서는 화면을 그리는 필수요소로, <strong>Window, Surface, Canvas, View</strong> 레이어로 나눠서 처리하게 된다.</p>\n<h3 id=\"Window\"><a href=\"#Window\" class=\"headerlink\" title=\"Window\"></a>Window</h3><p>무언가를 <strong>그릴 수 있는 창</strong>(Window)이다. 이 영역에서는 그릴 수 있는 Surface를 들고 있고, 애플리케이션은 WindowManager와 상호작용을 통해 Window를 만들고, Window위에 올려진 Surface를 통해 UI를 그린다.</p>\n<p>하나의 화면에서는 여러개의 Window를 가지며, WindowManager를 통해 관리받게 된다. </p>\n<p>대표적으로 PhoneWindowManager, DialogWindowManager와 같은 요소가 있다.</p>\n<h2 id=\"Surface-and-SurfacHolder\"><a href=\"#Surface-and-SurfacHolder\" class=\"headerlink\" title=\"Surface and SurfacHolder\"></a>Surface and SurfacHolder</h2><p>기본적으로 안드로이드에서 모든 화면에 그려지는 요소들은, <strong>Surface</strong>를 통해 처리된다. 안드로이드에서는 Surface와 SurfaceHolder를 통해 그려지는 영역을 제어한다.</p>\n<h3 id=\"Surface\"><a href=\"#Surface\" class=\"headerlink\" title=\"Surface\"></a>Surface</h3><p>Surface는 화면에 표시하는 이미지를 앱이 렌더링 할 수 있도록 해준다. 해당 클래스는 Android 1.0 초창기부터 API에 내장되어 있었으며, 안드로이드 온라인 도움말 사이트에는 <strong>Surface</strong> 클래스에 대해서 <strong>Screen Compositor</strong>가 관리하는 하나의 Raw 버퍼를 가리키는 핸들이라고 설명한다.</p>\n<p>잘 이해가 안갈테니, 이미지를 함께 보면서 이해 해보도록 하자.</p>\n<img src=\"/Team-Blog/2021/05/19/2021-05-19%20Android%20UI%20Rendering%20Optimization%20Part%202/ptHtNno.png\" class=\"\" title=\"[Surface &amp; Surface Flinger]\">\n\n<p>하나의 애플리케이션은 기본적으로 하나의 <strong>Surface</strong>를 가진다.  <strong>BufferQueue</strong>는 그래픽 데이터의 버퍼를 생성하는 요소(생산자)를 표시 데이터 또는 추가 처리를 허용하는 요소(소비자)에 연결한다.</p>\n<p><strong>Suface</strong>는 자주 사용되는 <strong>BufferQueue</strong>를 생성하고(Producer), 버퍼에 데이터를 담아 <strong>SurfaceFlinger</strong>(Consumer)로 전달하여 출력한다. 이를 통해 화면에 drawing을 하여 Application과 상호작용하게 된다.</p>\n<p>각 Surface는 <strong>이중 버퍼 렌더링</strong>을 위한 1개 이상 (보통 2개)의 버퍼를 가진다.</p>\n<h4 id=\"이중-버퍼-렌더링-Double-Buffer-Rendering\"><a href=\"#이중-버퍼-렌더링-Double-Buffer-Rendering\" class=\"headerlink\" title=\"이중 버퍼 렌더링(Double Buffer Rendering)\"></a>이중 버퍼 렌더링(Double Buffer Rendering)</h4><p>스크린에 출력될 화면 데이터는 <strong>프레임 버퍼</strong>에 저장되는데, 하나의 버퍼만 가지는 경우 이미지가 반복해서 그려지게 되거나, 이미지가 다 그려지지 않아도 화면 주사율 때문에 렌더링을 해야할 때, 다 그려지지 않은 프레임 버퍼가 렌더링이 되어서 이미지가 깜빡이는 Flicker 현상이 나타날 수 있다.</p>\n<p>이를 해결하기 위해 프레임 버퍼에 바로 렌더링 하지 않고, 다른 버퍼를 만들어서 그 버퍼에 렌더링을 완료 하고, 다음 프레임 버퍼에 옮기는 방식을 사용하여 Flicker 현상을 해결한다.</p>\n<h3 id=\"SurfaceFlinger\"><a href=\"#SurfaceFlinger\" class=\"headerlink\" title=\"SurfaceFlinger\"></a>SurfaceFlinger</h3><p>SurfaceFlinger는 버퍼를 받아들이고 버퍼를 구성하며 버퍼를 디스플레이로 보내는 역할을 한다. SurfaceFlinger는 BufferQueue 및 SurfaceControl을 통해 버퍼를 처리할 수 있다.</p>\n<p> 안드로이드 10부터는 <strong>ASurfaceControl</strong>라는 것을 통해 버퍼를 받아들인다.</p>\n<p>자세한 내용은 Google Android Source Document의 <a href=\"https://source.android.com/devices/graphics/surfaceflinger-windowmanager\">SurfaceFlinger 및 WindowManager</a>를 참고하자.</p>\n<h3 id=\"SurfaceHolder\"><a href=\"#SurfaceHolder\" class=\"headerlink\" title=\"SurfaceHolder\"></a>SurfaceHolder</h3><p>SurfaceHolder 인터페이스는 앱이 Surface을 수정하고 제어할 수 있게 해준다. 일부 서비스에서는 제어가 필요한 케이스가 있는데, 대표적으로 <strong>SurfaceView, GLSurfaceView</strong>를 사용한 기능이다. 영상처리나 카메라 미리보기 화면을 렌더링할 때 특히 많이 사용한다. 일반 VIew와 달리 onDraw를 호출하는 것이 아닌, Thread를 이용하여 화면에 강제로 그려 처리한다.</p>\n<h3 id=\"Canvas-Rendering\"><a href=\"#Canvas-Rendering\" class=\"headerlink\" title=\"Canvas Rendering\"></a>Canvas Rendering</h3><p>안드로이드에서 모든 그려지는 UI 요소는 대부분은 <a href=\"https://source.android.com/devices/graphics/arch-egl-opengl\">OpenGL ES</a> 또는 <a href=\"https://source.android.com/devices/graphics/arch-vulkan\">Vulkan</a>을 사용하여 View를 렌더링한다.</p>\n<p>하지만, 예외 요소도 있기 마련이다. 예를들면 2D게임을 구현한다던지, 스트리밍 컨텐츠를 보여주는 플레이어라던지, 카메라 등에서는 캔버스 API를 통해 뷰를 그리는 작업이 이뤄진다. 이를 <strong>Canvas Rendering</strong>이라 한다.</p>\n<p>Canvas가 가지는 특징을 정리하면 아래와 같다.</p>\n<ul>\n<li><strong>onDraw() 재정의</strong></li>\n<li>Canvas(그리는 내용) =&gt; Paint(그리기 방법)</li>\n<li>직접 구현도 가능하고, Drawable를 상속한  BitmapDrawable를 이용하여 그릴 수 있다.</li>\n<li>프로젝트에 저장된 이미지 리소스(비트맵 파일)를 확장한다.</li>\n<li>Drawable 속성을 정의하는  <strong>XML</strong> 리소스(우리가 아는 벡터 파일 변환도 여기 해당!)</li>\n<li>도형 Drawable(라운딩 처리 된 사각형, 동그라미 등등등..)</li>\n<li>NinePatch 드로어블</li>\n<li>최종적으로는 SKIA를 통해 캔버스 c++ native API를 호출하여 그린다.</li>\n</ul>\n<p>예전에는 모든 렌더링은 소프트웨어 레벨에서 처리되었다. 지금은 하드웨어 레벨에서 처리되어 최적화되어 구현이 가능하지만, 이러한 방식으로 수동적으로 처리가 가능하다.</p>\n<p>안드로이드의 경우 일반적으로 그리기를 프레임워크에 맡겨서 Rendering Process를 거치지만(우리가 알고 있는 <code>onDraw()</code> 함수를 통해 그리는 것을 말함), 위에서 언급한 Canvas Rendering의 경우 쓰레드를 이용해 화면에 강제로 그려 원하는 시점에 화면에 그릴 수 있다.</p>\n<p>캔버스 구현은 <a href=\"https://skia.org/\">Skia 그래픽 라이브러리</a>에서 제공한다. 직사각형을 그리고 싶은 경우 적절히 버퍼에 바이트를 설정하는 캔버스 API를 호출한다.</p>\n<p>Canvas 인스턴스를 생성할 때는 이에 바탕이 되는 Bitmap 인스턴스를 생성하여 처리한다.</p>\n<p>Surface까지 도달하기 위해 어떤 흐름을 타는지 알아보자.</p>\n<img src=\"/Team-Blog/2021/05/19/2021-05-19%20Android%20UI%20Rendering%20Optimization%20Part%202/JNfYVx7.png\" class=\"\" title=\"[android canvas drawing]\">\n\n<p>예를 들어, 우리가 View에서 직접 Rect를 생성하여 사각형을 그리고 싶다면, Skia 라이브러리를 호출하여 처리할 수 있다. Skia는 바이트들을 적절하게 버퍼의 형태로 구성한다. 그리고 버퍼가 두 클라이언트에 의해 한번에 업데이트 되는 것을 방지하기 위해, 버퍼에 액세스 하기 위해서는 락을 사용해야 한다. **lockCanvas()**는 버퍼에 락을 걸고 드로잉을 처리하기 위한 Canvas를 리턴한다. 그리고 **unlockCanvasAnsPost()**는 버퍼에 락을 해제하고, 그것을 compositor로 전달한다.</p>\n<p>그 과정에서 일어나는 매커니즘은 매우 복잡하지만, 결론은 Surface로 전달 된다.</p>\n<p>과거에는 View를 캔버스로 처리했지만, 현재는 범용 3D 엔진을 탑재한 기기들이 늘어나면서, 안드로이드에서 모든 그려지는 UI 요소는 대부분은 <a href=\"https://source.android.com/devices/graphics/arch-egl-opengl\">OpenGL ES</a> 또는 <a href=\"https://source.android.com/devices/graphics/arch-vulkan\">Vulkan</a>을 사용하여 View를 렌더링하도록 구성된다. 하지만 이전에 사용하던 API와의 호환성이 중요하기 때문에, 하드웨어 가속 Canvas API가 만들어지게 되었다.</p>\n<hr>\n<p>지금까지는 그래픽 데이터를 처리하는 과정 및 요소에 대한 내용을 보았다면, 이번에는 해당 데이터를 화면에 직접 보여지는 과정에서 어떤 요소들이 필요하고 어떻게 동작하는지 보도록 하겠다.</p>\n<h2 id=\"Surface-Flinger-and-Harware-Composer\"><a href=\"#Surface-Flinger-and-Harware-Composer\" class=\"headerlink\" title=\"Surface Flinger and Harware Composer\"></a>Surface Flinger and Harware Composer</h2><p>해당글은 <a href=\"https://lastyouth.tistory.com/24\">Android Drawing Process 1(App surface, SF Layer)</a>를 참고하여 작성하였다.</p>\n<p>앞에서 언급했던 <strong>SyrfaceFlinger</strong>에서는 **HWComposer(Hardware Composer)**를 통해 그래픽 데이터를 디바이스 디스플레이에 전송한다.</p>\n<p>이를 도식화 하면, 아래와 같이 표현 가능하다.</p>\n<img src=\"/Team-Blog/2021/05/19/2021-05-19%20Android%20UI%20Rendering%20Optimization%20Part%202/cK00ybR.png\" class=\"\" title=\"[Surface Flinger and Harware Composer]\">\n\n<h3 id=\"Layer-Management\"><a href=\"#Layer-Management\" class=\"headerlink\" title=\"Layer Management\"></a>Layer Management</h3><p>여기서 Layer Management는 우리가 앞서 언급한 각 어플리케이션이 갖는 Surface에서 SufraceFlinger에 의해 Layer 형태로 관리된다. 도식화 하면 아래와 같다.</p>\n<img src=\"/Team-Blog/2021/05/19/2021-05-19%20Android%20UI%20Rendering%20Optimization%20Part%202/7990Bf0.png\" class=\"\" title=\"[Layer Management]\">\n\n<h3 id=\"Screen-Refreshing\"><a href=\"#Screen-Refreshing\" class=\"headerlink\" title=\"Screen Refreshing\"></a>Screen Refreshing</h3><p>디바이스 디스플레이는 특정 주기로 리프레시되며, 일반적으로는 폰이나 테블릿에서는 초당 60프레임의 속도로 리프레시된다. 요즘 나오는 디바이스의 경우 90hz, 120hz 등 고주사율 디스플레이를 탑재하면서, 게임이 아닌 일반적인 애플리케이션은 높은 fps를 지원하게 되었다.</p>\n<p>일반적인 디스플레이 주사율을 기준으로 했을 때, 60 FPS(1초에 60프레임)을 지원하며, 이를 바꿔부르면, 16ms안에 화면을 갱신하면 사용자에게 있어 자연스러운 화면전환을 제공할 수 있기 때문에, 16ms 안에 draw가 완료되어야 한다.</p>\n<p>안드로이드 4.0 - ICS(아이스크림 샌드위치) 버전까지는 Screen Refershing과정에서 Framebuffer 출력이 SurfaceFligner의 Thread 동작 주기로 임으로 출력이 출력이 되어 프레임이 일정하지 않았다.</p>\n<p>만약 16ms 이상 걸리게 된다면 어떻게 될까? View 렌더링 과정이 지체되어 사용자 경험에 좋지 않을 것이고, 애니메이션이 매끄럽게 보이지 않으며, 앱이 정상적으로 작동되지 않는 것처럼 보이게 될 것이다. 흔히 “렉 걸린다” 라는 표현을 주로 하는데, 이를 <code>Frame Drop</code> 이라고 부른다. <code>Frame Drop</code> 이 발생하는 원인은 오랜 시간동안 뷰의 계층구조를 새로 그리거나, 유저가 볼 수 없는 화면에 공을 들여 색칠하는 경우 CPU &amp; GPU 에 과부하를 일으키게 된다.</p>\n<p>만약 디스플레이 컨텐츠가 UI 리프레시 도중에 업데이트가 된다면, <strong>티어링(tearing)</strong> / <strong>프레임 드롭(Frame Drop)</strong> 현상이 나타날 것이다. </p>\n<img src=\"/Team-Blog/2021/05/19/2021-05-19%20Android%20UI%20Rendering%20Optimization%20Part%202/image.png\" class=\"\" title=\"[Frame Drop]\">\n\n<h3 id=\"Project-Butter\"><a href=\"#Project-Butter\" class=\"headerlink\" title=\"Project Butter\"></a>Project Butter</h3><img src=\"/Team-Blog/2021/05/19/2021-05-19%20Android%20UI%20Rendering%20Optimization%20Part%202/n6fsbPA.png\" class=\"\" title=\"[Proejct Butter]\">\n\n<p>이러한 문제를 해결하기 위해 Android 4.1JB(젤리빈) 버전부터는 <strong>Project Butter</strong>를 발표하여 60hz디스플레이에 온전하게 60 FPS를 애플리케이션에서 지원하도록 하였다.</p>\n<p>그래서 각 리프레시 주기 동안에 컨텐츠 업데이트를 마무리 하는 것이 중요하다.</p>\n<p>Proejct Butter에서는 매끄러운 화면 출력을 위해 <strong>VSync</strong> 기술과 <strong>Choreographer</strong>를 도입하였다.</p>\n<h3 id=\"Vsync-Processing\"><a href=\"#Vsync-Processing\" class=\"headerlink\" title=\"Vsync Processing\"></a>Vsync Processing</h3><p><strong>VSync</strong>는 Vertical Synchronization(수직 동기화)의 약자이다. </p>\n<img src=\"/Team-Blog/2021/05/19/2021-05-19%20Android%20UI%20Rendering%20Optimization%20Part%202/ha7Eriy.png\" class=\"\" title=\"[Drawing with VSync]\">\n\n<p><strong>VSync</strong>는 화면의 출력되는 정보가 변경이 되었을 때 이를 동기화하고, 지속적으로 갱신해주는 기능이다. 쉽게 설명하면, GPU의 Rendering Rate, 즉 fps와 Device Presenting Rate, 즉 hz사이의 간극이 있을 때 이를 조정한다.</p>\n<p>예를들면, GPU가 그리는 프레임은 100fps(초 당 100개의 프레임을 그림), Device Screen의 주사율은 60hz(초 당 60개의 화면을 그림)라면, GPU에서 그리는 것을 그대로 Device Screen에 뿌리게 되면 계속 지연(Delay)이 생길 수 있다.</p>\n<p>이 때, VSync가 GPU 프레임과 Device 화면간의 시간차(Time Gap)를 계산하여 필요한 프레임만 만 그려주어 최적화를 해준다. VSync에 대한 Detail한 원리에 대해서 잘 소개된 영상은 <a href=\"https://www.youtube.com/watch?v=1iaHxmfZGGc\">Android Performance Patterns: Understanding VSYNC</a> 영상을 참고하라.</p>\n<h3 id=\"Choreographer\"><a href=\"#Choreographer\" class=\"headerlink\" title=\"Choreographer\"></a>Choreographer</h3><p>SurfaceFlinger에서 송신되는 Vsync Event를 요청/수신하여 아래 작업을 처리한다.</p>\n<ul>\n<li><strong>Input Event Handling</strong></li>\n<li><strong>Self-Invalidation</strong></li>\n<li><strong>Animation</strong></li>\n</ul>\n<h3 id=\"ViewRootImpl\"><a href=\"#ViewRootImpl\" class=\"headerlink\" title=\"ViewRootImpl\"></a>ViewRootImpl</h3><p><strong>ViewRootImpl</strong>은 DecorView와 <strong>Choreographer</strong>를 연결해주는 일종의 핸들러 역할을 하는 객체로써, DecorView와 Choreographer 사이에서 둘의 요청을 처리하고 중계한다.</p>\n<h3 id=\"Rendering-Flow\"><a href=\"#Rendering-Flow\" class=\"headerlink\" title=\"Rendering Flow\"></a>Rendering Flow</h3><p>최종적으로 <strong>Vsync Process</strong>에서는 아래 과정으로 처리된다.</p>\n<img src=\"/Team-Blog/2021/05/19/2021-05-19%20Android%20UI%20Rendering%20Optimization%20Part%202/1ZQEOg0.png\" class=\"\" title=\"[Rendering Flow]\">\n\n<p>실제 그리기는 현재 foreground에 표시되고 있는 어플리케이션에서 그릴 것이 생김으로써 시작한다.</p>\n<ol>\n<li><p>특정 변화가 생겨 <code>Invalidate</code>를 호출하게 되면 ViewRootImpl에  <code>scheduleTraversal()</code> 함수를 호출한다. </p>\n<p><code>scheduleTraversal()</code> 메서드 내부에서는 <strong>Choreographer</strong> 객체에게 다음 Vsync를 예약해달라는 요청을 보내게 된다. 이 작업이 위 그림에서 Invalidate와 Vsync scheduling에 해당한다.</p>\n</li>\n<li><p>Choreographer에 VSync 스케쥴링을 요청하여 Frame Render를 Screen Rate에 맞춘다. Vsync 예약 요청을 받은 Choreographer는 SurfaceFlinger로 하여금 다음 Vsync 도착 시 알려달라고 요청한다.</p>\n</li>\n<li><p>다음 Vsync signal이 도착하여 Choreographer에서 받게된다.</p>\n</li>\n<li><p>Choreographer는 ViewRootImpl의 <code>performTraversal()</code> 메서드를 호출한다. performTraversal 메서드 내부에서는 다시 그려야 될 부분을 <code>measure()</code>하고, 레이아웃을 재구성한다.</p>\n</li>\n<li><p>마지막으로 <code>performDraw()</code> 메서드를 호출하여 그리기를 수행한다.</p>\n</li>\n</ol>\n<h2 id=\"Software-Rendering-Model-V-S-Hardare-Rendering-Model\"><a href=\"#Software-Rendering-Model-V-S-Hardare-Rendering-Model\" class=\"headerlink\" title=\"Software Rendering Model V.S. Hardare Rendering Model\"></a>Software Rendering Model V.S. Hardare Rendering Model</h2><p>안드로이드의 렌더링 모델은 안드로이드3.0((API 레벨 11, 허니컴))버전을 기준으로 나뉜다. 이전까지는 소프트웨어 모델을 기반으로 렌더링이 되었다.</p>\n<h3 id=\"Software-Rendering-Model\"><a href=\"#Software-Rendering-Model\" class=\"headerlink\" title=\"Software Rendering Model\"></a>Software Rendering Model</h3><p>Software Rendering Model은 Android 3.0 전 버전까지 사용되던 방식이다.</p>\n<p>CPU 연산기반으로 동작하였으며, 아래 두단계로 그려진다.</p>\n<ol>\n<li>계층 구조 무효화</li>\n<li>계층 구조 그리기</li>\n</ol>\n<h3 id=\"Hardare-Rendering-Model-By-using-GPU\"><a href=\"#Hardare-Rendering-Model-By-using-GPU\" class=\"headerlink\" title=\"Hardare Rendering Model (By using GPU)\"></a>Hardare Rendering Model (By using GPU)</h3><p>Android 3.0부터 Android 2D 렌더링 파이프라인 하드웨어에서는 가속화를 지원하므로, <code>View</code>의 캔버스에서 실행되는 모든 그리기 작업에서 GPU를 사용한다.</p>\n<p>하드웨어 가속을 사용하려면 필요한 리소스가 늘어나므로 앱에서 더 많은 RAM을 사용한다.</p>\n<p>Android 시스템에서는 여전히 <code>invalidate()</code> 및 <code>draw()</code>를 사용하여 화면을 업데이트하고 보기를 렌더링하지만, 실제 그리기는 다르게 처리한다.</p>\n<p>Android 시스템에서는 즉시 그리기 명령을 실행하지 않고, 보기 계층 구조의 그리기 코드 출력을 포함하는 표시 목록에 기록한다.</p>\n<p>또한 Android 시스템에서 <code>invalidate()</code> 호출을 통해 더티로 표시된 보기의 표시 목록을 기록하고 업데이트만 하면 되도록 최적화한다.</p>\n<p>무효화되지 않은 보기는 단순히 이전에 기록된 표시 목록을 다시 실행하여 다시 그릴 수 있습니다. 새 그리기 모델에는 다음 세 단계가 포함된다.</p>\n<ol>\n<li>계층 구조 무효화</li>\n<li>표시 목록 기록 및 업데이트</li>\n<li>표시 목록 그리기</li>\n</ol>\n<h3 id=\"Internal-UI-Rendering-Optimization\"><a href=\"#Internal-UI-Rendering-Optimization\" class=\"headerlink\" title=\"Internal UI Rendering Optimization\"></a>Internal UI Rendering Optimization</h3><p>우리가 사용하는 <code>상위 수준의 객체</code>들(Button, TextView, etc.)은 아래의 과정을 거쳐 화면의 픽셀로 나타낼 수 있다.</p>\n<img src=\"/Team-Blog/2021/05/19/2021-05-19%20Android%20UI%20Rendering%20Optimization%20Part%202/image-1.png\" class=\"\" title=\"[View Rendering Principle]\">\n\n<ul>\n<li>CPU Level에서 상위 수준의 객체들을 가져오고, 이 객체를 그리기 위한 집합인 <code>displaylist</code> 로 바꾸어준다.</li>\n<li>GPU는 높은 수준의 객체들을 가져와 텍스처 또는 화면에서 픽셀로 바꾸어주는 <code>Rasterization</code>기능을 수행한다. CPU에서 만들어진 명령어들은 OpenGL-ES api를 이용해 GPU에 업로드 되며, 픽셀화에 이용된다. 한번 업로드되면 displaylist 객체는 캐싱되는데, 이는 우리가 다시 displaylist를 통해 그리고 싶다면 다시 새로 생성할 필요없이 기존에 존재하는 것을 다시 그리기 때문에 비용이 훨씬 더 저렴하다.</li>\n</ul>\n<p>UI 렌더링이 진행될 때, CPU에서 displaylist 를 생성하고 GPU에 업로드 하는 과정은 매우 고비용(High Cost)적이기 때문에, 효율적인 개선안을 찾아야한다.</p>\n<h2 id=\"Extra-Info\"><a href=\"#Extra-Info\" class=\"headerlink\" title=\"Extra Info\"></a>Extra Info</h2><h3 id=\"Displaylist란\"><a href=\"#Displaylist란\" class=\"headerlink\" title=\"Displaylist란 ?\"></a>Displaylist란 ?</h3><img src=\"/Team-Blog/2021/05/19/2021-05-19%20Android%20UI%20Rendering%20Optimization%20Part%202/4.png\" class=\"\" title=\"[Displaylist]\">\n\n<p>안드로이드 3.0 이전에는 View의 변경사항이 일어나면, ViewRoot까지 전파하도록 설계되었다. View에서 ViewGroup, ViewRoot를 거쳐 다시 View 까지 내려와야하는 과정이 많은 코드를 접근하기 때문에 비효율적이었다.</p>\n<p>이러한 대안에 Displaylist가 나오게 되었는데, 이는 UI 요소를 그리기 위한 정보를 리스트로 모아둔 것이다. UI요소의 변경이 일어났을 때, 다시 View Tree 를 탈 필요가 없이 리스트를 확인하고 사용하면 된다는 이점이 있다.</p>\n<hr>\n<p>이번시간에는 Window, Surface, Canvas에 대해 소개하고, 소프트웨어 레벨에서 어떻게 하드웨어 레벨까지 동기화 되는지 정리해보았다. 또한 View가 렌더링 될 때 두가지 방식으로 어떻게 동작하는지 개념 설명 및 원리 설명을 했다.</p>\n<p>다음 포스트에서는 하드웨어 가속을 사용하는 GPU 렌더링 체계의 경우 어떤 문제가 있고, 어떻게 프로파일링 하고, 어떻게 모니터링하는지 알아보도록 하겠다. 그리고 어떻게 최적화 할 수 있을지 방법을 소개하도록 하겠다.</p>\n","site":{"data":{}},"excerpt":"<article class=\"message message-immersive is-primary\">\n    <div class=\"message-body\">\n        <i class=\"fas fa-pen-fancy mr-2\"></i>Writers<br>\n        by 김남훈 @Naver<br>\n        by 배희성 @RocketPunch<br>\n        by 송시영 @SmartStudy<br>\n        by 이기정 @BankSalad<br>\n        by 정세희 @BankSalad<br>\n        by 최소영 @BankSalad\n    </div>\n</article>","more":"<p>저번 포스트에서는 View와 ViewGroup 개념, UI가 그려지는 과정, UI가 그려질 때 View의 생명주기에 대해 보았다. 이번시간에는 UI Rendering 시 화면에 보여질 때 어떤 과정을 거치는지 알아보자.</p>\n<h2 id=\"UI-Rendering\"><a href=\"#UI-Rendering\" class=\"headerlink\" title=\"UI Rendering\"></a>UI Rendering</h2><p>아래 내용은 Google Android Source Document의 <a href=\"https://source.android.com/devices/graphics/architecture\">그래픽 아키텍쳐</a> 내용을 참고하여 작성되었다.</p>\n<p>위와 같은 최적화가 내부적으로 일어나기 위해서는 화면을 그리는 필수요소로, <strong>Window, Surface, Canvas, View</strong> 레이어로 나눠서 처리하게 된다.</p>\n<h3 id=\"Window\"><a href=\"#Window\" class=\"headerlink\" title=\"Window\"></a>Window</h3><p>무언가를 <strong>그릴 수 있는 창</strong>(Window)이다. 이 영역에서는 그릴 수 있는 Surface를 들고 있고, 애플리케이션은 WindowManager와 상호작용을 통해 Window를 만들고, Window위에 올려진 Surface를 통해 UI를 그린다.</p>\n<p>하나의 화면에서는 여러개의 Window를 가지며, WindowManager를 통해 관리받게 된다. </p>\n<p>대표적으로 PhoneWindowManager, DialogWindowManager와 같은 요소가 있다.</p>\n<h2 id=\"Surface-and-SurfacHolder\"><a href=\"#Surface-and-SurfacHolder\" class=\"headerlink\" title=\"Surface and SurfacHolder\"></a>Surface and SurfacHolder</h2><p>기본적으로 안드로이드에서 모든 화면에 그려지는 요소들은, <strong>Surface</strong>를 통해 처리된다. 안드로이드에서는 Surface와 SurfaceHolder를 통해 그려지는 영역을 제어한다.</p>\n<h3 id=\"Surface\"><a href=\"#Surface\" class=\"headerlink\" title=\"Surface\"></a>Surface</h3><p>Surface는 화면에 표시하는 이미지를 앱이 렌더링 할 수 있도록 해준다. 해당 클래스는 Android 1.0 초창기부터 API에 내장되어 있었으며, 안드로이드 온라인 도움말 사이트에는 <strong>Surface</strong> 클래스에 대해서 <strong>Screen Compositor</strong>가 관리하는 하나의 Raw 버퍼를 가리키는 핸들이라고 설명한다.</p>\n<p>잘 이해가 안갈테니, 이미지를 함께 보면서 이해 해보도록 하자.</p>\n<img src=\"/Team-Blog/2021/05/19/2021-05-19%20Android%20UI%20Rendering%20Optimization%20Part%202/ptHtNno.png\" class=\"\" title=\"[Surface &amp; Surface Flinger]\">\n\n<p>하나의 애플리케이션은 기본적으로 하나의 <strong>Surface</strong>를 가진다.  <strong>BufferQueue</strong>는 그래픽 데이터의 버퍼를 생성하는 요소(생산자)를 표시 데이터 또는 추가 처리를 허용하는 요소(소비자)에 연결한다.</p>\n<p><strong>Suface</strong>는 자주 사용되는 <strong>BufferQueue</strong>를 생성하고(Producer), 버퍼에 데이터를 담아 <strong>SurfaceFlinger</strong>(Consumer)로 전달하여 출력한다. 이를 통해 화면에 drawing을 하여 Application과 상호작용하게 된다.</p>\n<p>각 Surface는 <strong>이중 버퍼 렌더링</strong>을 위한 1개 이상 (보통 2개)의 버퍼를 가진다.</p>\n<h4 id=\"이중-버퍼-렌더링-Double-Buffer-Rendering\"><a href=\"#이중-버퍼-렌더링-Double-Buffer-Rendering\" class=\"headerlink\" title=\"이중 버퍼 렌더링(Double Buffer Rendering)\"></a>이중 버퍼 렌더링(Double Buffer Rendering)</h4><p>스크린에 출력될 화면 데이터는 <strong>프레임 버퍼</strong>에 저장되는데, 하나의 버퍼만 가지는 경우 이미지가 반복해서 그려지게 되거나, 이미지가 다 그려지지 않아도 화면 주사율 때문에 렌더링을 해야할 때, 다 그려지지 않은 프레임 버퍼가 렌더링이 되어서 이미지가 깜빡이는 Flicker 현상이 나타날 수 있다.</p>\n<p>이를 해결하기 위해 프레임 버퍼에 바로 렌더링 하지 않고, 다른 버퍼를 만들어서 그 버퍼에 렌더링을 완료 하고, 다음 프레임 버퍼에 옮기는 방식을 사용하여 Flicker 현상을 해결한다.</p>\n<h3 id=\"SurfaceFlinger\"><a href=\"#SurfaceFlinger\" class=\"headerlink\" title=\"SurfaceFlinger\"></a>SurfaceFlinger</h3><p>SurfaceFlinger는 버퍼를 받아들이고 버퍼를 구성하며 버퍼를 디스플레이로 보내는 역할을 한다. SurfaceFlinger는 BufferQueue 및 SurfaceControl을 통해 버퍼를 처리할 수 있다.</p>\n<p> 안드로이드 10부터는 <strong>ASurfaceControl</strong>라는 것을 통해 버퍼를 받아들인다.</p>\n<p>자세한 내용은 Google Android Source Document의 <a href=\"https://source.android.com/devices/graphics/surfaceflinger-windowmanager\">SurfaceFlinger 및 WindowManager</a>를 참고하자.</p>\n<h3 id=\"SurfaceHolder\"><a href=\"#SurfaceHolder\" class=\"headerlink\" title=\"SurfaceHolder\"></a>SurfaceHolder</h3><p>SurfaceHolder 인터페이스는 앱이 Surface을 수정하고 제어할 수 있게 해준다. 일부 서비스에서는 제어가 필요한 케이스가 있는데, 대표적으로 <strong>SurfaceView, GLSurfaceView</strong>를 사용한 기능이다. 영상처리나 카메라 미리보기 화면을 렌더링할 때 특히 많이 사용한다. 일반 VIew와 달리 onDraw를 호출하는 것이 아닌, Thread를 이용하여 화면에 강제로 그려 처리한다.</p>\n<h3 id=\"Canvas-Rendering\"><a href=\"#Canvas-Rendering\" class=\"headerlink\" title=\"Canvas Rendering\"></a>Canvas Rendering</h3><p>안드로이드에서 모든 그려지는 UI 요소는 대부분은 <a href=\"https://source.android.com/devices/graphics/arch-egl-opengl\">OpenGL ES</a> 또는 <a href=\"https://source.android.com/devices/graphics/arch-vulkan\">Vulkan</a>을 사용하여 View를 렌더링한다.</p>\n<p>하지만, 예외 요소도 있기 마련이다. 예를들면 2D게임을 구현한다던지, 스트리밍 컨텐츠를 보여주는 플레이어라던지, 카메라 등에서는 캔버스 API를 통해 뷰를 그리는 작업이 이뤄진다. 이를 <strong>Canvas Rendering</strong>이라 한다.</p>\n<p>Canvas가 가지는 특징을 정리하면 아래와 같다.</p>\n<ul>\n<li><strong>onDraw() 재정의</strong></li>\n<li>Canvas(그리는 내용) =&gt; Paint(그리기 방법)</li>\n<li>직접 구현도 가능하고, Drawable를 상속한  BitmapDrawable를 이용하여 그릴 수 있다.</li>\n<li>프로젝트에 저장된 이미지 리소스(비트맵 파일)를 확장한다.</li>\n<li>Drawable 속성을 정의하는  <strong>XML</strong> 리소스(우리가 아는 벡터 파일 변환도 여기 해당!)</li>\n<li>도형 Drawable(라운딩 처리 된 사각형, 동그라미 등등등..)</li>\n<li>NinePatch 드로어블</li>\n<li>최종적으로는 SKIA를 통해 캔버스 c++ native API를 호출하여 그린다.</li>\n</ul>\n<p>예전에는 모든 렌더링은 소프트웨어 레벨에서 처리되었다. 지금은 하드웨어 레벨에서 처리되어 최적화되어 구현이 가능하지만, 이러한 방식으로 수동적으로 처리가 가능하다.</p>\n<p>안드로이드의 경우 일반적으로 그리기를 프레임워크에 맡겨서 Rendering Process를 거치지만(우리가 알고 있는 <code>onDraw()</code> 함수를 통해 그리는 것을 말함), 위에서 언급한 Canvas Rendering의 경우 쓰레드를 이용해 화면에 강제로 그려 원하는 시점에 화면에 그릴 수 있다.</p>\n<p>캔버스 구현은 <a href=\"https://skia.org/\">Skia 그래픽 라이브러리</a>에서 제공한다. 직사각형을 그리고 싶은 경우 적절히 버퍼에 바이트를 설정하는 캔버스 API를 호출한다.</p>\n<p>Canvas 인스턴스를 생성할 때는 이에 바탕이 되는 Bitmap 인스턴스를 생성하여 처리한다.</p>\n<p>Surface까지 도달하기 위해 어떤 흐름을 타는지 알아보자.</p>\n<img src=\"/Team-Blog/2021/05/19/2021-05-19%20Android%20UI%20Rendering%20Optimization%20Part%202/JNfYVx7.png\" class=\"\" title=\"[android canvas drawing]\">\n\n<p>예를 들어, 우리가 View에서 직접 Rect를 생성하여 사각형을 그리고 싶다면, Skia 라이브러리를 호출하여 처리할 수 있다. Skia는 바이트들을 적절하게 버퍼의 형태로 구성한다. 그리고 버퍼가 두 클라이언트에 의해 한번에 업데이트 되는 것을 방지하기 위해, 버퍼에 액세스 하기 위해서는 락을 사용해야 한다. **lockCanvas()**는 버퍼에 락을 걸고 드로잉을 처리하기 위한 Canvas를 리턴한다. 그리고 **unlockCanvasAnsPost()**는 버퍼에 락을 해제하고, 그것을 compositor로 전달한다.</p>\n<p>그 과정에서 일어나는 매커니즘은 매우 복잡하지만, 결론은 Surface로 전달 된다.</p>\n<p>과거에는 View를 캔버스로 처리했지만, 현재는 범용 3D 엔진을 탑재한 기기들이 늘어나면서, 안드로이드에서 모든 그려지는 UI 요소는 대부분은 <a href=\"https://source.android.com/devices/graphics/arch-egl-opengl\">OpenGL ES</a> 또는 <a href=\"https://source.android.com/devices/graphics/arch-vulkan\">Vulkan</a>을 사용하여 View를 렌더링하도록 구성된다. 하지만 이전에 사용하던 API와의 호환성이 중요하기 때문에, 하드웨어 가속 Canvas API가 만들어지게 되었다.</p>\n<hr>\n<p>지금까지는 그래픽 데이터를 처리하는 과정 및 요소에 대한 내용을 보았다면, 이번에는 해당 데이터를 화면에 직접 보여지는 과정에서 어떤 요소들이 필요하고 어떻게 동작하는지 보도록 하겠다.</p>\n<h2 id=\"Surface-Flinger-and-Harware-Composer\"><a href=\"#Surface-Flinger-and-Harware-Composer\" class=\"headerlink\" title=\"Surface Flinger and Harware Composer\"></a>Surface Flinger and Harware Composer</h2><p>해당글은 <a href=\"https://lastyouth.tistory.com/24\">Android Drawing Process 1(App surface, SF Layer)</a>를 참고하여 작성하였다.</p>\n<p>앞에서 언급했던 <strong>SyrfaceFlinger</strong>에서는 **HWComposer(Hardware Composer)**를 통해 그래픽 데이터를 디바이스 디스플레이에 전송한다.</p>\n<p>이를 도식화 하면, 아래와 같이 표현 가능하다.</p>\n<img src=\"/Team-Blog/2021/05/19/2021-05-19%20Android%20UI%20Rendering%20Optimization%20Part%202/cK00ybR.png\" class=\"\" title=\"[Surface Flinger and Harware Composer]\">\n\n<h3 id=\"Layer-Management\"><a href=\"#Layer-Management\" class=\"headerlink\" title=\"Layer Management\"></a>Layer Management</h3><p>여기서 Layer Management는 우리가 앞서 언급한 각 어플리케이션이 갖는 Surface에서 SufraceFlinger에 의해 Layer 형태로 관리된다. 도식화 하면 아래와 같다.</p>\n<img src=\"/Team-Blog/2021/05/19/2021-05-19%20Android%20UI%20Rendering%20Optimization%20Part%202/7990Bf0.png\" class=\"\" title=\"[Layer Management]\">\n\n<h3 id=\"Screen-Refreshing\"><a href=\"#Screen-Refreshing\" class=\"headerlink\" title=\"Screen Refreshing\"></a>Screen Refreshing</h3><p>디바이스 디스플레이는 특정 주기로 리프레시되며, 일반적으로는 폰이나 테블릿에서는 초당 60프레임의 속도로 리프레시된다. 요즘 나오는 디바이스의 경우 90hz, 120hz 등 고주사율 디스플레이를 탑재하면서, 게임이 아닌 일반적인 애플리케이션은 높은 fps를 지원하게 되었다.</p>\n<p>일반적인 디스플레이 주사율을 기준으로 했을 때, 60 FPS(1초에 60프레임)을 지원하며, 이를 바꿔부르면, 16ms안에 화면을 갱신하면 사용자에게 있어 자연스러운 화면전환을 제공할 수 있기 때문에, 16ms 안에 draw가 완료되어야 한다.</p>\n<p>안드로이드 4.0 - ICS(아이스크림 샌드위치) 버전까지는 Screen Refershing과정에서 Framebuffer 출력이 SurfaceFligner의 Thread 동작 주기로 임으로 출력이 출력이 되어 프레임이 일정하지 않았다.</p>\n<p>만약 16ms 이상 걸리게 된다면 어떻게 될까? View 렌더링 과정이 지체되어 사용자 경험에 좋지 않을 것이고, 애니메이션이 매끄럽게 보이지 않으며, 앱이 정상적으로 작동되지 않는 것처럼 보이게 될 것이다. 흔히 “렉 걸린다” 라는 표현을 주로 하는데, 이를 <code>Frame Drop</code> 이라고 부른다. <code>Frame Drop</code> 이 발생하는 원인은 오랜 시간동안 뷰의 계층구조를 새로 그리거나, 유저가 볼 수 없는 화면에 공을 들여 색칠하는 경우 CPU &amp; GPU 에 과부하를 일으키게 된다.</p>\n<p>만약 디스플레이 컨텐츠가 UI 리프레시 도중에 업데이트가 된다면, <strong>티어링(tearing)</strong> / <strong>프레임 드롭(Frame Drop)</strong> 현상이 나타날 것이다. </p>\n<img src=\"/Team-Blog/2021/05/19/2021-05-19%20Android%20UI%20Rendering%20Optimization%20Part%202/image.png\" class=\"\" title=\"[Frame Drop]\">\n\n<h3 id=\"Project-Butter\"><a href=\"#Project-Butter\" class=\"headerlink\" title=\"Project Butter\"></a>Project Butter</h3><img src=\"/Team-Blog/2021/05/19/2021-05-19%20Android%20UI%20Rendering%20Optimization%20Part%202/n6fsbPA.png\" class=\"\" title=\"[Proejct Butter]\">\n\n<p>이러한 문제를 해결하기 위해 Android 4.1JB(젤리빈) 버전부터는 <strong>Project Butter</strong>를 발표하여 60hz디스플레이에 온전하게 60 FPS를 애플리케이션에서 지원하도록 하였다.</p>\n<p>그래서 각 리프레시 주기 동안에 컨텐츠 업데이트를 마무리 하는 것이 중요하다.</p>\n<p>Proejct Butter에서는 매끄러운 화면 출력을 위해 <strong>VSync</strong> 기술과 <strong>Choreographer</strong>를 도입하였다.</p>\n<h3 id=\"Vsync-Processing\"><a href=\"#Vsync-Processing\" class=\"headerlink\" title=\"Vsync Processing\"></a>Vsync Processing</h3><p><strong>VSync</strong>는 Vertical Synchronization(수직 동기화)의 약자이다. </p>\n<img src=\"/Team-Blog/2021/05/19/2021-05-19%20Android%20UI%20Rendering%20Optimization%20Part%202/ha7Eriy.png\" class=\"\" title=\"[Drawing with VSync]\">\n\n<p><strong>VSync</strong>는 화면의 출력되는 정보가 변경이 되었을 때 이를 동기화하고, 지속적으로 갱신해주는 기능이다. 쉽게 설명하면, GPU의 Rendering Rate, 즉 fps와 Device Presenting Rate, 즉 hz사이의 간극이 있을 때 이를 조정한다.</p>\n<p>예를들면, GPU가 그리는 프레임은 100fps(초 당 100개의 프레임을 그림), Device Screen의 주사율은 60hz(초 당 60개의 화면을 그림)라면, GPU에서 그리는 것을 그대로 Device Screen에 뿌리게 되면 계속 지연(Delay)이 생길 수 있다.</p>\n<p>이 때, VSync가 GPU 프레임과 Device 화면간의 시간차(Time Gap)를 계산하여 필요한 프레임만 만 그려주어 최적화를 해준다. VSync에 대한 Detail한 원리에 대해서 잘 소개된 영상은 <a href=\"https://www.youtube.com/watch?v=1iaHxmfZGGc\">Android Performance Patterns: Understanding VSYNC</a> 영상을 참고하라.</p>\n<h3 id=\"Choreographer\"><a href=\"#Choreographer\" class=\"headerlink\" title=\"Choreographer\"></a>Choreographer</h3><p>SurfaceFlinger에서 송신되는 Vsync Event를 요청/수신하여 아래 작업을 처리한다.</p>\n<ul>\n<li><strong>Input Event Handling</strong></li>\n<li><strong>Self-Invalidation</strong></li>\n<li><strong>Animation</strong></li>\n</ul>\n<h3 id=\"ViewRootImpl\"><a href=\"#ViewRootImpl\" class=\"headerlink\" title=\"ViewRootImpl\"></a>ViewRootImpl</h3><p><strong>ViewRootImpl</strong>은 DecorView와 <strong>Choreographer</strong>를 연결해주는 일종의 핸들러 역할을 하는 객체로써, DecorView와 Choreographer 사이에서 둘의 요청을 처리하고 중계한다.</p>\n<h3 id=\"Rendering-Flow\"><a href=\"#Rendering-Flow\" class=\"headerlink\" title=\"Rendering Flow\"></a>Rendering Flow</h3><p>최종적으로 <strong>Vsync Process</strong>에서는 아래 과정으로 처리된다.</p>\n<img src=\"/Team-Blog/2021/05/19/2021-05-19%20Android%20UI%20Rendering%20Optimization%20Part%202/1ZQEOg0.png\" class=\"\" title=\"[Rendering Flow]\">\n\n<p>실제 그리기는 현재 foreground에 표시되고 있는 어플리케이션에서 그릴 것이 생김으로써 시작한다.</p>\n<ol>\n<li><p>특정 변화가 생겨 <code>Invalidate</code>를 호출하게 되면 ViewRootImpl에  <code>scheduleTraversal()</code> 함수를 호출한다. </p>\n<p><code>scheduleTraversal()</code> 메서드 내부에서는 <strong>Choreographer</strong> 객체에게 다음 Vsync를 예약해달라는 요청을 보내게 된다. 이 작업이 위 그림에서 Invalidate와 Vsync scheduling에 해당한다.</p>\n</li>\n<li><p>Choreographer에 VSync 스케쥴링을 요청하여 Frame Render를 Screen Rate에 맞춘다. Vsync 예약 요청을 받은 Choreographer는 SurfaceFlinger로 하여금 다음 Vsync 도착 시 알려달라고 요청한다.</p>\n</li>\n<li><p>다음 Vsync signal이 도착하여 Choreographer에서 받게된다.</p>\n</li>\n<li><p>Choreographer는 ViewRootImpl의 <code>performTraversal()</code> 메서드를 호출한다. performTraversal 메서드 내부에서는 다시 그려야 될 부분을 <code>measure()</code>하고, 레이아웃을 재구성한다.</p>\n</li>\n<li><p>마지막으로 <code>performDraw()</code> 메서드를 호출하여 그리기를 수행한다.</p>\n</li>\n</ol>\n<h2 id=\"Software-Rendering-Model-V-S-Hardare-Rendering-Model\"><a href=\"#Software-Rendering-Model-V-S-Hardare-Rendering-Model\" class=\"headerlink\" title=\"Software Rendering Model V.S. Hardare Rendering Model\"></a>Software Rendering Model V.S. Hardare Rendering Model</h2><p>안드로이드의 렌더링 모델은 안드로이드3.0((API 레벨 11, 허니컴))버전을 기준으로 나뉜다. 이전까지는 소프트웨어 모델을 기반으로 렌더링이 되었다.</p>\n<h3 id=\"Software-Rendering-Model\"><a href=\"#Software-Rendering-Model\" class=\"headerlink\" title=\"Software Rendering Model\"></a>Software Rendering Model</h3><p>Software Rendering Model은 Android 3.0 전 버전까지 사용되던 방식이다.</p>\n<p>CPU 연산기반으로 동작하였으며, 아래 두단계로 그려진다.</p>\n<ol>\n<li>계층 구조 무효화</li>\n<li>계층 구조 그리기</li>\n</ol>\n<h3 id=\"Hardare-Rendering-Model-By-using-GPU\"><a href=\"#Hardare-Rendering-Model-By-using-GPU\" class=\"headerlink\" title=\"Hardare Rendering Model (By using GPU)\"></a>Hardare Rendering Model (By using GPU)</h3><p>Android 3.0부터 Android 2D 렌더링 파이프라인 하드웨어에서는 가속화를 지원하므로, <code>View</code>의 캔버스에서 실행되는 모든 그리기 작업에서 GPU를 사용한다.</p>\n<p>하드웨어 가속을 사용하려면 필요한 리소스가 늘어나므로 앱에서 더 많은 RAM을 사용한다.</p>\n<p>Android 시스템에서는 여전히 <code>invalidate()</code> 및 <code>draw()</code>를 사용하여 화면을 업데이트하고 보기를 렌더링하지만, 실제 그리기는 다르게 처리한다.</p>\n<p>Android 시스템에서는 즉시 그리기 명령을 실행하지 않고, 보기 계층 구조의 그리기 코드 출력을 포함하는 표시 목록에 기록한다.</p>\n<p>또한 Android 시스템에서 <code>invalidate()</code> 호출을 통해 더티로 표시된 보기의 표시 목록을 기록하고 업데이트만 하면 되도록 최적화한다.</p>\n<p>무효화되지 않은 보기는 단순히 이전에 기록된 표시 목록을 다시 실행하여 다시 그릴 수 있습니다. 새 그리기 모델에는 다음 세 단계가 포함된다.</p>\n<ol>\n<li>계층 구조 무효화</li>\n<li>표시 목록 기록 및 업데이트</li>\n<li>표시 목록 그리기</li>\n</ol>\n<h3 id=\"Internal-UI-Rendering-Optimization\"><a href=\"#Internal-UI-Rendering-Optimization\" class=\"headerlink\" title=\"Internal UI Rendering Optimization\"></a>Internal UI Rendering Optimization</h3><p>우리가 사용하는 <code>상위 수준의 객체</code>들(Button, TextView, etc.)은 아래의 과정을 거쳐 화면의 픽셀로 나타낼 수 있다.</p>\n<img src=\"/Team-Blog/2021/05/19/2021-05-19%20Android%20UI%20Rendering%20Optimization%20Part%202/image-1.png\" class=\"\" title=\"[View Rendering Principle]\">\n\n<ul>\n<li>CPU Level에서 상위 수준의 객체들을 가져오고, 이 객체를 그리기 위한 집합인 <code>displaylist</code> 로 바꾸어준다.</li>\n<li>GPU는 높은 수준의 객체들을 가져와 텍스처 또는 화면에서 픽셀로 바꾸어주는 <code>Rasterization</code>기능을 수행한다. CPU에서 만들어진 명령어들은 OpenGL-ES api를 이용해 GPU에 업로드 되며, 픽셀화에 이용된다. 한번 업로드되면 displaylist 객체는 캐싱되는데, 이는 우리가 다시 displaylist를 통해 그리고 싶다면 다시 새로 생성할 필요없이 기존에 존재하는 것을 다시 그리기 때문에 비용이 훨씬 더 저렴하다.</li>\n</ul>\n<p>UI 렌더링이 진행될 때, CPU에서 displaylist 를 생성하고 GPU에 업로드 하는 과정은 매우 고비용(High Cost)적이기 때문에, 효율적인 개선안을 찾아야한다.</p>\n<h2 id=\"Extra-Info\"><a href=\"#Extra-Info\" class=\"headerlink\" title=\"Extra Info\"></a>Extra Info</h2><h3 id=\"Displaylist란\"><a href=\"#Displaylist란\" class=\"headerlink\" title=\"Displaylist란 ?\"></a>Displaylist란 ?</h3><img src=\"/Team-Blog/2021/05/19/2021-05-19%20Android%20UI%20Rendering%20Optimization%20Part%202/4.png\" class=\"\" title=\"[Displaylist]\">\n\n<p>안드로이드 3.0 이전에는 View의 변경사항이 일어나면, ViewRoot까지 전파하도록 설계되었다. View에서 ViewGroup, ViewRoot를 거쳐 다시 View 까지 내려와야하는 과정이 많은 코드를 접근하기 때문에 비효율적이었다.</p>\n<p>이러한 대안에 Displaylist가 나오게 되었는데, 이는 UI 요소를 그리기 위한 정보를 리스트로 모아둔 것이다. UI요소의 변경이 일어났을 때, 다시 View Tree 를 탈 필요가 없이 리스트를 확인하고 사용하면 된다는 이점이 있다.</p>\n<hr>\n<p>이번시간에는 Window, Surface, Canvas에 대해 소개하고, 소프트웨어 레벨에서 어떻게 하드웨어 레벨까지 동기화 되는지 정리해보았다. 또한 View가 렌더링 될 때 두가지 방식으로 어떻게 동작하는지 개념 설명 및 원리 설명을 했다.</p>\n<p>다음 포스트에서는 하드웨어 가속을 사용하는 GPU 렌더링 체계의 경우 어떤 문제가 있고, 어떻게 프로파일링 하고, 어떻게 모니터링하는지 알아보도록 하겠다. 그리고 어떻게 최적화 할 수 있을지 방법을 소개하도록 하겠다.</p>"},{"title":"Introduce Android UI Rendering Principle and View Optimization Part 3","date":"2021-05-18T18:00:00.000Z","cover":"https://androiddeepdive.github.io/Team-Blog/images/cover_ui_rendering.png","_content":"\n<article class=\"message message-immersive is-primary\">\n    <div class=\"message-body\">\n        <i class=\"fas fa-pen-fancy mr-2\"></i>Writers<br>\n        by 김남훈 @Naver<br>\n        by 배희성 @RocketPunch<br>\n        by 송시영 @SmartStudy<br>\n        by 이기정 @BankSalad<br>\n        by 정세희 @BankSalad<br>\n        by 최소영 @BankSalad\n    </div>\n</article>\n\n\n<!-- more -->\n\n저번 포스트에서는 UI Rendering 시 화면에 보여질 때 어떤 과정을 거치는지 알 수 있었고, 현재 보편적으로 사용되는 하드웨어 모델 기반 렌더링 방식에서 발생하는 문제는 무엇이고, 해당 문제를 해결하기 위해 어떤 방법이 있는지, 실제로 어느정도의 성과를 낼 수 있는지 정리해보았다.\n\n## 버벅거림(Jank)\n\n앱이 느린 렌더링으로 어려움을 겪는 경우, 시스템은 프레임을 건너 뛰게되고 사용자는 앱에서 끊김을 감지하게 된다.\n\n{% asset_img image.png [Frame Drop] %}\n\n버벅거림에는 여러문제가 있지만, 대표적으로 UI렌더링 시에는 **OverDraw, Slow Rendering**과 같은 문제가 존재한다.\n\n## Slow Rendering 방지하기\n\n해당 내용은 Google Android Source Document의 [느린 렌더링](https://developer.android.com/topic/performance/vitals/render#custom-monitoring)글 을 참고하였다.\n\n렌더링 시 버벅거림을 감지할 수 있는 방법은 세가지이다.\n\n- [Visual inspection](https://developer.android.com/topic/performance/vitals/render#visual-inspection)\n- [Systrace](https://developer.android.com/topic/performance/vitals/render#systrace)\n- [Custom performance monitoring](https://developer.android.com/topic/performance/vitals/render#custom-monitoring)\n\n\n\n### 시각적 검사(Visual Inspection)\n\n우리는 안드로이드에서 제공하는 몇가지 옵션을 통해 시각화 하여 문제를 해결할 수 있다. 해결책은 아래와 같다.\n\n#### `Profile GPU Rendering` 을 활성화\n\n60fps(GPU 연산으로 초 당 60프레임으로 화면을 뿌리는 것)일 때 렌더링에 얼마나 성능을 잡아먹는지 확인하기 위해 개발자 옵션을 통해 다음 도구를 사용설정 할 수 있다.\n\n프로파일링은 Android 4.1(API 16 ) 이상에서 사용 가능하며 미리 해당 기능을 활성화하는 작업이 필요하다. 다음과 같은 순서로 진행하면 활성화 할 수 있다.\n\n##### 여는방법\n\n1. 기기에서 **설정**으로 이동하여 **개발자 옵션**을 탭한다.\n2. **모니터링** 섹션에서 **프로필 GPU 렌더링**을 선택한다.\n3. ‘프로필 GPU 렌더링’ 대화상자에서 **화면에 막대로 표시**를 선택하여 기기의 화면에 그래프를 오버레이한다.\n4. 프로파일링하려는 앱을 연다.\n\n설정을 활성화 하고 확인해보면, 아래와 같이 히스토그램으로 표시되는 것을 볼 수 있다. \n\n{% asset_img gpu_profile.png [Profile GPU Rendering] %}\n\n- 표시되는 각 애플리케이션에 관해 그래프가 표시된다.\n- 가로축의 각 세로 막대는 프레임을 나타내며 각 세로 막대의 높이는 프레임을 렌더링하는 데 걸린 시간(밀리초)을 나타낸다.\n- 녹색 가로선은 16밀리초를 나타냅니다. 60fps를 달성하려면 각 프레임의 세로 막대가 이 선 아래에 머물러야 합니다. 막대가 이 선을 넘어서면 애니메이션이 일시중지될 수 있다.\n- 16밀리초 임계값을 초과하는 프레임은 막대를 더 넓고 덜 투명하게 만들어 강조표시한다.\n- 각 막대에는 렌더링 파이프라인의 단계로 매핑되는 색상으로 표시된 구성요소가 있습니다. 구성요소의 수는 기기의 API 수준에 따라 다르다.\n- 각 막대에는 렌더링 파이프 라인의 단계에 매핑되는 색상 구성 요소가 있으므로 어느 부분이 가장 오래 걸리는지 확인할 수 있다.\n- 예를 들어 프레임이 입력을 처리하는 데 많은 시간을 소비하는 경우 사용자 입력을 처리하는 앱 코드를 살펴 봐야한다.\n\n##### 막대 색상 별 의미\n\n{% asset_img graph_color.png [Profile Graph Color] %}\n\n세로 막대 차트는 위와 같이 8개의 단계로 표시된다.\n\n- **프로세스/스왑버퍼(Swap)**: 안드로이드는 디스플레이 목록을 GPU 에 제출하는것을 끝내면, 시스템은 그래픽 드라이버에 현재 프레임이 완료되었음을 알리며 드라이버를 업데이트된 이미지를 화면에 표시한다. CPU 와 GPU 는 병렬로 처리되는데 CPU 가 GPU 처리보다 빠른 경우, 프로세스간 통신 큐가 가득찰 수 있다. CPU 는 큐에 공간이 생길때까지 기다린다. 큐가 가득한 상태는 스왑버퍼 상태에서 자주 발생하는데 이 단계에서 프레임 전체의 명령어가 제출되기 때문이다. 명령어 실행 단계와 비슷하게 GPU 에서 일어나는 일의 복잡성을 줄여 문제를 해결할 수 있다.\n- **명령어 실행(Issue)**: 디스플레이 목록을 화면에 그리기 위한 모든 명령어를 실행하기 위해 걸리는 시간을 측정한다. 주어진 프레임에서 렌더링하는 디스플레이 목록과 수량을 직접적으로 측정한다. 내재적으로 많은 그리기 동작이 있는 경우, 오랜 시간이 걸릴수 있다.\n- **동기화/업로드(Upload)**: 현재 프레임에서 비트맵 객체가 CPU 메모리에서 GPU 메모리로 전송되는데 걸리는 시간을 측정한다. 오랜 시간이 걸리는 경우는 작은 리소스가 많이 로드되어 있거나 적지만 큰 리소스가 로드되어 있는 경우이다. 비트맵 해상도가 실제 디스플레이 해상도보다 큰 사이즈로 로드되어 있지 않도록 하거나 동기화 전에 비동기로 미리 업로드해서 실행 시간을 줄일 수 있다.\n- **그리기(Draw)**: 백그라운드 혹은 텍스트 그리기와 같은 뷰를 그리기 명령어로 번역하는 단계로 시스템은 명령어를 디스플레이 목록에 캡처한다. 무효화된 뷰에서 onDraw 호출을 실행해 걸리는 모든 시간을 측정하며, 오랜 시간이 걸린다는 것은 무효화된 뷰가 많다는 것을 의미한다. 뷰가 무효화되는 경우 뷰의 디스프레이 목록을 재생성한다. 혹은 커스텀한 뷰가 onDraw 할때 복잡한 로직을 가질 때도 실행시간이 오랜 걸린다.\n- **측정 및 배치(Measure)**: 안드로이드에서 뷰를 스크린에 그리기 위해 측정하고 배치하는데 걸리는 시간을 측정한다. 일반적으로 오랜 시간이 걸리는 경우는 배치할 뷰가 너무 많거나 혹은 계층구조의 잘못된 장소에서 중복 계산이 이뤄지며, Traceview와 Systrace 를 사용해서 호출 스택을 확인하여 문제를 파악할 수 있다.\n- **애니메이션(Anim)**: 현재 프레임에서 실행되는 애니메이션에 대해 걸리는 시간을 측정한다. 일반적으로 오랜 시간이 걸리는 경우는 애니메이션의 속성 변경으로 인해 발생한다.\n- **입력 처리(Input)**: 앱이 입력 이벤트를 처리하는 시간으로 입력 이벤트 콜백의 결과로 호출된 코드를 실행하는데 걸리는 시간을 나타낸다. 일반적으로 오랜 시간이 걸리는 경우는 메인쓰레드에서 발생하며, 작업을 최적화하거나 다른 쓰레드를 이용해서 작업을 실행하도록 한다.\n- **기타(Misc)**: 렌더링 시스템이 작업을 수행하는 시간외에 렌더링과 관련 없는 추가적인 작업이 있다. 일반적으로 렌더링의 연속된 두 프레임 사이에서 UI 스레드에서 발생할 수 있는 일을 나타낸다. 오랜 시간이 걸리는 경우, 다른스레드에서 실행해야할 콜백, 인텐트 또는 기타 다른 작업이 있을 수 있다. Method tracing 또는 Systrace 를 사용하면 메인스레드에서 실행중인 작업을 확인해 문제를 해결할 수 있다.\n\n아래에는 이미지 뷰에 클릭 이벤트를 설정하고 이미지 리소스를 변경하는 로직이다. 좌측에는 단순하게 이미지 리소스를 변경하는 로직만 추가하였고, 우측에는 리소스를 변경하는 과정에서 스레드를 일시 중단하는 코드를 추가하였다. 그 결과 입력처리 시간에 차이가 발생한다는 것을 확인할 수 있다.\n\n{% asset_img gpu_rendering_profile_1.png [Image Comparison By GPU Rendering Profiling - 1] %}\n\n아래에는 이미지 뷰에 각각 다른 크기의 이미지 리소스를 배치하였다. 좌측에는 8.1MB 크기의 이미지 리소스를 배치하고 우측에는 16KB 크기의 이미지 리소스를 배치하였다. \n\n그 결과 이미지를 업로드 시간에 차이가 발생한 다는 것을 확인할 수 있다.\n\n{% asset_img gpu_rendering_profile_2.png [Image Comparison By GPU Rendering Profiling - 2] %}\n\n#### Etc\n\n예외적인 케이스에 대한 해법으로는 아래 세가지가 있다.\n\n1. Release 버전의 앱을 실행하자.\n   - ART(Android Runtime)는 디버깅 기능을 지원하기 위해 몇 가지 중요한 최적화를 비활성화하기 때문이다.\n2. 때때로 버벅거림은 앱이 [cold start](https://developer.android.com/topic/performance/vitals/launch-time#cold) 에서 시작될 때만 재현 될 수 있다.\n3. 버벅거림을 극대화 시키기 위해 더 느린 장치에서 앱을 실행해 봐라.\n\n\n\n### Systrace\n\n기기가 수행하는 전체 작업을 보여주는 도구이지만 앱에서 버벅거림을 식별하는 데 유용할 수 있다.\n\nSystrace는 최소한의 시스템 오버헤드를 가지므로 계측 중에 현실적인 버벅거림을 경험할 수 있다.\n\n\n\n### 버벅거림을 유발할 수 있는 요소들\n\n버벅거림을 유발하는 요소는 대표적으로 **Scrollable lists, Layout performance, Rendering performance**가 있다.\n\n#### Scrollable lists\n\nListView 및 특히 RecyclerView는 버벅거림에 가장 취약한 복잡한 스크롤 목록에 일반적으로 사용된다.\n\n둘 다 Systrace 마커가 포함되어 있으므로 Systrace를 사용하여 앱에서 버벅거림을 유발하는지 여부를 파악할 수 있다.\n\nRecyclerView의 systrace 섹션을 표시하려면 명령에 `-a <your-package-name>`을 전달해야한다. 사용 가능한 경우 systrace 출력에 생성 된 경고의 지침을 따르자.\n\nSystrace 내에서 RecyclerView systrace 섹션을 클릭하여 RecyclerView가 수행하는 작업에 대한 설명을 볼 수 있다.\n\n1. 작은 업데이트를 위해 `notifyDataSetChanged()`, `setAdapter(Adapter)`, or `swapAdapter(Adapter, boolean)`를 호출하지 마라.\n   - 전체 목록 아이템이 변경되었다고 알리기 때문이다.\n   - 대신 `SortedList` 또는 `DiffUtil`을 사용하여 콘텐츠가 변경되거나 추가 될 때 최소한의 업데이트를 하도록하자.\n2. **Nested recyclerview**\n   - 내부 RecyclerView의 LinearLayoutManager에 `setInitialPrefetchItemCount(int)` 를 설정할 수도 있다.\n   - 예를 들어 항상 3.5 개의 항목이 한 행에 표시되는 경우, `innerLinearLayoutManager.setInitialItemPrefetchCount(4);` 를 호출한다.\n\n3. `RecyclerView` 의 `view type` 이 적을수록 새 item type 이 화면에 표시 될 때 수행해야하는 inflation 이 줄어 든다.\n   - 만약 아이콘, 색상, 작은 문구 변경 차이라면, 별도의 view type 으로 나누지 않고 bind 할 때 변경하는 것이 낫다. (동시에 앱의 메모리 사용량 감소)\n4. Bind (즉, onBindViewHolder (VH, int) 는 매우 간단해야하며 가장 복잡한 항목을 제외한 모든 항목에 대해 1 밀리 초 미만이 소요되야 한다.\n   - 단순히 adapter 의 내부 item 에서 POJO item 을 가져와서, ViewHolder의 view 에서 setter 를 호출해야 한다.\n\n#### Layout performance\n\n`Systrace`에서 `Choreographer # doFrame`의 레이아웃 세그먼트가 너무 많은 작업을 수행하거나 너무 자주 작업을 수행하는 것으로 표시되면 레이아웃 성능 문제가 있음을 의미한다.\n\n세그먼트가 몇 밀리 초보다 길면 `RelativeLayouts` 또는 `weighted-LinearLayouts`에 대해 최악의 경우 중첩 성능에 도달 할 수 있다. \n\n이러한 각 레이아웃은 자식의 여러 측정 / 레이아웃 패스를 트리거 할 수 있으므로 중첩하면 중첩 깊이에서 O (n ^ 2) 동작이 발생할 수 있다. \n\n**계층 구조의 최하위 리프 노드를 제외한 모든 노드에서 RelativeLayout 또는 LinearLayout의 가중치 기능을 피해라.**\n\n#### Rendering performance\n\n**Android UI는 UI 스레드의 Record `View # draw`와 RenderThread의 `DrawFrame`의 두 단계로 작동한다**.\n\n첫 번째는 모든 `invalidated View` 에서 `draw (Canvas)`를 실행한다.\n\n두 번째는 기본 `RenderThread`에서 실행되지만 `View#draw()` 단계에서 생성 된 작업을 기반으로 작동한다.\n\n`View#draw()` 가 너무 오래 걸린다면, 이 경우는 보통 UI 스레드에서 bitmap 이 그려지는 경우다. `Bitmap` 에 그리기는 CPU 렌더링을 사용하므로 일반적으로 가능하면 이를 피해야 한다.\n\n### Custom Performance Monitoring(맞춤 성능 모니터링 사용)\n\n로컬 기기에서 버벅거림을 재현할 수 없는 경우 앱에 맞춤 성능 모니터링을 빌드하여 현장에서 기기의 버벅거림 원인을 식별할 수 있다.\n\n이를 위해 [`FrameMetricsAggregator`](https://developer.android.com/reference/androidx/core/app/FrameMetricsAggregator)를 사용하여 앱의 특정 부분에서 프레임 렌더링 시간을 수집하고 [Firebase Performance Monitoring](https://firebase.google.com/docs/perf-mon/)을 사용하여 데이터를 기록하고 분석할 수 있다.\n\n자세한 내용은 아래내용을 참조하자.\n\n- [Android Vitals](https://developer.android.com/topic/performance/vitals)\n- [Firebase Performance Monitoring 사용](https://firebase.google.com/docs/perf-mon/get-started-android#pdc)\n\n## Overdraw\n\n> An app may draw the same pixel more than once within a single frame, an event called overdraw. Overdraw is usually unnecessary, and best eliminated. It manifests itself as a performance problem by wasting GPU time to render pixels that don't contribute to what the user sees on the screen.\n\n오버드로는 시스템이 단일 렌더링 프레임에서 화면에 여러 번 픽셀을 그리는 것을 말한다.\n\n> **참고** : Overdraw는 더 이상 Google I/O 성능 세션 및 성능 패턴 동영상에서 논의되었을 때 만큼 심각한 문제가 아니다.\n>\n> 이는 저가형 장치가 GPU 성능에서 지속적으로 성장하는 반면 디스플레이는 상대적으로 낮은 해상도에서 정체 되었기 때문. 알려진 저 성능 GPU 장치를 최적화하지 않는 한, 원활한 앱 성능을 보장하는 것 대신 UI 스레드 작업을 최적화하는 데 집중하는 것이 좋다.\n>\n> [참고영상](https://www.youtube.com/watch?v=vkTn3Ule4Ps)을 확인하자.\n\n다른 개발자 옵션으로 UI 에 컬러를 지정함으로써 오버드로를 식별할 수 있다. 같은 프레임내에서 같은 픽셀을 한번 이상 그릴 때 오버드로가 발생한다.\n\n앱에서 필요 이상으로 많은 렌더링이 발생하는 곳을 시각화로 보여주며, 사용자에게 보여지지 않는 픽셀을 렌더링하기 위해 추가 GPU 작업으로 성능 문제가 발생한 수 있음을 알 수 있다. 다음과 같이 설정하면 오버드로 시각화를 확인 할 수 있다.\n\n### Overdraw 디버깅\n\n##### 여는방법\n\n1. 기기에서 **설정**으로 이동하여 **개발자 옵션**을 탭한다.\n2. **하드웨어 가속 렌더링** 섹션으로 스크롤하여 **GPU 오버드로 디버그**를 선택한다.\n3. **GPU 오버드로 디버그** 대화상자에서 **오버드로 영역 표시**를 선택한다.\n4. **분석**\n\n- **True color:** No overdraw\n- **Blue:** Overdrawn 1 time {% asset_img overdrawn_1.png [Overdrawn 1 time] %}\n- **Green:** Overdrawn 2 times {% asset_img overdrawn_2.png [Overdrawn 2 time] %}\n- **Pink:** Overdrawn 3 times {% asset_img overdrawn_3.png [Overdrawn 3 time] %}\n- **Red:** Overdrawn 4 or more times {% asset_img overdrawn_4.png [Overdrawn 4 time] %}\n\n디버깅 결과는 아래와 같이 비교 가능하다.\n\n뷰의 배치에 따라 각각 오버드로가 발생한 픽셀을 확인할 수 있다.\n\n{% asset_img zw3H5pZ.png [Overdraw Visialization] %}\n\n\n### Overdraw 줄이기\n\nOverdraw를 줄일 수 있는 방법은 대표적으로 세가지가 있다.\n\n1. layouts 에서 불필요한 backgrounds 는 제거하자\n\n2. View 계층을 평면화하자\n\n3. 투명도를 줄이자 \n\n- 알파 렌더링으로 알려진 화면에서 투명 픽셀을 렌더링하는 것은 오버드로의 주요 원인이다.\n- 시스템이 그 위에 불투명 한 픽셀을 그려서 기존의 그려진 픽셀을 완전히 숨기는 표준 오버드로와 달리, 투명한 객체는 올바른 `blending equation` 이 발생하도록 기존 픽셀을 먼저 그려야한다.\n\n> **참고** blending equation : 2개의 픽셀 컬러 값을 결합시키는 것. [관련 블로그](https://xysterxx.tistory.com/50)\n\n\n## UI 렌더링 성능 개선\n\n지금까지는 원인 및 분석 방법에 대해서 살펴보았다. 이번에는 본격적으로 코드레벨에서 분석 및 개선방안을 통해 어떻게 개선할 수 있는지 보자.\n\n### 레이아웃 재사용\n\n- include, merge를 통해 뷰를 재사용한다.\n- include로만 뷰를 재사용하면 다음과 같이 뷰가 중첩될 수 있다.\n\n{% asset_img before_merge.png [before_merge] %}\n\n- merge를 같이 사용하여 중첩을 줄여준다 \n\n{% asset_img after_merge.png [after_merge] %}\n\n  \n\n### 오버드로잉 방지(뷰 백그라운드)\n\n일반적으로 우리는 앱의 배경 색상을 적용하기 위해 `android:background=\"@color/white\"` 해당 뷰의 배경색상을 적용한다.\n\n```xml\n<!-- /res/layout/activity_main.xml -->\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<androidx.constraintlayout.widget.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    xmlns:tools=\"http://schemas.android.com/tools\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    tools:context=\".MainActivity\"\n    android:background=\"@color/white\">\n\n    <TextView\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"Hello World!\"\n        app:layout_constraintBottom_toBottomOf=\"parent\"\n        app:layout_constraintLeft_toLeftOf=\"parent\"\n        app:layout_constraintRight_toRightOf=\"parent\"\n        app:layout_constraintTop_toTopOf=\"parent\" />\n\n</androidx.constraintlayout.widget.ConstraintLayout>\n```\n\n이러한 방법은 View에 그려짐에 있어 중복으로 그릴 수 있는 여지가 있다.\n\n{% asset_img example1.png [example1] %}\n\n왜 Overdraw가 생기는지 확인을 위해 앱 테마 값을 확인해보았다.\n\n```xml\n<!-- /res/values/themes.xml -->\n<resources xmlns:tools=\"http://schemas.android.com/tools\">\n    <!-- Base application theme. -->\n    <style name=\"Theme.UITest\" parent=\"Theme.MaterialComponents.DayNight.DarkActionBar\">\n        <!-- Primary brand color. -->\n        <item name=\"colorPrimary\">@color/purple_500</item>\n        <item name=\"colorPrimaryVariant\">@color/purple_700</item>\n        <item name=\"colorOnPrimary\">@color/white</item>\n        <!-- Secondary brand color. -->\n        <item name=\"colorSecondary\">@color/teal_200</item>\n        <item name=\"colorSecondaryVariant\">@color/teal_700</item>\n        <item name=\"colorOnSecondary\">@color/black</item>\n        <!-- Status bar color. -->\n        <item name=\"android:statusBarColor\" tools:targetApi=\"l\">?attr/colorPrimaryVariant</item>\n        <!-- Customize your theme here. -->\n    </style>\n</resources>\n```\n\n특별히 지정해준 사항이 없어 해당 테마의 Parent를 따라가 보았다.\n\n```\nBase.V14.Theme.MaterialComponents.Light\nㄴ Base.Theme.MaterialComponents.Light\n    ㄴ Base.Theme.MaterialComponents.Light.DarkActionBar\n        ㄴ Theme.MaterialComponents.Light.DarkActionBar\n            ㄴ Theme.MaterialComponents.DayNight.DarkActionBar\n```\n\n해당 소스에서 아래와 같이 배경 색상을 지정하는 걸 확인하였고\n\n```xml\n<item name=\"android:colorBackground\">@color/design_default_color_background</item>\n```\n\n해당 값을 확인해보니 아래와 같이 흰색으로 설정하고 있었다.\n\n```xml\n<color name=\"design_default_color_background\">#FFFFFF</color>\n```\n\n한마디로 배경 색상을 흰색으로 칠해주고 그 위에 다시 흰색으로 칠해주고 있었다. 해당 Overdraw를 없애고 내가 원하는 색상으로 설정하기 위해 테마 파일을 아래와 같이 `<item name=\"android:windowBackground\">@color/beige</item>` 를 통해 오버드로잉 문제를 해결할 수 있다.\n\n```xml\n<!-- /res/values/themes.xml -->\n<resources xmlns:tools=\"http://schemas.android.com/tools\">\n    <!-- Base application theme. -->\n    <style name=\"Theme.UITest\" parent=\"Theme.MaterialComponents.DayNight.NoActionBar\">\n        <!-- Primary brand color. -->\n        <item name=\"colorPrimary\">@color/purple_500</item>\n        <item name=\"colorPrimaryVariant\">@color/purple_700</item>\n        <item name=\"colorOnPrimary\">@color/white</item>\n        <!-- Secondary brand color. -->\n        <item name=\"colorSecondary\">@color/teal_200</item>\n        <item name=\"colorSecondaryVariant\">@color/teal_700</item>\n        <item name=\"colorOnSecondary\">@color/black</item>\n        <!-- Status bar color. -->\n        <item name=\"android:statusBarColor\" tools:targetApi=\"l\">?attr/colorPrimaryVariant</item>\n        <!-- Customize your theme here. -->\n        <item name=\"android:windowBackground\">@color/beige</item>\n    </style>\n</resources>\n```\n\n `/res/layout/activity_main.xml` 파일에 `android:background=\"@color/beige\"` 코드를 입력 후 Overdraw를 확인한 결과는 다음과 같다.\n\n{% asset_img example2.png [example2] %}\n\n결론적으로 배경 색상 지정을 테마를 통해 지정하면 Overdraw를 줄일 수 있다.\n\n\n### Lazy Load by ViewStub\n\n해당 내용은 [찰스의 안드로이드 - ViewStub 활용으로 성능 높이기](https://www.charlezz.com/?p=19977)글 을 참고하였다.\n\nViewStub은 사이즈가 없는 보이지 않는 뷰로 런타임에서 늦은 전개(lazy-inflate)를 원할 때 사용할 수 있다.\n\nViewStub을 보이게 만들거나 inflate() 메서드를 호출하면 레이아웃이 전개되면서 ViewStub을 대체하기 때문에 ViewStub은 사라진다.\n\n\n\n전개된 뷰는 ViewStub의 부모 뷰에 추가 된다. 레이아웃에서 ViewStub을 사용하는 예제를 확인하자.\n\n```xml\n<ViewStub android:id=\"@+id/stub\"\n          android:inflatedId=\"@+id/subTree\"\n          android:layout=\"@layout/mySubTree\"\n          android:layout_width=\"120dp\"\n          android:layout_height=\"40dp\" />\n```\n\n\n\nfindViewById() 호출을 통해 ViewStub에 접근할 수 있다.\n\n```kotlin\nval viewStub = findViewById(R.id.stub)\n```\n\n생성되는 바인딩 클래스에서 ViewStub은 ViewStubProxy로 표현되며, ViewStub에 대해 접근할 수 있게 해준다.\n\n```kotlin\nval binding: ActivityMainBinding = ...\nval viewStubProxy = binding.stub\nval viewStub = viewStubProxy.viewStub()\n```\n\nViewStub에 지정된 레이아웃을 전개 시키기 위해서 서는 setVisibility() 또는 inflate()를 호출 할 수 있다.\n\n```kotlin\nval viewStub: ViewStub = ...\nviewStub.inflate()\n//또는 viewStub.visibility = View.VISIBLE\n```\n\nViewStub은 복잡하게 구성된 레이아웃을 빠르게 전개시켜야하는 상황에서, 레이아웃의 전개 시기를 선택적으로 늦출 수 있다.\n\n예를 들어 리스트 형태의 UI를 구성하고 하나의 뷰홀더가 전개 되는데 상당한 비용이 발생한다고 가정하자.\n\n이 때 사용자가 빠르게 화면을 스크롤 할 경우 프레임 드랍이 발생 할 수 있다. 이럴 때 선택적으로 불필요한 레이아웃의 전개를 제어하고 전개 시기를 늦춤으로써 성능을 개선시킬 수 있다.\n\n\n\n우리는 1, 2, 3편에서 안드로이드의 기본적인 UI구성요소, 내부적인 렌더링 매커니즘, 렌더링 되면서 성능상 이슈가 있는 부분을 알아보았고 마지막으로 성능에 대한 개선방안에 대해 알 수 있었다.\n\n안드로이드를 공부하는 여러분들께 조금이나마 도움이 되길 바란다.\n\n\n\n## Reference\n\n### Members of Study\n\nhttps://soda1127.github.io/introduce-jetpack-compose/\n\nhttps://velog.io/@jshme/How-To-Render-UI-In-Android\n\nhttps://velog.io/@jshme/How-To-Render-UI-In-Android-22\n\n### Official\n\n#### Docs\n\n[Android vitals](https://developer.android.com/topic/performance/vitals)\n\n[Android 드로잉 보기 방법](https://developer.android.com/guide/topics/ui/how-android-draws)\n\n[느린렌터링](https://developer.android.com/topic/performance/vitals/render#custom-monitoring)\n\n[Firebase Performance Monitoring 사용](https://firebase.google.com/docs/perf-mon/get-started-android#pdc)\n\n[GPU 렌더링 속도 및 오버드로 검사](https://developer.android.com/topic/performance/rendering/inspect-gpu-rendering)\n\n[맞춤 그리기](https://developer.android.com/training/custom-views/custom-drawing?hl=ko)\n\n[뷰 최적화](https://developer.android.com/training/custom-views/optimizing-view?hl=ko)\n\n\n\n#### Videos\n\n[Android Performance Patterns: Understanding VSYNC](https://www.youtube.com/watch?v=1iaHxmfZGGc)\n\n[Android Performance Patterns: Rendering Performance 101](https://www.youtube.com/watch?v=HXQhu6qfTVU&list=PLOU2XLYxmsIKEOXh5TwZEv89aofHzNCiu&index=48)\n\n[Android Performance Patterns: Tool - Profile GPU Rendering](https://www.youtube.com/watch?v=VzYkVL1n4M8&list=PLOU2XLYxmsIKEOXh5TwZEv89aofHzNCiu&index=51)\n\n[Android Performance Patterns: Understanding Overdraw](https://www.youtube.com/watch?v=T52v50r-JfE&list=PLOU2XLYxmsIKEOXh5TwZEv89aofHzNCiu&index=49)\n\n[Android Performance Patterns: Invalidations, Layouts, and Performance](https://www.youtube.com/watch?v=we6poP0kw6E&list=PLOU2XLYxmsIKEOXh5TwZEv89aofHzNCiu&index=54)\n\n[Android Performance Patterns: Hidden Cost of Transparency](https://www.youtube.com/watch?v=wIy8g8yNhNk&index=46&list=PLWz5rJ2EKKc9CBxr3BVjPTPoDPLdPIFCE)\n\n\n\n### Etc\n\n[찰스의 안드로이드 - ViewStub 활용으로 성능 높이기](https://www.charlezz.com/?p=19977)\n\n[Android Drawing Process 1(App surface, SF Layer)](https://lastyouth.tistory.com/24)","source":"_posts/2021-05-19 Android UI Rendering Optimization Part 3.md","raw":"---\ntitle: Introduce Android UI Rendering Principle and View Optimization Part 3\ndate: 2021-05-19 03:00\ncover: https://androiddeepdive.github.io/Team-Blog/images/cover_ui_rendering.png\ncategories:\n- User Interface\ntags:\n- Android\n- Rendering\n- Principle\n- Optimize\n- UI\n---\n\n<article class=\"message message-immersive is-primary\">\n    <div class=\"message-body\">\n        <i class=\"fas fa-pen-fancy mr-2\"></i>Writers<br>\n        by 김남훈 @Naver<br>\n        by 배희성 @RocketPunch<br>\n        by 송시영 @SmartStudy<br>\n        by 이기정 @BankSalad<br>\n        by 정세희 @BankSalad<br>\n        by 최소영 @BankSalad\n    </div>\n</article>\n\n\n<!-- more -->\n\n저번 포스트에서는 UI Rendering 시 화면에 보여질 때 어떤 과정을 거치는지 알 수 있었고, 현재 보편적으로 사용되는 하드웨어 모델 기반 렌더링 방식에서 발생하는 문제는 무엇이고, 해당 문제를 해결하기 위해 어떤 방법이 있는지, 실제로 어느정도의 성과를 낼 수 있는지 정리해보았다.\n\n## 버벅거림(Jank)\n\n앱이 느린 렌더링으로 어려움을 겪는 경우, 시스템은 프레임을 건너 뛰게되고 사용자는 앱에서 끊김을 감지하게 된다.\n\n{% asset_img image.png [Frame Drop] %}\n\n버벅거림에는 여러문제가 있지만, 대표적으로 UI렌더링 시에는 **OverDraw, Slow Rendering**과 같은 문제가 존재한다.\n\n## Slow Rendering 방지하기\n\n해당 내용은 Google Android Source Document의 [느린 렌더링](https://developer.android.com/topic/performance/vitals/render#custom-monitoring)글 을 참고하였다.\n\n렌더링 시 버벅거림을 감지할 수 있는 방법은 세가지이다.\n\n- [Visual inspection](https://developer.android.com/topic/performance/vitals/render#visual-inspection)\n- [Systrace](https://developer.android.com/topic/performance/vitals/render#systrace)\n- [Custom performance monitoring](https://developer.android.com/topic/performance/vitals/render#custom-monitoring)\n\n\n\n### 시각적 검사(Visual Inspection)\n\n우리는 안드로이드에서 제공하는 몇가지 옵션을 통해 시각화 하여 문제를 해결할 수 있다. 해결책은 아래와 같다.\n\n#### `Profile GPU Rendering` 을 활성화\n\n60fps(GPU 연산으로 초 당 60프레임으로 화면을 뿌리는 것)일 때 렌더링에 얼마나 성능을 잡아먹는지 확인하기 위해 개발자 옵션을 통해 다음 도구를 사용설정 할 수 있다.\n\n프로파일링은 Android 4.1(API 16 ) 이상에서 사용 가능하며 미리 해당 기능을 활성화하는 작업이 필요하다. 다음과 같은 순서로 진행하면 활성화 할 수 있다.\n\n##### 여는방법\n\n1. 기기에서 **설정**으로 이동하여 **개발자 옵션**을 탭한다.\n2. **모니터링** 섹션에서 **프로필 GPU 렌더링**을 선택한다.\n3. ‘프로필 GPU 렌더링’ 대화상자에서 **화면에 막대로 표시**를 선택하여 기기의 화면에 그래프를 오버레이한다.\n4. 프로파일링하려는 앱을 연다.\n\n설정을 활성화 하고 확인해보면, 아래와 같이 히스토그램으로 표시되는 것을 볼 수 있다. \n\n{% asset_img gpu_profile.png [Profile GPU Rendering] %}\n\n- 표시되는 각 애플리케이션에 관해 그래프가 표시된다.\n- 가로축의 각 세로 막대는 프레임을 나타내며 각 세로 막대의 높이는 프레임을 렌더링하는 데 걸린 시간(밀리초)을 나타낸다.\n- 녹색 가로선은 16밀리초를 나타냅니다. 60fps를 달성하려면 각 프레임의 세로 막대가 이 선 아래에 머물러야 합니다. 막대가 이 선을 넘어서면 애니메이션이 일시중지될 수 있다.\n- 16밀리초 임계값을 초과하는 프레임은 막대를 더 넓고 덜 투명하게 만들어 강조표시한다.\n- 각 막대에는 렌더링 파이프라인의 단계로 매핑되는 색상으로 표시된 구성요소가 있습니다. 구성요소의 수는 기기의 API 수준에 따라 다르다.\n- 각 막대에는 렌더링 파이프 라인의 단계에 매핑되는 색상 구성 요소가 있으므로 어느 부분이 가장 오래 걸리는지 확인할 수 있다.\n- 예를 들어 프레임이 입력을 처리하는 데 많은 시간을 소비하는 경우 사용자 입력을 처리하는 앱 코드를 살펴 봐야한다.\n\n##### 막대 색상 별 의미\n\n{% asset_img graph_color.png [Profile Graph Color] %}\n\n세로 막대 차트는 위와 같이 8개의 단계로 표시된다.\n\n- **프로세스/스왑버퍼(Swap)**: 안드로이드는 디스플레이 목록을 GPU 에 제출하는것을 끝내면, 시스템은 그래픽 드라이버에 현재 프레임이 완료되었음을 알리며 드라이버를 업데이트된 이미지를 화면에 표시한다. CPU 와 GPU 는 병렬로 처리되는데 CPU 가 GPU 처리보다 빠른 경우, 프로세스간 통신 큐가 가득찰 수 있다. CPU 는 큐에 공간이 생길때까지 기다린다. 큐가 가득한 상태는 스왑버퍼 상태에서 자주 발생하는데 이 단계에서 프레임 전체의 명령어가 제출되기 때문이다. 명령어 실행 단계와 비슷하게 GPU 에서 일어나는 일의 복잡성을 줄여 문제를 해결할 수 있다.\n- **명령어 실행(Issue)**: 디스플레이 목록을 화면에 그리기 위한 모든 명령어를 실행하기 위해 걸리는 시간을 측정한다. 주어진 프레임에서 렌더링하는 디스플레이 목록과 수량을 직접적으로 측정한다. 내재적으로 많은 그리기 동작이 있는 경우, 오랜 시간이 걸릴수 있다.\n- **동기화/업로드(Upload)**: 현재 프레임에서 비트맵 객체가 CPU 메모리에서 GPU 메모리로 전송되는데 걸리는 시간을 측정한다. 오랜 시간이 걸리는 경우는 작은 리소스가 많이 로드되어 있거나 적지만 큰 리소스가 로드되어 있는 경우이다. 비트맵 해상도가 실제 디스플레이 해상도보다 큰 사이즈로 로드되어 있지 않도록 하거나 동기화 전에 비동기로 미리 업로드해서 실행 시간을 줄일 수 있다.\n- **그리기(Draw)**: 백그라운드 혹은 텍스트 그리기와 같은 뷰를 그리기 명령어로 번역하는 단계로 시스템은 명령어를 디스플레이 목록에 캡처한다. 무효화된 뷰에서 onDraw 호출을 실행해 걸리는 모든 시간을 측정하며, 오랜 시간이 걸린다는 것은 무효화된 뷰가 많다는 것을 의미한다. 뷰가 무효화되는 경우 뷰의 디스프레이 목록을 재생성한다. 혹은 커스텀한 뷰가 onDraw 할때 복잡한 로직을 가질 때도 실행시간이 오랜 걸린다.\n- **측정 및 배치(Measure)**: 안드로이드에서 뷰를 스크린에 그리기 위해 측정하고 배치하는데 걸리는 시간을 측정한다. 일반적으로 오랜 시간이 걸리는 경우는 배치할 뷰가 너무 많거나 혹은 계층구조의 잘못된 장소에서 중복 계산이 이뤄지며, Traceview와 Systrace 를 사용해서 호출 스택을 확인하여 문제를 파악할 수 있다.\n- **애니메이션(Anim)**: 현재 프레임에서 실행되는 애니메이션에 대해 걸리는 시간을 측정한다. 일반적으로 오랜 시간이 걸리는 경우는 애니메이션의 속성 변경으로 인해 발생한다.\n- **입력 처리(Input)**: 앱이 입력 이벤트를 처리하는 시간으로 입력 이벤트 콜백의 결과로 호출된 코드를 실행하는데 걸리는 시간을 나타낸다. 일반적으로 오랜 시간이 걸리는 경우는 메인쓰레드에서 발생하며, 작업을 최적화하거나 다른 쓰레드를 이용해서 작업을 실행하도록 한다.\n- **기타(Misc)**: 렌더링 시스템이 작업을 수행하는 시간외에 렌더링과 관련 없는 추가적인 작업이 있다. 일반적으로 렌더링의 연속된 두 프레임 사이에서 UI 스레드에서 발생할 수 있는 일을 나타낸다. 오랜 시간이 걸리는 경우, 다른스레드에서 실행해야할 콜백, 인텐트 또는 기타 다른 작업이 있을 수 있다. Method tracing 또는 Systrace 를 사용하면 메인스레드에서 실행중인 작업을 확인해 문제를 해결할 수 있다.\n\n아래에는 이미지 뷰에 클릭 이벤트를 설정하고 이미지 리소스를 변경하는 로직이다. 좌측에는 단순하게 이미지 리소스를 변경하는 로직만 추가하였고, 우측에는 리소스를 변경하는 과정에서 스레드를 일시 중단하는 코드를 추가하였다. 그 결과 입력처리 시간에 차이가 발생한다는 것을 확인할 수 있다.\n\n{% asset_img gpu_rendering_profile_1.png [Image Comparison By GPU Rendering Profiling - 1] %}\n\n아래에는 이미지 뷰에 각각 다른 크기의 이미지 리소스를 배치하였다. 좌측에는 8.1MB 크기의 이미지 리소스를 배치하고 우측에는 16KB 크기의 이미지 리소스를 배치하였다. \n\n그 결과 이미지를 업로드 시간에 차이가 발생한 다는 것을 확인할 수 있다.\n\n{% asset_img gpu_rendering_profile_2.png [Image Comparison By GPU Rendering Profiling - 2] %}\n\n#### Etc\n\n예외적인 케이스에 대한 해법으로는 아래 세가지가 있다.\n\n1. Release 버전의 앱을 실행하자.\n   - ART(Android Runtime)는 디버깅 기능을 지원하기 위해 몇 가지 중요한 최적화를 비활성화하기 때문이다.\n2. 때때로 버벅거림은 앱이 [cold start](https://developer.android.com/topic/performance/vitals/launch-time#cold) 에서 시작될 때만 재현 될 수 있다.\n3. 버벅거림을 극대화 시키기 위해 더 느린 장치에서 앱을 실행해 봐라.\n\n\n\n### Systrace\n\n기기가 수행하는 전체 작업을 보여주는 도구이지만 앱에서 버벅거림을 식별하는 데 유용할 수 있다.\n\nSystrace는 최소한의 시스템 오버헤드를 가지므로 계측 중에 현실적인 버벅거림을 경험할 수 있다.\n\n\n\n### 버벅거림을 유발할 수 있는 요소들\n\n버벅거림을 유발하는 요소는 대표적으로 **Scrollable lists, Layout performance, Rendering performance**가 있다.\n\n#### Scrollable lists\n\nListView 및 특히 RecyclerView는 버벅거림에 가장 취약한 복잡한 스크롤 목록에 일반적으로 사용된다.\n\n둘 다 Systrace 마커가 포함되어 있으므로 Systrace를 사용하여 앱에서 버벅거림을 유발하는지 여부를 파악할 수 있다.\n\nRecyclerView의 systrace 섹션을 표시하려면 명령에 `-a <your-package-name>`을 전달해야한다. 사용 가능한 경우 systrace 출력에 생성 된 경고의 지침을 따르자.\n\nSystrace 내에서 RecyclerView systrace 섹션을 클릭하여 RecyclerView가 수행하는 작업에 대한 설명을 볼 수 있다.\n\n1. 작은 업데이트를 위해 `notifyDataSetChanged()`, `setAdapter(Adapter)`, or `swapAdapter(Adapter, boolean)`를 호출하지 마라.\n   - 전체 목록 아이템이 변경되었다고 알리기 때문이다.\n   - 대신 `SortedList` 또는 `DiffUtil`을 사용하여 콘텐츠가 변경되거나 추가 될 때 최소한의 업데이트를 하도록하자.\n2. **Nested recyclerview**\n   - 내부 RecyclerView의 LinearLayoutManager에 `setInitialPrefetchItemCount(int)` 를 설정할 수도 있다.\n   - 예를 들어 항상 3.5 개의 항목이 한 행에 표시되는 경우, `innerLinearLayoutManager.setInitialItemPrefetchCount(4);` 를 호출한다.\n\n3. `RecyclerView` 의 `view type` 이 적을수록 새 item type 이 화면에 표시 될 때 수행해야하는 inflation 이 줄어 든다.\n   - 만약 아이콘, 색상, 작은 문구 변경 차이라면, 별도의 view type 으로 나누지 않고 bind 할 때 변경하는 것이 낫다. (동시에 앱의 메모리 사용량 감소)\n4. Bind (즉, onBindViewHolder (VH, int) 는 매우 간단해야하며 가장 복잡한 항목을 제외한 모든 항목에 대해 1 밀리 초 미만이 소요되야 한다.\n   - 단순히 adapter 의 내부 item 에서 POJO item 을 가져와서, ViewHolder의 view 에서 setter 를 호출해야 한다.\n\n#### Layout performance\n\n`Systrace`에서 `Choreographer # doFrame`의 레이아웃 세그먼트가 너무 많은 작업을 수행하거나 너무 자주 작업을 수행하는 것으로 표시되면 레이아웃 성능 문제가 있음을 의미한다.\n\n세그먼트가 몇 밀리 초보다 길면 `RelativeLayouts` 또는 `weighted-LinearLayouts`에 대해 최악의 경우 중첩 성능에 도달 할 수 있다. \n\n이러한 각 레이아웃은 자식의 여러 측정 / 레이아웃 패스를 트리거 할 수 있으므로 중첩하면 중첩 깊이에서 O (n ^ 2) 동작이 발생할 수 있다. \n\n**계층 구조의 최하위 리프 노드를 제외한 모든 노드에서 RelativeLayout 또는 LinearLayout의 가중치 기능을 피해라.**\n\n#### Rendering performance\n\n**Android UI는 UI 스레드의 Record `View # draw`와 RenderThread의 `DrawFrame`의 두 단계로 작동한다**.\n\n첫 번째는 모든 `invalidated View` 에서 `draw (Canvas)`를 실행한다.\n\n두 번째는 기본 `RenderThread`에서 실행되지만 `View#draw()` 단계에서 생성 된 작업을 기반으로 작동한다.\n\n`View#draw()` 가 너무 오래 걸린다면, 이 경우는 보통 UI 스레드에서 bitmap 이 그려지는 경우다. `Bitmap` 에 그리기는 CPU 렌더링을 사용하므로 일반적으로 가능하면 이를 피해야 한다.\n\n### Custom Performance Monitoring(맞춤 성능 모니터링 사용)\n\n로컬 기기에서 버벅거림을 재현할 수 없는 경우 앱에 맞춤 성능 모니터링을 빌드하여 현장에서 기기의 버벅거림 원인을 식별할 수 있다.\n\n이를 위해 [`FrameMetricsAggregator`](https://developer.android.com/reference/androidx/core/app/FrameMetricsAggregator)를 사용하여 앱의 특정 부분에서 프레임 렌더링 시간을 수집하고 [Firebase Performance Monitoring](https://firebase.google.com/docs/perf-mon/)을 사용하여 데이터를 기록하고 분석할 수 있다.\n\n자세한 내용은 아래내용을 참조하자.\n\n- [Android Vitals](https://developer.android.com/topic/performance/vitals)\n- [Firebase Performance Monitoring 사용](https://firebase.google.com/docs/perf-mon/get-started-android#pdc)\n\n## Overdraw\n\n> An app may draw the same pixel more than once within a single frame, an event called overdraw. Overdraw is usually unnecessary, and best eliminated. It manifests itself as a performance problem by wasting GPU time to render pixels that don't contribute to what the user sees on the screen.\n\n오버드로는 시스템이 단일 렌더링 프레임에서 화면에 여러 번 픽셀을 그리는 것을 말한다.\n\n> **참고** : Overdraw는 더 이상 Google I/O 성능 세션 및 성능 패턴 동영상에서 논의되었을 때 만큼 심각한 문제가 아니다.\n>\n> 이는 저가형 장치가 GPU 성능에서 지속적으로 성장하는 반면 디스플레이는 상대적으로 낮은 해상도에서 정체 되었기 때문. 알려진 저 성능 GPU 장치를 최적화하지 않는 한, 원활한 앱 성능을 보장하는 것 대신 UI 스레드 작업을 최적화하는 데 집중하는 것이 좋다.\n>\n> [참고영상](https://www.youtube.com/watch?v=vkTn3Ule4Ps)을 확인하자.\n\n다른 개발자 옵션으로 UI 에 컬러를 지정함으로써 오버드로를 식별할 수 있다. 같은 프레임내에서 같은 픽셀을 한번 이상 그릴 때 오버드로가 발생한다.\n\n앱에서 필요 이상으로 많은 렌더링이 발생하는 곳을 시각화로 보여주며, 사용자에게 보여지지 않는 픽셀을 렌더링하기 위해 추가 GPU 작업으로 성능 문제가 발생한 수 있음을 알 수 있다. 다음과 같이 설정하면 오버드로 시각화를 확인 할 수 있다.\n\n### Overdraw 디버깅\n\n##### 여는방법\n\n1. 기기에서 **설정**으로 이동하여 **개발자 옵션**을 탭한다.\n2. **하드웨어 가속 렌더링** 섹션으로 스크롤하여 **GPU 오버드로 디버그**를 선택한다.\n3. **GPU 오버드로 디버그** 대화상자에서 **오버드로 영역 표시**를 선택한다.\n4. **분석**\n\n- **True color:** No overdraw\n- **Blue:** Overdrawn 1 time {% asset_img overdrawn_1.png [Overdrawn 1 time] %}\n- **Green:** Overdrawn 2 times {% asset_img overdrawn_2.png [Overdrawn 2 time] %}\n- **Pink:** Overdrawn 3 times {% asset_img overdrawn_3.png [Overdrawn 3 time] %}\n- **Red:** Overdrawn 4 or more times {% asset_img overdrawn_4.png [Overdrawn 4 time] %}\n\n디버깅 결과는 아래와 같이 비교 가능하다.\n\n뷰의 배치에 따라 각각 오버드로가 발생한 픽셀을 확인할 수 있다.\n\n{% asset_img zw3H5pZ.png [Overdraw Visialization] %}\n\n\n### Overdraw 줄이기\n\nOverdraw를 줄일 수 있는 방법은 대표적으로 세가지가 있다.\n\n1. layouts 에서 불필요한 backgrounds 는 제거하자\n\n2. View 계층을 평면화하자\n\n3. 투명도를 줄이자 \n\n- 알파 렌더링으로 알려진 화면에서 투명 픽셀을 렌더링하는 것은 오버드로의 주요 원인이다.\n- 시스템이 그 위에 불투명 한 픽셀을 그려서 기존의 그려진 픽셀을 완전히 숨기는 표준 오버드로와 달리, 투명한 객체는 올바른 `blending equation` 이 발생하도록 기존 픽셀을 먼저 그려야한다.\n\n> **참고** blending equation : 2개의 픽셀 컬러 값을 결합시키는 것. [관련 블로그](https://xysterxx.tistory.com/50)\n\n\n## UI 렌더링 성능 개선\n\n지금까지는 원인 및 분석 방법에 대해서 살펴보았다. 이번에는 본격적으로 코드레벨에서 분석 및 개선방안을 통해 어떻게 개선할 수 있는지 보자.\n\n### 레이아웃 재사용\n\n- include, merge를 통해 뷰를 재사용한다.\n- include로만 뷰를 재사용하면 다음과 같이 뷰가 중첩될 수 있다.\n\n{% asset_img before_merge.png [before_merge] %}\n\n- merge를 같이 사용하여 중첩을 줄여준다 \n\n{% asset_img after_merge.png [after_merge] %}\n\n  \n\n### 오버드로잉 방지(뷰 백그라운드)\n\n일반적으로 우리는 앱의 배경 색상을 적용하기 위해 `android:background=\"@color/white\"` 해당 뷰의 배경색상을 적용한다.\n\n```xml\n<!-- /res/layout/activity_main.xml -->\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<androidx.constraintlayout.widget.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    xmlns:tools=\"http://schemas.android.com/tools\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    tools:context=\".MainActivity\"\n    android:background=\"@color/white\">\n\n    <TextView\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"Hello World!\"\n        app:layout_constraintBottom_toBottomOf=\"parent\"\n        app:layout_constraintLeft_toLeftOf=\"parent\"\n        app:layout_constraintRight_toRightOf=\"parent\"\n        app:layout_constraintTop_toTopOf=\"parent\" />\n\n</androidx.constraintlayout.widget.ConstraintLayout>\n```\n\n이러한 방법은 View에 그려짐에 있어 중복으로 그릴 수 있는 여지가 있다.\n\n{% asset_img example1.png [example1] %}\n\n왜 Overdraw가 생기는지 확인을 위해 앱 테마 값을 확인해보았다.\n\n```xml\n<!-- /res/values/themes.xml -->\n<resources xmlns:tools=\"http://schemas.android.com/tools\">\n    <!-- Base application theme. -->\n    <style name=\"Theme.UITest\" parent=\"Theme.MaterialComponents.DayNight.DarkActionBar\">\n        <!-- Primary brand color. -->\n        <item name=\"colorPrimary\">@color/purple_500</item>\n        <item name=\"colorPrimaryVariant\">@color/purple_700</item>\n        <item name=\"colorOnPrimary\">@color/white</item>\n        <!-- Secondary brand color. -->\n        <item name=\"colorSecondary\">@color/teal_200</item>\n        <item name=\"colorSecondaryVariant\">@color/teal_700</item>\n        <item name=\"colorOnSecondary\">@color/black</item>\n        <!-- Status bar color. -->\n        <item name=\"android:statusBarColor\" tools:targetApi=\"l\">?attr/colorPrimaryVariant</item>\n        <!-- Customize your theme here. -->\n    </style>\n</resources>\n```\n\n특별히 지정해준 사항이 없어 해당 테마의 Parent를 따라가 보았다.\n\n```\nBase.V14.Theme.MaterialComponents.Light\nㄴ Base.Theme.MaterialComponents.Light\n    ㄴ Base.Theme.MaterialComponents.Light.DarkActionBar\n        ㄴ Theme.MaterialComponents.Light.DarkActionBar\n            ㄴ Theme.MaterialComponents.DayNight.DarkActionBar\n```\n\n해당 소스에서 아래와 같이 배경 색상을 지정하는 걸 확인하였고\n\n```xml\n<item name=\"android:colorBackground\">@color/design_default_color_background</item>\n```\n\n해당 값을 확인해보니 아래와 같이 흰색으로 설정하고 있었다.\n\n```xml\n<color name=\"design_default_color_background\">#FFFFFF</color>\n```\n\n한마디로 배경 색상을 흰색으로 칠해주고 그 위에 다시 흰색으로 칠해주고 있었다. 해당 Overdraw를 없애고 내가 원하는 색상으로 설정하기 위해 테마 파일을 아래와 같이 `<item name=\"android:windowBackground\">@color/beige</item>` 를 통해 오버드로잉 문제를 해결할 수 있다.\n\n```xml\n<!-- /res/values/themes.xml -->\n<resources xmlns:tools=\"http://schemas.android.com/tools\">\n    <!-- Base application theme. -->\n    <style name=\"Theme.UITest\" parent=\"Theme.MaterialComponents.DayNight.NoActionBar\">\n        <!-- Primary brand color. -->\n        <item name=\"colorPrimary\">@color/purple_500</item>\n        <item name=\"colorPrimaryVariant\">@color/purple_700</item>\n        <item name=\"colorOnPrimary\">@color/white</item>\n        <!-- Secondary brand color. -->\n        <item name=\"colorSecondary\">@color/teal_200</item>\n        <item name=\"colorSecondaryVariant\">@color/teal_700</item>\n        <item name=\"colorOnSecondary\">@color/black</item>\n        <!-- Status bar color. -->\n        <item name=\"android:statusBarColor\" tools:targetApi=\"l\">?attr/colorPrimaryVariant</item>\n        <!-- Customize your theme here. -->\n        <item name=\"android:windowBackground\">@color/beige</item>\n    </style>\n</resources>\n```\n\n `/res/layout/activity_main.xml` 파일에 `android:background=\"@color/beige\"` 코드를 입력 후 Overdraw를 확인한 결과는 다음과 같다.\n\n{% asset_img example2.png [example2] %}\n\n결론적으로 배경 색상 지정을 테마를 통해 지정하면 Overdraw를 줄일 수 있다.\n\n\n### Lazy Load by ViewStub\n\n해당 내용은 [찰스의 안드로이드 - ViewStub 활용으로 성능 높이기](https://www.charlezz.com/?p=19977)글 을 참고하였다.\n\nViewStub은 사이즈가 없는 보이지 않는 뷰로 런타임에서 늦은 전개(lazy-inflate)를 원할 때 사용할 수 있다.\n\nViewStub을 보이게 만들거나 inflate() 메서드를 호출하면 레이아웃이 전개되면서 ViewStub을 대체하기 때문에 ViewStub은 사라진다.\n\n\n\n전개된 뷰는 ViewStub의 부모 뷰에 추가 된다. 레이아웃에서 ViewStub을 사용하는 예제를 확인하자.\n\n```xml\n<ViewStub android:id=\"@+id/stub\"\n          android:inflatedId=\"@+id/subTree\"\n          android:layout=\"@layout/mySubTree\"\n          android:layout_width=\"120dp\"\n          android:layout_height=\"40dp\" />\n```\n\n\n\nfindViewById() 호출을 통해 ViewStub에 접근할 수 있다.\n\n```kotlin\nval viewStub = findViewById(R.id.stub)\n```\n\n생성되는 바인딩 클래스에서 ViewStub은 ViewStubProxy로 표현되며, ViewStub에 대해 접근할 수 있게 해준다.\n\n```kotlin\nval binding: ActivityMainBinding = ...\nval viewStubProxy = binding.stub\nval viewStub = viewStubProxy.viewStub()\n```\n\nViewStub에 지정된 레이아웃을 전개 시키기 위해서 서는 setVisibility() 또는 inflate()를 호출 할 수 있다.\n\n```kotlin\nval viewStub: ViewStub = ...\nviewStub.inflate()\n//또는 viewStub.visibility = View.VISIBLE\n```\n\nViewStub은 복잡하게 구성된 레이아웃을 빠르게 전개시켜야하는 상황에서, 레이아웃의 전개 시기를 선택적으로 늦출 수 있다.\n\n예를 들어 리스트 형태의 UI를 구성하고 하나의 뷰홀더가 전개 되는데 상당한 비용이 발생한다고 가정하자.\n\n이 때 사용자가 빠르게 화면을 스크롤 할 경우 프레임 드랍이 발생 할 수 있다. 이럴 때 선택적으로 불필요한 레이아웃의 전개를 제어하고 전개 시기를 늦춤으로써 성능을 개선시킬 수 있다.\n\n\n\n우리는 1, 2, 3편에서 안드로이드의 기본적인 UI구성요소, 내부적인 렌더링 매커니즘, 렌더링 되면서 성능상 이슈가 있는 부분을 알아보았고 마지막으로 성능에 대한 개선방안에 대해 알 수 있었다.\n\n안드로이드를 공부하는 여러분들께 조금이나마 도움이 되길 바란다.\n\n\n\n## Reference\n\n### Members of Study\n\nhttps://soda1127.github.io/introduce-jetpack-compose/\n\nhttps://velog.io/@jshme/How-To-Render-UI-In-Android\n\nhttps://velog.io/@jshme/How-To-Render-UI-In-Android-22\n\n### Official\n\n#### Docs\n\n[Android vitals](https://developer.android.com/topic/performance/vitals)\n\n[Android 드로잉 보기 방법](https://developer.android.com/guide/topics/ui/how-android-draws)\n\n[느린렌터링](https://developer.android.com/topic/performance/vitals/render#custom-monitoring)\n\n[Firebase Performance Monitoring 사용](https://firebase.google.com/docs/perf-mon/get-started-android#pdc)\n\n[GPU 렌더링 속도 및 오버드로 검사](https://developer.android.com/topic/performance/rendering/inspect-gpu-rendering)\n\n[맞춤 그리기](https://developer.android.com/training/custom-views/custom-drawing?hl=ko)\n\n[뷰 최적화](https://developer.android.com/training/custom-views/optimizing-view?hl=ko)\n\n\n\n#### Videos\n\n[Android Performance Patterns: Understanding VSYNC](https://www.youtube.com/watch?v=1iaHxmfZGGc)\n\n[Android Performance Patterns: Rendering Performance 101](https://www.youtube.com/watch?v=HXQhu6qfTVU&list=PLOU2XLYxmsIKEOXh5TwZEv89aofHzNCiu&index=48)\n\n[Android Performance Patterns: Tool - Profile GPU Rendering](https://www.youtube.com/watch?v=VzYkVL1n4M8&list=PLOU2XLYxmsIKEOXh5TwZEv89aofHzNCiu&index=51)\n\n[Android Performance Patterns: Understanding Overdraw](https://www.youtube.com/watch?v=T52v50r-JfE&list=PLOU2XLYxmsIKEOXh5TwZEv89aofHzNCiu&index=49)\n\n[Android Performance Patterns: Invalidations, Layouts, and Performance](https://www.youtube.com/watch?v=we6poP0kw6E&list=PLOU2XLYxmsIKEOXh5TwZEv89aofHzNCiu&index=54)\n\n[Android Performance Patterns: Hidden Cost of Transparency](https://www.youtube.com/watch?v=wIy8g8yNhNk&index=46&list=PLWz5rJ2EKKc9CBxr3BVjPTPoDPLdPIFCE)\n\n\n\n### Etc\n\n[찰스의 안드로이드 - ViewStub 활용으로 성능 높이기](https://www.charlezz.com/?p=19977)\n\n[Android Drawing Process 1(App surface, SF Layer)](https://lastyouth.tistory.com/24)","slug":"2021-05-19 Android UI Rendering Optimization Part 3","published":1,"updated":"2021-07-25T13:28:28.008Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cksagj7l400093lreh3dy7weh","content":"<article class=\"message message-immersive is-primary\">\n    <div class=\"message-body\">\n        <i class=\"fas fa-pen-fancy mr-2\"></i>Writers<br>\n        by 김남훈 @Naver<br>\n        by 배희성 @RocketPunch<br>\n        by 송시영 @SmartStudy<br>\n        by 이기정 @BankSalad<br>\n        by 정세희 @BankSalad<br>\n        by 최소영 @BankSalad\n    </div>\n</article>\n\n\n<span id=\"more\"></span>\n\n<p>저번 포스트에서는 UI Rendering 시 화면에 보여질 때 어떤 과정을 거치는지 알 수 있었고, 현재 보편적으로 사용되는 하드웨어 모델 기반 렌더링 방식에서 발생하는 문제는 무엇이고, 해당 문제를 해결하기 위해 어떤 방법이 있는지, 실제로 어느정도의 성과를 낼 수 있는지 정리해보았다.</p>\n<h2 id=\"버벅거림-Jank\"><a href=\"#버벅거림-Jank\" class=\"headerlink\" title=\"버벅거림(Jank)\"></a>버벅거림(Jank)</h2><p>앱이 느린 렌더링으로 어려움을 겪는 경우, 시스템은 프레임을 건너 뛰게되고 사용자는 앱에서 끊김을 감지하게 된다.</p>\n<img src=\"/Team-Blog/2021/05/19/2021-05-19%20Android%20UI%20Rendering%20Optimization%20Part%203/image.png\" class=\"\" title=\"[Frame Drop]\">\n\n<p>버벅거림에는 여러문제가 있지만, 대표적으로 UI렌더링 시에는 <strong>OverDraw, Slow Rendering</strong>과 같은 문제가 존재한다.</p>\n<h2 id=\"Slow-Rendering-방지하기\"><a href=\"#Slow-Rendering-방지하기\" class=\"headerlink\" title=\"Slow Rendering 방지하기\"></a>Slow Rendering 방지하기</h2><p>해당 내용은 Google Android Source Document의 <a href=\"https://developer.android.com/topic/performance/vitals/render#custom-monitoring\">느린 렌더링</a>글 을 참고하였다.</p>\n<p>렌더링 시 버벅거림을 감지할 수 있는 방법은 세가지이다.</p>\n<ul>\n<li><a href=\"https://developer.android.com/topic/performance/vitals/render#visual-inspection\">Visual inspection</a></li>\n<li><a href=\"https://developer.android.com/topic/performance/vitals/render#systrace\">Systrace</a></li>\n<li><a href=\"https://developer.android.com/topic/performance/vitals/render#custom-monitoring\">Custom performance monitoring</a></li>\n</ul>\n<h3 id=\"시각적-검사-Visual-Inspection\"><a href=\"#시각적-검사-Visual-Inspection\" class=\"headerlink\" title=\"시각적 검사(Visual Inspection)\"></a>시각적 검사(Visual Inspection)</h3><p>우리는 안드로이드에서 제공하는 몇가지 옵션을 통해 시각화 하여 문제를 해결할 수 있다. 해결책은 아래와 같다.</p>\n<h4 id=\"Profile-GPU-Rendering-을-활성화\"><a href=\"#Profile-GPU-Rendering-을-활성화\" class=\"headerlink\" title=\"Profile GPU Rendering 을 활성화\"></a><code>Profile GPU Rendering</code> 을 활성화</h4><p>60fps(GPU 연산으로 초 당 60프레임으로 화면을 뿌리는 것)일 때 렌더링에 얼마나 성능을 잡아먹는지 확인하기 위해 개발자 옵션을 통해 다음 도구를 사용설정 할 수 있다.</p>\n<p>프로파일링은 Android 4.1(API 16 ) 이상에서 사용 가능하며 미리 해당 기능을 활성화하는 작업이 필요하다. 다음과 같은 순서로 진행하면 활성화 할 수 있다.</p>\n<h5 id=\"여는방법\"><a href=\"#여는방법\" class=\"headerlink\" title=\"여는방법\"></a>여는방법</h5><ol>\n<li>기기에서 <strong>설정</strong>으로 이동하여 <strong>개발자 옵션</strong>을 탭한다.</li>\n<li><strong>모니터링</strong> 섹션에서 <strong>프로필 GPU 렌더링</strong>을 선택한다.</li>\n<li>‘프로필 GPU 렌더링’ 대화상자에서 <strong>화면에 막대로 표시</strong>를 선택하여 기기의 화면에 그래프를 오버레이한다.</li>\n<li>프로파일링하려는 앱을 연다.</li>\n</ol>\n<p>설정을 활성화 하고 확인해보면, 아래와 같이 히스토그램으로 표시되는 것을 볼 수 있다. </p>\n<img src=\"/Team-Blog/2021/05/19/2021-05-19%20Android%20UI%20Rendering%20Optimization%20Part%203/gpu_profile.png\" class=\"\" title=\"[Profile GPU Rendering]\">\n\n<ul>\n<li>표시되는 각 애플리케이션에 관해 그래프가 표시된다.</li>\n<li>가로축의 각 세로 막대는 프레임을 나타내며 각 세로 막대의 높이는 프레임을 렌더링하는 데 걸린 시간(밀리초)을 나타낸다.</li>\n<li>녹색 가로선은 16밀리초를 나타냅니다. 60fps를 달성하려면 각 프레임의 세로 막대가 이 선 아래에 머물러야 합니다. 막대가 이 선을 넘어서면 애니메이션이 일시중지될 수 있다.</li>\n<li>16밀리초 임계값을 초과하는 프레임은 막대를 더 넓고 덜 투명하게 만들어 강조표시한다.</li>\n<li>각 막대에는 렌더링 파이프라인의 단계로 매핑되는 색상으로 표시된 구성요소가 있습니다. 구성요소의 수는 기기의 API 수준에 따라 다르다.</li>\n<li>각 막대에는 렌더링 파이프 라인의 단계에 매핑되는 색상 구성 요소가 있으므로 어느 부분이 가장 오래 걸리는지 확인할 수 있다.</li>\n<li>예를 들어 프레임이 입력을 처리하는 데 많은 시간을 소비하는 경우 사용자 입력을 처리하는 앱 코드를 살펴 봐야한다.</li>\n</ul>\n<h5 id=\"막대-색상-별-의미\"><a href=\"#막대-색상-별-의미\" class=\"headerlink\" title=\"막대 색상 별 의미\"></a>막대 색상 별 의미</h5><img src=\"/Team-Blog/2021/05/19/2021-05-19%20Android%20UI%20Rendering%20Optimization%20Part%203/graph_color.png\" class=\"\" title=\"[Profile Graph Color]\">\n\n<p>세로 막대 차트는 위와 같이 8개의 단계로 표시된다.</p>\n<ul>\n<li><strong>프로세스/스왑버퍼(Swap)</strong>: 안드로이드는 디스플레이 목록을 GPU 에 제출하는것을 끝내면, 시스템은 그래픽 드라이버에 현재 프레임이 완료되었음을 알리며 드라이버를 업데이트된 이미지를 화면에 표시한다. CPU 와 GPU 는 병렬로 처리되는데 CPU 가 GPU 처리보다 빠른 경우, 프로세스간 통신 큐가 가득찰 수 있다. CPU 는 큐에 공간이 생길때까지 기다린다. 큐가 가득한 상태는 스왑버퍼 상태에서 자주 발생하는데 이 단계에서 프레임 전체의 명령어가 제출되기 때문이다. 명령어 실행 단계와 비슷하게 GPU 에서 일어나는 일의 복잡성을 줄여 문제를 해결할 수 있다.</li>\n<li><strong>명령어 실행(Issue)</strong>: 디스플레이 목록을 화면에 그리기 위한 모든 명령어를 실행하기 위해 걸리는 시간을 측정한다. 주어진 프레임에서 렌더링하는 디스플레이 목록과 수량을 직접적으로 측정한다. 내재적으로 많은 그리기 동작이 있는 경우, 오랜 시간이 걸릴수 있다.</li>\n<li><strong>동기화/업로드(Upload)</strong>: 현재 프레임에서 비트맵 객체가 CPU 메모리에서 GPU 메모리로 전송되는데 걸리는 시간을 측정한다. 오랜 시간이 걸리는 경우는 작은 리소스가 많이 로드되어 있거나 적지만 큰 리소스가 로드되어 있는 경우이다. 비트맵 해상도가 실제 디스플레이 해상도보다 큰 사이즈로 로드되어 있지 않도록 하거나 동기화 전에 비동기로 미리 업로드해서 실행 시간을 줄일 수 있다.</li>\n<li><strong>그리기(Draw)</strong>: 백그라운드 혹은 텍스트 그리기와 같은 뷰를 그리기 명령어로 번역하는 단계로 시스템은 명령어를 디스플레이 목록에 캡처한다. 무효화된 뷰에서 onDraw 호출을 실행해 걸리는 모든 시간을 측정하며, 오랜 시간이 걸린다는 것은 무효화된 뷰가 많다는 것을 의미한다. 뷰가 무효화되는 경우 뷰의 디스프레이 목록을 재생성한다. 혹은 커스텀한 뷰가 onDraw 할때 복잡한 로직을 가질 때도 실행시간이 오랜 걸린다.</li>\n<li><strong>측정 및 배치(Measure)</strong>: 안드로이드에서 뷰를 스크린에 그리기 위해 측정하고 배치하는데 걸리는 시간을 측정한다. 일반적으로 오랜 시간이 걸리는 경우는 배치할 뷰가 너무 많거나 혹은 계층구조의 잘못된 장소에서 중복 계산이 이뤄지며, Traceview와 Systrace 를 사용해서 호출 스택을 확인하여 문제를 파악할 수 있다.</li>\n<li><strong>애니메이션(Anim)</strong>: 현재 프레임에서 실행되는 애니메이션에 대해 걸리는 시간을 측정한다. 일반적으로 오랜 시간이 걸리는 경우는 애니메이션의 속성 변경으로 인해 발생한다.</li>\n<li><strong>입력 처리(Input)</strong>: 앱이 입력 이벤트를 처리하는 시간으로 입력 이벤트 콜백의 결과로 호출된 코드를 실행하는데 걸리는 시간을 나타낸다. 일반적으로 오랜 시간이 걸리는 경우는 메인쓰레드에서 발생하며, 작업을 최적화하거나 다른 쓰레드를 이용해서 작업을 실행하도록 한다.</li>\n<li><strong>기타(Misc)</strong>: 렌더링 시스템이 작업을 수행하는 시간외에 렌더링과 관련 없는 추가적인 작업이 있다. 일반적으로 렌더링의 연속된 두 프레임 사이에서 UI 스레드에서 발생할 수 있는 일을 나타낸다. 오랜 시간이 걸리는 경우, 다른스레드에서 실행해야할 콜백, 인텐트 또는 기타 다른 작업이 있을 수 있다. Method tracing 또는 Systrace 를 사용하면 메인스레드에서 실행중인 작업을 확인해 문제를 해결할 수 있다.</li>\n</ul>\n<p>아래에는 이미지 뷰에 클릭 이벤트를 설정하고 이미지 리소스를 변경하는 로직이다. 좌측에는 단순하게 이미지 리소스를 변경하는 로직만 추가하였고, 우측에는 리소스를 변경하는 과정에서 스레드를 일시 중단하는 코드를 추가하였다. 그 결과 입력처리 시간에 차이가 발생한다는 것을 확인할 수 있다.</p>\n<img src=\"/Team-Blog/2021/05/19/2021-05-19%20Android%20UI%20Rendering%20Optimization%20Part%203/gpu_rendering_profile_1.png\" class=\"\" title=\"[Image Comparison By GPU Rendering Profiling - 1]\">\n\n<p>아래에는 이미지 뷰에 각각 다른 크기의 이미지 리소스를 배치하였다. 좌측에는 8.1MB 크기의 이미지 리소스를 배치하고 우측에는 16KB 크기의 이미지 리소스를 배치하였다. </p>\n<p>그 결과 이미지를 업로드 시간에 차이가 발생한 다는 것을 확인할 수 있다.</p>\n<img src=\"/Team-Blog/2021/05/19/2021-05-19%20Android%20UI%20Rendering%20Optimization%20Part%203/gpu_rendering_profile_2.png\" class=\"\" title=\"[Image Comparison By GPU Rendering Profiling - 2]\">\n\n<h4 id=\"Etc\"><a href=\"#Etc\" class=\"headerlink\" title=\"Etc\"></a>Etc</h4><p>예외적인 케이스에 대한 해법으로는 아래 세가지가 있다.</p>\n<ol>\n<li>Release 버전의 앱을 실행하자.<ul>\n<li>ART(Android Runtime)는 디버깅 기능을 지원하기 위해 몇 가지 중요한 최적화를 비활성화하기 때문이다.</li>\n</ul>\n</li>\n<li>때때로 버벅거림은 앱이 <a href=\"https://developer.android.com/topic/performance/vitals/launch-time#cold\">cold start</a> 에서 시작될 때만 재현 될 수 있다.</li>\n<li>버벅거림을 극대화 시키기 위해 더 느린 장치에서 앱을 실행해 봐라.</li>\n</ol>\n<h3 id=\"Systrace\"><a href=\"#Systrace\" class=\"headerlink\" title=\"Systrace\"></a>Systrace</h3><p>기기가 수행하는 전체 작업을 보여주는 도구이지만 앱에서 버벅거림을 식별하는 데 유용할 수 있다.</p>\n<p>Systrace는 최소한의 시스템 오버헤드를 가지므로 계측 중에 현실적인 버벅거림을 경험할 수 있다.</p>\n<h3 id=\"버벅거림을-유발할-수-있는-요소들\"><a href=\"#버벅거림을-유발할-수-있는-요소들\" class=\"headerlink\" title=\"버벅거림을 유발할 수 있는 요소들\"></a>버벅거림을 유발할 수 있는 요소들</h3><p>버벅거림을 유발하는 요소는 대표적으로 <strong>Scrollable lists, Layout performance, Rendering performance</strong>가 있다.</p>\n<h4 id=\"Scrollable-lists\"><a href=\"#Scrollable-lists\" class=\"headerlink\" title=\"Scrollable lists\"></a>Scrollable lists</h4><p>ListView 및 특히 RecyclerView는 버벅거림에 가장 취약한 복잡한 스크롤 목록에 일반적으로 사용된다.</p>\n<p>둘 다 Systrace 마커가 포함되어 있으므로 Systrace를 사용하여 앱에서 버벅거림을 유발하는지 여부를 파악할 수 있다.</p>\n<p>RecyclerView의 systrace 섹션을 표시하려면 명령에 <code>-a &lt;your-package-name&gt;</code>을 전달해야한다. 사용 가능한 경우 systrace 출력에 생성 된 경고의 지침을 따르자.</p>\n<p>Systrace 내에서 RecyclerView systrace 섹션을 클릭하여 RecyclerView가 수행하는 작업에 대한 설명을 볼 수 있다.</p>\n<ol>\n<li><p>작은 업데이트를 위해 <code>notifyDataSetChanged()</code>, <code>setAdapter(Adapter)</code>, or <code>swapAdapter(Adapter, boolean)</code>를 호출하지 마라.</p>\n<ul>\n<li>전체 목록 아이템이 변경되었다고 알리기 때문이다.</li>\n<li>대신 <code>SortedList</code> 또는 <code>DiffUtil</code>을 사용하여 콘텐츠가 변경되거나 추가 될 때 최소한의 업데이트를 하도록하자.</li>\n</ul>\n</li>\n<li><p><strong>Nested recyclerview</strong></p>\n<ul>\n<li>내부 RecyclerView의 LinearLayoutManager에 <code>setInitialPrefetchItemCount(int)</code> 를 설정할 수도 있다.</li>\n<li>예를 들어 항상 3.5 개의 항목이 한 행에 표시되는 경우, <code>innerLinearLayoutManager.setInitialItemPrefetchCount(4);</code> 를 호출한다.</li>\n</ul>\n</li>\n<li><p><code>RecyclerView</code> 의 <code>view type</code> 이 적을수록 새 item type 이 화면에 표시 될 때 수행해야하는 inflation 이 줄어 든다.</p>\n<ul>\n<li>만약 아이콘, 색상, 작은 문구 변경 차이라면, 별도의 view type 으로 나누지 않고 bind 할 때 변경하는 것이 낫다. (동시에 앱의 메모리 사용량 감소)</li>\n</ul>\n</li>\n<li><p>Bind (즉, onBindViewHolder (VH, int) 는 매우 간단해야하며 가장 복잡한 항목을 제외한 모든 항목에 대해 1 밀리 초 미만이 소요되야 한다.</p>\n<ul>\n<li>단순히 adapter 의 내부 item 에서 POJO item 을 가져와서, ViewHolder의 view 에서 setter 를 호출해야 한다.</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"Layout-performance\"><a href=\"#Layout-performance\" class=\"headerlink\" title=\"Layout performance\"></a>Layout performance</h4><p><code>Systrace</code>에서 <code>Choreographer # doFrame</code>의 레이아웃 세그먼트가 너무 많은 작업을 수행하거나 너무 자주 작업을 수행하는 것으로 표시되면 레이아웃 성능 문제가 있음을 의미한다.</p>\n<p>세그먼트가 몇 밀리 초보다 길면 <code>RelativeLayouts</code> 또는 <code>weighted-LinearLayouts</code>에 대해 최악의 경우 중첩 성능에 도달 할 수 있다. </p>\n<p>이러한 각 레이아웃은 자식의 여러 측정 / 레이아웃 패스를 트리거 할 수 있으므로 중첩하면 중첩 깊이에서 O (n ^ 2) 동작이 발생할 수 있다. </p>\n<p><strong>계층 구조의 최하위 리프 노드를 제외한 모든 노드에서 RelativeLayout 또는 LinearLayout의 가중치 기능을 피해라.</strong></p>\n<h4 id=\"Rendering-performance\"><a href=\"#Rendering-performance\" class=\"headerlink\" title=\"Rendering performance\"></a>Rendering performance</h4><p><strong>Android UI는 UI 스레드의 Record <code>View # draw</code>와 RenderThread의 <code>DrawFrame</code>의 두 단계로 작동한다</strong>.</p>\n<p>첫 번째는 모든 <code>invalidated View</code> 에서 <code>draw (Canvas)</code>를 실행한다.</p>\n<p>두 번째는 기본 <code>RenderThread</code>에서 실행되지만 <code>View#draw()</code> 단계에서 생성 된 작업을 기반으로 작동한다.</p>\n<p><code>View#draw()</code> 가 너무 오래 걸린다면, 이 경우는 보통 UI 스레드에서 bitmap 이 그려지는 경우다. <code>Bitmap</code> 에 그리기는 CPU 렌더링을 사용하므로 일반적으로 가능하면 이를 피해야 한다.</p>\n<h3 id=\"Custom-Performance-Monitoring-맞춤-성능-모니터링-사용\"><a href=\"#Custom-Performance-Monitoring-맞춤-성능-모니터링-사용\" class=\"headerlink\" title=\"Custom Performance Monitoring(맞춤 성능 모니터링 사용)\"></a>Custom Performance Monitoring(맞춤 성능 모니터링 사용)</h3><p>로컬 기기에서 버벅거림을 재현할 수 없는 경우 앱에 맞춤 성능 모니터링을 빌드하여 현장에서 기기의 버벅거림 원인을 식별할 수 있다.</p>\n<p>이를 위해 <a href=\"https://developer.android.com/reference/androidx/core/app/FrameMetricsAggregator\"><code>FrameMetricsAggregator</code></a>를 사용하여 앱의 특정 부분에서 프레임 렌더링 시간을 수집하고 <a href=\"https://firebase.google.com/docs/perf-mon/\">Firebase Performance Monitoring</a>을 사용하여 데이터를 기록하고 분석할 수 있다.</p>\n<p>자세한 내용은 아래내용을 참조하자.</p>\n<ul>\n<li><a href=\"https://developer.android.com/topic/performance/vitals\">Android Vitals</a></li>\n<li><a href=\"https://firebase.google.com/docs/perf-mon/get-started-android#pdc\">Firebase Performance Monitoring 사용</a></li>\n</ul>\n<h2 id=\"Overdraw\"><a href=\"#Overdraw\" class=\"headerlink\" title=\"Overdraw\"></a>Overdraw</h2><blockquote>\n<p>An app may draw the same pixel more than once within a single frame, an event called overdraw. Overdraw is usually unnecessary, and best eliminated. It manifests itself as a performance problem by wasting GPU time to render pixels that don’t contribute to what the user sees on the screen.</p>\n</blockquote>\n<p>오버드로는 시스템이 단일 렌더링 프레임에서 화면에 여러 번 픽셀을 그리는 것을 말한다.</p>\n<blockquote>\n<p><strong>참고</strong> : Overdraw는 더 이상 Google I/O 성능 세션 및 성능 패턴 동영상에서 논의되었을 때 만큼 심각한 문제가 아니다.</p>\n<p>이는 저가형 장치가 GPU 성능에서 지속적으로 성장하는 반면 디스플레이는 상대적으로 낮은 해상도에서 정체 되었기 때문. 알려진 저 성능 GPU 장치를 최적화하지 않는 한, 원활한 앱 성능을 보장하는 것 대신 UI 스레드 작업을 최적화하는 데 집중하는 것이 좋다.</p>\n<p><a href=\"https://www.youtube.com/watch?v=vkTn3Ule4Ps\">참고영상</a>을 확인하자.</p>\n</blockquote>\n<p>다른 개발자 옵션으로 UI 에 컬러를 지정함으로써 오버드로를 식별할 수 있다. 같은 프레임내에서 같은 픽셀을 한번 이상 그릴 때 오버드로가 발생한다.</p>\n<p>앱에서 필요 이상으로 많은 렌더링이 발생하는 곳을 시각화로 보여주며, 사용자에게 보여지지 않는 픽셀을 렌더링하기 위해 추가 GPU 작업으로 성능 문제가 발생한 수 있음을 알 수 있다. 다음과 같이 설정하면 오버드로 시각화를 확인 할 수 있다.</p>\n<h3 id=\"Overdraw-디버깅\"><a href=\"#Overdraw-디버깅\" class=\"headerlink\" title=\"Overdraw 디버깅\"></a>Overdraw 디버깅</h3><h5 id=\"여는방법-1\"><a href=\"#여는방법-1\" class=\"headerlink\" title=\"여는방법\"></a>여는방법</h5><ol>\n<li>기기에서 <strong>설정</strong>으로 이동하여 <strong>개발자 옵션</strong>을 탭한다.</li>\n<li><strong>하드웨어 가속 렌더링</strong> 섹션으로 스크롤하여 <strong>GPU 오버드로 디버그</strong>를 선택한다.</li>\n<li><strong>GPU 오버드로 디버그</strong> 대화상자에서 <strong>오버드로 영역 표시</strong>를 선택한다.</li>\n<li><strong>분석</strong></li>\n</ol>\n<ul>\n<li><strong>True color:</strong> No overdraw</li>\n<li><strong>Blue:</strong> Overdrawn 1 time <img src=\"/Team-Blog/2021/05/19/2021-05-19%20Android%20UI%20Rendering%20Optimization%20Part%203/overdrawn_1.png\" class=\"\" title=\"[Overdrawn 1 time]\"></li>\n<li><strong>Green:</strong> Overdrawn 2 times <img src=\"/Team-Blog/2021/05/19/2021-05-19%20Android%20UI%20Rendering%20Optimization%20Part%203/overdrawn_2.png\" class=\"\" title=\"[Overdrawn 2 time]\"></li>\n<li><strong>Pink:</strong> Overdrawn 3 times <img src=\"/Team-Blog/2021/05/19/2021-05-19%20Android%20UI%20Rendering%20Optimization%20Part%203/overdrawn_3.png\" class=\"\" title=\"[Overdrawn 3 time]\"></li>\n<li><strong>Red:</strong> Overdrawn 4 or more times <img src=\"/Team-Blog/2021/05/19/2021-05-19%20Android%20UI%20Rendering%20Optimization%20Part%203/overdrawn_4.png\" class=\"\" title=\"[Overdrawn 4 time]\"></li>\n</ul>\n<p>디버깅 결과는 아래와 같이 비교 가능하다.</p>\n<p>뷰의 배치에 따라 각각 오버드로가 발생한 픽셀을 확인할 수 있다.</p>\n<img src=\"/Team-Blog/2021/05/19/2021-05-19%20Android%20UI%20Rendering%20Optimization%20Part%203/zw3H5pZ.png\" class=\"\" title=\"[Overdraw Visialization]\">\n\n\n<h3 id=\"Overdraw-줄이기\"><a href=\"#Overdraw-줄이기\" class=\"headerlink\" title=\"Overdraw 줄이기\"></a>Overdraw 줄이기</h3><p>Overdraw를 줄일 수 있는 방법은 대표적으로 세가지가 있다.</p>\n<ol>\n<li><p>layouts 에서 불필요한 backgrounds 는 제거하자</p>\n</li>\n<li><p>View 계층을 평면화하자</p>\n</li>\n<li><p>투명도를 줄이자 </p>\n</li>\n</ol>\n<ul>\n<li>알파 렌더링으로 알려진 화면에서 투명 픽셀을 렌더링하는 것은 오버드로의 주요 원인이다.</li>\n<li>시스템이 그 위에 불투명 한 픽셀을 그려서 기존의 그려진 픽셀을 완전히 숨기는 표준 오버드로와 달리, 투명한 객체는 올바른 <code>blending equation</code> 이 발생하도록 기존 픽셀을 먼저 그려야한다.</li>\n</ul>\n<blockquote>\n<p><strong>참고</strong> blending equation : 2개의 픽셀 컬러 값을 결합시키는 것. <a href=\"https://xysterxx.tistory.com/50\">관련 블로그</a></p>\n</blockquote>\n<h2 id=\"UI-렌더링-성능-개선\"><a href=\"#UI-렌더링-성능-개선\" class=\"headerlink\" title=\"UI 렌더링 성능 개선\"></a>UI 렌더링 성능 개선</h2><p>지금까지는 원인 및 분석 방법에 대해서 살펴보았다. 이번에는 본격적으로 코드레벨에서 분석 및 개선방안을 통해 어떻게 개선할 수 있는지 보자.</p>\n<h3 id=\"레이아웃-재사용\"><a href=\"#레이아웃-재사용\" class=\"headerlink\" title=\"레이아웃 재사용\"></a>레이아웃 재사용</h3><ul>\n<li>include, merge를 통해 뷰를 재사용한다.</li>\n<li>include로만 뷰를 재사용하면 다음과 같이 뷰가 중첩될 수 있다.</li>\n</ul>\n<img src=\"/Team-Blog/2021/05/19/2021-05-19%20Android%20UI%20Rendering%20Optimization%20Part%203/before_merge.png\" class=\"\" title=\"[before_merge]\">\n\n<ul>\n<li>merge를 같이 사용하여 중첩을 줄여준다 </li>\n</ul>\n<img src=\"/Team-Blog/2021/05/19/2021-05-19%20Android%20UI%20Rendering%20Optimization%20Part%203/after_merge.png\" class=\"\" title=\"[after_merge]\">\n\n<h3 id=\"오버드로잉-방지-뷰-백그라운드\"><a href=\"#오버드로잉-방지-뷰-백그라운드\" class=\"headerlink\" title=\"오버드로잉 방지(뷰 백그라운드)\"></a>오버드로잉 방지(뷰 백그라운드)</h3><p>일반적으로 우리는 앱의 배경 색상을 적용하기 위해 <code>android:background=&quot;@color/white&quot;</code> 해당 뷰의 배경색상을 적용한다.</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- /res/layout/activity_main.xml --&gt;</span></span><br><span class=\"line\"><span class=\"meta\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">androidx.constraintlayout.widget.ConstraintLayout</span> <span class=\"attr\">xmlns:android</span>=<span class=\"string\">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">xmlns:app</span>=<span class=\"string\">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">xmlns:tools</span>=<span class=\"string\">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:layout_width</span>=<span class=\"string\">&quot;match_parent&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:layout_height</span>=<span class=\"string\">&quot;match_parent&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">tools:context</span>=<span class=\"string\">&quot;.MainActivity&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:background</span>=<span class=\"string\">&quot;@color/white&quot;</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">TextView</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:layout_width</span>=<span class=\"string\">&quot;wrap_content&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:layout_height</span>=<span class=\"string\">&quot;wrap_content&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:text</span>=<span class=\"string\">&quot;Hello World!&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">app:layout_constraintBottom_toBottomOf</span>=<span class=\"string\">&quot;parent&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">app:layout_constraintLeft_toLeftOf</span>=<span class=\"string\">&quot;parent&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">app:layout_constraintRight_toRightOf</span>=<span class=\"string\">&quot;parent&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">app:layout_constraintTop_toTopOf</span>=<span class=\"string\">&quot;parent&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">androidx.constraintlayout.widget.ConstraintLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>이러한 방법은 View에 그려짐에 있어 중복으로 그릴 수 있는 여지가 있다.</p>\n<img src=\"/Team-Blog/2021/05/19/2021-05-19%20Android%20UI%20Rendering%20Optimization%20Part%203/example1.png\" class=\"\" title=\"[example1]\">\n\n<p>왜 Overdraw가 생기는지 확인을 위해 앱 테마 값을 확인해보았다.</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- /res/values/themes.xml --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">resources</span> <span class=\"attr\">xmlns:tools</span>=<span class=\"string\">&quot;http://schemas.android.com/tools&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- Base application theme. --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">style</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;Theme.UITest&quot;</span> <span class=\"attr\">parent</span>=<span class=\"string\">&quot;Theme.MaterialComponents.DayNight.DarkActionBar&quot;</span>&gt;</span><span class=\"xml\"></span></span><br><span class=\"line\"><span class=\"xml\">        <span class=\"comment\">&lt;!-- Primary brand color. --&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">        <span class=\"tag\">&lt;<span class=\"name\">item</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;colorPrimary&quot;</span>&gt;</span>@color/purple_500<span class=\"tag\">&lt;/<span class=\"name\">item</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">        <span class=\"tag\">&lt;<span class=\"name\">item</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;colorPrimaryVariant&quot;</span>&gt;</span>@color/purple_700<span class=\"tag\">&lt;/<span class=\"name\">item</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">        <span class=\"tag\">&lt;<span class=\"name\">item</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;colorOnPrimary&quot;</span>&gt;</span>@color/white<span class=\"tag\">&lt;/<span class=\"name\">item</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">        <span class=\"comment\">&lt;!-- Secondary brand color. --&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">        <span class=\"tag\">&lt;<span class=\"name\">item</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;colorSecondary&quot;</span>&gt;</span>@color/teal_200<span class=\"tag\">&lt;/<span class=\"name\">item</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">        <span class=\"tag\">&lt;<span class=\"name\">item</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;colorSecondaryVariant&quot;</span>&gt;</span>@color/teal_700<span class=\"tag\">&lt;/<span class=\"name\">item</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">        <span class=\"tag\">&lt;<span class=\"name\">item</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;colorOnSecondary&quot;</span>&gt;</span>@color/black<span class=\"tag\">&lt;/<span class=\"name\">item</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">        <span class=\"comment\">&lt;!-- Status bar color. --&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">        <span class=\"tag\">&lt;<span class=\"name\">item</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;android:statusBarColor&quot;</span> <span class=\"attr\">tools:targetApi</span>=<span class=\"string\">&quot;l&quot;</span>&gt;</span>?attr/colorPrimaryVariant<span class=\"tag\">&lt;/<span class=\"name\">item</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">        <span class=\"comment\">&lt;!-- Customize your theme here. --&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">    </span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">resources</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>특별히 지정해준 사항이 없어 해당 테마의 Parent를 따라가 보았다.</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Base.V14.Theme.MaterialComponents.Light</span><br><span class=\"line\">ㄴ Base.Theme.MaterialComponents.Light</span><br><span class=\"line\">    ㄴ Base.Theme.MaterialComponents.Light.DarkActionBar</span><br><span class=\"line\">        ㄴ Theme.MaterialComponents.Light.DarkActionBar</span><br><span class=\"line\">            ㄴ Theme.MaterialComponents.DayNight.DarkActionBar</span><br></pre></td></tr></table></figure>\n\n<p>해당 소스에서 아래와 같이 배경 색상을 지정하는 걸 확인하였고</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">item</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;android:colorBackground&quot;</span>&gt;</span>@color/design_default_color_background<span class=\"tag\">&lt;/<span class=\"name\">item</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>해당 값을 확인해보니 아래와 같이 흰색으로 설정하고 있었다.</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">color</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;design_default_color_background&quot;</span>&gt;</span>#FFFFFF<span class=\"tag\">&lt;/<span class=\"name\">color</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>한마디로 배경 색상을 흰색으로 칠해주고 그 위에 다시 흰색으로 칠해주고 있었다. 해당 Overdraw를 없애고 내가 원하는 색상으로 설정하기 위해 테마 파일을 아래와 같이 <code>&lt;item name=&quot;android:windowBackground&quot;&gt;@color/beige&lt;/item&gt;</code> 를 통해 오버드로잉 문제를 해결할 수 있다.</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- /res/values/themes.xml --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">resources</span> <span class=\"attr\">xmlns:tools</span>=<span class=\"string\">&quot;http://schemas.android.com/tools&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- Base application theme. --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">style</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;Theme.UITest&quot;</span> <span class=\"attr\">parent</span>=<span class=\"string\">&quot;Theme.MaterialComponents.DayNight.NoActionBar&quot;</span>&gt;</span><span class=\"xml\"></span></span><br><span class=\"line\"><span class=\"xml\">        <span class=\"comment\">&lt;!-- Primary brand color. --&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">        <span class=\"tag\">&lt;<span class=\"name\">item</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;colorPrimary&quot;</span>&gt;</span>@color/purple_500<span class=\"tag\">&lt;/<span class=\"name\">item</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">        <span class=\"tag\">&lt;<span class=\"name\">item</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;colorPrimaryVariant&quot;</span>&gt;</span>@color/purple_700<span class=\"tag\">&lt;/<span class=\"name\">item</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">        <span class=\"tag\">&lt;<span class=\"name\">item</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;colorOnPrimary&quot;</span>&gt;</span>@color/white<span class=\"tag\">&lt;/<span class=\"name\">item</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">        <span class=\"comment\">&lt;!-- Secondary brand color. --&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">        <span class=\"tag\">&lt;<span class=\"name\">item</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;colorSecondary&quot;</span>&gt;</span>@color/teal_200<span class=\"tag\">&lt;/<span class=\"name\">item</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">        <span class=\"tag\">&lt;<span class=\"name\">item</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;colorSecondaryVariant&quot;</span>&gt;</span>@color/teal_700<span class=\"tag\">&lt;/<span class=\"name\">item</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">        <span class=\"tag\">&lt;<span class=\"name\">item</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;colorOnSecondary&quot;</span>&gt;</span>@color/black<span class=\"tag\">&lt;/<span class=\"name\">item</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">        <span class=\"comment\">&lt;!-- Status bar color. --&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">        <span class=\"tag\">&lt;<span class=\"name\">item</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;android:statusBarColor&quot;</span> <span class=\"attr\">tools:targetApi</span>=<span class=\"string\">&quot;l&quot;</span>&gt;</span>?attr/colorPrimaryVariant<span class=\"tag\">&lt;/<span class=\"name\">item</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">        <span class=\"comment\">&lt;!-- Customize your theme here. --&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">        <span class=\"tag\">&lt;<span class=\"name\">item</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;android:windowBackground&quot;</span>&gt;</span>@color/beige<span class=\"tag\">&lt;/<span class=\"name\">item</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">    </span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">resources</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p> <code>/res/layout/activity_main.xml</code> 파일에 <code>android:background=&quot;@color/beige&quot;</code> 코드를 입력 후 Overdraw를 확인한 결과는 다음과 같다.</p>\n<img src=\"/Team-Blog/2021/05/19/2021-05-19%20Android%20UI%20Rendering%20Optimization%20Part%203/example2.png\" class=\"\" title=\"[example2]\">\n\n<p>결론적으로 배경 색상 지정을 테마를 통해 지정하면 Overdraw를 줄일 수 있다.</p>\n<h3 id=\"Lazy-Load-by-ViewStub\"><a href=\"#Lazy-Load-by-ViewStub\" class=\"headerlink\" title=\"Lazy Load by ViewStub\"></a>Lazy Load by ViewStub</h3><p>해당 내용은 <a href=\"https://www.charlezz.com/?p=19977\">찰스의 안드로이드 - ViewStub 활용으로 성능 높이기</a>글 을 참고하였다.</p>\n<p>ViewStub은 사이즈가 없는 보이지 않는 뷰로 런타임에서 늦은 전개(lazy-inflate)를 원할 때 사용할 수 있다.</p>\n<p>ViewStub을 보이게 만들거나 inflate() 메서드를 호출하면 레이아웃이 전개되면서 ViewStub을 대체하기 때문에 ViewStub은 사라진다.</p>\n<p>전개된 뷰는 ViewStub의 부모 뷰에 추가 된다. 레이아웃에서 ViewStub을 사용하는 예제를 확인하자.</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ViewStub</span> <span class=\"attr\">android:id</span>=<span class=\"string\">&quot;@+id/stub&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">          <span class=\"attr\">android:inflatedId</span>=<span class=\"string\">&quot;@+id/subTree&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">          <span class=\"attr\">android:layout</span>=<span class=\"string\">&quot;@layout/mySubTree&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">          <span class=\"attr\">android:layout_width</span>=<span class=\"string\">&quot;120dp&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">          <span class=\"attr\">android:layout_height</span>=<span class=\"string\">&quot;40dp&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n\n\n\n<p>findViewById() 호출을 통해 ViewStub에 접근할 수 있다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> viewStub = findViewById(R.id.stub)</span><br></pre></td></tr></table></figure>\n\n<p>생성되는 바인딩 클래스에서 ViewStub은 ViewStubProxy로 표현되며, ViewStub에 대해 접근할 수 있게 해준다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> binding: ActivityMainBinding = ...</span><br><span class=\"line\"><span class=\"keyword\">val</span> viewStubProxy = binding.stub</span><br><span class=\"line\"><span class=\"keyword\">val</span> viewStub = viewStubProxy.viewStub()</span><br></pre></td></tr></table></figure>\n\n<p>ViewStub에 지정된 레이아웃을 전개 시키기 위해서 서는 setVisibility() 또는 inflate()를 호출 할 수 있다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> viewStub: ViewStub = ...</span><br><span class=\"line\">viewStub.inflate()</span><br><span class=\"line\"><span class=\"comment\">//또는 viewStub.visibility = View.VISIBLE</span></span><br></pre></td></tr></table></figure>\n\n<p>ViewStub은 복잡하게 구성된 레이아웃을 빠르게 전개시켜야하는 상황에서, 레이아웃의 전개 시기를 선택적으로 늦출 수 있다.</p>\n<p>예를 들어 리스트 형태의 UI를 구성하고 하나의 뷰홀더가 전개 되는데 상당한 비용이 발생한다고 가정하자.</p>\n<p>이 때 사용자가 빠르게 화면을 스크롤 할 경우 프레임 드랍이 발생 할 수 있다. 이럴 때 선택적으로 불필요한 레이아웃의 전개를 제어하고 전개 시기를 늦춤으로써 성능을 개선시킬 수 있다.</p>\n<p>우리는 1, 2, 3편에서 안드로이드의 기본적인 UI구성요소, 내부적인 렌더링 매커니즘, 렌더링 되면서 성능상 이슈가 있는 부분을 알아보았고 마지막으로 성능에 대한 개선방안에 대해 알 수 있었다.</p>\n<p>안드로이드를 공부하는 여러분들께 조금이나마 도움이 되길 바란다.</p>\n<h2 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h2><h3 id=\"Members-of-Study\"><a href=\"#Members-of-Study\" class=\"headerlink\" title=\"Members of Study\"></a>Members of Study</h3><p><a href=\"https://soda1127.github.io/introduce-jetpack-compose/\">https://soda1127.github.io/introduce-jetpack-compose/</a></p>\n<p><a href=\"https://velog.io/@jshme/How-To-Render-UI-In-Android\">https://velog.io/@jshme/How-To-Render-UI-In-Android</a></p>\n<p><a href=\"https://velog.io/@jshme/How-To-Render-UI-In-Android-22\">https://velog.io/@jshme/How-To-Render-UI-In-Android-22</a></p>\n<h3 id=\"Official\"><a href=\"#Official\" class=\"headerlink\" title=\"Official\"></a>Official</h3><h4 id=\"Docs\"><a href=\"#Docs\" class=\"headerlink\" title=\"Docs\"></a>Docs</h4><p><a href=\"https://developer.android.com/topic/performance/vitals\">Android vitals</a></p>\n<p><a href=\"https://developer.android.com/guide/topics/ui/how-android-draws\">Android 드로잉 보기 방법</a></p>\n<p><a href=\"https://developer.android.com/topic/performance/vitals/render#custom-monitoring\">느린렌터링</a></p>\n<p><a href=\"https://firebase.google.com/docs/perf-mon/get-started-android#pdc\">Firebase Performance Monitoring 사용</a></p>\n<p><a href=\"https://developer.android.com/topic/performance/rendering/inspect-gpu-rendering\">GPU 렌더링 속도 및 오버드로 검사</a></p>\n<p><a href=\"https://developer.android.com/training/custom-views/custom-drawing?hl=ko\">맞춤 그리기</a></p>\n<p><a href=\"https://developer.android.com/training/custom-views/optimizing-view?hl=ko\">뷰 최적화</a></p>\n<h4 id=\"Videos\"><a href=\"#Videos\" class=\"headerlink\" title=\"Videos\"></a>Videos</h4><p><a href=\"https://www.youtube.com/watch?v=1iaHxmfZGGc\">Android Performance Patterns: Understanding VSYNC</a></p>\n<p><a href=\"https://www.youtube.com/watch?v=HXQhu6qfTVU&list=PLOU2XLYxmsIKEOXh5TwZEv89aofHzNCiu&index=48\">Android Performance Patterns: Rendering Performance 101</a></p>\n<p><a href=\"https://www.youtube.com/watch?v=VzYkVL1n4M8&list=PLOU2XLYxmsIKEOXh5TwZEv89aofHzNCiu&index=51\">Android Performance Patterns: Tool - Profile GPU Rendering</a></p>\n<p><a href=\"https://www.youtube.com/watch?v=T52v50r-JfE&list=PLOU2XLYxmsIKEOXh5TwZEv89aofHzNCiu&index=49\">Android Performance Patterns: Understanding Overdraw</a></p>\n<p><a href=\"https://www.youtube.com/watch?v=we6poP0kw6E&list=PLOU2XLYxmsIKEOXh5TwZEv89aofHzNCiu&index=54\">Android Performance Patterns: Invalidations, Layouts, and Performance</a></p>\n<p><a href=\"https://www.youtube.com/watch?v=wIy8g8yNhNk&index=46&list=PLWz5rJ2EKKc9CBxr3BVjPTPoDPLdPIFCE\">Android Performance Patterns: Hidden Cost of Transparency</a></p>\n<h3 id=\"Etc-1\"><a href=\"#Etc-1\" class=\"headerlink\" title=\"Etc\"></a>Etc</h3><p><a href=\"https://www.charlezz.com/?p=19977\">찰스의 안드로이드 - ViewStub 활용으로 성능 높이기</a></p>\n<p><a href=\"https://lastyouth.tistory.com/24\">Android Drawing Process 1(App surface, SF Layer)</a></p>\n","site":{"data":{}},"excerpt":"<article class=\"message message-immersive is-primary\">\n    <div class=\"message-body\">\n        <i class=\"fas fa-pen-fancy mr-2\"></i>Writers<br>\n        by 김남훈 @Naver<br>\n        by 배희성 @RocketPunch<br>\n        by 송시영 @SmartStudy<br>\n        by 이기정 @BankSalad<br>\n        by 정세희 @BankSalad<br>\n        by 최소영 @BankSalad\n    </div>\n</article>","more":"<p>저번 포스트에서는 UI Rendering 시 화면에 보여질 때 어떤 과정을 거치는지 알 수 있었고, 현재 보편적으로 사용되는 하드웨어 모델 기반 렌더링 방식에서 발생하는 문제는 무엇이고, 해당 문제를 해결하기 위해 어떤 방법이 있는지, 실제로 어느정도의 성과를 낼 수 있는지 정리해보았다.</p>\n<h2 id=\"버벅거림-Jank\"><a href=\"#버벅거림-Jank\" class=\"headerlink\" title=\"버벅거림(Jank)\"></a>버벅거림(Jank)</h2><p>앱이 느린 렌더링으로 어려움을 겪는 경우, 시스템은 프레임을 건너 뛰게되고 사용자는 앱에서 끊김을 감지하게 된다.</p>\n<img src=\"/Team-Blog/2021/05/19/2021-05-19%20Android%20UI%20Rendering%20Optimization%20Part%203/image.png\" class=\"\" title=\"[Frame Drop]\">\n\n<p>버벅거림에는 여러문제가 있지만, 대표적으로 UI렌더링 시에는 <strong>OverDraw, Slow Rendering</strong>과 같은 문제가 존재한다.</p>\n<h2 id=\"Slow-Rendering-방지하기\"><a href=\"#Slow-Rendering-방지하기\" class=\"headerlink\" title=\"Slow Rendering 방지하기\"></a>Slow Rendering 방지하기</h2><p>해당 내용은 Google Android Source Document의 <a href=\"https://developer.android.com/topic/performance/vitals/render#custom-monitoring\">느린 렌더링</a>글 을 참고하였다.</p>\n<p>렌더링 시 버벅거림을 감지할 수 있는 방법은 세가지이다.</p>\n<ul>\n<li><a href=\"https://developer.android.com/topic/performance/vitals/render#visual-inspection\">Visual inspection</a></li>\n<li><a href=\"https://developer.android.com/topic/performance/vitals/render#systrace\">Systrace</a></li>\n<li><a href=\"https://developer.android.com/topic/performance/vitals/render#custom-monitoring\">Custom performance monitoring</a></li>\n</ul>\n<h3 id=\"시각적-검사-Visual-Inspection\"><a href=\"#시각적-검사-Visual-Inspection\" class=\"headerlink\" title=\"시각적 검사(Visual Inspection)\"></a>시각적 검사(Visual Inspection)</h3><p>우리는 안드로이드에서 제공하는 몇가지 옵션을 통해 시각화 하여 문제를 해결할 수 있다. 해결책은 아래와 같다.</p>\n<h4 id=\"Profile-GPU-Rendering-을-활성화\"><a href=\"#Profile-GPU-Rendering-을-활성화\" class=\"headerlink\" title=\"Profile GPU Rendering 을 활성화\"></a><code>Profile GPU Rendering</code> 을 활성화</h4><p>60fps(GPU 연산으로 초 당 60프레임으로 화면을 뿌리는 것)일 때 렌더링에 얼마나 성능을 잡아먹는지 확인하기 위해 개발자 옵션을 통해 다음 도구를 사용설정 할 수 있다.</p>\n<p>프로파일링은 Android 4.1(API 16 ) 이상에서 사용 가능하며 미리 해당 기능을 활성화하는 작업이 필요하다. 다음과 같은 순서로 진행하면 활성화 할 수 있다.</p>\n<h5 id=\"여는방법\"><a href=\"#여는방법\" class=\"headerlink\" title=\"여는방법\"></a>여는방법</h5><ol>\n<li>기기에서 <strong>설정</strong>으로 이동하여 <strong>개발자 옵션</strong>을 탭한다.</li>\n<li><strong>모니터링</strong> 섹션에서 <strong>프로필 GPU 렌더링</strong>을 선택한다.</li>\n<li>‘프로필 GPU 렌더링’ 대화상자에서 <strong>화면에 막대로 표시</strong>를 선택하여 기기의 화면에 그래프를 오버레이한다.</li>\n<li>프로파일링하려는 앱을 연다.</li>\n</ol>\n<p>설정을 활성화 하고 확인해보면, 아래와 같이 히스토그램으로 표시되는 것을 볼 수 있다. </p>\n<img src=\"/Team-Blog/2021/05/19/2021-05-19%20Android%20UI%20Rendering%20Optimization%20Part%203/gpu_profile.png\" class=\"\" title=\"[Profile GPU Rendering]\">\n\n<ul>\n<li>표시되는 각 애플리케이션에 관해 그래프가 표시된다.</li>\n<li>가로축의 각 세로 막대는 프레임을 나타내며 각 세로 막대의 높이는 프레임을 렌더링하는 데 걸린 시간(밀리초)을 나타낸다.</li>\n<li>녹색 가로선은 16밀리초를 나타냅니다. 60fps를 달성하려면 각 프레임의 세로 막대가 이 선 아래에 머물러야 합니다. 막대가 이 선을 넘어서면 애니메이션이 일시중지될 수 있다.</li>\n<li>16밀리초 임계값을 초과하는 프레임은 막대를 더 넓고 덜 투명하게 만들어 강조표시한다.</li>\n<li>각 막대에는 렌더링 파이프라인의 단계로 매핑되는 색상으로 표시된 구성요소가 있습니다. 구성요소의 수는 기기의 API 수준에 따라 다르다.</li>\n<li>각 막대에는 렌더링 파이프 라인의 단계에 매핑되는 색상 구성 요소가 있으므로 어느 부분이 가장 오래 걸리는지 확인할 수 있다.</li>\n<li>예를 들어 프레임이 입력을 처리하는 데 많은 시간을 소비하는 경우 사용자 입력을 처리하는 앱 코드를 살펴 봐야한다.</li>\n</ul>\n<h5 id=\"막대-색상-별-의미\"><a href=\"#막대-색상-별-의미\" class=\"headerlink\" title=\"막대 색상 별 의미\"></a>막대 색상 별 의미</h5><img src=\"/Team-Blog/2021/05/19/2021-05-19%20Android%20UI%20Rendering%20Optimization%20Part%203/graph_color.png\" class=\"\" title=\"[Profile Graph Color]\">\n\n<p>세로 막대 차트는 위와 같이 8개의 단계로 표시된다.</p>\n<ul>\n<li><strong>프로세스/스왑버퍼(Swap)</strong>: 안드로이드는 디스플레이 목록을 GPU 에 제출하는것을 끝내면, 시스템은 그래픽 드라이버에 현재 프레임이 완료되었음을 알리며 드라이버를 업데이트된 이미지를 화면에 표시한다. CPU 와 GPU 는 병렬로 처리되는데 CPU 가 GPU 처리보다 빠른 경우, 프로세스간 통신 큐가 가득찰 수 있다. CPU 는 큐에 공간이 생길때까지 기다린다. 큐가 가득한 상태는 스왑버퍼 상태에서 자주 발생하는데 이 단계에서 프레임 전체의 명령어가 제출되기 때문이다. 명령어 실행 단계와 비슷하게 GPU 에서 일어나는 일의 복잡성을 줄여 문제를 해결할 수 있다.</li>\n<li><strong>명령어 실행(Issue)</strong>: 디스플레이 목록을 화면에 그리기 위한 모든 명령어를 실행하기 위해 걸리는 시간을 측정한다. 주어진 프레임에서 렌더링하는 디스플레이 목록과 수량을 직접적으로 측정한다. 내재적으로 많은 그리기 동작이 있는 경우, 오랜 시간이 걸릴수 있다.</li>\n<li><strong>동기화/업로드(Upload)</strong>: 현재 프레임에서 비트맵 객체가 CPU 메모리에서 GPU 메모리로 전송되는데 걸리는 시간을 측정한다. 오랜 시간이 걸리는 경우는 작은 리소스가 많이 로드되어 있거나 적지만 큰 리소스가 로드되어 있는 경우이다. 비트맵 해상도가 실제 디스플레이 해상도보다 큰 사이즈로 로드되어 있지 않도록 하거나 동기화 전에 비동기로 미리 업로드해서 실행 시간을 줄일 수 있다.</li>\n<li><strong>그리기(Draw)</strong>: 백그라운드 혹은 텍스트 그리기와 같은 뷰를 그리기 명령어로 번역하는 단계로 시스템은 명령어를 디스플레이 목록에 캡처한다. 무효화된 뷰에서 onDraw 호출을 실행해 걸리는 모든 시간을 측정하며, 오랜 시간이 걸린다는 것은 무효화된 뷰가 많다는 것을 의미한다. 뷰가 무효화되는 경우 뷰의 디스프레이 목록을 재생성한다. 혹은 커스텀한 뷰가 onDraw 할때 복잡한 로직을 가질 때도 실행시간이 오랜 걸린다.</li>\n<li><strong>측정 및 배치(Measure)</strong>: 안드로이드에서 뷰를 스크린에 그리기 위해 측정하고 배치하는데 걸리는 시간을 측정한다. 일반적으로 오랜 시간이 걸리는 경우는 배치할 뷰가 너무 많거나 혹은 계층구조의 잘못된 장소에서 중복 계산이 이뤄지며, Traceview와 Systrace 를 사용해서 호출 스택을 확인하여 문제를 파악할 수 있다.</li>\n<li><strong>애니메이션(Anim)</strong>: 현재 프레임에서 실행되는 애니메이션에 대해 걸리는 시간을 측정한다. 일반적으로 오랜 시간이 걸리는 경우는 애니메이션의 속성 변경으로 인해 발생한다.</li>\n<li><strong>입력 처리(Input)</strong>: 앱이 입력 이벤트를 처리하는 시간으로 입력 이벤트 콜백의 결과로 호출된 코드를 실행하는데 걸리는 시간을 나타낸다. 일반적으로 오랜 시간이 걸리는 경우는 메인쓰레드에서 발생하며, 작업을 최적화하거나 다른 쓰레드를 이용해서 작업을 실행하도록 한다.</li>\n<li><strong>기타(Misc)</strong>: 렌더링 시스템이 작업을 수행하는 시간외에 렌더링과 관련 없는 추가적인 작업이 있다. 일반적으로 렌더링의 연속된 두 프레임 사이에서 UI 스레드에서 발생할 수 있는 일을 나타낸다. 오랜 시간이 걸리는 경우, 다른스레드에서 실행해야할 콜백, 인텐트 또는 기타 다른 작업이 있을 수 있다. Method tracing 또는 Systrace 를 사용하면 메인스레드에서 실행중인 작업을 확인해 문제를 해결할 수 있다.</li>\n</ul>\n<p>아래에는 이미지 뷰에 클릭 이벤트를 설정하고 이미지 리소스를 변경하는 로직이다. 좌측에는 단순하게 이미지 리소스를 변경하는 로직만 추가하였고, 우측에는 리소스를 변경하는 과정에서 스레드를 일시 중단하는 코드를 추가하였다. 그 결과 입력처리 시간에 차이가 발생한다는 것을 확인할 수 있다.</p>\n<img src=\"/Team-Blog/2021/05/19/2021-05-19%20Android%20UI%20Rendering%20Optimization%20Part%203/gpu_rendering_profile_1.png\" class=\"\" title=\"[Image Comparison By GPU Rendering Profiling - 1]\">\n\n<p>아래에는 이미지 뷰에 각각 다른 크기의 이미지 리소스를 배치하였다. 좌측에는 8.1MB 크기의 이미지 리소스를 배치하고 우측에는 16KB 크기의 이미지 리소스를 배치하였다. </p>\n<p>그 결과 이미지를 업로드 시간에 차이가 발생한 다는 것을 확인할 수 있다.</p>\n<img src=\"/Team-Blog/2021/05/19/2021-05-19%20Android%20UI%20Rendering%20Optimization%20Part%203/gpu_rendering_profile_2.png\" class=\"\" title=\"[Image Comparison By GPU Rendering Profiling - 2]\">\n\n<h4 id=\"Etc\"><a href=\"#Etc\" class=\"headerlink\" title=\"Etc\"></a>Etc</h4><p>예외적인 케이스에 대한 해법으로는 아래 세가지가 있다.</p>\n<ol>\n<li>Release 버전의 앱을 실행하자.<ul>\n<li>ART(Android Runtime)는 디버깅 기능을 지원하기 위해 몇 가지 중요한 최적화를 비활성화하기 때문이다.</li>\n</ul>\n</li>\n<li>때때로 버벅거림은 앱이 <a href=\"https://developer.android.com/topic/performance/vitals/launch-time#cold\">cold start</a> 에서 시작될 때만 재현 될 수 있다.</li>\n<li>버벅거림을 극대화 시키기 위해 더 느린 장치에서 앱을 실행해 봐라.</li>\n</ol>\n<h3 id=\"Systrace\"><a href=\"#Systrace\" class=\"headerlink\" title=\"Systrace\"></a>Systrace</h3><p>기기가 수행하는 전체 작업을 보여주는 도구이지만 앱에서 버벅거림을 식별하는 데 유용할 수 있다.</p>\n<p>Systrace는 최소한의 시스템 오버헤드를 가지므로 계측 중에 현실적인 버벅거림을 경험할 수 있다.</p>\n<h3 id=\"버벅거림을-유발할-수-있는-요소들\"><a href=\"#버벅거림을-유발할-수-있는-요소들\" class=\"headerlink\" title=\"버벅거림을 유발할 수 있는 요소들\"></a>버벅거림을 유발할 수 있는 요소들</h3><p>버벅거림을 유발하는 요소는 대표적으로 <strong>Scrollable lists, Layout performance, Rendering performance</strong>가 있다.</p>\n<h4 id=\"Scrollable-lists\"><a href=\"#Scrollable-lists\" class=\"headerlink\" title=\"Scrollable lists\"></a>Scrollable lists</h4><p>ListView 및 특히 RecyclerView는 버벅거림에 가장 취약한 복잡한 스크롤 목록에 일반적으로 사용된다.</p>\n<p>둘 다 Systrace 마커가 포함되어 있으므로 Systrace를 사용하여 앱에서 버벅거림을 유발하는지 여부를 파악할 수 있다.</p>\n<p>RecyclerView의 systrace 섹션을 표시하려면 명령에 <code>-a &lt;your-package-name&gt;</code>을 전달해야한다. 사용 가능한 경우 systrace 출력에 생성 된 경고의 지침을 따르자.</p>\n<p>Systrace 내에서 RecyclerView systrace 섹션을 클릭하여 RecyclerView가 수행하는 작업에 대한 설명을 볼 수 있다.</p>\n<ol>\n<li><p>작은 업데이트를 위해 <code>notifyDataSetChanged()</code>, <code>setAdapter(Adapter)</code>, or <code>swapAdapter(Adapter, boolean)</code>를 호출하지 마라.</p>\n<ul>\n<li>전체 목록 아이템이 변경되었다고 알리기 때문이다.</li>\n<li>대신 <code>SortedList</code> 또는 <code>DiffUtil</code>을 사용하여 콘텐츠가 변경되거나 추가 될 때 최소한의 업데이트를 하도록하자.</li>\n</ul>\n</li>\n<li><p><strong>Nested recyclerview</strong></p>\n<ul>\n<li>내부 RecyclerView의 LinearLayoutManager에 <code>setInitialPrefetchItemCount(int)</code> 를 설정할 수도 있다.</li>\n<li>예를 들어 항상 3.5 개의 항목이 한 행에 표시되는 경우, <code>innerLinearLayoutManager.setInitialItemPrefetchCount(4);</code> 를 호출한다.</li>\n</ul>\n</li>\n<li><p><code>RecyclerView</code> 의 <code>view type</code> 이 적을수록 새 item type 이 화면에 표시 될 때 수행해야하는 inflation 이 줄어 든다.</p>\n<ul>\n<li>만약 아이콘, 색상, 작은 문구 변경 차이라면, 별도의 view type 으로 나누지 않고 bind 할 때 변경하는 것이 낫다. (동시에 앱의 메모리 사용량 감소)</li>\n</ul>\n</li>\n<li><p>Bind (즉, onBindViewHolder (VH, int) 는 매우 간단해야하며 가장 복잡한 항목을 제외한 모든 항목에 대해 1 밀리 초 미만이 소요되야 한다.</p>\n<ul>\n<li>단순히 adapter 의 내부 item 에서 POJO item 을 가져와서, ViewHolder의 view 에서 setter 를 호출해야 한다.</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"Layout-performance\"><a href=\"#Layout-performance\" class=\"headerlink\" title=\"Layout performance\"></a>Layout performance</h4><p><code>Systrace</code>에서 <code>Choreographer # doFrame</code>의 레이아웃 세그먼트가 너무 많은 작업을 수행하거나 너무 자주 작업을 수행하는 것으로 표시되면 레이아웃 성능 문제가 있음을 의미한다.</p>\n<p>세그먼트가 몇 밀리 초보다 길면 <code>RelativeLayouts</code> 또는 <code>weighted-LinearLayouts</code>에 대해 최악의 경우 중첩 성능에 도달 할 수 있다. </p>\n<p>이러한 각 레이아웃은 자식의 여러 측정 / 레이아웃 패스를 트리거 할 수 있으므로 중첩하면 중첩 깊이에서 O (n ^ 2) 동작이 발생할 수 있다. </p>\n<p><strong>계층 구조의 최하위 리프 노드를 제외한 모든 노드에서 RelativeLayout 또는 LinearLayout의 가중치 기능을 피해라.</strong></p>\n<h4 id=\"Rendering-performance\"><a href=\"#Rendering-performance\" class=\"headerlink\" title=\"Rendering performance\"></a>Rendering performance</h4><p><strong>Android UI는 UI 스레드의 Record <code>View # draw</code>와 RenderThread의 <code>DrawFrame</code>의 두 단계로 작동한다</strong>.</p>\n<p>첫 번째는 모든 <code>invalidated View</code> 에서 <code>draw (Canvas)</code>를 실행한다.</p>\n<p>두 번째는 기본 <code>RenderThread</code>에서 실행되지만 <code>View#draw()</code> 단계에서 생성 된 작업을 기반으로 작동한다.</p>\n<p><code>View#draw()</code> 가 너무 오래 걸린다면, 이 경우는 보통 UI 스레드에서 bitmap 이 그려지는 경우다. <code>Bitmap</code> 에 그리기는 CPU 렌더링을 사용하므로 일반적으로 가능하면 이를 피해야 한다.</p>\n<h3 id=\"Custom-Performance-Monitoring-맞춤-성능-모니터링-사용\"><a href=\"#Custom-Performance-Monitoring-맞춤-성능-모니터링-사용\" class=\"headerlink\" title=\"Custom Performance Monitoring(맞춤 성능 모니터링 사용)\"></a>Custom Performance Monitoring(맞춤 성능 모니터링 사용)</h3><p>로컬 기기에서 버벅거림을 재현할 수 없는 경우 앱에 맞춤 성능 모니터링을 빌드하여 현장에서 기기의 버벅거림 원인을 식별할 수 있다.</p>\n<p>이를 위해 <a href=\"https://developer.android.com/reference/androidx/core/app/FrameMetricsAggregator\"><code>FrameMetricsAggregator</code></a>를 사용하여 앱의 특정 부분에서 프레임 렌더링 시간을 수집하고 <a href=\"https://firebase.google.com/docs/perf-mon/\">Firebase Performance Monitoring</a>을 사용하여 데이터를 기록하고 분석할 수 있다.</p>\n<p>자세한 내용은 아래내용을 참조하자.</p>\n<ul>\n<li><a href=\"https://developer.android.com/topic/performance/vitals\">Android Vitals</a></li>\n<li><a href=\"https://firebase.google.com/docs/perf-mon/get-started-android#pdc\">Firebase Performance Monitoring 사용</a></li>\n</ul>\n<h2 id=\"Overdraw\"><a href=\"#Overdraw\" class=\"headerlink\" title=\"Overdraw\"></a>Overdraw</h2><blockquote>\n<p>An app may draw the same pixel more than once within a single frame, an event called overdraw. Overdraw is usually unnecessary, and best eliminated. It manifests itself as a performance problem by wasting GPU time to render pixels that don’t contribute to what the user sees on the screen.</p>\n</blockquote>\n<p>오버드로는 시스템이 단일 렌더링 프레임에서 화면에 여러 번 픽셀을 그리는 것을 말한다.</p>\n<blockquote>\n<p><strong>참고</strong> : Overdraw는 더 이상 Google I/O 성능 세션 및 성능 패턴 동영상에서 논의되었을 때 만큼 심각한 문제가 아니다.</p>\n<p>이는 저가형 장치가 GPU 성능에서 지속적으로 성장하는 반면 디스플레이는 상대적으로 낮은 해상도에서 정체 되었기 때문. 알려진 저 성능 GPU 장치를 최적화하지 않는 한, 원활한 앱 성능을 보장하는 것 대신 UI 스레드 작업을 최적화하는 데 집중하는 것이 좋다.</p>\n<p><a href=\"https://www.youtube.com/watch?v=vkTn3Ule4Ps\">참고영상</a>을 확인하자.</p>\n</blockquote>\n<p>다른 개발자 옵션으로 UI 에 컬러를 지정함으로써 오버드로를 식별할 수 있다. 같은 프레임내에서 같은 픽셀을 한번 이상 그릴 때 오버드로가 발생한다.</p>\n<p>앱에서 필요 이상으로 많은 렌더링이 발생하는 곳을 시각화로 보여주며, 사용자에게 보여지지 않는 픽셀을 렌더링하기 위해 추가 GPU 작업으로 성능 문제가 발생한 수 있음을 알 수 있다. 다음과 같이 설정하면 오버드로 시각화를 확인 할 수 있다.</p>\n<h3 id=\"Overdraw-디버깅\"><a href=\"#Overdraw-디버깅\" class=\"headerlink\" title=\"Overdraw 디버깅\"></a>Overdraw 디버깅</h3><h5 id=\"여는방법-1\"><a href=\"#여는방법-1\" class=\"headerlink\" title=\"여는방법\"></a>여는방법</h5><ol>\n<li>기기에서 <strong>설정</strong>으로 이동하여 <strong>개발자 옵션</strong>을 탭한다.</li>\n<li><strong>하드웨어 가속 렌더링</strong> 섹션으로 스크롤하여 <strong>GPU 오버드로 디버그</strong>를 선택한다.</li>\n<li><strong>GPU 오버드로 디버그</strong> 대화상자에서 <strong>오버드로 영역 표시</strong>를 선택한다.</li>\n<li><strong>분석</strong></li>\n</ol>\n<ul>\n<li><strong>True color:</strong> No overdraw</li>\n<li><strong>Blue:</strong> Overdrawn 1 time <img src=\"/Team-Blog/2021/05/19/2021-05-19%20Android%20UI%20Rendering%20Optimization%20Part%203/overdrawn_1.png\" class=\"\" title=\"[Overdrawn 1 time]\"></li>\n<li><strong>Green:</strong> Overdrawn 2 times <img src=\"/Team-Blog/2021/05/19/2021-05-19%20Android%20UI%20Rendering%20Optimization%20Part%203/overdrawn_2.png\" class=\"\" title=\"[Overdrawn 2 time]\"></li>\n<li><strong>Pink:</strong> Overdrawn 3 times <img src=\"/Team-Blog/2021/05/19/2021-05-19%20Android%20UI%20Rendering%20Optimization%20Part%203/overdrawn_3.png\" class=\"\" title=\"[Overdrawn 3 time]\"></li>\n<li><strong>Red:</strong> Overdrawn 4 or more times <img src=\"/Team-Blog/2021/05/19/2021-05-19%20Android%20UI%20Rendering%20Optimization%20Part%203/overdrawn_4.png\" class=\"\" title=\"[Overdrawn 4 time]\"></li>\n</ul>\n<p>디버깅 결과는 아래와 같이 비교 가능하다.</p>\n<p>뷰의 배치에 따라 각각 오버드로가 발생한 픽셀을 확인할 수 있다.</p>\n<img src=\"/Team-Blog/2021/05/19/2021-05-19%20Android%20UI%20Rendering%20Optimization%20Part%203/zw3H5pZ.png\" class=\"\" title=\"[Overdraw Visialization]\">\n\n\n<h3 id=\"Overdraw-줄이기\"><a href=\"#Overdraw-줄이기\" class=\"headerlink\" title=\"Overdraw 줄이기\"></a>Overdraw 줄이기</h3><p>Overdraw를 줄일 수 있는 방법은 대표적으로 세가지가 있다.</p>\n<ol>\n<li><p>layouts 에서 불필요한 backgrounds 는 제거하자</p>\n</li>\n<li><p>View 계층을 평면화하자</p>\n</li>\n<li><p>투명도를 줄이자 </p>\n</li>\n</ol>\n<ul>\n<li>알파 렌더링으로 알려진 화면에서 투명 픽셀을 렌더링하는 것은 오버드로의 주요 원인이다.</li>\n<li>시스템이 그 위에 불투명 한 픽셀을 그려서 기존의 그려진 픽셀을 완전히 숨기는 표준 오버드로와 달리, 투명한 객체는 올바른 <code>blending equation</code> 이 발생하도록 기존 픽셀을 먼저 그려야한다.</li>\n</ul>\n<blockquote>\n<p><strong>참고</strong> blending equation : 2개의 픽셀 컬러 값을 결합시키는 것. <a href=\"https://xysterxx.tistory.com/50\">관련 블로그</a></p>\n</blockquote>\n<h2 id=\"UI-렌더링-성능-개선\"><a href=\"#UI-렌더링-성능-개선\" class=\"headerlink\" title=\"UI 렌더링 성능 개선\"></a>UI 렌더링 성능 개선</h2><p>지금까지는 원인 및 분석 방법에 대해서 살펴보았다. 이번에는 본격적으로 코드레벨에서 분석 및 개선방안을 통해 어떻게 개선할 수 있는지 보자.</p>\n<h3 id=\"레이아웃-재사용\"><a href=\"#레이아웃-재사용\" class=\"headerlink\" title=\"레이아웃 재사용\"></a>레이아웃 재사용</h3><ul>\n<li>include, merge를 통해 뷰를 재사용한다.</li>\n<li>include로만 뷰를 재사용하면 다음과 같이 뷰가 중첩될 수 있다.</li>\n</ul>\n<img src=\"/Team-Blog/2021/05/19/2021-05-19%20Android%20UI%20Rendering%20Optimization%20Part%203/before_merge.png\" class=\"\" title=\"[before_merge]\">\n\n<ul>\n<li>merge를 같이 사용하여 중첩을 줄여준다 </li>\n</ul>\n<img src=\"/Team-Blog/2021/05/19/2021-05-19%20Android%20UI%20Rendering%20Optimization%20Part%203/after_merge.png\" class=\"\" title=\"[after_merge]\">\n\n<h3 id=\"오버드로잉-방지-뷰-백그라운드\"><a href=\"#오버드로잉-방지-뷰-백그라운드\" class=\"headerlink\" title=\"오버드로잉 방지(뷰 백그라운드)\"></a>오버드로잉 방지(뷰 백그라운드)</h3><p>일반적으로 우리는 앱의 배경 색상을 적용하기 위해 <code>android:background=&quot;@color/white&quot;</code> 해당 뷰의 배경색상을 적용한다.</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- /res/layout/activity_main.xml --&gt;</span></span><br><span class=\"line\"><span class=\"meta\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">androidx.constraintlayout.widget.ConstraintLayout</span> <span class=\"attr\">xmlns:android</span>=<span class=\"string\">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">xmlns:app</span>=<span class=\"string\">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">xmlns:tools</span>=<span class=\"string\">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:layout_width</span>=<span class=\"string\">&quot;match_parent&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:layout_height</span>=<span class=\"string\">&quot;match_parent&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">tools:context</span>=<span class=\"string\">&quot;.MainActivity&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:background</span>=<span class=\"string\">&quot;@color/white&quot;</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">TextView</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:layout_width</span>=<span class=\"string\">&quot;wrap_content&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:layout_height</span>=<span class=\"string\">&quot;wrap_content&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:text</span>=<span class=\"string\">&quot;Hello World!&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">app:layout_constraintBottom_toBottomOf</span>=<span class=\"string\">&quot;parent&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">app:layout_constraintLeft_toLeftOf</span>=<span class=\"string\">&quot;parent&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">app:layout_constraintRight_toRightOf</span>=<span class=\"string\">&quot;parent&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">app:layout_constraintTop_toTopOf</span>=<span class=\"string\">&quot;parent&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">androidx.constraintlayout.widget.ConstraintLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>이러한 방법은 View에 그려짐에 있어 중복으로 그릴 수 있는 여지가 있다.</p>\n<img src=\"/Team-Blog/2021/05/19/2021-05-19%20Android%20UI%20Rendering%20Optimization%20Part%203/example1.png\" class=\"\" title=\"[example1]\">\n\n<p>왜 Overdraw가 생기는지 확인을 위해 앱 테마 값을 확인해보았다.</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- /res/values/themes.xml --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">resources</span> <span class=\"attr\">xmlns:tools</span>=<span class=\"string\">&quot;http://schemas.android.com/tools&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- Base application theme. --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">style</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;Theme.UITest&quot;</span> <span class=\"attr\">parent</span>=<span class=\"string\">&quot;Theme.MaterialComponents.DayNight.DarkActionBar&quot;</span>&gt;</span><span class=\"xml\"></span></span><br><span class=\"line\"><span class=\"xml\">        <span class=\"comment\">&lt;!-- Primary brand color. --&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">        <span class=\"tag\">&lt;<span class=\"name\">item</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;colorPrimary&quot;</span>&gt;</span>@color/purple_500<span class=\"tag\">&lt;/<span class=\"name\">item</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">        <span class=\"tag\">&lt;<span class=\"name\">item</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;colorPrimaryVariant&quot;</span>&gt;</span>@color/purple_700<span class=\"tag\">&lt;/<span class=\"name\">item</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">        <span class=\"tag\">&lt;<span class=\"name\">item</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;colorOnPrimary&quot;</span>&gt;</span>@color/white<span class=\"tag\">&lt;/<span class=\"name\">item</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">        <span class=\"comment\">&lt;!-- Secondary brand color. --&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">        <span class=\"tag\">&lt;<span class=\"name\">item</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;colorSecondary&quot;</span>&gt;</span>@color/teal_200<span class=\"tag\">&lt;/<span class=\"name\">item</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">        <span class=\"tag\">&lt;<span class=\"name\">item</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;colorSecondaryVariant&quot;</span>&gt;</span>@color/teal_700<span class=\"tag\">&lt;/<span class=\"name\">item</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">        <span class=\"tag\">&lt;<span class=\"name\">item</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;colorOnSecondary&quot;</span>&gt;</span>@color/black<span class=\"tag\">&lt;/<span class=\"name\">item</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">        <span class=\"comment\">&lt;!-- Status bar color. --&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">        <span class=\"tag\">&lt;<span class=\"name\">item</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;android:statusBarColor&quot;</span> <span class=\"attr\">tools:targetApi</span>=<span class=\"string\">&quot;l&quot;</span>&gt;</span>?attr/colorPrimaryVariant<span class=\"tag\">&lt;/<span class=\"name\">item</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">        <span class=\"comment\">&lt;!-- Customize your theme here. --&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">    </span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">resources</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>특별히 지정해준 사항이 없어 해당 테마의 Parent를 따라가 보았다.</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Base.V14.Theme.MaterialComponents.Light</span><br><span class=\"line\">ㄴ Base.Theme.MaterialComponents.Light</span><br><span class=\"line\">    ㄴ Base.Theme.MaterialComponents.Light.DarkActionBar</span><br><span class=\"line\">        ㄴ Theme.MaterialComponents.Light.DarkActionBar</span><br><span class=\"line\">            ㄴ Theme.MaterialComponents.DayNight.DarkActionBar</span><br></pre></td></tr></table></figure>\n\n<p>해당 소스에서 아래와 같이 배경 색상을 지정하는 걸 확인하였고</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">item</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;android:colorBackground&quot;</span>&gt;</span>@color/design_default_color_background<span class=\"tag\">&lt;/<span class=\"name\">item</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>해당 값을 확인해보니 아래와 같이 흰색으로 설정하고 있었다.</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">color</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;design_default_color_background&quot;</span>&gt;</span>#FFFFFF<span class=\"tag\">&lt;/<span class=\"name\">color</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>한마디로 배경 색상을 흰색으로 칠해주고 그 위에 다시 흰색으로 칠해주고 있었다. 해당 Overdraw를 없애고 내가 원하는 색상으로 설정하기 위해 테마 파일을 아래와 같이 <code>&lt;item name=&quot;android:windowBackground&quot;&gt;@color/beige&lt;/item&gt;</code> 를 통해 오버드로잉 문제를 해결할 수 있다.</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- /res/values/themes.xml --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">resources</span> <span class=\"attr\">xmlns:tools</span>=<span class=\"string\">&quot;http://schemas.android.com/tools&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- Base application theme. --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">style</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;Theme.UITest&quot;</span> <span class=\"attr\">parent</span>=<span class=\"string\">&quot;Theme.MaterialComponents.DayNight.NoActionBar&quot;</span>&gt;</span><span class=\"xml\"></span></span><br><span class=\"line\"><span class=\"xml\">        <span class=\"comment\">&lt;!-- Primary brand color. --&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">        <span class=\"tag\">&lt;<span class=\"name\">item</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;colorPrimary&quot;</span>&gt;</span>@color/purple_500<span class=\"tag\">&lt;/<span class=\"name\">item</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">        <span class=\"tag\">&lt;<span class=\"name\">item</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;colorPrimaryVariant&quot;</span>&gt;</span>@color/purple_700<span class=\"tag\">&lt;/<span class=\"name\">item</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">        <span class=\"tag\">&lt;<span class=\"name\">item</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;colorOnPrimary&quot;</span>&gt;</span>@color/white<span class=\"tag\">&lt;/<span class=\"name\">item</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">        <span class=\"comment\">&lt;!-- Secondary brand color. --&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">        <span class=\"tag\">&lt;<span class=\"name\">item</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;colorSecondary&quot;</span>&gt;</span>@color/teal_200<span class=\"tag\">&lt;/<span class=\"name\">item</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">        <span class=\"tag\">&lt;<span class=\"name\">item</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;colorSecondaryVariant&quot;</span>&gt;</span>@color/teal_700<span class=\"tag\">&lt;/<span class=\"name\">item</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">        <span class=\"tag\">&lt;<span class=\"name\">item</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;colorOnSecondary&quot;</span>&gt;</span>@color/black<span class=\"tag\">&lt;/<span class=\"name\">item</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">        <span class=\"comment\">&lt;!-- Status bar color. --&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">        <span class=\"tag\">&lt;<span class=\"name\">item</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;android:statusBarColor&quot;</span> <span class=\"attr\">tools:targetApi</span>=<span class=\"string\">&quot;l&quot;</span>&gt;</span>?attr/colorPrimaryVariant<span class=\"tag\">&lt;/<span class=\"name\">item</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">        <span class=\"comment\">&lt;!-- Customize your theme here. --&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">        <span class=\"tag\">&lt;<span class=\"name\">item</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;android:windowBackground&quot;</span>&gt;</span>@color/beige<span class=\"tag\">&lt;/<span class=\"name\">item</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">    </span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">resources</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p> <code>/res/layout/activity_main.xml</code> 파일에 <code>android:background=&quot;@color/beige&quot;</code> 코드를 입력 후 Overdraw를 확인한 결과는 다음과 같다.</p>\n<img src=\"/Team-Blog/2021/05/19/2021-05-19%20Android%20UI%20Rendering%20Optimization%20Part%203/example2.png\" class=\"\" title=\"[example2]\">\n\n<p>결론적으로 배경 색상 지정을 테마를 통해 지정하면 Overdraw를 줄일 수 있다.</p>\n<h3 id=\"Lazy-Load-by-ViewStub\"><a href=\"#Lazy-Load-by-ViewStub\" class=\"headerlink\" title=\"Lazy Load by ViewStub\"></a>Lazy Load by ViewStub</h3><p>해당 내용은 <a href=\"https://www.charlezz.com/?p=19977\">찰스의 안드로이드 - ViewStub 활용으로 성능 높이기</a>글 을 참고하였다.</p>\n<p>ViewStub은 사이즈가 없는 보이지 않는 뷰로 런타임에서 늦은 전개(lazy-inflate)를 원할 때 사용할 수 있다.</p>\n<p>ViewStub을 보이게 만들거나 inflate() 메서드를 호출하면 레이아웃이 전개되면서 ViewStub을 대체하기 때문에 ViewStub은 사라진다.</p>\n<p>전개된 뷰는 ViewStub의 부모 뷰에 추가 된다. 레이아웃에서 ViewStub을 사용하는 예제를 확인하자.</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ViewStub</span> <span class=\"attr\">android:id</span>=<span class=\"string\">&quot;@+id/stub&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">          <span class=\"attr\">android:inflatedId</span>=<span class=\"string\">&quot;@+id/subTree&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">          <span class=\"attr\">android:layout</span>=<span class=\"string\">&quot;@layout/mySubTree&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">          <span class=\"attr\">android:layout_width</span>=<span class=\"string\">&quot;120dp&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">          <span class=\"attr\">android:layout_height</span>=<span class=\"string\">&quot;40dp&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n\n\n\n<p>findViewById() 호출을 통해 ViewStub에 접근할 수 있다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> viewStub = findViewById(R.id.stub)</span><br></pre></td></tr></table></figure>\n\n<p>생성되는 바인딩 클래스에서 ViewStub은 ViewStubProxy로 표현되며, ViewStub에 대해 접근할 수 있게 해준다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> binding: ActivityMainBinding = ...</span><br><span class=\"line\"><span class=\"keyword\">val</span> viewStubProxy = binding.stub</span><br><span class=\"line\"><span class=\"keyword\">val</span> viewStub = viewStubProxy.viewStub()</span><br></pre></td></tr></table></figure>\n\n<p>ViewStub에 지정된 레이아웃을 전개 시키기 위해서 서는 setVisibility() 또는 inflate()를 호출 할 수 있다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> viewStub: ViewStub = ...</span><br><span class=\"line\">viewStub.inflate()</span><br><span class=\"line\"><span class=\"comment\">//또는 viewStub.visibility = View.VISIBLE</span></span><br></pre></td></tr></table></figure>\n\n<p>ViewStub은 복잡하게 구성된 레이아웃을 빠르게 전개시켜야하는 상황에서, 레이아웃의 전개 시기를 선택적으로 늦출 수 있다.</p>\n<p>예를 들어 리스트 형태의 UI를 구성하고 하나의 뷰홀더가 전개 되는데 상당한 비용이 발생한다고 가정하자.</p>\n<p>이 때 사용자가 빠르게 화면을 스크롤 할 경우 프레임 드랍이 발생 할 수 있다. 이럴 때 선택적으로 불필요한 레이아웃의 전개를 제어하고 전개 시기를 늦춤으로써 성능을 개선시킬 수 있다.</p>\n<p>우리는 1, 2, 3편에서 안드로이드의 기본적인 UI구성요소, 내부적인 렌더링 매커니즘, 렌더링 되면서 성능상 이슈가 있는 부분을 알아보았고 마지막으로 성능에 대한 개선방안에 대해 알 수 있었다.</p>\n<p>안드로이드를 공부하는 여러분들께 조금이나마 도움이 되길 바란다.</p>\n<h2 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h2><h3 id=\"Members-of-Study\"><a href=\"#Members-of-Study\" class=\"headerlink\" title=\"Members of Study\"></a>Members of Study</h3><p><a href=\"https://soda1127.github.io/introduce-jetpack-compose/\">https://soda1127.github.io/introduce-jetpack-compose/</a></p>\n<p><a href=\"https://velog.io/@jshme/How-To-Render-UI-In-Android\">https://velog.io/@jshme/How-To-Render-UI-In-Android</a></p>\n<p><a href=\"https://velog.io/@jshme/How-To-Render-UI-In-Android-22\">https://velog.io/@jshme/How-To-Render-UI-In-Android-22</a></p>\n<h3 id=\"Official\"><a href=\"#Official\" class=\"headerlink\" title=\"Official\"></a>Official</h3><h4 id=\"Docs\"><a href=\"#Docs\" class=\"headerlink\" title=\"Docs\"></a>Docs</h4><p><a href=\"https://developer.android.com/topic/performance/vitals\">Android vitals</a></p>\n<p><a href=\"https://developer.android.com/guide/topics/ui/how-android-draws\">Android 드로잉 보기 방법</a></p>\n<p><a href=\"https://developer.android.com/topic/performance/vitals/render#custom-monitoring\">느린렌터링</a></p>\n<p><a href=\"https://firebase.google.com/docs/perf-mon/get-started-android#pdc\">Firebase Performance Monitoring 사용</a></p>\n<p><a href=\"https://developer.android.com/topic/performance/rendering/inspect-gpu-rendering\">GPU 렌더링 속도 및 오버드로 검사</a></p>\n<p><a href=\"https://developer.android.com/training/custom-views/custom-drawing?hl=ko\">맞춤 그리기</a></p>\n<p><a href=\"https://developer.android.com/training/custom-views/optimizing-view?hl=ko\">뷰 최적화</a></p>\n<h4 id=\"Videos\"><a href=\"#Videos\" class=\"headerlink\" title=\"Videos\"></a>Videos</h4><p><a href=\"https://www.youtube.com/watch?v=1iaHxmfZGGc\">Android Performance Patterns: Understanding VSYNC</a></p>\n<p><a href=\"https://www.youtube.com/watch?v=HXQhu6qfTVU&list=PLOU2XLYxmsIKEOXh5TwZEv89aofHzNCiu&index=48\">Android Performance Patterns: Rendering Performance 101</a></p>\n<p><a href=\"https://www.youtube.com/watch?v=VzYkVL1n4M8&list=PLOU2XLYxmsIKEOXh5TwZEv89aofHzNCiu&index=51\">Android Performance Patterns: Tool - Profile GPU Rendering</a></p>\n<p><a href=\"https://www.youtube.com/watch?v=T52v50r-JfE&list=PLOU2XLYxmsIKEOXh5TwZEv89aofHzNCiu&index=49\">Android Performance Patterns: Understanding Overdraw</a></p>\n<p><a href=\"https://www.youtube.com/watch?v=we6poP0kw6E&list=PLOU2XLYxmsIKEOXh5TwZEv89aofHzNCiu&index=54\">Android Performance Patterns: Invalidations, Layouts, and Performance</a></p>\n<p><a href=\"https://www.youtube.com/watch?v=wIy8g8yNhNk&index=46&list=PLWz5rJ2EKKc9CBxr3BVjPTPoDPLdPIFCE\">Android Performance Patterns: Hidden Cost of Transparency</a></p>\n<h3 id=\"Etc-1\"><a href=\"#Etc-1\" class=\"headerlink\" title=\"Etc\"></a>Etc</h3><p><a href=\"https://www.charlezz.com/?p=19977\">찰스의 안드로이드 - ViewStub 활용으로 성능 높이기</a></p>\n<p><a href=\"https://lastyouth.tistory.com/24\">Android Drawing Process 1(App surface, SF Layer)</a></p>"},{"title":"Image Loading and Caching Library Part 1 — Why use?","date":"2021-06-23T16:00:00.000Z","cover":"https://androiddeepdive.github.io/Team-Blog/images/cover_image_library.png","_content":"\n<article class=\"message message-immersive is-primary\">\n    <div class=\"message-body\">\n        <i class=\"fas fa-pen-fancy mr-2\"></i>Writers<br>\n        by 곽욱현 @Knowre<br>\n        by 김남훈 @Naver<br>\n        by 배희성 @RocketPunch<br>\n        by 송시영 @SmartStudy<br>\n        by 옥수환 @Naver<br>\n        by 이기정 @BankSalad<br>\n        by 정세희 @BankSalad\n    </div>\n</article>\n\n<!-- more -->\n\nAndroid에서는 Image를 나타내기 위해 ImageView라는 위젯을 사용한다.\n\nImageView가 무엇인지 간단하게 알아보자.\n\n### android.widget.ImageView\n\n```kotlin\nkotlin.Any\n  ㄴ android.view.View\n    ㄴ android.widget.ImageView\n```\n\nImageView는 View를 상속받아 구현된 Image를 보여주기 위한 위젯이다.\n\n`android.graphics.Bitmap`나 `android.graphics.drawable.Drawable` 리소스를 표현해줄 수 있으며, tint 처리나 스케일링에 대한 처리에 일반적으로 사용된다.\n\n아래 xml 코드가 ImageView의 일반적인 쓰임새를 나타낸다.\n\n```js\n<LinearLayout\n    xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\">\n    <ImageView\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:src=\"@drawable/my_image\"\n        android:contentDescription=\"@string/my_image_description\"/>\n</LinearLayout>\n```\n\n> **참고** [Android Developers#Drawble Resources](https://developer.android.com/guide/topics/resources/drawable-resource.html)\n\n> **참고** [Android Developers#Handling bitmaps](https://developer.android.com/topic/performance/graphics/index.html)\n\n### Bitmap\n\n```kotlin\nkotlin.Any\n  ㄴ android.graphics.Bitmap\n```\n\n흔히 `.bmp` 확장자로 알려진 이미지 파일 포맷이다.\n\n사이즈가 정해진 이미지를 픽셀들의 조합으로 표현하는 방식이다.\n\n이 사이즈만큼의 픽셀 정보를 다 저장해야하기 때문에 상대적으로 용량이 크고 처리 속도가 느리므로, Android 개발시 메모리 관리에 신경써주어야 하는 부분이 많다.\n\n흔히 볼 수 있는 확장자인 `.jpg`, `.jpeg`, `.png`, `.gif` 파일들이 비트맵 방식으로 이루어진 이미지 파일이다.\n\n## Android에서 이미지를 렌더링하려면?\n\nAndroid Platform에서 이미지를 렌더링하려면 어떤 걸 고려해야할까?\n\n먼저 예제를 작성해보자.\n\nAndroid Studio에서 **Empty Activity** 으로 프로젝트를 생성한 후, Layout을 아래와 같이 수정하였다.\n\n```js\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<androidx.constraintlayout.widget.ConstraintLayout\n    xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    xmlns:tools=\"http://schemas.android.com/tools\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    tools:context=\".MainActivity\">\n\n    <ImageView\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:src=\"@drawable/ic_launcher_foreground\"\n        android:background=\"@drawable/ic_launcher_background\"\n        app:layout_constraintBottom_toBottomOf=\"parent\"\n        app:layout_constraintLeft_toLeftOf=\"parent\"\n        app:layout_constraintRight_toRightOf=\"parent\"\n        app:layout_constraintTop_toTopOf=\"parent\"/>\n\n</androidx.constraintlayout.widget.ConstraintLayout>\n```\n\n빌드 후 에뮬레이터로 실행하면 아래와 같이 렌더링 된다.\n\n{% asset_img Screenshot_1623775512.png 350 [Screenshot_1623775512] %}\n\n코드레벨에서 분석하기 위해 xml을 수정하고 ImageView의 소스를 코드로 주입해보자.\n\n코드는 간단하게 아래와 같다.\n\n```kotlin\nclass MainActivity : AppCompatActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_main)\n\n        var imageView: ImageView = findViewById(R.id.imageView)\n        imageView.background = getDrawable(R.drawable.ic_launcher_background)\n        imageView.setImageResource(R.drawable.ic_launcher_foreground)\n    }\n}\n```\n\n여기서 `imageView` 변수의 `background` 속성은 `View`에 해당하는 것이므로 제외하고, `ImageView` 위젯의 메서드인 `setImageResource`에 대해서 탐구해보자.\n\n\n```java\n// ImageView#setImageResource\n@android.view.RemotableViewMethod(asyncImpl=\"setImageResourceAsync\")\npublic void setImageResource(@DrawableRes int resId) {\n  // The resource configuration may have changed, so we should always\n  // try to load the resource even if the resId hasn't changed.\n  final int oldWidth = mDrawableWidth;\n  final int oldHeight = mDrawableHeight;\n\n  updateDrawable(null);\n  mResource = resId;\n  mUri = null;\n\n  resolveUri();\n\n  if (oldWidth != mDrawableWidth || oldHeight != mDrawableHeight) {\n    requestLayout();\n  }\n  invalidate();\n}\n```\n\n`ImageView`에는 위 메서드와 유사한 메서드들이 더 존재하고 있다.\n\n```java\n// ImageView#setImageBitmap\n@android.view.RemotableViewMethod\npublic void setImageBitmap(Bitmap bm) {\n  // Hacky fix to force setImageDrawable to do a full setImageDrawable\n  // instead of doing an object reference comparison\n  mDrawable = null;\n  if (mRecycleableBitmapDrawable == null) {\n      mRecycleableBitmapDrawable = new BitmapDrawable(mContext.getResources(), bm);\n  } else {\n      mRecycleableBitmapDrawable.setBitmap(bm);\n  }\n  setImageDrawable(mRecycleableBitmapDrawable);\n}\n```\n\n```java\n// ImageView#setImageDrawable\npublic void setImageDrawable(@Nullable Drawable drawable) {\n  if (mDrawable != drawable) {\n    mResource = 0;\n    mUri = null;\n\n    final int oldWidth = mDrawableWidth;\n    final int oldHeight = mDrawableHeight;\n\n    updateDrawable(drawable);\n\n    if (oldWidth != mDrawableWidth || oldHeight != mDrawableHeight) {\n      requestLayout();\n    }\n    invalidate();\n  }\n}\n```\n\n```java\n// ImageView#setImageURI\n@android.view.RemotableViewMethod(asyncImpl=\"setImageURIAsync\")\npublic void setImageURI(@Nullable Uri uri) {\n  if (mResource != 0 || (mUri != uri && (uri == null || mUri == null || !uri.equals(mUri)))) {\n    updateDrawable(null);\n    mResource = 0;\n    mUri = uri;\n\n    final int oldWidth = mDrawableWidth;\n    final int oldHeight = mDrawableHeight;\n\n    resolveUri();\n\n    if (oldWidth != mDrawableWidth || oldHeight != mDrawableHeight) {\n      requestLayout();\n    }\n    invalidate();\n  }\n}\n```\n\n어떤 방식을 선택하더라도 `ImageView`에 비트맵을 밀어넣으려하면 비슷비슷한 로직들을 수행하고 있다.\n\n1. 이미지의 가로 및 세로 길이를 획득한다.\n2. `requestLayout()` 메서드를 호출한다.\n3. `invalidate()` 메서드를 호출한다.\n\n`requestLayout()`와 `invalidate()` 모두 `View`에 속해있는 메서드이다.\n\n결국 주어진 이미지 리소스를 뷰의 사이즈를 측정한 뒤 onDraw하는 역할을 공통적으로 수행하는 것이다.\n\n이렇게만 보면 간단하지만, Android에서 `Bitmap` 또는 `Drawable`과 같은 리소스를 사용할 때엔 아래와 같은 사항을 고려해야 한다.\n\n- `Bitmap` 은 쉽게 앱의 메모리한도를 고갈시킬 수 있다. 예를 들어 픽셀 폰은 카메라 사진이 4048x3036 픽셀(12 메가픽셀)까지 찍을수 있다. `Bitmap` 구성이 ARGB_8888 인 경우, 기본적으로 안드로이드 2.3 (API level 9) 이상에서는 하나의 사진을 메모리에 로딩하기 위해 48MB 의 메모리를 차지하게 된다. 이렇게 큰 메모리를 요구하면 앱에서 사용할 수 있는 모든 메모리를 즉시 사용하게 될 수 있다.\n\n- UI 스레드에서 비트맵을 로딩하는 것은 앱의 성능을 저하되어 늦은 응답성 또는 ANR 메시지와 같은 원인이 된다. 따라서 `Bitmap` 을 작업할 때에는 스레드를 적절하게 관리하는 것이 중요하다.\n\n- 앱에서 여러 `Bitmap` 을 메모리에 로딩할 때에는, 메모리 관리와 디스크 캐싱이 필요하다. 그렇지 않으면, 앱의 응답성과 유동성이 나빠질 수 있다.\n\n- 앱에서 `Bitmap` 을 가져와서 디코딩하고 표시하기 위해서는 이미지 라이브러를 사용하는 것이 좋다. 이미지 라이브러리는 `Bitmap` 과 관련된 다양하고 복잡한 과정을 대신 관리해주며, 손쉽게 사용할 수 있도록 되어있다.\n\n\n고려사항을 주제별로 쪼개어서 조금 더 명세해보자.\n\n### ImageView를 사용할때 고려해야할 점\n\n#### Out of memory\n\nAndroid에서 가장 중요한 것 중 하나는 메모리를 관리하는 것이다.\n\n카메라 하드웨어의 발달로 사진 한 장의 사이즈가 어마어마하게 커졌는데, 이걸 사용자에게 보여준다고 생각한다면 OOM 이슈는 개발자로서 꼭 피해야할 요소일 것이다.\n\n아무리 큰 사이즈의 이미지여도 사용자에게 보여지는 사이즈엔 한계가 있고, 특히 썸네일의 경우 더더욱 고화질일 필요가 없으므로 다운샘플링을 통해 적당한 사이즈의 이미지로 가공하는 테크닉이 필요하다.\n\n#### Slow Loading\n\nBitmap 이미지가 지나치게 크면 이미지를 보여주는 데 많은 시간이 걸리게 되고, 이는 사용자로 하여금 로딩 속도가 느려진 듯한 불쾌한 경험을 선사하게 된다.\n\n비단 사이즈 뿐만 아니라, 이미지를 다운로드 받는 시간과 불필요한 디코딩 등 여러가지 원인이 존재할 수 있다.\n\n#### Bitmap Caching (Memory / Disk cache)\n\n반복적으로 노출되는 이미지에 쓰이는 작업을 줄이는 방법은 해당 이미지의 비트맵을 캐싱해두는 것이다.\n\n예를 들어 외부 url을 통해 다운로드 받은 이미지를 캐싱해둔다면, 동일한 url에서 이미지를 다시 그려줄 때에 해당 캐시에서 바로 가져와 사용할 수 있을 것이다.\n\nAndroid에서 캐싱을 처리하기 위해선 먼저 Memory를 먼저 확인한 뒤, 그 다음에 Disk를 검증하도록 처리할 수 있다.\n\n#### LRU Cache\n\nAndroid에서는 `LruCache`라는 객체를 제공해주고 있다.\n\n이 객체를 이용해 비트맵 캐시를 생성해서 작업할 수 있다.\n\n가장 최근에 불러온 이미지를 가장 앞으로 불러오는 식으로 캐시 적중률을 올리는 알고리즘인 **LRU Algorithm**으로 동작하며, 4Mib(메비바이트) 단위로 캐시 사이즈가 제한되어 있다.\n\n> **참고** [Android Developers#LruCache](https://developer.android.com/reference/android/util/LruCache)\n\n> **참고** [androidx.collection.LruCache](https://developer.android.com/reference/androidx/collection/LruCache)\n\n> **참고** [Cache replacement policies#recently used](https://en.wikipedia.org/wiki/Cache_replacement_policies#Least_recently_used_(LRU))\n\n#### Unresponsive UI / Gabarge collector\n\nBitmap의 사이즈가 지나치게 크다면 해당 Bitmap을 처리하기 위해 많은 작업이 필요하게 된다.\n\nui thread에서의 과도한 작업은 결국 끊어지는 듯한 ui를 사용자에게 보여주게 될 것이며, 만약 16ms 이상 걸리는 작업이라면 Android OS가 해당 작업의 프레임을 건너뛰는 이슈를 겪게 될 것이다.\n\n### Image Library 소개\n\nAndroid에서 ImageView를 통해 Bitmap을 단순히 보여주기 위해서도 고려해야할 점, 처리해야할 문제들이 매우 많다.\n\n이 많은 문제들을 한 번에 다 처리할 수 있는 방법은 바로 **검증된 이미지 라이브러리를 사용**하는 것이다.\n\n간단하게 Android에서 자주 쓰이는 이미지 라이브러리들의 리스트를 살펴보자.\n\n#### 1. Picasso\n\n![](https://square.github.io/picasso/static/sample.png)\n\n- 개발 주체 : [Square Open Source](https://square.github.io)\n- 웹 사이트 : https://square.github.io/picasso/\n- 주요 기능\n  - 이미지 재활용\n  - 다운로드 취소 처리\n  - 최소한으로 사용하는 메모리\n  - 이미지 변환\n  - 메모리 및 디스크 캐싱 자동화\n\n\n#### 2. Glide\n\n![](https://github.com/bumptech/glide/blob/master/static/glide_logo.png?raw=true)\n\n- 개발 주체 : Bump Technologies\n- 웹 사이트 : https://bumptech.github.io/glide/\n- 주요 기능\n  - 미디어 디코딩\n  - `LruResourceCache` 및 `MemorySizeCalculator`를 사용한 메모리 캐싱\n  - `Lru` 기반의 디스크 캐싱 (기본값 250mb)\n  - 리소스 풀링을 위한 간단한 인터페이스 제공\n  - `RGB_565`의 기본 포맷 사용\n  - gif, jpeg, war, png, webp 포맷 지원\n\n### Coil (Coroutine Image Loader)\n\n![](https://github.com/coil-kt/coil/raw/main/logo.svg)\n\n- 개발 주체 : [Instacart](https://www.instacart.com)\n- 웹 사이트 : https://github.com/coil-kt/coil\n- 주요 기능\n  - `MemoryCache.Key`를 사용한 메모리 캐싱\n  - `OkHttpClient` 기반의 디스크 캐싱 (`CoilUtils.createDefaultCache`에서 옵션 설정)\n  - 다운 샘플링\n  - 이미지 재사용\n  - 일시정지 및 취소의 자동화를 비롯한 최적화 작업\n  - Corotines, Okio 등의 최신 라이브러리 사용\n  - bmp, jpeg, png, webp 포맷 지원\n  - Android 8.0 이상에서 heif 포맷 지원\n  - `coil-gif` 의존성 추가시\n    - Android 9.0 이상에서 animated webp 포맷 지원 \n    - Android 11.0 이상에서 animated heif 지원 ()\n  - `coil-svg` 의존성 추가시 svg 포맷 지원\n  - `coil-video` 의존성 추가시 Android가 지원하는 모든 비디오 코덱으로부터 정적 frame 획득 가능\n\n\n\n### Fresco\n\n<img alt=\"Fresco Logo\" src=\"https://github.com/facebook/fresco/raw/master/docs/static/sample-images/fresco_logo.svg\" width=\"15%\" />\n\n- 개발 주체 : [Facebook](https://developers.facebook.com)\n- 웹 사이트 : https://frescolib.org\n- 주요 기능\n  - 압축된 이미지를 통한 메모리 사용 최소화\n  - 이미지 파이프라인을 통한 최적화\n  - Drawees를 사용한 이미지 렌더링\n  - URI 지정을 통한 점진적 jpeg 이미지 개선\n  - Android 4.0 이하에서 OOM을 최소화\n  - 다운로드중일 경우 PlaceHolder 제공\n\n### AMUL (Android-Universal-Image-Loader)\n\n![](https://github.com/nostra13/Android-Universal-Image-Loader/raw/master/sample/src/main/res/drawable-mdpi/ic_launcher.png)\n\n- 개발 주체 : [Sergey Tarasevich(User)](https://github.com/nostra13/Android-Universal-Image-Loader)\n- 웹 사이트 : https://github.com/nostra13/Android-Universal-Image-Loader/wiki\n- 주요 기능\n  - 동기/비동기 기반의 멀티스레드 이미지 로딩\n  - Thread / Downloader / Decoder에 대한 광범위한 커스터마이징\n  - 메모리 및 디스크 캐싱 자동화\n  - 다운로드 진행률 제공\n\n\n## 대표적인 라이브러리들의 간단한 성능 비교\n\n### Picasso\n\nPicasso 는 번거로움 없이 종종 단 한줄의 코드만으로도 이미지를 로딩할 수 있게 해준다. \n\n어댑터에서 이미지뷰를 재사용하고 다운로드와 취소할 수 있다. 적은 메모리 사용으로 복잡한 이미지 변환을 할 수 있다. 자동 메모리와 디스크 캐싱을 지원한다.\n\n또한 Picasso는 최소한의 메모리로 이미지의 다양한 Transformation을 지원하며, 자동으로 메모리 & 디스크 캐싱, 어댑터에서 ImageView를 재활용 및 다운로드 취소가 가능하다는 점을 강조하고 있다.\n\n| MinSdkVersion | CompileSdkVersion | AAR Size | 비고 |\n| :--: | :--: | :--: | :--: |\n| 14 | 29 | 105kb | GIF를 지원하지 않음 |\n\n``` kotlin\nPicasso.get().load(url)\n    .transform(RoundedCornersTransformation(128, 3))\n    .into(imageView5, object : Callback {\n        override fun onSuccess() {\n            toast(\"Complete\")\n        }\n\n        override fun onError(e: Exception?) {\n            TODO(\"Not yet implemented\")\n        }\n    })\n```\n\n| 최초 로딩 속도 : 6.4s | 기본 캐싱 적용 : 1.6s |\n| :--: | :--: |\n| {% asset_img picasso_test.gif [picasso test] %} | {% asset_img picasso_caching.gif [picasso_caching] %} |\n\nPicasso는 원본 이미지 크기를 그대로 비트맵에 그린 후에 이미지뷰에 적용한다. 아래와같이  `1000 * 800` 의 이미지가 존재할 때, Bitmap 에 `1000 * 800 * 4bytes` = 3MB 가 ImageView 위에 올라갈 것이다. 그렇기 때문에 고화질의 이미지를 로드한다면 OOM을 발생시킬 수 있다. \n\n{% asset_img IMG_9F5E046409C4-1.jpg [IMG_9F5E046409C4-1] %}\n\n이 문제를 방지하기 위해 `fit()` 함수를 이용한다면 고화질 이미지를 로드하기 전 이미지뷰의 크기를 먼저 측정하기 때문에 메모리 사용량을 최소화할 수 있을 것이다.\n\n```kotlin\nPicasso.get()\n    .fit()\n    .transform({...})\n    .load(url)\n```\n\n#### Heap Dump\n\n{% asset_img heap_dump.png [heap_dump] %}\n\n10,136,858 byte (= 10MB)\n\n### Glide\n\nGoogle에서 만든 이미지 로더 라이브러리인 Glide는 빠른 이미지 로딩, 버벅 거림과 끊김 현상이 발생하지 않는다는 점을 강조하고 있다. \n\n미디어 디코딩, 메모리 및 디스크 캐싱 그리고 리소스 풀링을 간단하고 사용하기 쉽게 인터페이스로 래핑하였으며 페치, 디코딩, 그리고 비디오스틸, 이미지, 움직이는 GIF 를 표시할 수 있다. \n\n커스텀된 HttpUrlConnection 을 기본 스택으로 사용하지만 거의 모든 네트워크 스택에 연결할 수 있는 유연한 API 를 포함하고 있어, Volly 또는 OkHttp 라이브러리를 대신 사용할 수 있다. \n\n| MinSdkVersion | CompileSdkVersion | AAR Size | 비고 |\n| :--: | :--: | :--: | :--: |\n| 14 | 26 | 625kb | |\n\nGlide는 아래처럼 싱글톤으로 만들어 간단하게 사용할 수 있다. \n\n```kotlin\nGlide.with(this)\n    .load(url)\n    .apply(RequestOptions.bitmapTransform(RoundedCornersTransformation(128, 3)))\n    .listener(object : RequestListener<Drawable> {\n        override fun onLoadFailed(e: GlideException?, model: Any?, target: Target<Drawable>?, isFirstResource: Boolean): Boolean {\n            TODO(\"Not yet implemented\")\n        }\n\n        override fun onResourceReady(resource: Drawable?, model: Any?, target: Target<Drawable>?, \n          dataSource: DataSource?, isFirstResource: Boolean): Boolean {\n            toast(\"Complete\")\n            return false\n        }\n    })\n    .into(imageView)\n```\n\n| 최초 로딩 속도 : 6.2s | 기본 캐싱 적용 : 0.72s |\n| :--: | :--: |\n| {% asset_img glide_test.gif [glide_test] %} | {% asset_img glide_caching.gif [glide_caching] %} |\n\n\nPicasso와는 달리 Glide는 이미지뷰의 크기를 측정한 다음 원본이미지를 가져와 이미지 뷰 크기에 맞게 리사이징 후 비트맵에 그려주는 것을 기본 옵션으로 하기 때문에 메모리 효율성이 Picasso보다 좋다.\n\n{% asset_img IMG_8FF7402ED110-1.jpg [IMG_8FF7402ED110-1] %}\n\nGlide가 언급한 이미지 라이브러리 중에서 완벽하게 Gif를 지원하는 것이 특징이다.\n\nPicasso는 미지원, Coil은 `1.2.2` 기준 확장 라이브러리로 Gif를 지원하지만 실제 사용해보니 라이브러리 자체가 불안정했으며, Fresco는 Gif에 Transformation와 같은 다양한 옵션을 적용할 수는 없었다.)\n\n{% asset_img glide_gif.gif [glide_gif] %}\n\n#### Heap Dump\n\n{% asset_img glide_heap_dump.png [glide_heap_dump] %}\n\n11,004,024 byte (= 11MB)\n\n\n### Coil\n\nInstacart에서 만든 Coil 은 Coroutine Image Loading의 줄임말로 위에 설명했던 이미지로더 라이브러리와 달리 코틀린 & 코루틴으로 구성되어있다. 제일 장점으로는 라이브러리가 거의 100% 코틀린으로 이루어졌다는 점과 AndroidX, OkHttp 등 현업에서 많이 쓰이고있는 라이브러리들을 지원하고 있다는 점이다. Coil 라이브러리 내부를 살펴보면, Glide와 굉장히 비슷하다는 것을 알 수 있는데 Glide를 많이 `벤치마킹`했다고 한다 👀. 또한 ImageView의 확장함수로 지원하고, 코틀린의 매력인 함수형 언어 덕으로 다른 라이브러리보다 `더욱 간결한` 코드를 구성할 수 있다.\n\n| MinSdkVersion | CompileSdkVersion | AAR Size | 비고 |\n| :--: | :--: | :--: | :--: |\n| 14 | 30 | 16kb | |\n\n\n``` kotlin\nimageView.load(url) {\n    listener(\n        onError = { _,_ -> /** Show toast. */ },\n        onSuccess = { _,_ -> toast(\"Complete\") }\n    )\n    transformations(RoundedCornersTransformation(128f))\n}\n```\n\n| 최초 로딩 속도 : 5.24s | 기본 캐싱 적용 : 1.3s |\n| :--: | :--: |\n| {% asset_img coil_test.gif [coil_test] %} | {% asset_img coil_caching.gif [coil_caching] %} |\n\n#### Heap Dump\n\n{% asset_img coil_heap_dump.png [coil_heap_dump] %}\n\n6,995,072 byte (= 7MB)\n\n\n좀 더 자세한 퍼포먼스 테스트는 Part 3에서 다루도록 하자.\n","source":"_posts/2021-06-24 Image Loading and Caching Library Part 1.md","raw":"---\ntitle: Image Loading and Caching Library Part 1 — Why use?\ndate: 2021-06-24 01:00\ncover: https://androiddeepdive.github.io/Team-Blog/images/cover_image_library.png\ncategories:\n- Image Library\ntags:\n- Android\n- Image\n- Library\n---\n\n<article class=\"message message-immersive is-primary\">\n    <div class=\"message-body\">\n        <i class=\"fas fa-pen-fancy mr-2\"></i>Writers<br>\n        by 곽욱현 @Knowre<br>\n        by 김남훈 @Naver<br>\n        by 배희성 @RocketPunch<br>\n        by 송시영 @SmartStudy<br>\n        by 옥수환 @Naver<br>\n        by 이기정 @BankSalad<br>\n        by 정세희 @BankSalad\n    </div>\n</article>\n\n<!-- more -->\n\nAndroid에서는 Image를 나타내기 위해 ImageView라는 위젯을 사용한다.\n\nImageView가 무엇인지 간단하게 알아보자.\n\n### android.widget.ImageView\n\n```kotlin\nkotlin.Any\n  ㄴ android.view.View\n    ㄴ android.widget.ImageView\n```\n\nImageView는 View를 상속받아 구현된 Image를 보여주기 위한 위젯이다.\n\n`android.graphics.Bitmap`나 `android.graphics.drawable.Drawable` 리소스를 표현해줄 수 있으며, tint 처리나 스케일링에 대한 처리에 일반적으로 사용된다.\n\n아래 xml 코드가 ImageView의 일반적인 쓰임새를 나타낸다.\n\n```js\n<LinearLayout\n    xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\">\n    <ImageView\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:src=\"@drawable/my_image\"\n        android:contentDescription=\"@string/my_image_description\"/>\n</LinearLayout>\n```\n\n> **참고** [Android Developers#Drawble Resources](https://developer.android.com/guide/topics/resources/drawable-resource.html)\n\n> **참고** [Android Developers#Handling bitmaps](https://developer.android.com/topic/performance/graphics/index.html)\n\n### Bitmap\n\n```kotlin\nkotlin.Any\n  ㄴ android.graphics.Bitmap\n```\n\n흔히 `.bmp` 확장자로 알려진 이미지 파일 포맷이다.\n\n사이즈가 정해진 이미지를 픽셀들의 조합으로 표현하는 방식이다.\n\n이 사이즈만큼의 픽셀 정보를 다 저장해야하기 때문에 상대적으로 용량이 크고 처리 속도가 느리므로, Android 개발시 메모리 관리에 신경써주어야 하는 부분이 많다.\n\n흔히 볼 수 있는 확장자인 `.jpg`, `.jpeg`, `.png`, `.gif` 파일들이 비트맵 방식으로 이루어진 이미지 파일이다.\n\n## Android에서 이미지를 렌더링하려면?\n\nAndroid Platform에서 이미지를 렌더링하려면 어떤 걸 고려해야할까?\n\n먼저 예제를 작성해보자.\n\nAndroid Studio에서 **Empty Activity** 으로 프로젝트를 생성한 후, Layout을 아래와 같이 수정하였다.\n\n```js\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<androidx.constraintlayout.widget.ConstraintLayout\n    xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    xmlns:tools=\"http://schemas.android.com/tools\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    tools:context=\".MainActivity\">\n\n    <ImageView\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:src=\"@drawable/ic_launcher_foreground\"\n        android:background=\"@drawable/ic_launcher_background\"\n        app:layout_constraintBottom_toBottomOf=\"parent\"\n        app:layout_constraintLeft_toLeftOf=\"parent\"\n        app:layout_constraintRight_toRightOf=\"parent\"\n        app:layout_constraintTop_toTopOf=\"parent\"/>\n\n</androidx.constraintlayout.widget.ConstraintLayout>\n```\n\n빌드 후 에뮬레이터로 실행하면 아래와 같이 렌더링 된다.\n\n{% asset_img Screenshot_1623775512.png 350 [Screenshot_1623775512] %}\n\n코드레벨에서 분석하기 위해 xml을 수정하고 ImageView의 소스를 코드로 주입해보자.\n\n코드는 간단하게 아래와 같다.\n\n```kotlin\nclass MainActivity : AppCompatActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_main)\n\n        var imageView: ImageView = findViewById(R.id.imageView)\n        imageView.background = getDrawable(R.drawable.ic_launcher_background)\n        imageView.setImageResource(R.drawable.ic_launcher_foreground)\n    }\n}\n```\n\n여기서 `imageView` 변수의 `background` 속성은 `View`에 해당하는 것이므로 제외하고, `ImageView` 위젯의 메서드인 `setImageResource`에 대해서 탐구해보자.\n\n\n```java\n// ImageView#setImageResource\n@android.view.RemotableViewMethod(asyncImpl=\"setImageResourceAsync\")\npublic void setImageResource(@DrawableRes int resId) {\n  // The resource configuration may have changed, so we should always\n  // try to load the resource even if the resId hasn't changed.\n  final int oldWidth = mDrawableWidth;\n  final int oldHeight = mDrawableHeight;\n\n  updateDrawable(null);\n  mResource = resId;\n  mUri = null;\n\n  resolveUri();\n\n  if (oldWidth != mDrawableWidth || oldHeight != mDrawableHeight) {\n    requestLayout();\n  }\n  invalidate();\n}\n```\n\n`ImageView`에는 위 메서드와 유사한 메서드들이 더 존재하고 있다.\n\n```java\n// ImageView#setImageBitmap\n@android.view.RemotableViewMethod\npublic void setImageBitmap(Bitmap bm) {\n  // Hacky fix to force setImageDrawable to do a full setImageDrawable\n  // instead of doing an object reference comparison\n  mDrawable = null;\n  if (mRecycleableBitmapDrawable == null) {\n      mRecycleableBitmapDrawable = new BitmapDrawable(mContext.getResources(), bm);\n  } else {\n      mRecycleableBitmapDrawable.setBitmap(bm);\n  }\n  setImageDrawable(mRecycleableBitmapDrawable);\n}\n```\n\n```java\n// ImageView#setImageDrawable\npublic void setImageDrawable(@Nullable Drawable drawable) {\n  if (mDrawable != drawable) {\n    mResource = 0;\n    mUri = null;\n\n    final int oldWidth = mDrawableWidth;\n    final int oldHeight = mDrawableHeight;\n\n    updateDrawable(drawable);\n\n    if (oldWidth != mDrawableWidth || oldHeight != mDrawableHeight) {\n      requestLayout();\n    }\n    invalidate();\n  }\n}\n```\n\n```java\n// ImageView#setImageURI\n@android.view.RemotableViewMethod(asyncImpl=\"setImageURIAsync\")\npublic void setImageURI(@Nullable Uri uri) {\n  if (mResource != 0 || (mUri != uri && (uri == null || mUri == null || !uri.equals(mUri)))) {\n    updateDrawable(null);\n    mResource = 0;\n    mUri = uri;\n\n    final int oldWidth = mDrawableWidth;\n    final int oldHeight = mDrawableHeight;\n\n    resolveUri();\n\n    if (oldWidth != mDrawableWidth || oldHeight != mDrawableHeight) {\n      requestLayout();\n    }\n    invalidate();\n  }\n}\n```\n\n어떤 방식을 선택하더라도 `ImageView`에 비트맵을 밀어넣으려하면 비슷비슷한 로직들을 수행하고 있다.\n\n1. 이미지의 가로 및 세로 길이를 획득한다.\n2. `requestLayout()` 메서드를 호출한다.\n3. `invalidate()` 메서드를 호출한다.\n\n`requestLayout()`와 `invalidate()` 모두 `View`에 속해있는 메서드이다.\n\n결국 주어진 이미지 리소스를 뷰의 사이즈를 측정한 뒤 onDraw하는 역할을 공통적으로 수행하는 것이다.\n\n이렇게만 보면 간단하지만, Android에서 `Bitmap` 또는 `Drawable`과 같은 리소스를 사용할 때엔 아래와 같은 사항을 고려해야 한다.\n\n- `Bitmap` 은 쉽게 앱의 메모리한도를 고갈시킬 수 있다. 예를 들어 픽셀 폰은 카메라 사진이 4048x3036 픽셀(12 메가픽셀)까지 찍을수 있다. `Bitmap` 구성이 ARGB_8888 인 경우, 기본적으로 안드로이드 2.3 (API level 9) 이상에서는 하나의 사진을 메모리에 로딩하기 위해 48MB 의 메모리를 차지하게 된다. 이렇게 큰 메모리를 요구하면 앱에서 사용할 수 있는 모든 메모리를 즉시 사용하게 될 수 있다.\n\n- UI 스레드에서 비트맵을 로딩하는 것은 앱의 성능을 저하되어 늦은 응답성 또는 ANR 메시지와 같은 원인이 된다. 따라서 `Bitmap` 을 작업할 때에는 스레드를 적절하게 관리하는 것이 중요하다.\n\n- 앱에서 여러 `Bitmap` 을 메모리에 로딩할 때에는, 메모리 관리와 디스크 캐싱이 필요하다. 그렇지 않으면, 앱의 응답성과 유동성이 나빠질 수 있다.\n\n- 앱에서 `Bitmap` 을 가져와서 디코딩하고 표시하기 위해서는 이미지 라이브러를 사용하는 것이 좋다. 이미지 라이브러리는 `Bitmap` 과 관련된 다양하고 복잡한 과정을 대신 관리해주며, 손쉽게 사용할 수 있도록 되어있다.\n\n\n고려사항을 주제별로 쪼개어서 조금 더 명세해보자.\n\n### ImageView를 사용할때 고려해야할 점\n\n#### Out of memory\n\nAndroid에서 가장 중요한 것 중 하나는 메모리를 관리하는 것이다.\n\n카메라 하드웨어의 발달로 사진 한 장의 사이즈가 어마어마하게 커졌는데, 이걸 사용자에게 보여준다고 생각한다면 OOM 이슈는 개발자로서 꼭 피해야할 요소일 것이다.\n\n아무리 큰 사이즈의 이미지여도 사용자에게 보여지는 사이즈엔 한계가 있고, 특히 썸네일의 경우 더더욱 고화질일 필요가 없으므로 다운샘플링을 통해 적당한 사이즈의 이미지로 가공하는 테크닉이 필요하다.\n\n#### Slow Loading\n\nBitmap 이미지가 지나치게 크면 이미지를 보여주는 데 많은 시간이 걸리게 되고, 이는 사용자로 하여금 로딩 속도가 느려진 듯한 불쾌한 경험을 선사하게 된다.\n\n비단 사이즈 뿐만 아니라, 이미지를 다운로드 받는 시간과 불필요한 디코딩 등 여러가지 원인이 존재할 수 있다.\n\n#### Bitmap Caching (Memory / Disk cache)\n\n반복적으로 노출되는 이미지에 쓰이는 작업을 줄이는 방법은 해당 이미지의 비트맵을 캐싱해두는 것이다.\n\n예를 들어 외부 url을 통해 다운로드 받은 이미지를 캐싱해둔다면, 동일한 url에서 이미지를 다시 그려줄 때에 해당 캐시에서 바로 가져와 사용할 수 있을 것이다.\n\nAndroid에서 캐싱을 처리하기 위해선 먼저 Memory를 먼저 확인한 뒤, 그 다음에 Disk를 검증하도록 처리할 수 있다.\n\n#### LRU Cache\n\nAndroid에서는 `LruCache`라는 객체를 제공해주고 있다.\n\n이 객체를 이용해 비트맵 캐시를 생성해서 작업할 수 있다.\n\n가장 최근에 불러온 이미지를 가장 앞으로 불러오는 식으로 캐시 적중률을 올리는 알고리즘인 **LRU Algorithm**으로 동작하며, 4Mib(메비바이트) 단위로 캐시 사이즈가 제한되어 있다.\n\n> **참고** [Android Developers#LruCache](https://developer.android.com/reference/android/util/LruCache)\n\n> **참고** [androidx.collection.LruCache](https://developer.android.com/reference/androidx/collection/LruCache)\n\n> **참고** [Cache replacement policies#recently used](https://en.wikipedia.org/wiki/Cache_replacement_policies#Least_recently_used_(LRU))\n\n#### Unresponsive UI / Gabarge collector\n\nBitmap의 사이즈가 지나치게 크다면 해당 Bitmap을 처리하기 위해 많은 작업이 필요하게 된다.\n\nui thread에서의 과도한 작업은 결국 끊어지는 듯한 ui를 사용자에게 보여주게 될 것이며, 만약 16ms 이상 걸리는 작업이라면 Android OS가 해당 작업의 프레임을 건너뛰는 이슈를 겪게 될 것이다.\n\n### Image Library 소개\n\nAndroid에서 ImageView를 통해 Bitmap을 단순히 보여주기 위해서도 고려해야할 점, 처리해야할 문제들이 매우 많다.\n\n이 많은 문제들을 한 번에 다 처리할 수 있는 방법은 바로 **검증된 이미지 라이브러리를 사용**하는 것이다.\n\n간단하게 Android에서 자주 쓰이는 이미지 라이브러리들의 리스트를 살펴보자.\n\n#### 1. Picasso\n\n![](https://square.github.io/picasso/static/sample.png)\n\n- 개발 주체 : [Square Open Source](https://square.github.io)\n- 웹 사이트 : https://square.github.io/picasso/\n- 주요 기능\n  - 이미지 재활용\n  - 다운로드 취소 처리\n  - 최소한으로 사용하는 메모리\n  - 이미지 변환\n  - 메모리 및 디스크 캐싱 자동화\n\n\n#### 2. Glide\n\n![](https://github.com/bumptech/glide/blob/master/static/glide_logo.png?raw=true)\n\n- 개발 주체 : Bump Technologies\n- 웹 사이트 : https://bumptech.github.io/glide/\n- 주요 기능\n  - 미디어 디코딩\n  - `LruResourceCache` 및 `MemorySizeCalculator`를 사용한 메모리 캐싱\n  - `Lru` 기반의 디스크 캐싱 (기본값 250mb)\n  - 리소스 풀링을 위한 간단한 인터페이스 제공\n  - `RGB_565`의 기본 포맷 사용\n  - gif, jpeg, war, png, webp 포맷 지원\n\n### Coil (Coroutine Image Loader)\n\n![](https://github.com/coil-kt/coil/raw/main/logo.svg)\n\n- 개발 주체 : [Instacart](https://www.instacart.com)\n- 웹 사이트 : https://github.com/coil-kt/coil\n- 주요 기능\n  - `MemoryCache.Key`를 사용한 메모리 캐싱\n  - `OkHttpClient` 기반의 디스크 캐싱 (`CoilUtils.createDefaultCache`에서 옵션 설정)\n  - 다운 샘플링\n  - 이미지 재사용\n  - 일시정지 및 취소의 자동화를 비롯한 최적화 작업\n  - Corotines, Okio 등의 최신 라이브러리 사용\n  - bmp, jpeg, png, webp 포맷 지원\n  - Android 8.0 이상에서 heif 포맷 지원\n  - `coil-gif` 의존성 추가시\n    - Android 9.0 이상에서 animated webp 포맷 지원 \n    - Android 11.0 이상에서 animated heif 지원 ()\n  - `coil-svg` 의존성 추가시 svg 포맷 지원\n  - `coil-video` 의존성 추가시 Android가 지원하는 모든 비디오 코덱으로부터 정적 frame 획득 가능\n\n\n\n### Fresco\n\n<img alt=\"Fresco Logo\" src=\"https://github.com/facebook/fresco/raw/master/docs/static/sample-images/fresco_logo.svg\" width=\"15%\" />\n\n- 개발 주체 : [Facebook](https://developers.facebook.com)\n- 웹 사이트 : https://frescolib.org\n- 주요 기능\n  - 압축된 이미지를 통한 메모리 사용 최소화\n  - 이미지 파이프라인을 통한 최적화\n  - Drawees를 사용한 이미지 렌더링\n  - URI 지정을 통한 점진적 jpeg 이미지 개선\n  - Android 4.0 이하에서 OOM을 최소화\n  - 다운로드중일 경우 PlaceHolder 제공\n\n### AMUL (Android-Universal-Image-Loader)\n\n![](https://github.com/nostra13/Android-Universal-Image-Loader/raw/master/sample/src/main/res/drawable-mdpi/ic_launcher.png)\n\n- 개발 주체 : [Sergey Tarasevich(User)](https://github.com/nostra13/Android-Universal-Image-Loader)\n- 웹 사이트 : https://github.com/nostra13/Android-Universal-Image-Loader/wiki\n- 주요 기능\n  - 동기/비동기 기반의 멀티스레드 이미지 로딩\n  - Thread / Downloader / Decoder에 대한 광범위한 커스터마이징\n  - 메모리 및 디스크 캐싱 자동화\n  - 다운로드 진행률 제공\n\n\n## 대표적인 라이브러리들의 간단한 성능 비교\n\n### Picasso\n\nPicasso 는 번거로움 없이 종종 단 한줄의 코드만으로도 이미지를 로딩할 수 있게 해준다. \n\n어댑터에서 이미지뷰를 재사용하고 다운로드와 취소할 수 있다. 적은 메모리 사용으로 복잡한 이미지 변환을 할 수 있다. 자동 메모리와 디스크 캐싱을 지원한다.\n\n또한 Picasso는 최소한의 메모리로 이미지의 다양한 Transformation을 지원하며, 자동으로 메모리 & 디스크 캐싱, 어댑터에서 ImageView를 재활용 및 다운로드 취소가 가능하다는 점을 강조하고 있다.\n\n| MinSdkVersion | CompileSdkVersion | AAR Size | 비고 |\n| :--: | :--: | :--: | :--: |\n| 14 | 29 | 105kb | GIF를 지원하지 않음 |\n\n``` kotlin\nPicasso.get().load(url)\n    .transform(RoundedCornersTransformation(128, 3))\n    .into(imageView5, object : Callback {\n        override fun onSuccess() {\n            toast(\"Complete\")\n        }\n\n        override fun onError(e: Exception?) {\n            TODO(\"Not yet implemented\")\n        }\n    })\n```\n\n| 최초 로딩 속도 : 6.4s | 기본 캐싱 적용 : 1.6s |\n| :--: | :--: |\n| {% asset_img picasso_test.gif [picasso test] %} | {% asset_img picasso_caching.gif [picasso_caching] %} |\n\nPicasso는 원본 이미지 크기를 그대로 비트맵에 그린 후에 이미지뷰에 적용한다. 아래와같이  `1000 * 800` 의 이미지가 존재할 때, Bitmap 에 `1000 * 800 * 4bytes` = 3MB 가 ImageView 위에 올라갈 것이다. 그렇기 때문에 고화질의 이미지를 로드한다면 OOM을 발생시킬 수 있다. \n\n{% asset_img IMG_9F5E046409C4-1.jpg [IMG_9F5E046409C4-1] %}\n\n이 문제를 방지하기 위해 `fit()` 함수를 이용한다면 고화질 이미지를 로드하기 전 이미지뷰의 크기를 먼저 측정하기 때문에 메모리 사용량을 최소화할 수 있을 것이다.\n\n```kotlin\nPicasso.get()\n    .fit()\n    .transform({...})\n    .load(url)\n```\n\n#### Heap Dump\n\n{% asset_img heap_dump.png [heap_dump] %}\n\n10,136,858 byte (= 10MB)\n\n### Glide\n\nGoogle에서 만든 이미지 로더 라이브러리인 Glide는 빠른 이미지 로딩, 버벅 거림과 끊김 현상이 발생하지 않는다는 점을 강조하고 있다. \n\n미디어 디코딩, 메모리 및 디스크 캐싱 그리고 리소스 풀링을 간단하고 사용하기 쉽게 인터페이스로 래핑하였으며 페치, 디코딩, 그리고 비디오스틸, 이미지, 움직이는 GIF 를 표시할 수 있다. \n\n커스텀된 HttpUrlConnection 을 기본 스택으로 사용하지만 거의 모든 네트워크 스택에 연결할 수 있는 유연한 API 를 포함하고 있어, Volly 또는 OkHttp 라이브러리를 대신 사용할 수 있다. \n\n| MinSdkVersion | CompileSdkVersion | AAR Size | 비고 |\n| :--: | :--: | :--: | :--: |\n| 14 | 26 | 625kb | |\n\nGlide는 아래처럼 싱글톤으로 만들어 간단하게 사용할 수 있다. \n\n```kotlin\nGlide.with(this)\n    .load(url)\n    .apply(RequestOptions.bitmapTransform(RoundedCornersTransformation(128, 3)))\n    .listener(object : RequestListener<Drawable> {\n        override fun onLoadFailed(e: GlideException?, model: Any?, target: Target<Drawable>?, isFirstResource: Boolean): Boolean {\n            TODO(\"Not yet implemented\")\n        }\n\n        override fun onResourceReady(resource: Drawable?, model: Any?, target: Target<Drawable>?, \n          dataSource: DataSource?, isFirstResource: Boolean): Boolean {\n            toast(\"Complete\")\n            return false\n        }\n    })\n    .into(imageView)\n```\n\n| 최초 로딩 속도 : 6.2s | 기본 캐싱 적용 : 0.72s |\n| :--: | :--: |\n| {% asset_img glide_test.gif [glide_test] %} | {% asset_img glide_caching.gif [glide_caching] %} |\n\n\nPicasso와는 달리 Glide는 이미지뷰의 크기를 측정한 다음 원본이미지를 가져와 이미지 뷰 크기에 맞게 리사이징 후 비트맵에 그려주는 것을 기본 옵션으로 하기 때문에 메모리 효율성이 Picasso보다 좋다.\n\n{% asset_img IMG_8FF7402ED110-1.jpg [IMG_8FF7402ED110-1] %}\n\nGlide가 언급한 이미지 라이브러리 중에서 완벽하게 Gif를 지원하는 것이 특징이다.\n\nPicasso는 미지원, Coil은 `1.2.2` 기준 확장 라이브러리로 Gif를 지원하지만 실제 사용해보니 라이브러리 자체가 불안정했으며, Fresco는 Gif에 Transformation와 같은 다양한 옵션을 적용할 수는 없었다.)\n\n{% asset_img glide_gif.gif [glide_gif] %}\n\n#### Heap Dump\n\n{% asset_img glide_heap_dump.png [glide_heap_dump] %}\n\n11,004,024 byte (= 11MB)\n\n\n### Coil\n\nInstacart에서 만든 Coil 은 Coroutine Image Loading의 줄임말로 위에 설명했던 이미지로더 라이브러리와 달리 코틀린 & 코루틴으로 구성되어있다. 제일 장점으로는 라이브러리가 거의 100% 코틀린으로 이루어졌다는 점과 AndroidX, OkHttp 등 현업에서 많이 쓰이고있는 라이브러리들을 지원하고 있다는 점이다. Coil 라이브러리 내부를 살펴보면, Glide와 굉장히 비슷하다는 것을 알 수 있는데 Glide를 많이 `벤치마킹`했다고 한다 👀. 또한 ImageView의 확장함수로 지원하고, 코틀린의 매력인 함수형 언어 덕으로 다른 라이브러리보다 `더욱 간결한` 코드를 구성할 수 있다.\n\n| MinSdkVersion | CompileSdkVersion | AAR Size | 비고 |\n| :--: | :--: | :--: | :--: |\n| 14 | 30 | 16kb | |\n\n\n``` kotlin\nimageView.load(url) {\n    listener(\n        onError = { _,_ -> /** Show toast. */ },\n        onSuccess = { _,_ -> toast(\"Complete\") }\n    )\n    transformations(RoundedCornersTransformation(128f))\n}\n```\n\n| 최초 로딩 속도 : 5.24s | 기본 캐싱 적용 : 1.3s |\n| :--: | :--: |\n| {% asset_img coil_test.gif [coil_test] %} | {% asset_img coil_caching.gif [coil_caching] %} |\n\n#### Heap Dump\n\n{% asset_img coil_heap_dump.png [coil_heap_dump] %}\n\n6,995,072 byte (= 7MB)\n\n\n좀 더 자세한 퍼포먼스 테스트는 Part 3에서 다루도록 하자.\n","slug":"2021-06-24 Image Loading and Caching Library Part 1","published":1,"updated":"2021-07-25T13:29:06.334Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cksagj7ls001r3lrehr0p4cex","content":"<article class=\"message message-immersive is-primary\">\n    <div class=\"message-body\">\n        <i class=\"fas fa-pen-fancy mr-2\"></i>Writers<br>\n        by 곽욱현 @Knowre<br>\n        by 김남훈 @Naver<br>\n        by 배희성 @RocketPunch<br>\n        by 송시영 @SmartStudy<br>\n        by 옥수환 @Naver<br>\n        by 이기정 @BankSalad<br>\n        by 정세희 @BankSalad\n    </div>\n</article>\n\n<span id=\"more\"></span>\n\n<p>Android에서는 Image를 나타내기 위해 ImageView라는 위젯을 사용한다.</p>\n<p>ImageView가 무엇인지 간단하게 알아보자.</p>\n<h3 id=\"android-widget-ImageView\"><a href=\"#android-widget-ImageView\" class=\"headerlink\" title=\"android.widget.ImageView\"></a>android.widget.ImageView</h3><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kotlin.Any</span><br><span class=\"line\">  ㄴ android.view.View</span><br><span class=\"line\">    ㄴ android.widget.ImageView</span><br></pre></td></tr></table></figure>\n\n<p>ImageView는 View를 상속받아 구현된 Image를 보여주기 위한 위젯이다.</p>\n<p><code>android.graphics.Bitmap</code>나 <code>android.graphics.drawable.Drawable</code> 리소스를 표현해줄 수 있으며, tint 처리나 스케일링에 대한 처리에 일반적으로 사용된다.</p>\n<p>아래 xml 코드가 ImageView의 일반적인 쓰임새를 나타낸다.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;LinearLayout</span><br><span class=\"line\">    <span class=\"attr\">xmlns</span>:android=<span class=\"string\">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class=\"line\">    <span class=\"attr\">android</span>:layout_width=<span class=\"string\">&quot;match_parent&quot;</span></span><br><span class=\"line\">    <span class=\"attr\">android</span>:layout_height=<span class=\"string\">&quot;match_parent&quot;</span>&gt;</span><br><span class=\"line\">    <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">ImageView</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"xml\">        <span class=\"attr\">android:layout_width</span>=<span class=\"string\">&quot;wrap_content&quot;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"xml\">        <span class=\"attr\">android:layout_height</span>=<span class=\"string\">&quot;wrap_content&quot;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"xml\">        <span class=\"attr\">android:src</span>=<span class=\"string\">&quot;@drawable/my_image&quot;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"xml\">        <span class=\"attr\">android:contentDescription</span>=<span class=\"string\">&quot;@string/my_image_description&quot;</span>/&gt;</span></span></span><br><span class=\"line\">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p><strong>참고</strong> <a href=\"https://developer.android.com/guide/topics/resources/drawable-resource.html\">Android Developers#Drawble Resources</a></p>\n</blockquote>\n<blockquote>\n<p><strong>참고</strong> <a href=\"https://developer.android.com/topic/performance/graphics/index.html\">Android Developers#Handling bitmaps</a></p>\n</blockquote>\n<h3 id=\"Bitmap\"><a href=\"#Bitmap\" class=\"headerlink\" title=\"Bitmap\"></a>Bitmap</h3><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kotlin.Any</span><br><span class=\"line\">  ㄴ android.graphics.Bitmap</span><br></pre></td></tr></table></figure>\n\n<p>흔히 <code>.bmp</code> 확장자로 알려진 이미지 파일 포맷이다.</p>\n<p>사이즈가 정해진 이미지를 픽셀들의 조합으로 표현하는 방식이다.</p>\n<p>이 사이즈만큼의 픽셀 정보를 다 저장해야하기 때문에 상대적으로 용량이 크고 처리 속도가 느리므로, Android 개발시 메모리 관리에 신경써주어야 하는 부분이 많다.</p>\n<p>흔히 볼 수 있는 확장자인 <code>.jpg</code>, <code>.jpeg</code>, <code>.png</code>, <code>.gif</code> 파일들이 비트맵 방식으로 이루어진 이미지 파일이다.</p>\n<h2 id=\"Android에서-이미지를-렌더링하려면\"><a href=\"#Android에서-이미지를-렌더링하려면\" class=\"headerlink\" title=\"Android에서 이미지를 렌더링하려면?\"></a>Android에서 이미지를 렌더링하려면?</h2><p>Android Platform에서 이미지를 렌더링하려면 어떤 걸 고려해야할까?</p>\n<p>먼저 예제를 작성해보자.</p>\n<p>Android Studio에서 <strong>Empty Activity</strong> 으로 프로젝트를 생성한 후, Layout을 아래와 같이 수정하였다.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=<span class=\"string\">&quot;1.0&quot;</span> encoding=<span class=\"string\">&quot;utf-8&quot;</span>?&gt;</span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">androidx.constraintlayout.widget.ConstraintLayout</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"xml\">    <span class=\"attr\">xmlns:android</span>=<span class=\"string\">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"xml\">    <span class=\"attr\">xmlns:app</span>=<span class=\"string\">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"xml\">    <span class=\"attr\">xmlns:tools</span>=<span class=\"string\">&quot;http://schemas.android.com/tools&quot;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"xml\">    <span class=\"attr\">android:layout_width</span>=<span class=\"string\">&quot;match_parent&quot;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"xml\">    <span class=\"attr\">android:layout_height</span>=<span class=\"string\">&quot;match_parent&quot;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"xml\">    <span class=\"attr\">tools:context</span>=<span class=\"string\">&quot;.MainActivity&quot;</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\"></span></span><br><span class=\"line\"><span class=\"xml\">    <span class=\"tag\">&lt;<span class=\"name\">ImageView</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"xml\">        <span class=\"attr\">android:layout_width</span>=<span class=\"string\">&quot;wrap_content&quot;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"xml\">        <span class=\"attr\">android:layout_height</span>=<span class=\"string\">&quot;wrap_content&quot;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"xml\">        <span class=\"attr\">android:src</span>=<span class=\"string\">&quot;@drawable/ic_launcher_foreground&quot;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"xml\">        <span class=\"attr\">android:background</span>=<span class=\"string\">&quot;@drawable/ic_launcher_background&quot;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"xml\">        <span class=\"attr\">app:layout_constraintBottom_toBottomOf</span>=<span class=\"string\">&quot;parent&quot;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"xml\">        <span class=\"attr\">app:layout_constraintLeft_toLeftOf</span>=<span class=\"string\">&quot;parent&quot;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"xml\">        <span class=\"attr\">app:layout_constraintRight_toRightOf</span>=<span class=\"string\">&quot;parent&quot;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"xml\">        <span class=\"attr\">app:layout_constraintTop_toTopOf</span>=<span class=\"string\">&quot;parent&quot;</span>/&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\"></span></span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">androidx.constraintlayout.widget.ConstraintLayout</span>&gt;</span></span></span><br></pre></td></tr></table></figure>\n\n<p>빌드 후 에뮬레이터로 실행하면 아래와 같이 렌더링 된다.</p>\n<img src=\"/Team-Blog/2021/06/24/2021-06-24%20Image%20Loading%20and%20Caching%20Library%20Part%201/Screenshot_1623775512.png\" class=\"\" width=\"350\" title=\"[Screenshot_1623775512]\">\n\n<p>코드레벨에서 분석하기 위해 xml을 수정하고 ImageView의 소스를 코드로 주입해보자.</p>\n<p>코드는 간단하게 아래와 같다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MainActivity</span> : <span class=\"type\">AppCompatActivity</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onCreate</span><span class=\"params\">(savedInstanceState: <span class=\"type\">Bundle</span>?)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onCreate(savedInstanceState)</span><br><span class=\"line\">        setContentView(R.layout.activity_main)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">var</span> imageView: ImageView = findViewById(R.id.imageView)</span><br><span class=\"line\">        imageView.background = getDrawable(R.drawable.ic_launcher_background)</span><br><span class=\"line\">        imageView.setImageResource(R.drawable.ic_launcher_foreground)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>여기서 <code>imageView</code> 변수의 <code>background</code> 속성은 <code>View</code>에 해당하는 것이므로 제외하고, <code>ImageView</code> 위젯의 메서드인 <code>setImageResource</code>에 대해서 탐구해보자.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ImageView#setImageResource</span></span><br><span class=\"line\"><span class=\"meta\">@android</span>.view.RemotableViewMethod(asyncImpl=<span class=\"string\">&quot;setImageResourceAsync&quot;</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setImageResource</span><span class=\"params\">(<span class=\"meta\">@DrawableRes</span> <span class=\"keyword\">int</span> resId)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// The resource configuration may have changed, so we should always</span></span><br><span class=\"line\">  <span class=\"comment\">// try to load the resource even if the resId hasn&#x27;t changed.</span></span><br><span class=\"line\">  <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> oldWidth = mDrawableWidth;</span><br><span class=\"line\">  <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> oldHeight = mDrawableHeight;</span><br><span class=\"line\"></span><br><span class=\"line\">  updateDrawable(<span class=\"keyword\">null</span>);</span><br><span class=\"line\">  mResource = resId;</span><br><span class=\"line\">  mUri = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  resolveUri();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (oldWidth != mDrawableWidth || oldHeight != mDrawableHeight) &#123;</span><br><span class=\"line\">    requestLayout();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  invalidate();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>ImageView</code>에는 위 메서드와 유사한 메서드들이 더 존재하고 있다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ImageView#setImageBitmap</span></span><br><span class=\"line\"><span class=\"meta\">@android</span>.view.<span class=\"function\">RemotableViewMethod</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setImageBitmap</span><span class=\"params\">(Bitmap bm)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// Hacky fix to force setImageDrawable to do a full setImageDrawable</span></span><br><span class=\"line\">  <span class=\"comment\">// instead of doing an object reference comparison</span></span><br><span class=\"line\">  mDrawable = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (mRecycleableBitmapDrawable == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      mRecycleableBitmapDrawable = <span class=\"keyword\">new</span> BitmapDrawable(mContext.getResources(), bm);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      mRecycleableBitmapDrawable.setBitmap(bm);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  setImageDrawable(mRecycleableBitmapDrawable);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ImageView#setImageDrawable</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setImageDrawable</span><span class=\"params\">(<span class=\"meta\">@Nullable</span> Drawable drawable)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (mDrawable != drawable) &#123;</span><br><span class=\"line\">    mResource = <span class=\"number\">0</span>;</span><br><span class=\"line\">    mUri = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> oldWidth = mDrawableWidth;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> oldHeight = mDrawableHeight;</span><br><span class=\"line\"></span><br><span class=\"line\">    updateDrawable(drawable);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (oldWidth != mDrawableWidth || oldHeight != mDrawableHeight) &#123;</span><br><span class=\"line\">      requestLayout();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    invalidate();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ImageView#setImageURI</span></span><br><span class=\"line\"><span class=\"meta\">@android</span>.view.RemotableViewMethod(asyncImpl=<span class=\"string\">&quot;setImageURIAsync&quot;</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setImageURI</span><span class=\"params\">(<span class=\"meta\">@Nullable</span> Uri uri)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (mResource != <span class=\"number\">0</span> || (mUri != uri &amp;&amp; (uri == <span class=\"keyword\">null</span> || mUri == <span class=\"keyword\">null</span> || !uri.equals(mUri)))) &#123;</span><br><span class=\"line\">    updateDrawable(<span class=\"keyword\">null</span>);</span><br><span class=\"line\">    mResource = <span class=\"number\">0</span>;</span><br><span class=\"line\">    mUri = uri;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> oldWidth = mDrawableWidth;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> oldHeight = mDrawableHeight;</span><br><span class=\"line\"></span><br><span class=\"line\">    resolveUri();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (oldWidth != mDrawableWidth || oldHeight != mDrawableHeight) &#123;</span><br><span class=\"line\">      requestLayout();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    invalidate();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>어떤 방식을 선택하더라도 <code>ImageView</code>에 비트맵을 밀어넣으려하면 비슷비슷한 로직들을 수행하고 있다.</p>\n<ol>\n<li>이미지의 가로 및 세로 길이를 획득한다.</li>\n<li><code>requestLayout()</code> 메서드를 호출한다.</li>\n<li><code>invalidate()</code> 메서드를 호출한다.</li>\n</ol>\n<p><code>requestLayout()</code>와 <code>invalidate()</code> 모두 <code>View</code>에 속해있는 메서드이다.</p>\n<p>결국 주어진 이미지 리소스를 뷰의 사이즈를 측정한 뒤 onDraw하는 역할을 공통적으로 수행하는 것이다.</p>\n<p>이렇게만 보면 간단하지만, Android에서 <code>Bitmap</code> 또는 <code>Drawable</code>과 같은 리소스를 사용할 때엔 아래와 같은 사항을 고려해야 한다.</p>\n<ul>\n<li><p><code>Bitmap</code> 은 쉽게 앱의 메모리한도를 고갈시킬 수 있다. 예를 들어 픽셀 폰은 카메라 사진이 4048x3036 픽셀(12 메가픽셀)까지 찍을수 있다. <code>Bitmap</code> 구성이 ARGB_8888 인 경우, 기본적으로 안드로이드 2.3 (API level 9) 이상에서는 하나의 사진을 메모리에 로딩하기 위해 48MB 의 메모리를 차지하게 된다. 이렇게 큰 메모리를 요구하면 앱에서 사용할 수 있는 모든 메모리를 즉시 사용하게 될 수 있다.</p>\n</li>\n<li><p>UI 스레드에서 비트맵을 로딩하는 것은 앱의 성능을 저하되어 늦은 응답성 또는 ANR 메시지와 같은 원인이 된다. 따라서 <code>Bitmap</code> 을 작업할 때에는 스레드를 적절하게 관리하는 것이 중요하다.</p>\n</li>\n<li><p>앱에서 여러 <code>Bitmap</code> 을 메모리에 로딩할 때에는, 메모리 관리와 디스크 캐싱이 필요하다. 그렇지 않으면, 앱의 응답성과 유동성이 나빠질 수 있다.</p>\n</li>\n<li><p>앱에서 <code>Bitmap</code> 을 가져와서 디코딩하고 표시하기 위해서는 이미지 라이브러를 사용하는 것이 좋다. 이미지 라이브러리는 <code>Bitmap</code> 과 관련된 다양하고 복잡한 과정을 대신 관리해주며, 손쉽게 사용할 수 있도록 되어있다.</p>\n</li>\n</ul>\n<p>고려사항을 주제별로 쪼개어서 조금 더 명세해보자.</p>\n<h3 id=\"ImageView를-사용할때-고려해야할-점\"><a href=\"#ImageView를-사용할때-고려해야할-점\" class=\"headerlink\" title=\"ImageView를 사용할때 고려해야할 점\"></a>ImageView를 사용할때 고려해야할 점</h3><h4 id=\"Out-of-memory\"><a href=\"#Out-of-memory\" class=\"headerlink\" title=\"Out of memory\"></a>Out of memory</h4><p>Android에서 가장 중요한 것 중 하나는 메모리를 관리하는 것이다.</p>\n<p>카메라 하드웨어의 발달로 사진 한 장의 사이즈가 어마어마하게 커졌는데, 이걸 사용자에게 보여준다고 생각한다면 OOM 이슈는 개발자로서 꼭 피해야할 요소일 것이다.</p>\n<p>아무리 큰 사이즈의 이미지여도 사용자에게 보여지는 사이즈엔 한계가 있고, 특히 썸네일의 경우 더더욱 고화질일 필요가 없으므로 다운샘플링을 통해 적당한 사이즈의 이미지로 가공하는 테크닉이 필요하다.</p>\n<h4 id=\"Slow-Loading\"><a href=\"#Slow-Loading\" class=\"headerlink\" title=\"Slow Loading\"></a>Slow Loading</h4><p>Bitmap 이미지가 지나치게 크면 이미지를 보여주는 데 많은 시간이 걸리게 되고, 이는 사용자로 하여금 로딩 속도가 느려진 듯한 불쾌한 경험을 선사하게 된다.</p>\n<p>비단 사이즈 뿐만 아니라, 이미지를 다운로드 받는 시간과 불필요한 디코딩 등 여러가지 원인이 존재할 수 있다.</p>\n<h4 id=\"Bitmap-Caching-Memory-Disk-cache\"><a href=\"#Bitmap-Caching-Memory-Disk-cache\" class=\"headerlink\" title=\"Bitmap Caching (Memory / Disk cache)\"></a>Bitmap Caching (Memory / Disk cache)</h4><p>반복적으로 노출되는 이미지에 쓰이는 작업을 줄이는 방법은 해당 이미지의 비트맵을 캐싱해두는 것이다.</p>\n<p>예를 들어 외부 url을 통해 다운로드 받은 이미지를 캐싱해둔다면, 동일한 url에서 이미지를 다시 그려줄 때에 해당 캐시에서 바로 가져와 사용할 수 있을 것이다.</p>\n<p>Android에서 캐싱을 처리하기 위해선 먼저 Memory를 먼저 확인한 뒤, 그 다음에 Disk를 검증하도록 처리할 수 있다.</p>\n<h4 id=\"LRU-Cache\"><a href=\"#LRU-Cache\" class=\"headerlink\" title=\"LRU Cache\"></a>LRU Cache</h4><p>Android에서는 <code>LruCache</code>라는 객체를 제공해주고 있다.</p>\n<p>이 객체를 이용해 비트맵 캐시를 생성해서 작업할 수 있다.</p>\n<p>가장 최근에 불러온 이미지를 가장 앞으로 불러오는 식으로 캐시 적중률을 올리는 알고리즘인 <strong>LRU Algorithm</strong>으로 동작하며, 4Mib(메비바이트) 단위로 캐시 사이즈가 제한되어 있다.</p>\n<blockquote>\n<p><strong>참고</strong> <a href=\"https://developer.android.com/reference/android/util/LruCache\">Android Developers#LruCache</a></p>\n</blockquote>\n<blockquote>\n<p><strong>참고</strong> <a href=\"https://developer.android.com/reference/androidx/collection/LruCache\">androidx.collection.LruCache</a></p>\n</blockquote>\n<blockquote>\n<p><strong>참고</strong> <a href=\"https://en.wikipedia.org/wiki/Cache_replacement_policies#Least_recently_used_(LRU)\">Cache replacement policies#recently used</a></p>\n</blockquote>\n<h4 id=\"Unresponsive-UI-Gabarge-collector\"><a href=\"#Unresponsive-UI-Gabarge-collector\" class=\"headerlink\" title=\"Unresponsive UI / Gabarge collector\"></a>Unresponsive UI / Gabarge collector</h4><p>Bitmap의 사이즈가 지나치게 크다면 해당 Bitmap을 처리하기 위해 많은 작업이 필요하게 된다.</p>\n<p>ui thread에서의 과도한 작업은 결국 끊어지는 듯한 ui를 사용자에게 보여주게 될 것이며, 만약 16ms 이상 걸리는 작업이라면 Android OS가 해당 작업의 프레임을 건너뛰는 이슈를 겪게 될 것이다.</p>\n<h3 id=\"Image-Library-소개\"><a href=\"#Image-Library-소개\" class=\"headerlink\" title=\"Image Library 소개\"></a>Image Library 소개</h3><p>Android에서 ImageView를 통해 Bitmap을 단순히 보여주기 위해서도 고려해야할 점, 처리해야할 문제들이 매우 많다.</p>\n<p>이 많은 문제들을 한 번에 다 처리할 수 있는 방법은 바로 <strong>검증된 이미지 라이브러리를 사용</strong>하는 것이다.</p>\n<p>간단하게 Android에서 자주 쓰이는 이미지 라이브러리들의 리스트를 살펴보자.</p>\n<h4 id=\"1-Picasso\"><a href=\"#1-Picasso\" class=\"headerlink\" title=\"1. Picasso\"></a>1. Picasso</h4><p><img src=\"https://square.github.io/picasso/static/sample.png\"></p>\n<ul>\n<li>개발 주체 : <a href=\"https://square.github.io/\">Square Open Source</a></li>\n<li>웹 사이트 : <a href=\"https://square.github.io/picasso/\">https://square.github.io/picasso/</a></li>\n<li>주요 기능<ul>\n<li>이미지 재활용</li>\n<li>다운로드 취소 처리</li>\n<li>최소한으로 사용하는 메모리</li>\n<li>이미지 변환</li>\n<li>메모리 및 디스크 캐싱 자동화</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"2-Glide\"><a href=\"#2-Glide\" class=\"headerlink\" title=\"2. Glide\"></a>2. Glide</h4><p><img src=\"https://github.com/bumptech/glide/blob/master/static/glide_logo.png?raw=true\"></p>\n<ul>\n<li>개발 주체 : Bump Technologies</li>\n<li>웹 사이트 : <a href=\"https://bumptech.github.io/glide/\">https://bumptech.github.io/glide/</a></li>\n<li>주요 기능<ul>\n<li>미디어 디코딩</li>\n<li><code>LruResourceCache</code> 및 <code>MemorySizeCalculator</code>를 사용한 메모리 캐싱</li>\n<li><code>Lru</code> 기반의 디스크 캐싱 (기본값 250mb)</li>\n<li>리소스 풀링을 위한 간단한 인터페이스 제공</li>\n<li><code>RGB_565</code>의 기본 포맷 사용</li>\n<li>gif, jpeg, war, png, webp 포맷 지원</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Coil-Coroutine-Image-Loader\"><a href=\"#Coil-Coroutine-Image-Loader\" class=\"headerlink\" title=\"Coil (Coroutine Image Loader)\"></a>Coil (Coroutine Image Loader)</h3><p><img src=\"https://github.com/coil-kt/coil/raw/main/logo.svg\"></p>\n<ul>\n<li>개발 주체 : <a href=\"https://www.instacart.com/\">Instacart</a></li>\n<li>웹 사이트 : <a href=\"https://github.com/coil-kt/coil\">https://github.com/coil-kt/coil</a></li>\n<li>주요 기능<ul>\n<li><code>MemoryCache.Key</code>를 사용한 메모리 캐싱</li>\n<li><code>OkHttpClient</code> 기반의 디스크 캐싱 (<code>CoilUtils.createDefaultCache</code>에서 옵션 설정)</li>\n<li>다운 샘플링</li>\n<li>이미지 재사용</li>\n<li>일시정지 및 취소의 자동화를 비롯한 최적화 작업</li>\n<li>Corotines, Okio 등의 최신 라이브러리 사용</li>\n<li>bmp, jpeg, png, webp 포맷 지원</li>\n<li>Android 8.0 이상에서 heif 포맷 지원</li>\n<li><code>coil-gif</code> 의존성 추가시<ul>\n<li>Android 9.0 이상에서 animated webp 포맷 지원 </li>\n<li>Android 11.0 이상에서 animated heif 지원 ()</li>\n</ul>\n</li>\n<li><code>coil-svg</code> 의존성 추가시 svg 포맷 지원</li>\n<li><code>coil-video</code> 의존성 추가시 Android가 지원하는 모든 비디오 코덱으로부터 정적 frame 획득 가능</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Fresco\"><a href=\"#Fresco\" class=\"headerlink\" title=\"Fresco\"></a>Fresco</h3><img alt=\"Fresco Logo\" src=\"https://github.com/facebook/fresco/raw/master/docs/static/sample-images/fresco_logo.svg\" width=\"15%\" />\n\n<ul>\n<li>개발 주체 : <a href=\"https://developers.facebook.com/\">Facebook</a></li>\n<li>웹 사이트 : <a href=\"https://frescolib.org/\">https://frescolib.org</a></li>\n<li>주요 기능<ul>\n<li>압축된 이미지를 통한 메모리 사용 최소화</li>\n<li>이미지 파이프라인을 통한 최적화</li>\n<li>Drawees를 사용한 이미지 렌더링</li>\n<li>URI 지정을 통한 점진적 jpeg 이미지 개선</li>\n<li>Android 4.0 이하에서 OOM을 최소화</li>\n<li>다운로드중일 경우 PlaceHolder 제공</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"AMUL-Android-Universal-Image-Loader\"><a href=\"#AMUL-Android-Universal-Image-Loader\" class=\"headerlink\" title=\"AMUL (Android-Universal-Image-Loader)\"></a>AMUL (Android-Universal-Image-Loader)</h3><p><img src=\"https://github.com/nostra13/Android-Universal-Image-Loader/raw/master/sample/src/main/res/drawable-mdpi/ic_launcher.png\"></p>\n<ul>\n<li>개발 주체 : <a href=\"https://github.com/nostra13/Android-Universal-Image-Loader\">Sergey Tarasevich(User)</a></li>\n<li>웹 사이트 : <a href=\"https://github.com/nostra13/Android-Universal-Image-Loader/wiki\">https://github.com/nostra13/Android-Universal-Image-Loader/wiki</a></li>\n<li>주요 기능<ul>\n<li>동기/비동기 기반의 멀티스레드 이미지 로딩</li>\n<li>Thread / Downloader / Decoder에 대한 광범위한 커스터마이징</li>\n<li>메모리 및 디스크 캐싱 자동화</li>\n<li>다운로드 진행률 제공</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"대표적인-라이브러리들의-간단한-성능-비교\"><a href=\"#대표적인-라이브러리들의-간단한-성능-비교\" class=\"headerlink\" title=\"대표적인 라이브러리들의 간단한 성능 비교\"></a>대표적인 라이브러리들의 간단한 성능 비교</h2><h3 id=\"Picasso\"><a href=\"#Picasso\" class=\"headerlink\" title=\"Picasso\"></a>Picasso</h3><p>Picasso 는 번거로움 없이 종종 단 한줄의 코드만으로도 이미지를 로딩할 수 있게 해준다. </p>\n<p>어댑터에서 이미지뷰를 재사용하고 다운로드와 취소할 수 있다. 적은 메모리 사용으로 복잡한 이미지 변환을 할 수 있다. 자동 메모리와 디스크 캐싱을 지원한다.</p>\n<p>또한 Picasso는 최소한의 메모리로 이미지의 다양한 Transformation을 지원하며, 자동으로 메모리 &amp; 디스크 캐싱, 어댑터에서 ImageView를 재활용 및 다운로드 취소가 가능하다는 점을 강조하고 있다.</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">MinSdkVersion</th>\n<th align=\"center\">CompileSdkVersion</th>\n<th align=\"center\">AAR Size</th>\n<th align=\"center\">비고</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">14</td>\n<td align=\"center\">29</td>\n<td align=\"center\">105kb</td>\n<td align=\"center\">GIF를 지원하지 않음</td>\n</tr>\n</tbody></table>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Picasso.<span class=\"keyword\">get</span>().load(url)</span><br><span class=\"line\">    .transform(RoundedCornersTransformation(<span class=\"number\">128</span>, <span class=\"number\">3</span>))</span><br><span class=\"line\">    .into(imageView5, <span class=\"keyword\">object</span> : Callback &#123;</span><br><span class=\"line\">        <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onSuccess</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">            toast(<span class=\"string\">&quot;Complete&quot;</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onError</span><span class=\"params\">(e: <span class=\"type\">Exception</span>?)</span></span> &#123;</span><br><span class=\"line\">            TODO(<span class=\"string\">&quot;Not yet implemented&quot;</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th align=\"center\">최초 로딩 속도 : 6.4s</th>\n<th align=\"center\">기본 캐싱 적용 : 1.6s</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><img src=\"/Team-Blog/2021/06/24/2021-06-24%20Image%20Loading%20and%20Caching%20Library%20Part%201/picasso_test.gif\" class=\"\" title=\"[picasso test]\"></td>\n<td align=\"center\"><img src=\"/Team-Blog/2021/06/24/2021-06-24%20Image%20Loading%20and%20Caching%20Library%20Part%201/picasso_caching.gif\" class=\"\" title=\"[picasso_caching]\"></td>\n</tr>\n</tbody></table>\n<p>Picasso는 원본 이미지 크기를 그대로 비트맵에 그린 후에 이미지뷰에 적용한다. 아래와같이  <code>1000 * 800</code> 의 이미지가 존재할 때, Bitmap 에 <code>1000 * 800 * 4bytes</code> = 3MB 가 ImageView 위에 올라갈 것이다. 그렇기 때문에 고화질의 이미지를 로드한다면 OOM을 발생시킬 수 있다. </p>\n<img src=\"/Team-Blog/2021/06/24/2021-06-24%20Image%20Loading%20and%20Caching%20Library%20Part%201/IMG_9F5E046409C4-1.jpg\" class=\"\" title=\"[IMG_9F5E046409C4-1]\">\n\n<p>이 문제를 방지하기 위해 <code>fit()</code> 함수를 이용한다면 고화질 이미지를 로드하기 전 이미지뷰의 크기를 먼저 측정하기 때문에 메모리 사용량을 최소화할 수 있을 것이다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Picasso.<span class=\"keyword\">get</span>()</span><br><span class=\"line\">    .fit()</span><br><span class=\"line\">    .transform(&#123;...&#125;)</span><br><span class=\"line\">    .load(url)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Heap-Dump\"><a href=\"#Heap-Dump\" class=\"headerlink\" title=\"Heap Dump\"></a>Heap Dump</h4><img src=\"/Team-Blog/2021/06/24/2021-06-24%20Image%20Loading%20and%20Caching%20Library%20Part%201/heap_dump.png\" class=\"\" title=\"[heap_dump]\">\n\n<p>10,136,858 byte (= 10MB)</p>\n<h3 id=\"Glide\"><a href=\"#Glide\" class=\"headerlink\" title=\"Glide\"></a>Glide</h3><p>Google에서 만든 이미지 로더 라이브러리인 Glide는 빠른 이미지 로딩, 버벅 거림과 끊김 현상이 발생하지 않는다는 점을 강조하고 있다. </p>\n<p>미디어 디코딩, 메모리 및 디스크 캐싱 그리고 리소스 풀링을 간단하고 사용하기 쉽게 인터페이스로 래핑하였으며 페치, 디코딩, 그리고 비디오스틸, 이미지, 움직이는 GIF 를 표시할 수 있다. </p>\n<p>커스텀된 HttpUrlConnection 을 기본 스택으로 사용하지만 거의 모든 네트워크 스택에 연결할 수 있는 유연한 API 를 포함하고 있어, Volly 또는 OkHttp 라이브러리를 대신 사용할 수 있다. </p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">MinSdkVersion</th>\n<th align=\"center\">CompileSdkVersion</th>\n<th align=\"center\">AAR Size</th>\n<th align=\"center\">비고</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">14</td>\n<td align=\"center\">26</td>\n<td align=\"center\">625kb</td>\n<td align=\"center\"></td>\n</tr>\n</tbody></table>\n<p>Glide는 아래처럼 싱글톤으로 만들어 간단하게 사용할 수 있다. </p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Glide.with(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">    .load(url)</span><br><span class=\"line\">    .apply(RequestOptions.bitmapTransform(RoundedCornersTransformation(<span class=\"number\">128</span>, <span class=\"number\">3</span>)))</span><br><span class=\"line\">    .listener(<span class=\"keyword\">object</span> : RequestListener&lt;Drawable&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onLoadFailed</span><span class=\"params\">(e: <span class=\"type\">GlideException</span>?, model: <span class=\"type\">Any</span>?, target: <span class=\"type\">Target</span>&lt;<span class=\"type\">Drawable</span>&gt;?, isFirstResource: <span class=\"type\">Boolean</span>)</span></span>: <span class=\"built_in\">Boolean</span> &#123;</span><br><span class=\"line\">            TODO(<span class=\"string\">&quot;Not yet implemented&quot;</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onResourceReady</span><span class=\"params\">(resource: <span class=\"type\">Drawable</span>?, model: <span class=\"type\">Any</span>?, target: <span class=\"type\">Target</span>&lt;<span class=\"type\">Drawable</span>&gt;?, </span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">          dataSource: <span class=\"type\">DataSource</span>?, isFirstResource: <span class=\"type\">Boolean</span>)</span></span>: <span class=\"built_in\">Boolean</span> &#123;</span><br><span class=\"line\">            toast(<span class=\"string\">&quot;Complete&quot;</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .into(imageView)</span><br></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th align=\"center\">최초 로딩 속도 : 6.2s</th>\n<th align=\"center\">기본 캐싱 적용 : 0.72s</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><img src=\"/Team-Blog/2021/06/24/2021-06-24%20Image%20Loading%20and%20Caching%20Library%20Part%201/glide_test.gif\" class=\"\" title=\"[glide_test]\"></td>\n<td align=\"center\"><img src=\"/Team-Blog/2021/06/24/2021-06-24%20Image%20Loading%20and%20Caching%20Library%20Part%201/glide_caching.gif\" class=\"\" title=\"[glide_caching]\"></td>\n</tr>\n</tbody></table>\n<p>Picasso와는 달리 Glide는 이미지뷰의 크기를 측정한 다음 원본이미지를 가져와 이미지 뷰 크기에 맞게 리사이징 후 비트맵에 그려주는 것을 기본 옵션으로 하기 때문에 메모리 효율성이 Picasso보다 좋다.</p>\n<img src=\"/Team-Blog/2021/06/24/2021-06-24%20Image%20Loading%20and%20Caching%20Library%20Part%201/IMG_8FF7402ED110-1.jpg\" class=\"\" title=\"[IMG_8FF7402ED110-1]\">\n\n<p>Glide가 언급한 이미지 라이브러리 중에서 완벽하게 Gif를 지원하는 것이 특징이다.</p>\n<p>Picasso는 미지원, Coil은 <code>1.2.2</code> 기준 확장 라이브러리로 Gif를 지원하지만 실제 사용해보니 라이브러리 자체가 불안정했으며, Fresco는 Gif에 Transformation와 같은 다양한 옵션을 적용할 수는 없었다.)</p>\n<img src=\"/Team-Blog/2021/06/24/2021-06-24%20Image%20Loading%20and%20Caching%20Library%20Part%201/glide_gif.gif\" class=\"\" title=\"[glide_gif]\">\n\n<h4 id=\"Heap-Dump-1\"><a href=\"#Heap-Dump-1\" class=\"headerlink\" title=\"Heap Dump\"></a>Heap Dump</h4><img src=\"/Team-Blog/2021/06/24/2021-06-24%20Image%20Loading%20and%20Caching%20Library%20Part%201/glide_heap_dump.png\" class=\"\" title=\"[glide_heap_dump]\">\n\n<p>11,004,024 byte (= 11MB)</p>\n<h3 id=\"Coil\"><a href=\"#Coil\" class=\"headerlink\" title=\"Coil\"></a>Coil</h3><p>Instacart에서 만든 Coil 은 Coroutine Image Loading의 줄임말로 위에 설명했던 이미지로더 라이브러리와 달리 코틀린 &amp; 코루틴으로 구성되어있다. 제일 장점으로는 라이브러리가 거의 100% 코틀린으로 이루어졌다는 점과 AndroidX, OkHttp 등 현업에서 많이 쓰이고있는 라이브러리들을 지원하고 있다는 점이다. Coil 라이브러리 내부를 살펴보면, Glide와 굉장히 비슷하다는 것을 알 수 있는데 Glide를 많이 <code>벤치마킹</code>했다고 한다 👀. 또한 ImageView의 확장함수로 지원하고, 코틀린의 매력인 함수형 언어 덕으로 다른 라이브러리보다 <code>더욱 간결한</code> 코드를 구성할 수 있다.</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">MinSdkVersion</th>\n<th align=\"center\">CompileSdkVersion</th>\n<th align=\"center\">AAR Size</th>\n<th align=\"center\">비고</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">14</td>\n<td align=\"center\">30</td>\n<td align=\"center\">16kb</td>\n<td align=\"center\"></td>\n</tr>\n</tbody></table>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">imageView.load(url) &#123;</span><br><span class=\"line\">    listener(</span><br><span class=\"line\">        onError = &#123; _,_ -&gt; <span class=\"comment\">/** Show toast. */</span> &#125;,</span><br><span class=\"line\">        onSuccess = &#123; _,_ -&gt; toast(<span class=\"string\">&quot;Complete&quot;</span>) &#125;</span><br><span class=\"line\">    )</span><br><span class=\"line\">    transformations(RoundedCornersTransformation(<span class=\"number\">128f</span>))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th align=\"center\">최초 로딩 속도 : 5.24s</th>\n<th align=\"center\">기본 캐싱 적용 : 1.3s</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><img src=\"/Team-Blog/2021/06/24/2021-06-24%20Image%20Loading%20and%20Caching%20Library%20Part%201/coil_test.gif\" class=\"\" title=\"[coil_test]\"></td>\n<td align=\"center\"><img src=\"/Team-Blog/2021/06/24/2021-06-24%20Image%20Loading%20and%20Caching%20Library%20Part%201/coil_caching.gif\" class=\"\" title=\"[coil_caching]\"></td>\n</tr>\n</tbody></table>\n<h4 id=\"Heap-Dump-2\"><a href=\"#Heap-Dump-2\" class=\"headerlink\" title=\"Heap Dump\"></a>Heap Dump</h4><img src=\"/Team-Blog/2021/06/24/2021-06-24%20Image%20Loading%20and%20Caching%20Library%20Part%201/coil_heap_dump.png\" class=\"\" title=\"[coil_heap_dump]\">\n\n<p>6,995,072 byte (= 7MB)</p>\n<p>좀 더 자세한 퍼포먼스 테스트는 Part 3에서 다루도록 하자.</p>\n","site":{"data":{}},"excerpt":"<article class=\"message message-immersive is-primary\">\n    <div class=\"message-body\">\n        <i class=\"fas fa-pen-fancy mr-2\"></i>Writers<br>\n        by 곽욱현 @Knowre<br>\n        by 김남훈 @Naver<br>\n        by 배희성 @RocketPunch<br>\n        by 송시영 @SmartStudy<br>\n        by 옥수환 @Naver<br>\n        by 이기정 @BankSalad<br>\n        by 정세희 @BankSalad\n    </div>\n</article>","more":"<p>Android에서는 Image를 나타내기 위해 ImageView라는 위젯을 사용한다.</p>\n<p>ImageView가 무엇인지 간단하게 알아보자.</p>\n<h3 id=\"android-widget-ImageView\"><a href=\"#android-widget-ImageView\" class=\"headerlink\" title=\"android.widget.ImageView\"></a>android.widget.ImageView</h3><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kotlin.Any</span><br><span class=\"line\">  ㄴ android.view.View</span><br><span class=\"line\">    ㄴ android.widget.ImageView</span><br></pre></td></tr></table></figure>\n\n<p>ImageView는 View를 상속받아 구현된 Image를 보여주기 위한 위젯이다.</p>\n<p><code>android.graphics.Bitmap</code>나 <code>android.graphics.drawable.Drawable</code> 리소스를 표현해줄 수 있으며, tint 처리나 스케일링에 대한 처리에 일반적으로 사용된다.</p>\n<p>아래 xml 코드가 ImageView의 일반적인 쓰임새를 나타낸다.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;LinearLayout</span><br><span class=\"line\">    <span class=\"attr\">xmlns</span>:android=<span class=\"string\">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class=\"line\">    <span class=\"attr\">android</span>:layout_width=<span class=\"string\">&quot;match_parent&quot;</span></span><br><span class=\"line\">    <span class=\"attr\">android</span>:layout_height=<span class=\"string\">&quot;match_parent&quot;</span>&gt;</span><br><span class=\"line\">    <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">ImageView</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"xml\">        <span class=\"attr\">android:layout_width</span>=<span class=\"string\">&quot;wrap_content&quot;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"xml\">        <span class=\"attr\">android:layout_height</span>=<span class=\"string\">&quot;wrap_content&quot;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"xml\">        <span class=\"attr\">android:src</span>=<span class=\"string\">&quot;@drawable/my_image&quot;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"xml\">        <span class=\"attr\">android:contentDescription</span>=<span class=\"string\">&quot;@string/my_image_description&quot;</span>/&gt;</span></span></span><br><span class=\"line\">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p><strong>참고</strong> <a href=\"https://developer.android.com/guide/topics/resources/drawable-resource.html\">Android Developers#Drawble Resources</a></p>\n</blockquote>\n<blockquote>\n<p><strong>참고</strong> <a href=\"https://developer.android.com/topic/performance/graphics/index.html\">Android Developers#Handling bitmaps</a></p>\n</blockquote>\n<h3 id=\"Bitmap\"><a href=\"#Bitmap\" class=\"headerlink\" title=\"Bitmap\"></a>Bitmap</h3><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kotlin.Any</span><br><span class=\"line\">  ㄴ android.graphics.Bitmap</span><br></pre></td></tr></table></figure>\n\n<p>흔히 <code>.bmp</code> 확장자로 알려진 이미지 파일 포맷이다.</p>\n<p>사이즈가 정해진 이미지를 픽셀들의 조합으로 표현하는 방식이다.</p>\n<p>이 사이즈만큼의 픽셀 정보를 다 저장해야하기 때문에 상대적으로 용량이 크고 처리 속도가 느리므로, Android 개발시 메모리 관리에 신경써주어야 하는 부분이 많다.</p>\n<p>흔히 볼 수 있는 확장자인 <code>.jpg</code>, <code>.jpeg</code>, <code>.png</code>, <code>.gif</code> 파일들이 비트맵 방식으로 이루어진 이미지 파일이다.</p>\n<h2 id=\"Android에서-이미지를-렌더링하려면\"><a href=\"#Android에서-이미지를-렌더링하려면\" class=\"headerlink\" title=\"Android에서 이미지를 렌더링하려면?\"></a>Android에서 이미지를 렌더링하려면?</h2><p>Android Platform에서 이미지를 렌더링하려면 어떤 걸 고려해야할까?</p>\n<p>먼저 예제를 작성해보자.</p>\n<p>Android Studio에서 <strong>Empty Activity</strong> 으로 프로젝트를 생성한 후, Layout을 아래와 같이 수정하였다.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=<span class=\"string\">&quot;1.0&quot;</span> encoding=<span class=\"string\">&quot;utf-8&quot;</span>?&gt;</span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">androidx.constraintlayout.widget.ConstraintLayout</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"xml\">    <span class=\"attr\">xmlns:android</span>=<span class=\"string\">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"xml\">    <span class=\"attr\">xmlns:app</span>=<span class=\"string\">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"xml\">    <span class=\"attr\">xmlns:tools</span>=<span class=\"string\">&quot;http://schemas.android.com/tools&quot;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"xml\">    <span class=\"attr\">android:layout_width</span>=<span class=\"string\">&quot;match_parent&quot;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"xml\">    <span class=\"attr\">android:layout_height</span>=<span class=\"string\">&quot;match_parent&quot;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"xml\">    <span class=\"attr\">tools:context</span>=<span class=\"string\">&quot;.MainActivity&quot;</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\"></span></span><br><span class=\"line\"><span class=\"xml\">    <span class=\"tag\">&lt;<span class=\"name\">ImageView</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"xml\">        <span class=\"attr\">android:layout_width</span>=<span class=\"string\">&quot;wrap_content&quot;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"xml\">        <span class=\"attr\">android:layout_height</span>=<span class=\"string\">&quot;wrap_content&quot;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"xml\">        <span class=\"attr\">android:src</span>=<span class=\"string\">&quot;@drawable/ic_launcher_foreground&quot;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"xml\">        <span class=\"attr\">android:background</span>=<span class=\"string\">&quot;@drawable/ic_launcher_background&quot;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"xml\">        <span class=\"attr\">app:layout_constraintBottom_toBottomOf</span>=<span class=\"string\">&quot;parent&quot;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"xml\">        <span class=\"attr\">app:layout_constraintLeft_toLeftOf</span>=<span class=\"string\">&quot;parent&quot;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"xml\">        <span class=\"attr\">app:layout_constraintRight_toRightOf</span>=<span class=\"string\">&quot;parent&quot;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"xml\">        <span class=\"attr\">app:layout_constraintTop_toTopOf</span>=<span class=\"string\">&quot;parent&quot;</span>/&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\"></span></span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">androidx.constraintlayout.widget.ConstraintLayout</span>&gt;</span></span></span><br></pre></td></tr></table></figure>\n\n<p>빌드 후 에뮬레이터로 실행하면 아래와 같이 렌더링 된다.</p>\n<img src=\"/Team-Blog/2021/06/24/2021-06-24%20Image%20Loading%20and%20Caching%20Library%20Part%201/Screenshot_1623775512.png\" class=\"\" width=\"350\" title=\"[Screenshot_1623775512]\">\n\n<p>코드레벨에서 분석하기 위해 xml을 수정하고 ImageView의 소스를 코드로 주입해보자.</p>\n<p>코드는 간단하게 아래와 같다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MainActivity</span> : <span class=\"type\">AppCompatActivity</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onCreate</span><span class=\"params\">(savedInstanceState: <span class=\"type\">Bundle</span>?)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onCreate(savedInstanceState)</span><br><span class=\"line\">        setContentView(R.layout.activity_main)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">var</span> imageView: ImageView = findViewById(R.id.imageView)</span><br><span class=\"line\">        imageView.background = getDrawable(R.drawable.ic_launcher_background)</span><br><span class=\"line\">        imageView.setImageResource(R.drawable.ic_launcher_foreground)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>여기서 <code>imageView</code> 변수의 <code>background</code> 속성은 <code>View</code>에 해당하는 것이므로 제외하고, <code>ImageView</code> 위젯의 메서드인 <code>setImageResource</code>에 대해서 탐구해보자.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ImageView#setImageResource</span></span><br><span class=\"line\"><span class=\"meta\">@android</span>.view.RemotableViewMethod(asyncImpl=<span class=\"string\">&quot;setImageResourceAsync&quot;</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setImageResource</span><span class=\"params\">(<span class=\"meta\">@DrawableRes</span> <span class=\"keyword\">int</span> resId)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// The resource configuration may have changed, so we should always</span></span><br><span class=\"line\">  <span class=\"comment\">// try to load the resource even if the resId hasn&#x27;t changed.</span></span><br><span class=\"line\">  <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> oldWidth = mDrawableWidth;</span><br><span class=\"line\">  <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> oldHeight = mDrawableHeight;</span><br><span class=\"line\"></span><br><span class=\"line\">  updateDrawable(<span class=\"keyword\">null</span>);</span><br><span class=\"line\">  mResource = resId;</span><br><span class=\"line\">  mUri = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  resolveUri();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (oldWidth != mDrawableWidth || oldHeight != mDrawableHeight) &#123;</span><br><span class=\"line\">    requestLayout();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  invalidate();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>ImageView</code>에는 위 메서드와 유사한 메서드들이 더 존재하고 있다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ImageView#setImageBitmap</span></span><br><span class=\"line\"><span class=\"meta\">@android</span>.view.<span class=\"function\">RemotableViewMethod</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setImageBitmap</span><span class=\"params\">(Bitmap bm)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// Hacky fix to force setImageDrawable to do a full setImageDrawable</span></span><br><span class=\"line\">  <span class=\"comment\">// instead of doing an object reference comparison</span></span><br><span class=\"line\">  mDrawable = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (mRecycleableBitmapDrawable == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      mRecycleableBitmapDrawable = <span class=\"keyword\">new</span> BitmapDrawable(mContext.getResources(), bm);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      mRecycleableBitmapDrawable.setBitmap(bm);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  setImageDrawable(mRecycleableBitmapDrawable);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ImageView#setImageDrawable</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setImageDrawable</span><span class=\"params\">(<span class=\"meta\">@Nullable</span> Drawable drawable)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (mDrawable != drawable) &#123;</span><br><span class=\"line\">    mResource = <span class=\"number\">0</span>;</span><br><span class=\"line\">    mUri = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> oldWidth = mDrawableWidth;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> oldHeight = mDrawableHeight;</span><br><span class=\"line\"></span><br><span class=\"line\">    updateDrawable(drawable);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (oldWidth != mDrawableWidth || oldHeight != mDrawableHeight) &#123;</span><br><span class=\"line\">      requestLayout();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    invalidate();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ImageView#setImageURI</span></span><br><span class=\"line\"><span class=\"meta\">@android</span>.view.RemotableViewMethod(asyncImpl=<span class=\"string\">&quot;setImageURIAsync&quot;</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setImageURI</span><span class=\"params\">(<span class=\"meta\">@Nullable</span> Uri uri)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (mResource != <span class=\"number\">0</span> || (mUri != uri &amp;&amp; (uri == <span class=\"keyword\">null</span> || mUri == <span class=\"keyword\">null</span> || !uri.equals(mUri)))) &#123;</span><br><span class=\"line\">    updateDrawable(<span class=\"keyword\">null</span>);</span><br><span class=\"line\">    mResource = <span class=\"number\">0</span>;</span><br><span class=\"line\">    mUri = uri;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> oldWidth = mDrawableWidth;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> oldHeight = mDrawableHeight;</span><br><span class=\"line\"></span><br><span class=\"line\">    resolveUri();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (oldWidth != mDrawableWidth || oldHeight != mDrawableHeight) &#123;</span><br><span class=\"line\">      requestLayout();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    invalidate();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>어떤 방식을 선택하더라도 <code>ImageView</code>에 비트맵을 밀어넣으려하면 비슷비슷한 로직들을 수행하고 있다.</p>\n<ol>\n<li>이미지의 가로 및 세로 길이를 획득한다.</li>\n<li><code>requestLayout()</code> 메서드를 호출한다.</li>\n<li><code>invalidate()</code> 메서드를 호출한다.</li>\n</ol>\n<p><code>requestLayout()</code>와 <code>invalidate()</code> 모두 <code>View</code>에 속해있는 메서드이다.</p>\n<p>결국 주어진 이미지 리소스를 뷰의 사이즈를 측정한 뒤 onDraw하는 역할을 공통적으로 수행하는 것이다.</p>\n<p>이렇게만 보면 간단하지만, Android에서 <code>Bitmap</code> 또는 <code>Drawable</code>과 같은 리소스를 사용할 때엔 아래와 같은 사항을 고려해야 한다.</p>\n<ul>\n<li><p><code>Bitmap</code> 은 쉽게 앱의 메모리한도를 고갈시킬 수 있다. 예를 들어 픽셀 폰은 카메라 사진이 4048x3036 픽셀(12 메가픽셀)까지 찍을수 있다. <code>Bitmap</code> 구성이 ARGB_8888 인 경우, 기본적으로 안드로이드 2.3 (API level 9) 이상에서는 하나의 사진을 메모리에 로딩하기 위해 48MB 의 메모리를 차지하게 된다. 이렇게 큰 메모리를 요구하면 앱에서 사용할 수 있는 모든 메모리를 즉시 사용하게 될 수 있다.</p>\n</li>\n<li><p>UI 스레드에서 비트맵을 로딩하는 것은 앱의 성능을 저하되어 늦은 응답성 또는 ANR 메시지와 같은 원인이 된다. 따라서 <code>Bitmap</code> 을 작업할 때에는 스레드를 적절하게 관리하는 것이 중요하다.</p>\n</li>\n<li><p>앱에서 여러 <code>Bitmap</code> 을 메모리에 로딩할 때에는, 메모리 관리와 디스크 캐싱이 필요하다. 그렇지 않으면, 앱의 응답성과 유동성이 나빠질 수 있다.</p>\n</li>\n<li><p>앱에서 <code>Bitmap</code> 을 가져와서 디코딩하고 표시하기 위해서는 이미지 라이브러를 사용하는 것이 좋다. 이미지 라이브러리는 <code>Bitmap</code> 과 관련된 다양하고 복잡한 과정을 대신 관리해주며, 손쉽게 사용할 수 있도록 되어있다.</p>\n</li>\n</ul>\n<p>고려사항을 주제별로 쪼개어서 조금 더 명세해보자.</p>\n<h3 id=\"ImageView를-사용할때-고려해야할-점\"><a href=\"#ImageView를-사용할때-고려해야할-점\" class=\"headerlink\" title=\"ImageView를 사용할때 고려해야할 점\"></a>ImageView를 사용할때 고려해야할 점</h3><h4 id=\"Out-of-memory\"><a href=\"#Out-of-memory\" class=\"headerlink\" title=\"Out of memory\"></a>Out of memory</h4><p>Android에서 가장 중요한 것 중 하나는 메모리를 관리하는 것이다.</p>\n<p>카메라 하드웨어의 발달로 사진 한 장의 사이즈가 어마어마하게 커졌는데, 이걸 사용자에게 보여준다고 생각한다면 OOM 이슈는 개발자로서 꼭 피해야할 요소일 것이다.</p>\n<p>아무리 큰 사이즈의 이미지여도 사용자에게 보여지는 사이즈엔 한계가 있고, 특히 썸네일의 경우 더더욱 고화질일 필요가 없으므로 다운샘플링을 통해 적당한 사이즈의 이미지로 가공하는 테크닉이 필요하다.</p>\n<h4 id=\"Slow-Loading\"><a href=\"#Slow-Loading\" class=\"headerlink\" title=\"Slow Loading\"></a>Slow Loading</h4><p>Bitmap 이미지가 지나치게 크면 이미지를 보여주는 데 많은 시간이 걸리게 되고, 이는 사용자로 하여금 로딩 속도가 느려진 듯한 불쾌한 경험을 선사하게 된다.</p>\n<p>비단 사이즈 뿐만 아니라, 이미지를 다운로드 받는 시간과 불필요한 디코딩 등 여러가지 원인이 존재할 수 있다.</p>\n<h4 id=\"Bitmap-Caching-Memory-Disk-cache\"><a href=\"#Bitmap-Caching-Memory-Disk-cache\" class=\"headerlink\" title=\"Bitmap Caching (Memory / Disk cache)\"></a>Bitmap Caching (Memory / Disk cache)</h4><p>반복적으로 노출되는 이미지에 쓰이는 작업을 줄이는 방법은 해당 이미지의 비트맵을 캐싱해두는 것이다.</p>\n<p>예를 들어 외부 url을 통해 다운로드 받은 이미지를 캐싱해둔다면, 동일한 url에서 이미지를 다시 그려줄 때에 해당 캐시에서 바로 가져와 사용할 수 있을 것이다.</p>\n<p>Android에서 캐싱을 처리하기 위해선 먼저 Memory를 먼저 확인한 뒤, 그 다음에 Disk를 검증하도록 처리할 수 있다.</p>\n<h4 id=\"LRU-Cache\"><a href=\"#LRU-Cache\" class=\"headerlink\" title=\"LRU Cache\"></a>LRU Cache</h4><p>Android에서는 <code>LruCache</code>라는 객체를 제공해주고 있다.</p>\n<p>이 객체를 이용해 비트맵 캐시를 생성해서 작업할 수 있다.</p>\n<p>가장 최근에 불러온 이미지를 가장 앞으로 불러오는 식으로 캐시 적중률을 올리는 알고리즘인 <strong>LRU Algorithm</strong>으로 동작하며, 4Mib(메비바이트) 단위로 캐시 사이즈가 제한되어 있다.</p>\n<blockquote>\n<p><strong>참고</strong> <a href=\"https://developer.android.com/reference/android/util/LruCache\">Android Developers#LruCache</a></p>\n</blockquote>\n<blockquote>\n<p><strong>참고</strong> <a href=\"https://developer.android.com/reference/androidx/collection/LruCache\">androidx.collection.LruCache</a></p>\n</blockquote>\n<blockquote>\n<p><strong>참고</strong> <a href=\"https://en.wikipedia.org/wiki/Cache_replacement_policies#Least_recently_used_(LRU)\">Cache replacement policies#recently used</a></p>\n</blockquote>\n<h4 id=\"Unresponsive-UI-Gabarge-collector\"><a href=\"#Unresponsive-UI-Gabarge-collector\" class=\"headerlink\" title=\"Unresponsive UI / Gabarge collector\"></a>Unresponsive UI / Gabarge collector</h4><p>Bitmap의 사이즈가 지나치게 크다면 해당 Bitmap을 처리하기 위해 많은 작업이 필요하게 된다.</p>\n<p>ui thread에서의 과도한 작업은 결국 끊어지는 듯한 ui를 사용자에게 보여주게 될 것이며, 만약 16ms 이상 걸리는 작업이라면 Android OS가 해당 작업의 프레임을 건너뛰는 이슈를 겪게 될 것이다.</p>\n<h3 id=\"Image-Library-소개\"><a href=\"#Image-Library-소개\" class=\"headerlink\" title=\"Image Library 소개\"></a>Image Library 소개</h3><p>Android에서 ImageView를 통해 Bitmap을 단순히 보여주기 위해서도 고려해야할 점, 처리해야할 문제들이 매우 많다.</p>\n<p>이 많은 문제들을 한 번에 다 처리할 수 있는 방법은 바로 <strong>검증된 이미지 라이브러리를 사용</strong>하는 것이다.</p>\n<p>간단하게 Android에서 자주 쓰이는 이미지 라이브러리들의 리스트를 살펴보자.</p>\n<h4 id=\"1-Picasso\"><a href=\"#1-Picasso\" class=\"headerlink\" title=\"1. Picasso\"></a>1. Picasso</h4><p><img src=\"https://square.github.io/picasso/static/sample.png\"></p>\n<ul>\n<li>개발 주체 : <a href=\"https://square.github.io/\">Square Open Source</a></li>\n<li>웹 사이트 : <a href=\"https://square.github.io/picasso/\">https://square.github.io/picasso/</a></li>\n<li>주요 기능<ul>\n<li>이미지 재활용</li>\n<li>다운로드 취소 처리</li>\n<li>최소한으로 사용하는 메모리</li>\n<li>이미지 변환</li>\n<li>메모리 및 디스크 캐싱 자동화</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"2-Glide\"><a href=\"#2-Glide\" class=\"headerlink\" title=\"2. Glide\"></a>2. Glide</h4><p><img src=\"https://github.com/bumptech/glide/blob/master/static/glide_logo.png?raw=true\"></p>\n<ul>\n<li>개발 주체 : Bump Technologies</li>\n<li>웹 사이트 : <a href=\"https://bumptech.github.io/glide/\">https://bumptech.github.io/glide/</a></li>\n<li>주요 기능<ul>\n<li>미디어 디코딩</li>\n<li><code>LruResourceCache</code> 및 <code>MemorySizeCalculator</code>를 사용한 메모리 캐싱</li>\n<li><code>Lru</code> 기반의 디스크 캐싱 (기본값 250mb)</li>\n<li>리소스 풀링을 위한 간단한 인터페이스 제공</li>\n<li><code>RGB_565</code>의 기본 포맷 사용</li>\n<li>gif, jpeg, war, png, webp 포맷 지원</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Coil-Coroutine-Image-Loader\"><a href=\"#Coil-Coroutine-Image-Loader\" class=\"headerlink\" title=\"Coil (Coroutine Image Loader)\"></a>Coil (Coroutine Image Loader)</h3><p><img src=\"https://github.com/coil-kt/coil/raw/main/logo.svg\"></p>\n<ul>\n<li>개발 주체 : <a href=\"https://www.instacart.com/\">Instacart</a></li>\n<li>웹 사이트 : <a href=\"https://github.com/coil-kt/coil\">https://github.com/coil-kt/coil</a></li>\n<li>주요 기능<ul>\n<li><code>MemoryCache.Key</code>를 사용한 메모리 캐싱</li>\n<li><code>OkHttpClient</code> 기반의 디스크 캐싱 (<code>CoilUtils.createDefaultCache</code>에서 옵션 설정)</li>\n<li>다운 샘플링</li>\n<li>이미지 재사용</li>\n<li>일시정지 및 취소의 자동화를 비롯한 최적화 작업</li>\n<li>Corotines, Okio 등의 최신 라이브러리 사용</li>\n<li>bmp, jpeg, png, webp 포맷 지원</li>\n<li>Android 8.0 이상에서 heif 포맷 지원</li>\n<li><code>coil-gif</code> 의존성 추가시<ul>\n<li>Android 9.0 이상에서 animated webp 포맷 지원 </li>\n<li>Android 11.0 이상에서 animated heif 지원 ()</li>\n</ul>\n</li>\n<li><code>coil-svg</code> 의존성 추가시 svg 포맷 지원</li>\n<li><code>coil-video</code> 의존성 추가시 Android가 지원하는 모든 비디오 코덱으로부터 정적 frame 획득 가능</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Fresco\"><a href=\"#Fresco\" class=\"headerlink\" title=\"Fresco\"></a>Fresco</h3><img alt=\"Fresco Logo\" src=\"https://github.com/facebook/fresco/raw/master/docs/static/sample-images/fresco_logo.svg\" width=\"15%\" />\n\n<ul>\n<li>개발 주체 : <a href=\"https://developers.facebook.com/\">Facebook</a></li>\n<li>웹 사이트 : <a href=\"https://frescolib.org/\">https://frescolib.org</a></li>\n<li>주요 기능<ul>\n<li>압축된 이미지를 통한 메모리 사용 최소화</li>\n<li>이미지 파이프라인을 통한 최적화</li>\n<li>Drawees를 사용한 이미지 렌더링</li>\n<li>URI 지정을 통한 점진적 jpeg 이미지 개선</li>\n<li>Android 4.0 이하에서 OOM을 최소화</li>\n<li>다운로드중일 경우 PlaceHolder 제공</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"AMUL-Android-Universal-Image-Loader\"><a href=\"#AMUL-Android-Universal-Image-Loader\" class=\"headerlink\" title=\"AMUL (Android-Universal-Image-Loader)\"></a>AMUL (Android-Universal-Image-Loader)</h3><p><img src=\"https://github.com/nostra13/Android-Universal-Image-Loader/raw/master/sample/src/main/res/drawable-mdpi/ic_launcher.png\"></p>\n<ul>\n<li>개발 주체 : <a href=\"https://github.com/nostra13/Android-Universal-Image-Loader\">Sergey Tarasevich(User)</a></li>\n<li>웹 사이트 : <a href=\"https://github.com/nostra13/Android-Universal-Image-Loader/wiki\">https://github.com/nostra13/Android-Universal-Image-Loader/wiki</a></li>\n<li>주요 기능<ul>\n<li>동기/비동기 기반의 멀티스레드 이미지 로딩</li>\n<li>Thread / Downloader / Decoder에 대한 광범위한 커스터마이징</li>\n<li>메모리 및 디스크 캐싱 자동화</li>\n<li>다운로드 진행률 제공</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"대표적인-라이브러리들의-간단한-성능-비교\"><a href=\"#대표적인-라이브러리들의-간단한-성능-비교\" class=\"headerlink\" title=\"대표적인 라이브러리들의 간단한 성능 비교\"></a>대표적인 라이브러리들의 간단한 성능 비교</h2><h3 id=\"Picasso\"><a href=\"#Picasso\" class=\"headerlink\" title=\"Picasso\"></a>Picasso</h3><p>Picasso 는 번거로움 없이 종종 단 한줄의 코드만으로도 이미지를 로딩할 수 있게 해준다. </p>\n<p>어댑터에서 이미지뷰를 재사용하고 다운로드와 취소할 수 있다. 적은 메모리 사용으로 복잡한 이미지 변환을 할 수 있다. 자동 메모리와 디스크 캐싱을 지원한다.</p>\n<p>또한 Picasso는 최소한의 메모리로 이미지의 다양한 Transformation을 지원하며, 자동으로 메모리 &amp; 디스크 캐싱, 어댑터에서 ImageView를 재활용 및 다운로드 취소가 가능하다는 점을 강조하고 있다.</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">MinSdkVersion</th>\n<th align=\"center\">CompileSdkVersion</th>\n<th align=\"center\">AAR Size</th>\n<th align=\"center\">비고</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">14</td>\n<td align=\"center\">29</td>\n<td align=\"center\">105kb</td>\n<td align=\"center\">GIF를 지원하지 않음</td>\n</tr>\n</tbody></table>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Picasso.<span class=\"keyword\">get</span>().load(url)</span><br><span class=\"line\">    .transform(RoundedCornersTransformation(<span class=\"number\">128</span>, <span class=\"number\">3</span>))</span><br><span class=\"line\">    .into(imageView5, <span class=\"keyword\">object</span> : Callback &#123;</span><br><span class=\"line\">        <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onSuccess</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">            toast(<span class=\"string\">&quot;Complete&quot;</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onError</span><span class=\"params\">(e: <span class=\"type\">Exception</span>?)</span></span> &#123;</span><br><span class=\"line\">            TODO(<span class=\"string\">&quot;Not yet implemented&quot;</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th align=\"center\">최초 로딩 속도 : 6.4s</th>\n<th align=\"center\">기본 캐싱 적용 : 1.6s</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><img src=\"/Team-Blog/2021/06/24/2021-06-24%20Image%20Loading%20and%20Caching%20Library%20Part%201/picasso_test.gif\" class=\"\" title=\"[picasso test]\"></td>\n<td align=\"center\"><img src=\"/Team-Blog/2021/06/24/2021-06-24%20Image%20Loading%20and%20Caching%20Library%20Part%201/picasso_caching.gif\" class=\"\" title=\"[picasso_caching]\"></td>\n</tr>\n</tbody></table>\n<p>Picasso는 원본 이미지 크기를 그대로 비트맵에 그린 후에 이미지뷰에 적용한다. 아래와같이  <code>1000 * 800</code> 의 이미지가 존재할 때, Bitmap 에 <code>1000 * 800 * 4bytes</code> = 3MB 가 ImageView 위에 올라갈 것이다. 그렇기 때문에 고화질의 이미지를 로드한다면 OOM을 발생시킬 수 있다. </p>\n<img src=\"/Team-Blog/2021/06/24/2021-06-24%20Image%20Loading%20and%20Caching%20Library%20Part%201/IMG_9F5E046409C4-1.jpg\" class=\"\" title=\"[IMG_9F5E046409C4-1]\">\n\n<p>이 문제를 방지하기 위해 <code>fit()</code> 함수를 이용한다면 고화질 이미지를 로드하기 전 이미지뷰의 크기를 먼저 측정하기 때문에 메모리 사용량을 최소화할 수 있을 것이다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Picasso.<span class=\"keyword\">get</span>()</span><br><span class=\"line\">    .fit()</span><br><span class=\"line\">    .transform(&#123;...&#125;)</span><br><span class=\"line\">    .load(url)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Heap-Dump\"><a href=\"#Heap-Dump\" class=\"headerlink\" title=\"Heap Dump\"></a>Heap Dump</h4><img src=\"/Team-Blog/2021/06/24/2021-06-24%20Image%20Loading%20and%20Caching%20Library%20Part%201/heap_dump.png\" class=\"\" title=\"[heap_dump]\">\n\n<p>10,136,858 byte (= 10MB)</p>\n<h3 id=\"Glide\"><a href=\"#Glide\" class=\"headerlink\" title=\"Glide\"></a>Glide</h3><p>Google에서 만든 이미지 로더 라이브러리인 Glide는 빠른 이미지 로딩, 버벅 거림과 끊김 현상이 발생하지 않는다는 점을 강조하고 있다. </p>\n<p>미디어 디코딩, 메모리 및 디스크 캐싱 그리고 리소스 풀링을 간단하고 사용하기 쉽게 인터페이스로 래핑하였으며 페치, 디코딩, 그리고 비디오스틸, 이미지, 움직이는 GIF 를 표시할 수 있다. </p>\n<p>커스텀된 HttpUrlConnection 을 기본 스택으로 사용하지만 거의 모든 네트워크 스택에 연결할 수 있는 유연한 API 를 포함하고 있어, Volly 또는 OkHttp 라이브러리를 대신 사용할 수 있다. </p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">MinSdkVersion</th>\n<th align=\"center\">CompileSdkVersion</th>\n<th align=\"center\">AAR Size</th>\n<th align=\"center\">비고</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">14</td>\n<td align=\"center\">26</td>\n<td align=\"center\">625kb</td>\n<td align=\"center\"></td>\n</tr>\n</tbody></table>\n<p>Glide는 아래처럼 싱글톤으로 만들어 간단하게 사용할 수 있다. </p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Glide.with(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">    .load(url)</span><br><span class=\"line\">    .apply(RequestOptions.bitmapTransform(RoundedCornersTransformation(<span class=\"number\">128</span>, <span class=\"number\">3</span>)))</span><br><span class=\"line\">    .listener(<span class=\"keyword\">object</span> : RequestListener&lt;Drawable&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onLoadFailed</span><span class=\"params\">(e: <span class=\"type\">GlideException</span>?, model: <span class=\"type\">Any</span>?, target: <span class=\"type\">Target</span>&lt;<span class=\"type\">Drawable</span>&gt;?, isFirstResource: <span class=\"type\">Boolean</span>)</span></span>: <span class=\"built_in\">Boolean</span> &#123;</span><br><span class=\"line\">            TODO(<span class=\"string\">&quot;Not yet implemented&quot;</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onResourceReady</span><span class=\"params\">(resource: <span class=\"type\">Drawable</span>?, model: <span class=\"type\">Any</span>?, target: <span class=\"type\">Target</span>&lt;<span class=\"type\">Drawable</span>&gt;?, </span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">          dataSource: <span class=\"type\">DataSource</span>?, isFirstResource: <span class=\"type\">Boolean</span>)</span></span>: <span class=\"built_in\">Boolean</span> &#123;</span><br><span class=\"line\">            toast(<span class=\"string\">&quot;Complete&quot;</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .into(imageView)</span><br></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th align=\"center\">최초 로딩 속도 : 6.2s</th>\n<th align=\"center\">기본 캐싱 적용 : 0.72s</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><img src=\"/Team-Blog/2021/06/24/2021-06-24%20Image%20Loading%20and%20Caching%20Library%20Part%201/glide_test.gif\" class=\"\" title=\"[glide_test]\"></td>\n<td align=\"center\"><img src=\"/Team-Blog/2021/06/24/2021-06-24%20Image%20Loading%20and%20Caching%20Library%20Part%201/glide_caching.gif\" class=\"\" title=\"[glide_caching]\"></td>\n</tr>\n</tbody></table>\n<p>Picasso와는 달리 Glide는 이미지뷰의 크기를 측정한 다음 원본이미지를 가져와 이미지 뷰 크기에 맞게 리사이징 후 비트맵에 그려주는 것을 기본 옵션으로 하기 때문에 메모리 효율성이 Picasso보다 좋다.</p>\n<img src=\"/Team-Blog/2021/06/24/2021-06-24%20Image%20Loading%20and%20Caching%20Library%20Part%201/IMG_8FF7402ED110-1.jpg\" class=\"\" title=\"[IMG_8FF7402ED110-1]\">\n\n<p>Glide가 언급한 이미지 라이브러리 중에서 완벽하게 Gif를 지원하는 것이 특징이다.</p>\n<p>Picasso는 미지원, Coil은 <code>1.2.2</code> 기준 확장 라이브러리로 Gif를 지원하지만 실제 사용해보니 라이브러리 자체가 불안정했으며, Fresco는 Gif에 Transformation와 같은 다양한 옵션을 적용할 수는 없었다.)</p>\n<img src=\"/Team-Blog/2021/06/24/2021-06-24%20Image%20Loading%20and%20Caching%20Library%20Part%201/glide_gif.gif\" class=\"\" title=\"[glide_gif]\">\n\n<h4 id=\"Heap-Dump-1\"><a href=\"#Heap-Dump-1\" class=\"headerlink\" title=\"Heap Dump\"></a>Heap Dump</h4><img src=\"/Team-Blog/2021/06/24/2021-06-24%20Image%20Loading%20and%20Caching%20Library%20Part%201/glide_heap_dump.png\" class=\"\" title=\"[glide_heap_dump]\">\n\n<p>11,004,024 byte (= 11MB)</p>\n<h3 id=\"Coil\"><a href=\"#Coil\" class=\"headerlink\" title=\"Coil\"></a>Coil</h3><p>Instacart에서 만든 Coil 은 Coroutine Image Loading의 줄임말로 위에 설명했던 이미지로더 라이브러리와 달리 코틀린 &amp; 코루틴으로 구성되어있다. 제일 장점으로는 라이브러리가 거의 100% 코틀린으로 이루어졌다는 점과 AndroidX, OkHttp 등 현업에서 많이 쓰이고있는 라이브러리들을 지원하고 있다는 점이다. Coil 라이브러리 내부를 살펴보면, Glide와 굉장히 비슷하다는 것을 알 수 있는데 Glide를 많이 <code>벤치마킹</code>했다고 한다 👀. 또한 ImageView의 확장함수로 지원하고, 코틀린의 매력인 함수형 언어 덕으로 다른 라이브러리보다 <code>더욱 간결한</code> 코드를 구성할 수 있다.</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">MinSdkVersion</th>\n<th align=\"center\">CompileSdkVersion</th>\n<th align=\"center\">AAR Size</th>\n<th align=\"center\">비고</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">14</td>\n<td align=\"center\">30</td>\n<td align=\"center\">16kb</td>\n<td align=\"center\"></td>\n</tr>\n</tbody></table>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">imageView.load(url) &#123;</span><br><span class=\"line\">    listener(</span><br><span class=\"line\">        onError = &#123; _,_ -&gt; <span class=\"comment\">/** Show toast. */</span> &#125;,</span><br><span class=\"line\">        onSuccess = &#123; _,_ -&gt; toast(<span class=\"string\">&quot;Complete&quot;</span>) &#125;</span><br><span class=\"line\">    )</span><br><span class=\"line\">    transformations(RoundedCornersTransformation(<span class=\"number\">128f</span>))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th align=\"center\">최초 로딩 속도 : 5.24s</th>\n<th align=\"center\">기본 캐싱 적용 : 1.3s</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><img src=\"/Team-Blog/2021/06/24/2021-06-24%20Image%20Loading%20and%20Caching%20Library%20Part%201/coil_test.gif\" class=\"\" title=\"[coil_test]\"></td>\n<td align=\"center\"><img src=\"/Team-Blog/2021/06/24/2021-06-24%20Image%20Loading%20and%20Caching%20Library%20Part%201/coil_caching.gif\" class=\"\" title=\"[coil_caching]\"></td>\n</tr>\n</tbody></table>\n<h4 id=\"Heap-Dump-2\"><a href=\"#Heap-Dump-2\" class=\"headerlink\" title=\"Heap Dump\"></a>Heap Dump</h4><img src=\"/Team-Blog/2021/06/24/2021-06-24%20Image%20Loading%20and%20Caching%20Library%20Part%201/coil_heap_dump.png\" class=\"\" title=\"[coil_heap_dump]\">\n\n<p>6,995,072 byte (= 7MB)</p>\n<p>좀 더 자세한 퍼포먼스 테스트는 Part 3에서 다루도록 하자.</p>"},{"title":"Image Loading and Caching Library Part 2 — Principle / Memory & Footprint / Compose","date":"2021-06-23T17:00:00.000Z","cover":"https://androiddeepdive.github.io/Team-Blog/images/cover_image_library.png","_content":"\n<article class=\"message message-immersive is-primary\">\n    <div class=\"message-body\">\n        <i class=\"fas fa-pen-fancy mr-2\"></i>Writers<br>\n        by 곽욱현 @Knowre<br>\n        by 김남훈 @Naver<br>\n        by 배희성 @RocketPunch<br>\n        by 송시영 @SmartStudy<br>\n        by 옥수환 @Naver<br>\n        by 이기정 @BankSalad<br>\n        by 정세희 @BankSalad\n    </div>\n</article>\n\n<!-- more -->\n## Image Library의 동작 방식\n\nAndroid 에서 가장 많이 쓰이는 `Glide`를 기준으로 이미지 라이브러리의 동작 방식을 살펴보자.\n\n먼저 Part 1에서 다루었던 기본 예제를 수정하도록 하자.\n\n### Glide 의존성 설정\n\n```gradle\ndependencies {\n    ...\n    implementation 'com.github.bumptech.glide:glide:4.12.0'\n    annotationProcessor 'com.github.bumptech.glide:compiler:4.12.0'\n    ...\n}\n```\n\n### 인터넷 사용 권한 부여\n\n```xml\n<manifest \n    xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    package=\"android.deepdive.raw\">\n\n    <uses-permission android:name=\"android.permission.INTERNET\"/>\n\n    <!-- ... -->\n\n</manifest>\n```\n\n### 레이아웃 파일에서 이미지 소스 제거\n\n```js\n<ImageView\n    android:id=\"@+id/imageView\"\n    android:layout_width=\"wrap_content\"\n    android:layout_height=\"wrap_content\"\n    app:layout_constraintBottom_toBottomOf=\"parent\"\n    app:layout_constraintLeft_toLeftOf=\"parent\"\n    app:layout_constraintRight_toRightOf=\"parent\"\n    app:layout_constraintTop_toTopOf=\"parent\"/>\n```\n\n### 코드에 Glide 예제 적용\n\n```kotlin\nclass MainActivity : AppCompatActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_main)\n\n        var imageView: ImageView = findViewById(R.id.imageView)\n\n        Glide\n            .with(this)\n            .load(\"https://goo.gl/gEgYUd\")\n            .into(imageView)\n    }\n}\n```\n\n위와 같이 작업을 하고 나면 아래와 같은 화면을 렌더링할 수 있다.\n\n{% asset_img Screenshot_1624078627.png 350 [Screenshot_1624078627] %}\n\n## 기능 톺아보기\n### 이미지 렌더링 방식\n\n```\nGlide\n    .with(this)\n    .load(\"https://goo.gl/gEgYUd\")\n    .into(imageView)\n```\n\n개발자 입장에서는 매우 간단하게 이미지를 렌더링할 수 있게 해준다.\n\nGlide 문서에서 최소로 요구되고 있는 `with()`와 `load()`, `into()`의 내부 구조를 한 번 살펴보자.\n\n#### 1. with 메서드\n\n```java\n@NonNull\npublic static RequestManager with(@NonNull FragmentActivity activity) {\n    return getRetriever(activity).get(activity);\n}\n```\n\n```java\n@NonNull\nprivate static RequestManagerRetriever getRetriever(@Nullable Context context) {\n    // Context could be null for other reasons (ie the user passes in null), but in practice it will\n    // only occur due to errors with the Fragment lifecycle.\n    Preconditions.checkNotNull(\n        context,\n        \"You cannot start a load on a not yet attached View or a Fragment where getActivity() \"\n            + \"returns null (which usually occurs when getActivity() is called before the Fragment \"\n            + \"is attached or after the Fragment is destroyed).\");\n    return Glide.get(context).getRequestManagerRetriever();\n}\n```\n\n`with()`메서드를 호출하면 `getRetriever()` 메서드를 통해 `RequestManagerRetriever` 객체를 획득한다.\n\n이후 `get()` 메서드를 이용해 `RequestManager` 객체를 생성하는 코드도 연달아 호출하게 된다.\n\n```java\n@NonNull\npublic RequestManager get(@NonNull Context context) {\n    if (context == null) {\n        throw new IllegalArgumentException(\"You cannot start a load on a null Context\");\n    } else if (Util.isOnMainThread() && !(context instanceof Application)) {\n        if (context instanceof FragmentActivity) {\n        return get((FragmentActivity) context);\n        } else if (context instanceof Activity) {\n        return get((Activity) context);\n        } else if (context instanceof ContextWrapper\n            // Only unwrap a ContextWrapper if the baseContext has a non-null application context.\n            // Context#createPackageContext may return a Context without an Application instance,\n            // in which case a ContextWrapper may be used to attach one.\n            && ((ContextWrapper) context).getBaseContext().getApplicationContext() != null) {\n        return get(((ContextWrapper) context).getBaseContext());\n        }\n    }\n    return getApplicationManager(context);\n}\n```\n\nContext의 instance type에 대한 처리후 제일 마지막에 `getApplicationManager()`를 호출한다.\n\n```java\n@NonNull\nprivate RequestManager getApplicationManager(@NonNull Context context) {\n    // Either an application context or we're on a background thread.\n    if (applicationManager == null) {  \n        synchronized (this) {\n            if (applicationManager == null) {\n            // Normally pause/resume is taken care of by the fragment we add to the fragment or\n            // activity. However, in this case since the manager attached to the application will not\n            // receive lifecycle events, we must force the manager to start resumed using\n            // ApplicationLifecycle.\n\n          // T  ODO(b/27524013): Factor out this Glide.get() call.\n            Glide glide = Glide.get(context.getApplicationContext());\n            applicationManager =\n                factory.build(\n                    glide,\n                    new ApplicationLifecycle(),\n                    new EmptyRequestManagerTreeNode(),\n                    context.getApplicationContext());\n            }\n        }\n    }\n    return applicationManager;\n}\n```\n\n`with()` 메서드는 Global Scope에서 애플리케이션의 생명주기와 연동하여 Glide의 싱글턴 객체를 획득하는 것이 목적이라고 볼 수 있다.\n\n#### 2. load 메서드\n\n두 번째로 `load()` 메서드를 살펴보자.\n\n```java\n@NonNull\n@CheckResult\n@Override\npublic RequestBuilder<Drawable> load(@Nullable String string) {\n    return asDrawable().load(string);\n}\n```\n\n단순힌 `asDrawable()`을 호출해 `RequestBuilder` 객체를 만들고, `load()`를 호출한다고만 명세되어있다.\n\n`asDrawable()` 구현체를 살펴보자.\n\n```java\n@NonNull\n@CheckResult\npublic RequestBuilder<Drawable> asDrawable() {\n    return as(Drawable.class);\n}\n```\n\n`android.graphics.drawable.Drawable` 타입을 `as()`에 파라미터로 넘겨주고 있다.\n\n`as()` 구현체를 살펴보자.\n\n\n```java\n@NonNull\n@CheckResult\npublic <ResourceType> RequestBuilder<ResourceType> as(@NonNull Class<ResourceType> resourceClass) {\n    return new RequestBuilder<>(glide, this, resourceClass, context);\n}\n```\n\n파라미터로 주어진 객체 타입(여기서는 `android.graphics.drawable.Drawable`)으로 디코딩하여 반환한다.\n\n여기서 쓰이는 디코더는 `com.bumptech.glide.load.ResourceDecoders`이다.\n\n`Drawable.class`로 고정되어있지 않은 이유는 리소스 클래스의 서브클래스들도 호환하기 위해서이다.\n\n`Glide.load()`에서 호출하는 `asDrawable()`이 디코딩할 리소스 클래스를 생성하였다면 바로 뒤에 붙은 `RequestBuilder.load()` 메서드에서 데이터를 불러올 것임을 추측할 수 있다.\n\n`RequestBuilder.load()` 메서드의 호출 구조를 살펴보자.\n\n```java\n@NonNull\n@Override\n@CheckResult\npublic RequestBuilder<TranscodeType> load(@Nullable String string) {\n    return loadGeneric(string);\n}\n```\n\n`load()`의 파라미터로 주어진 `string`값을 key로 사용해 데이터를 캐시하는 영역이다.\n\n동일 이미지의 반복적인 렌더링 작업에 대해 처리한 부분임을 알 수 있다.\n\n이후 `loadGeneric()`을 호출한다.\n\n```java\n@NonNull\nprivate RequestBuilder<TranscodeType> loadGeneric(@Nullable Object model) {\n    if (isAutoCloneEnabled()) {\n        return clone().loadGeneric(model);\n    }\n    this.model = model;\n    isModelSet = true;\n    return selfOrThrowIfLocked();\n}\n```\n\n파라미터의 타입이 `String`에서 `Object`로 변경되었다.\n\n이 `model`은 `com.bumptech.glide.load.model.UriLoader` 객체에서 핸들링하게 된다.\n\n```java\n@NonNull\n@SuppressWarnings(\"unchecked\")\nprotected final T selfOrThrowIfLocked() {\n    if (isLocked) {\n        throw new IllegalStateException(\"You cannot modify locked T, consider clone()\");\n    }\n    return self();\n}\n```\n\n```java\n@SuppressWarnings(\"unchecked\")\nprivate T self() {\n    return (T) this;\n}\n```\n\n이후 `RequestBuilder.load()`는 최종적으로 `RequestBuilder` 객체를 반환해주게 된다.\n\n#### 3. into 메서드\n\n현재까지 `with()`에서 `RequestManager`객체를 생성한 뒤, 이 객체의 `load()` 메서드를 호출하여 `RequestBuilder` 객체를 획득하는 과정까지 진행되었다.\n\n이제 `RequestBuilder`에서 `into()` 메서드를 호출해 `ImageView`에 리소스를 할당하는 마지막 작업이다.\n\n리소스를 할당할 ImageView를 파라미터로 요구한다.\n\n```java\n@NonNull\npublic ViewTarget<ImageView, TranscodeType> into(@NonNull ImageView view) {\n    Util.assertMainThread();\n    Preconditions.checkNotNull(view);\n\n    BaseRequestOptions<?> requestOptions = this;\n    if (!requestOptions.isTransformationSet()\n        && requestOptions.isTransformationAllowed()\n        && view.getScaleType() != null) {\n        // Clone in this method so that if we use this RequestBuilder to load into a View and then\n        // into a different target, we don't retain the transformation applied based on the previous\n        // View's scale type.\n        switch (view.getScaleType()) {\n        case CENTER_CROP:\n            requestOptions = requestOptions.clone().optionalCenterCrop();\n            break;\n        case CENTER_INSIDE:\n            requestOptions = requestOptions.clone().optionalCenterInside();\n            break;\n        case FIT_CENTER:\n        case FIT_START:\n        case FIT_END:\n            requestOptions = requestOptions.clone().optionalFitCenter();\n            break;\n        case FIT_XY:\n            requestOptions = requestOptions.clone().optionalCenterInside();\n            break;\n        case CENTER:\n        case MATRIX:\n        default:\n            // Do nothing.\n            }\n        }\n    return into(\n        glideContext.buildImageViewTarget(view, transcodeClass),\n        /*targetListener=*/ null,\n        requestOptions,\n        Executors.mainThreadExecutor());\n}\n```\n`Util.assertMainThread()`에서 메인 쓰레드 여부를 검증한 뒤, `Preconditions.checkNotNull(view)`에서 파라미터로 주어진 ImageView에 대한 null check를 수행한다.\n\n이후 ImageView의 scaleType에 대한 처리 후, `into(target, targetListener, options, callbackExecutor)`를 호출한다.\n\n이때 `target` 자리에 `GlideContext.buildImageViewTarget()`이라는 메서드를 주입하는데, 파라미터로 주어진 ImageView를 이용해 `BitmapImageViewTarget`이나 `DrawableImageViewTarget`으로 변환하는 작업을 수행한다.\n\n`GlideContext.buildImageViewTarget()`의 두 번째 파라미터인 `transcodeClass`의 값은 `Glide.load()`를 호출하였을 때 수행하는 `as()` 메소드의 파라미터인 `Drawable.class`로 이미 주입되어있다.\n\n```java\nprivate <Y extends Target<TranscodeType>> Y into(\n    @NonNull Y target,\n    @Nullable RequestListener<TranscodeType> targetListener,\n    BaseRequestOptions<?> options,\n    Executor callbackExecutor) {\n\n    Preconditions.checkNotNull(target);\n    if (!isModelSet) {\n        throw new IllegalArgumentException(\"You must call #load() before calling #into()\");\n    }\n\n    Request request = buildRequest(target, targetListener, options, callbackExecutor);\n    Request previous = target.getRequest();\n    if (request.isEquivalentTo(previous) && !isSkipMemoryCacheWithCompletePreviousRequest(options, previous)) {\n        // If the request is completed, beginning again will ensure the result is re-delivered,\n        // triggering RequestListeners and Targets. If the request is failed, beginning again will\n        // restart the request, giving it another chance to complete. If the request is already\n        // running, we can let it continue running without interruption.\n        if (!Preconditions.checkNotNull(previous).isRunning()) {\n            // Use the previous request rather than the new one to allow for optimizations like skipping\n            // setting placeholders, tracking and un-tracking Targets, and obtaining View dimensions\n            // that are done in the individual Request.\n            previous.begin();\n        }\n        return target;\n    }\n\n    requestManager.clear(target);\n    target.setRequest(request);\n    requestManager.track(target, request);\n\n    return target;\n}\n```\n\n`target`으로 주어진 ImageView에 리소스를 세팅하는 곳인데, 특기할만한 부분은 `requestManager.clear(target)`이다.\n\n해당 메서드를 호출하면 현재 target으로 설정된 뷰에 대한 모든 로딩을 취소하고 모든 리소스를 해제한다.\n\n## Memory & Footprint\n\nBitmap를 다루다보면 필연적으로 OOM 관련하여 메모리 이슈를 피할 수 없다.\n\nImage Library를 사용하지 않은 상태에서 많은 이미지를 사용하거나 고해상도 이미지를 이미지뷰에 로드해야하는 경우 메모리 부족으로 OOM이 발생하게 된다.\n\n요즘 나오는 스마트폰은 굉장히 많은 메모리를 가지고 태어나는데 **왜 이정도도 못 버티지(?)** 라는 생각을 한다면, 안드로이드는 앱 내에서 사용할 수 있는 힙 메모리가 정해져있기 때문이다.\n\n{% asset_img IMG_06A0242D2ABE-1.jpg [IMG_06A0242D2ABE-1] %}\n\nAndroid의 메모리 모델은 운영체제 버전에 따라 두가지로 나뉘게 된다. \n\n* Dalvik heap 영역 : java 객체를 저장하는 메모리\n* External 영역 : native heap의 일종으로 네이티브의 비트맵 객체를 저장하는 메모리\nDalvik heap 영역와 External 영역의 `Dalvik heap footprint + External Limit`을 합쳐 프로세스당 메모리 한계를 초과하면 OOM이 발생하게 된다.\n\n### Footprint\njava의 footprint는 한 번 증가하면 크기가 다시 감소되지 않기 때문에, footprint가 과도하게 커지지 않게끔 잘 관리해야한다. \n\n{% asset_img image.png [image] %}\n\nDalvik VM은 처음에 동작에 필요한 만큼만 프로세스에 Heap을 할당하게 되고, 프로세스에 할당된 메모리보다 많은 메모리를 필요하게될 때마다 Dalvit Footfrint도 증가하게된다. 하지만 증가된 Footfrint는 결코 감소하지 않기 때문에 java 객체가 사용가능한 메모리 공간의 여유가 있어도, External heap의 크기가 증가되면 OOM이 발생할 수 있다. 하지만 이런 문제도 Honeycomb 이후부터는 Dalvik heap 과 External 영역이 합쳐졌기 때문에, 고려할 필요가 없어졌다. \n\nExternal 영역을 사용하는 Honeycomb 미만 버전에서는 이미지를 많이 사용하고있는 화면에서 화면을 전환하는 행동이 발생했을 때도 OOM이 발생하면서 앱이 중지될 것이다. 화면을 전환하면 이전 액티비티 인스턴스에 있던 이미지뷰나 할당되었던 비트맵이 함께 소멸되어 메모리가 회수되고 새로운 액티비티 인스턴스를 생성할텐데, 이 과정에서 이전 액티비티 인스턴스의 비트맵 객체가 회수되지 않아 메모리 누수가 발생했기 때문이다. \n\n비트맵 객체에 대한 참조가 없는데도 왜 회수가 될 수 없을까? Honeycomb 미만 버전에서는 Java 비트맵 객체는 실제 비트맵 데이터를 가지고 있는 곳을 가리키는 포인터일 뿐이고 실제 데이터는 External 영역인 Native Heap 영역에 저장되기 때문이다. Java 비트맵 객체는 참조가 없을 때 GC에 의해 회수되지만 Native Heap 영역은 GC 수행영역 밖이기 때문에 메모리 소멸 시점이 다르다. \n\n이러한 문제점 때문에, Honeycomb 이후 버전에서는 External 영역이 없어지면서 Dalvik heap 영역에 비트맵 메모리를 올릴 수 있게 되었고 GC도 접근할 수 있게 되었다.\n\n다시 돌아와, 만약 고해상도 이미지를 로드할 때 OOM이 발생하는 경우 BitmapFactory 객체를 이용해 다운샘플링, 디코딩 방식을 선택해 적절하게 뷰에 로드하면 된다. 하지만 많은 이미지를 사용하게 되면서 OOM이 발생한다면, `이미지 캐싱`을 이용해보는 것이 어떨까?\n\n### Bitmap Caching\n\n이미지가 화면에서 사라지고 다시 구성할 때 이미지를 매번 로드하는 것은 성능상으로나 사용자 경험에 좋지 않다. 이럴 때 메모리와 디스크 캐시를 이용하여 어디에선가 저장되어있던 비트맵을 다시 가져온다면 다시 로드하는 시간도 단축시킬 수 있으며 성능 개선도 가능할 것이다. 이 때 캐싱을 위해 `Memory Cache`와 `Disk Cache` 사용을 추천하는데 두가지가 어떤 차이점이 있는지 알아보자.\n\n#### 1. Memory Cache\nMemory Cache는 어플리케이션 내에 존재하는 메모리에 비트맵을 캐싱하고, 필요할 때 빠르게 접근가능하다. 하지만 Memory Cache도 곧 어플리케이션 용량을 키우는 주범이 될 수 있기 때문에 많은 캐싱을 요구하는 비트맵의 경우에는 Disk Cache에 넣는 것이 더 좋을 수 있다.\n\n\n#### 2. Disk Cache\nMemory Cache에 넣기엔 많은 캐시를 요구하는 경우, 혹은 앱이 백그라운드로 전환되어도 적재한 캐시가 삭제되지 않기를 바란다면 Disk Cache를 이용하는 것이 좋다. 하지만 Disk로부터 캐싱된 비트맵을 가져올 때는 Memory에서 로드하는 것보다 오랜시간이 걸린다.\n\n\n### BitmapPool\nMemory Cache의 예시를 위해 소개할 것은 `BitmapPool`이다. `BitmapPool`의 원리는 사용하지 않는 Bitmap을 리스트에 넣어놓고, 추후에 동일한 이미지를 로드할 때 다시 메모리에 적재하지 않고 pool에 있는 이미지를 가져와 재사용하는 것이다. \n\n보통 BitmapPool을 이용해 재사용 Pool을 만들게 될 때, LRU 캐싱 알고리즘으로 구현된 LinkedList `(lruBItmapList)`와 Byte Size 순으로 정렬된 LinkedList`(bitmapList)`를 사용하여 구현하게 된다. 이 둘은 들어있는 비트맵의 순서만 다를 뿐, 같은 비트맵이 담기게된다.\n\n``` kotlin\nprivate val lruBitmapList = LinkedList<Bitmap>()\nprivate val bitmapList = LinkedList<Bitmap>()\n```\n\nLRU 알고리즘을 이용해 오랫동안 참조되지않은 비트맵 객체는 맨 뒤로 밀리게되고, `맨 뒤에있는 객체를 회수`하면서 BitmapPool을 유지시키는 것이다. LRU 알고리즘을 이용하지 않는다면 처음 BitmapPool이 가득 찰 때까지는 문제없이 동작하지만, 비트맵을 재사용하는 시점부터는 특정 비트맵만 재사용될 수 있으며, 앱이 끝날 때까지 메모리가 줄어들지 않게된다. 자세한 내용은 [이 블로그](https://jamssoft.tistory.com/195)를 참고하길 바란다.\n\n\n\n대표적인 이미지 로더 라이브러리인 `Glide`에서 구현한 LruBitmapPool Class 내부를 보며, LruBitmapList와 bitmapList가 어떻게 쓰이고있는지 살펴보자. \n\n``` java\npublic class LruBitmapPool implements BitmapPool {\n    private static final String TAG = \"LruBitmapPool\";\n    private static final Bitmap.Config DEFAULT_CONFIG = Bitmap.Config.ARGB_8888;\n\n    private final LruPoolStrategy strategy;\n    private final Set<Bitmap.Config> allowedConfigs;\n    private final BitmapTracker tracker;\n\n    // Pool에 들어올수 있는 최대 크기\n    private long maxSize;\n    // 현재 pool에 들어간 bitmap byte 크기\n    private long currentSize;\n\n  // ...\n```\n\nGlide내 LruBitmapPool Class 에서는 strategy(LruPoolStrategy)가 곧 LRU 기반으로 구현된 리스트이며, tracker(BitmapTracker)가 Bitmap size 순으로 정렬된 리스트이다.\n\n``` java\n@Override\npublic synchronized void put(Bitmap bitmap) {\n    if (bitmap == null) {\n        throw new NullPointerException(\"Bitmap must not be null\");\n    }\n    // isRecycled: 재활용된 bitmap인지 여부\n    if (bitmap.isRecycled()) {\n        throw new IllegalStateException(\"Cannot pool recycled bitmap\");\n    }\n    // isMutable: canvas를 얻을 수 있는 bitmap 인지 여부.\n    if (!bitmap.isMutable()\n        || strategy.getSize(bitmap) > maxSize\n        || !allowedConfigs.contains(bitmap.getConfig())) {\n        \n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(\n                TAG,\n                \"Reject bitmap from pool\"\n                + \", bitmap: \"\n                + strategy.logBitmap(bitmap)\n                + \", is mutable: \"\n                + bitmap.isMutable()\n                + \", is allowed config: \"\n                + allowedConfigs.contains(bitmap.getConfig()));\n        }\n        bitmap.recycle();\n        return;\n    }\n    // pool에 넣으려는 bitmap의 사이즈를 얻어온다.\n    final int size = strategy.getSize(bitmap);\n    strategy.put(bitmap);\n    tracker.add(bitmap);\n\n    puts++;\n    currentSize += size;\n\n    if (Log.isLoggable(TAG, Log.VERBOSE)) {\n        Log.v(TAG, \"Put bitmap in pool=\" + strategy.logBitmap(bitmap));\n    }\n    dump();\n\n    evict();\n}\n```\n\nBitmap을 Pool에 넣을 수 있는 조건을 충족시킨다면, strategy & tracker에 bitmap이 들어가게된다. \n\n> **참고** Lru 기반인 strategy 는 최근에 들어온 bitmap일수록 리스트의 맨 앞으로 배치시켜야하는데, 그 로직이 `LruPoolStrategy` 구현체 내부에 존재하게 된다.\n\n```java\n// Pool의 최대 사용량을 넘기면 크기를 줄여준다.\nprivate synchronized void trimToSize(long size) {\n    while (currentSize > size) {\n        //LRU List에서 삭제한다.\n        final Bitmap removed = strategy.removeLast();\n        if (removed == null) {\n            if (Log.isLoggable(TAG, Log.WARN)) {\n                Log.w(TAG, \"Size mismatch, resetting\");\n                dumpUnchecked();\n            }\n            currentSize = 0;\n            return;\n        }\n        // BitmapList에서 삭제한다. \n        tracker.remove(removed);\n        currentSize -= strategy.getSize(removed);\n        evictions++;\n        if (Log.isLoggable(TAG, Log.DEBUG)) {\n            Log.d(TAG, \"Evicting bitmap=\" + strategy.logBitmap(removed));\n        }\n        dump();\n        removed.recycle();\n    }\n}\n```\n\ntrimToSize()를 이용하면 pool이 최대사용량을 넘어선 경우 참조를 가장 적게하고 있는 lastIndex 부터 객체를 지워가며 크기를 줄여줄 수 있다. \n\n```java\n@Override\n@Nullable\npublic Bitmap get(int width, int height, Bitmap.Config config) {\n    final int size = Util.getBitmapByteSize(width, height, config);\n    Key key = keyPool.get(size);\n\n    Integer possibleSize = sortedSizes.ceilingKey(size);\n    if (possibleSize != null && possibleSize != size && possibleSize <= size * MAX_SIZE_MULTIPLE) {\n        keyPool.offer(key);\n        key = keyPool.get(possibleSize);\n    }\n\n    final Bitmap result = groupedMap.get(key);\n    // 비트맵을 찾은 경우, pool에서 제거한다.\n    if (result != null) {\n        result.reconfigure(width, height, config);\n        decrementBitmapOfSize(possibleSize);\n    }\n    return result;\n}\n```\n\n이미지를 로드하기 위해 pool에서 필요한 비트맵을 가져온다.\n\n## Jetpack Compose에서 이미지 라이브러리 사용하기\n\nGoogle 에서는 Jetpack Compose를 보다 편하게 사용하기 위한 라이브러리를 묶어서 제공한다.\n\n**Accompanist** 라고 하는 GroupId를 가진 라이브러리 모음이다.\n\n> **참고** [Google#Accompanist Repository](https://github.com/google/accompanist)\n\nAccompanist에서는 Glide와 Coil을 지원하고 있다.\n\n의존성 설정은 아래와 같다.\n\n```gradle\ndependencies {\n    ...\n    implementation \"com.google.accompanist:accompanist-glide:0.11.1\"\n    implementation \"com.google.accompanist:accompanist-coil:0.11.1\"\n    ...\n}\n```\n\nGlide는 아래와 같이 적용한다.\n\n```kotlin\nImage(\n    painter = rememberGlidePainter(\n        request = \"https://picsum.photos/300/300\",\n        // placeHolder\n    ),\n    contentDescription = stringResource(R.string.image_content_desc)\n)\nImage(\n    painter = rememberGlidePainter(\n        request = \"https://cataas.com/cat/gif\",\n        // placeHolder\n    ),\n    contentDescription = null\n)\n```\n\nCoil은 아래와 같이 적용한다.\n\n```kotlin\nImage(\n    painter = rememberCoilPainter(\n        request = \"https://picsum.photos/300/300\",\n        // placeHolder\n    ),\n    contentDescription = null\n)\n```\n\nCoil에서 gif를 렌더링하기 위해선 `coil-gif` 의존성을 추가한다.\n\n```gradle\ndependencies {\n    ...\n    implementation \"com.google.accompanist:accompanist-glide:0.11.1\"\n    implementation \"com.google.accompanist:accompanist-coil:0.11.1\"\n    // Coil 에서 gif 를 사용하기 위해서 추가\n    implementation \"io.coil-kt:coil-gif:1.2.2\"\n    ...\n}\n```\n\n아래와 같이 별도의 ImageLoader를 설정한다.\n\n```kotlin\nfun gifImageLoader(context: Context) = ImageLoader.Builder(context)\n    .componentRegistry {\n    if (SDK_INT >= 28) {\n        add(ImageDecoderDecoder(context))\n    } else {\n        add(GifDecoder())\n        }\n    }\n    .build()\n```\n\nImage의 적용은 아래와 같이 적용한다.\n\n```kotlin\nImage(\n    painter = rememberCoilPainter(\n        request = \"https://cataas.com/cat/gif\",\n        imageLoader = gifImageLoader(LocalContext*.current),\n    ),\n    contentDescription = null\n)\n```","source":"_posts/2021-06-24 Image Loading and Caching Library Part 2.md","raw":"---\ntitle: Image Loading and Caching Library Part 2 — Principle / Memory & Footprint / Compose\ndate: 2021-06-24 02:00\ncover: https://androiddeepdive.github.io/Team-Blog/images/cover_image_library.png\ncategories:\n- Image Library\ntags:\n- Android\n- Image\n- Library\n---\n\n<article class=\"message message-immersive is-primary\">\n    <div class=\"message-body\">\n        <i class=\"fas fa-pen-fancy mr-2\"></i>Writers<br>\n        by 곽욱현 @Knowre<br>\n        by 김남훈 @Naver<br>\n        by 배희성 @RocketPunch<br>\n        by 송시영 @SmartStudy<br>\n        by 옥수환 @Naver<br>\n        by 이기정 @BankSalad<br>\n        by 정세희 @BankSalad\n    </div>\n</article>\n\n<!-- more -->\n## Image Library의 동작 방식\n\nAndroid 에서 가장 많이 쓰이는 `Glide`를 기준으로 이미지 라이브러리의 동작 방식을 살펴보자.\n\n먼저 Part 1에서 다루었던 기본 예제를 수정하도록 하자.\n\n### Glide 의존성 설정\n\n```gradle\ndependencies {\n    ...\n    implementation 'com.github.bumptech.glide:glide:4.12.0'\n    annotationProcessor 'com.github.bumptech.glide:compiler:4.12.0'\n    ...\n}\n```\n\n### 인터넷 사용 권한 부여\n\n```xml\n<manifest \n    xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    package=\"android.deepdive.raw\">\n\n    <uses-permission android:name=\"android.permission.INTERNET\"/>\n\n    <!-- ... -->\n\n</manifest>\n```\n\n### 레이아웃 파일에서 이미지 소스 제거\n\n```js\n<ImageView\n    android:id=\"@+id/imageView\"\n    android:layout_width=\"wrap_content\"\n    android:layout_height=\"wrap_content\"\n    app:layout_constraintBottom_toBottomOf=\"parent\"\n    app:layout_constraintLeft_toLeftOf=\"parent\"\n    app:layout_constraintRight_toRightOf=\"parent\"\n    app:layout_constraintTop_toTopOf=\"parent\"/>\n```\n\n### 코드에 Glide 예제 적용\n\n```kotlin\nclass MainActivity : AppCompatActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_main)\n\n        var imageView: ImageView = findViewById(R.id.imageView)\n\n        Glide\n            .with(this)\n            .load(\"https://goo.gl/gEgYUd\")\n            .into(imageView)\n    }\n}\n```\n\n위와 같이 작업을 하고 나면 아래와 같은 화면을 렌더링할 수 있다.\n\n{% asset_img Screenshot_1624078627.png 350 [Screenshot_1624078627] %}\n\n## 기능 톺아보기\n### 이미지 렌더링 방식\n\n```\nGlide\n    .with(this)\n    .load(\"https://goo.gl/gEgYUd\")\n    .into(imageView)\n```\n\n개발자 입장에서는 매우 간단하게 이미지를 렌더링할 수 있게 해준다.\n\nGlide 문서에서 최소로 요구되고 있는 `with()`와 `load()`, `into()`의 내부 구조를 한 번 살펴보자.\n\n#### 1. with 메서드\n\n```java\n@NonNull\npublic static RequestManager with(@NonNull FragmentActivity activity) {\n    return getRetriever(activity).get(activity);\n}\n```\n\n```java\n@NonNull\nprivate static RequestManagerRetriever getRetriever(@Nullable Context context) {\n    // Context could be null for other reasons (ie the user passes in null), but in practice it will\n    // only occur due to errors with the Fragment lifecycle.\n    Preconditions.checkNotNull(\n        context,\n        \"You cannot start a load on a not yet attached View or a Fragment where getActivity() \"\n            + \"returns null (which usually occurs when getActivity() is called before the Fragment \"\n            + \"is attached or after the Fragment is destroyed).\");\n    return Glide.get(context).getRequestManagerRetriever();\n}\n```\n\n`with()`메서드를 호출하면 `getRetriever()` 메서드를 통해 `RequestManagerRetriever` 객체를 획득한다.\n\n이후 `get()` 메서드를 이용해 `RequestManager` 객체를 생성하는 코드도 연달아 호출하게 된다.\n\n```java\n@NonNull\npublic RequestManager get(@NonNull Context context) {\n    if (context == null) {\n        throw new IllegalArgumentException(\"You cannot start a load on a null Context\");\n    } else if (Util.isOnMainThread() && !(context instanceof Application)) {\n        if (context instanceof FragmentActivity) {\n        return get((FragmentActivity) context);\n        } else if (context instanceof Activity) {\n        return get((Activity) context);\n        } else if (context instanceof ContextWrapper\n            // Only unwrap a ContextWrapper if the baseContext has a non-null application context.\n            // Context#createPackageContext may return a Context without an Application instance,\n            // in which case a ContextWrapper may be used to attach one.\n            && ((ContextWrapper) context).getBaseContext().getApplicationContext() != null) {\n        return get(((ContextWrapper) context).getBaseContext());\n        }\n    }\n    return getApplicationManager(context);\n}\n```\n\nContext의 instance type에 대한 처리후 제일 마지막에 `getApplicationManager()`를 호출한다.\n\n```java\n@NonNull\nprivate RequestManager getApplicationManager(@NonNull Context context) {\n    // Either an application context or we're on a background thread.\n    if (applicationManager == null) {  \n        synchronized (this) {\n            if (applicationManager == null) {\n            // Normally pause/resume is taken care of by the fragment we add to the fragment or\n            // activity. However, in this case since the manager attached to the application will not\n            // receive lifecycle events, we must force the manager to start resumed using\n            // ApplicationLifecycle.\n\n          // T  ODO(b/27524013): Factor out this Glide.get() call.\n            Glide glide = Glide.get(context.getApplicationContext());\n            applicationManager =\n                factory.build(\n                    glide,\n                    new ApplicationLifecycle(),\n                    new EmptyRequestManagerTreeNode(),\n                    context.getApplicationContext());\n            }\n        }\n    }\n    return applicationManager;\n}\n```\n\n`with()` 메서드는 Global Scope에서 애플리케이션의 생명주기와 연동하여 Glide의 싱글턴 객체를 획득하는 것이 목적이라고 볼 수 있다.\n\n#### 2. load 메서드\n\n두 번째로 `load()` 메서드를 살펴보자.\n\n```java\n@NonNull\n@CheckResult\n@Override\npublic RequestBuilder<Drawable> load(@Nullable String string) {\n    return asDrawable().load(string);\n}\n```\n\n단순힌 `asDrawable()`을 호출해 `RequestBuilder` 객체를 만들고, `load()`를 호출한다고만 명세되어있다.\n\n`asDrawable()` 구현체를 살펴보자.\n\n```java\n@NonNull\n@CheckResult\npublic RequestBuilder<Drawable> asDrawable() {\n    return as(Drawable.class);\n}\n```\n\n`android.graphics.drawable.Drawable` 타입을 `as()`에 파라미터로 넘겨주고 있다.\n\n`as()` 구현체를 살펴보자.\n\n\n```java\n@NonNull\n@CheckResult\npublic <ResourceType> RequestBuilder<ResourceType> as(@NonNull Class<ResourceType> resourceClass) {\n    return new RequestBuilder<>(glide, this, resourceClass, context);\n}\n```\n\n파라미터로 주어진 객체 타입(여기서는 `android.graphics.drawable.Drawable`)으로 디코딩하여 반환한다.\n\n여기서 쓰이는 디코더는 `com.bumptech.glide.load.ResourceDecoders`이다.\n\n`Drawable.class`로 고정되어있지 않은 이유는 리소스 클래스의 서브클래스들도 호환하기 위해서이다.\n\n`Glide.load()`에서 호출하는 `asDrawable()`이 디코딩할 리소스 클래스를 생성하였다면 바로 뒤에 붙은 `RequestBuilder.load()` 메서드에서 데이터를 불러올 것임을 추측할 수 있다.\n\n`RequestBuilder.load()` 메서드의 호출 구조를 살펴보자.\n\n```java\n@NonNull\n@Override\n@CheckResult\npublic RequestBuilder<TranscodeType> load(@Nullable String string) {\n    return loadGeneric(string);\n}\n```\n\n`load()`의 파라미터로 주어진 `string`값을 key로 사용해 데이터를 캐시하는 영역이다.\n\n동일 이미지의 반복적인 렌더링 작업에 대해 처리한 부분임을 알 수 있다.\n\n이후 `loadGeneric()`을 호출한다.\n\n```java\n@NonNull\nprivate RequestBuilder<TranscodeType> loadGeneric(@Nullable Object model) {\n    if (isAutoCloneEnabled()) {\n        return clone().loadGeneric(model);\n    }\n    this.model = model;\n    isModelSet = true;\n    return selfOrThrowIfLocked();\n}\n```\n\n파라미터의 타입이 `String`에서 `Object`로 변경되었다.\n\n이 `model`은 `com.bumptech.glide.load.model.UriLoader` 객체에서 핸들링하게 된다.\n\n```java\n@NonNull\n@SuppressWarnings(\"unchecked\")\nprotected final T selfOrThrowIfLocked() {\n    if (isLocked) {\n        throw new IllegalStateException(\"You cannot modify locked T, consider clone()\");\n    }\n    return self();\n}\n```\n\n```java\n@SuppressWarnings(\"unchecked\")\nprivate T self() {\n    return (T) this;\n}\n```\n\n이후 `RequestBuilder.load()`는 최종적으로 `RequestBuilder` 객체를 반환해주게 된다.\n\n#### 3. into 메서드\n\n현재까지 `with()`에서 `RequestManager`객체를 생성한 뒤, 이 객체의 `load()` 메서드를 호출하여 `RequestBuilder` 객체를 획득하는 과정까지 진행되었다.\n\n이제 `RequestBuilder`에서 `into()` 메서드를 호출해 `ImageView`에 리소스를 할당하는 마지막 작업이다.\n\n리소스를 할당할 ImageView를 파라미터로 요구한다.\n\n```java\n@NonNull\npublic ViewTarget<ImageView, TranscodeType> into(@NonNull ImageView view) {\n    Util.assertMainThread();\n    Preconditions.checkNotNull(view);\n\n    BaseRequestOptions<?> requestOptions = this;\n    if (!requestOptions.isTransformationSet()\n        && requestOptions.isTransformationAllowed()\n        && view.getScaleType() != null) {\n        // Clone in this method so that if we use this RequestBuilder to load into a View and then\n        // into a different target, we don't retain the transformation applied based on the previous\n        // View's scale type.\n        switch (view.getScaleType()) {\n        case CENTER_CROP:\n            requestOptions = requestOptions.clone().optionalCenterCrop();\n            break;\n        case CENTER_INSIDE:\n            requestOptions = requestOptions.clone().optionalCenterInside();\n            break;\n        case FIT_CENTER:\n        case FIT_START:\n        case FIT_END:\n            requestOptions = requestOptions.clone().optionalFitCenter();\n            break;\n        case FIT_XY:\n            requestOptions = requestOptions.clone().optionalCenterInside();\n            break;\n        case CENTER:\n        case MATRIX:\n        default:\n            // Do nothing.\n            }\n        }\n    return into(\n        glideContext.buildImageViewTarget(view, transcodeClass),\n        /*targetListener=*/ null,\n        requestOptions,\n        Executors.mainThreadExecutor());\n}\n```\n`Util.assertMainThread()`에서 메인 쓰레드 여부를 검증한 뒤, `Preconditions.checkNotNull(view)`에서 파라미터로 주어진 ImageView에 대한 null check를 수행한다.\n\n이후 ImageView의 scaleType에 대한 처리 후, `into(target, targetListener, options, callbackExecutor)`를 호출한다.\n\n이때 `target` 자리에 `GlideContext.buildImageViewTarget()`이라는 메서드를 주입하는데, 파라미터로 주어진 ImageView를 이용해 `BitmapImageViewTarget`이나 `DrawableImageViewTarget`으로 변환하는 작업을 수행한다.\n\n`GlideContext.buildImageViewTarget()`의 두 번째 파라미터인 `transcodeClass`의 값은 `Glide.load()`를 호출하였을 때 수행하는 `as()` 메소드의 파라미터인 `Drawable.class`로 이미 주입되어있다.\n\n```java\nprivate <Y extends Target<TranscodeType>> Y into(\n    @NonNull Y target,\n    @Nullable RequestListener<TranscodeType> targetListener,\n    BaseRequestOptions<?> options,\n    Executor callbackExecutor) {\n\n    Preconditions.checkNotNull(target);\n    if (!isModelSet) {\n        throw new IllegalArgumentException(\"You must call #load() before calling #into()\");\n    }\n\n    Request request = buildRequest(target, targetListener, options, callbackExecutor);\n    Request previous = target.getRequest();\n    if (request.isEquivalentTo(previous) && !isSkipMemoryCacheWithCompletePreviousRequest(options, previous)) {\n        // If the request is completed, beginning again will ensure the result is re-delivered,\n        // triggering RequestListeners and Targets. If the request is failed, beginning again will\n        // restart the request, giving it another chance to complete. If the request is already\n        // running, we can let it continue running without interruption.\n        if (!Preconditions.checkNotNull(previous).isRunning()) {\n            // Use the previous request rather than the new one to allow for optimizations like skipping\n            // setting placeholders, tracking and un-tracking Targets, and obtaining View dimensions\n            // that are done in the individual Request.\n            previous.begin();\n        }\n        return target;\n    }\n\n    requestManager.clear(target);\n    target.setRequest(request);\n    requestManager.track(target, request);\n\n    return target;\n}\n```\n\n`target`으로 주어진 ImageView에 리소스를 세팅하는 곳인데, 특기할만한 부분은 `requestManager.clear(target)`이다.\n\n해당 메서드를 호출하면 현재 target으로 설정된 뷰에 대한 모든 로딩을 취소하고 모든 리소스를 해제한다.\n\n## Memory & Footprint\n\nBitmap를 다루다보면 필연적으로 OOM 관련하여 메모리 이슈를 피할 수 없다.\n\nImage Library를 사용하지 않은 상태에서 많은 이미지를 사용하거나 고해상도 이미지를 이미지뷰에 로드해야하는 경우 메모리 부족으로 OOM이 발생하게 된다.\n\n요즘 나오는 스마트폰은 굉장히 많은 메모리를 가지고 태어나는데 **왜 이정도도 못 버티지(?)** 라는 생각을 한다면, 안드로이드는 앱 내에서 사용할 수 있는 힙 메모리가 정해져있기 때문이다.\n\n{% asset_img IMG_06A0242D2ABE-1.jpg [IMG_06A0242D2ABE-1] %}\n\nAndroid의 메모리 모델은 운영체제 버전에 따라 두가지로 나뉘게 된다. \n\n* Dalvik heap 영역 : java 객체를 저장하는 메모리\n* External 영역 : native heap의 일종으로 네이티브의 비트맵 객체를 저장하는 메모리\nDalvik heap 영역와 External 영역의 `Dalvik heap footprint + External Limit`을 합쳐 프로세스당 메모리 한계를 초과하면 OOM이 발생하게 된다.\n\n### Footprint\njava의 footprint는 한 번 증가하면 크기가 다시 감소되지 않기 때문에, footprint가 과도하게 커지지 않게끔 잘 관리해야한다. \n\n{% asset_img image.png [image] %}\n\nDalvik VM은 처음에 동작에 필요한 만큼만 프로세스에 Heap을 할당하게 되고, 프로세스에 할당된 메모리보다 많은 메모리를 필요하게될 때마다 Dalvit Footfrint도 증가하게된다. 하지만 증가된 Footfrint는 결코 감소하지 않기 때문에 java 객체가 사용가능한 메모리 공간의 여유가 있어도, External heap의 크기가 증가되면 OOM이 발생할 수 있다. 하지만 이런 문제도 Honeycomb 이후부터는 Dalvik heap 과 External 영역이 합쳐졌기 때문에, 고려할 필요가 없어졌다. \n\nExternal 영역을 사용하는 Honeycomb 미만 버전에서는 이미지를 많이 사용하고있는 화면에서 화면을 전환하는 행동이 발생했을 때도 OOM이 발생하면서 앱이 중지될 것이다. 화면을 전환하면 이전 액티비티 인스턴스에 있던 이미지뷰나 할당되었던 비트맵이 함께 소멸되어 메모리가 회수되고 새로운 액티비티 인스턴스를 생성할텐데, 이 과정에서 이전 액티비티 인스턴스의 비트맵 객체가 회수되지 않아 메모리 누수가 발생했기 때문이다. \n\n비트맵 객체에 대한 참조가 없는데도 왜 회수가 될 수 없을까? Honeycomb 미만 버전에서는 Java 비트맵 객체는 실제 비트맵 데이터를 가지고 있는 곳을 가리키는 포인터일 뿐이고 실제 데이터는 External 영역인 Native Heap 영역에 저장되기 때문이다. Java 비트맵 객체는 참조가 없을 때 GC에 의해 회수되지만 Native Heap 영역은 GC 수행영역 밖이기 때문에 메모리 소멸 시점이 다르다. \n\n이러한 문제점 때문에, Honeycomb 이후 버전에서는 External 영역이 없어지면서 Dalvik heap 영역에 비트맵 메모리를 올릴 수 있게 되었고 GC도 접근할 수 있게 되었다.\n\n다시 돌아와, 만약 고해상도 이미지를 로드할 때 OOM이 발생하는 경우 BitmapFactory 객체를 이용해 다운샘플링, 디코딩 방식을 선택해 적절하게 뷰에 로드하면 된다. 하지만 많은 이미지를 사용하게 되면서 OOM이 발생한다면, `이미지 캐싱`을 이용해보는 것이 어떨까?\n\n### Bitmap Caching\n\n이미지가 화면에서 사라지고 다시 구성할 때 이미지를 매번 로드하는 것은 성능상으로나 사용자 경험에 좋지 않다. 이럴 때 메모리와 디스크 캐시를 이용하여 어디에선가 저장되어있던 비트맵을 다시 가져온다면 다시 로드하는 시간도 단축시킬 수 있으며 성능 개선도 가능할 것이다. 이 때 캐싱을 위해 `Memory Cache`와 `Disk Cache` 사용을 추천하는데 두가지가 어떤 차이점이 있는지 알아보자.\n\n#### 1. Memory Cache\nMemory Cache는 어플리케이션 내에 존재하는 메모리에 비트맵을 캐싱하고, 필요할 때 빠르게 접근가능하다. 하지만 Memory Cache도 곧 어플리케이션 용량을 키우는 주범이 될 수 있기 때문에 많은 캐싱을 요구하는 비트맵의 경우에는 Disk Cache에 넣는 것이 더 좋을 수 있다.\n\n\n#### 2. Disk Cache\nMemory Cache에 넣기엔 많은 캐시를 요구하는 경우, 혹은 앱이 백그라운드로 전환되어도 적재한 캐시가 삭제되지 않기를 바란다면 Disk Cache를 이용하는 것이 좋다. 하지만 Disk로부터 캐싱된 비트맵을 가져올 때는 Memory에서 로드하는 것보다 오랜시간이 걸린다.\n\n\n### BitmapPool\nMemory Cache의 예시를 위해 소개할 것은 `BitmapPool`이다. `BitmapPool`의 원리는 사용하지 않는 Bitmap을 리스트에 넣어놓고, 추후에 동일한 이미지를 로드할 때 다시 메모리에 적재하지 않고 pool에 있는 이미지를 가져와 재사용하는 것이다. \n\n보통 BitmapPool을 이용해 재사용 Pool을 만들게 될 때, LRU 캐싱 알고리즘으로 구현된 LinkedList `(lruBItmapList)`와 Byte Size 순으로 정렬된 LinkedList`(bitmapList)`를 사용하여 구현하게 된다. 이 둘은 들어있는 비트맵의 순서만 다를 뿐, 같은 비트맵이 담기게된다.\n\n``` kotlin\nprivate val lruBitmapList = LinkedList<Bitmap>()\nprivate val bitmapList = LinkedList<Bitmap>()\n```\n\nLRU 알고리즘을 이용해 오랫동안 참조되지않은 비트맵 객체는 맨 뒤로 밀리게되고, `맨 뒤에있는 객체를 회수`하면서 BitmapPool을 유지시키는 것이다. LRU 알고리즘을 이용하지 않는다면 처음 BitmapPool이 가득 찰 때까지는 문제없이 동작하지만, 비트맵을 재사용하는 시점부터는 특정 비트맵만 재사용될 수 있으며, 앱이 끝날 때까지 메모리가 줄어들지 않게된다. 자세한 내용은 [이 블로그](https://jamssoft.tistory.com/195)를 참고하길 바란다.\n\n\n\n대표적인 이미지 로더 라이브러리인 `Glide`에서 구현한 LruBitmapPool Class 내부를 보며, LruBitmapList와 bitmapList가 어떻게 쓰이고있는지 살펴보자. \n\n``` java\npublic class LruBitmapPool implements BitmapPool {\n    private static final String TAG = \"LruBitmapPool\";\n    private static final Bitmap.Config DEFAULT_CONFIG = Bitmap.Config.ARGB_8888;\n\n    private final LruPoolStrategy strategy;\n    private final Set<Bitmap.Config> allowedConfigs;\n    private final BitmapTracker tracker;\n\n    // Pool에 들어올수 있는 최대 크기\n    private long maxSize;\n    // 현재 pool에 들어간 bitmap byte 크기\n    private long currentSize;\n\n  // ...\n```\n\nGlide내 LruBitmapPool Class 에서는 strategy(LruPoolStrategy)가 곧 LRU 기반으로 구현된 리스트이며, tracker(BitmapTracker)가 Bitmap size 순으로 정렬된 리스트이다.\n\n``` java\n@Override\npublic synchronized void put(Bitmap bitmap) {\n    if (bitmap == null) {\n        throw new NullPointerException(\"Bitmap must not be null\");\n    }\n    // isRecycled: 재활용된 bitmap인지 여부\n    if (bitmap.isRecycled()) {\n        throw new IllegalStateException(\"Cannot pool recycled bitmap\");\n    }\n    // isMutable: canvas를 얻을 수 있는 bitmap 인지 여부.\n    if (!bitmap.isMutable()\n        || strategy.getSize(bitmap) > maxSize\n        || !allowedConfigs.contains(bitmap.getConfig())) {\n        \n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(\n                TAG,\n                \"Reject bitmap from pool\"\n                + \", bitmap: \"\n                + strategy.logBitmap(bitmap)\n                + \", is mutable: \"\n                + bitmap.isMutable()\n                + \", is allowed config: \"\n                + allowedConfigs.contains(bitmap.getConfig()));\n        }\n        bitmap.recycle();\n        return;\n    }\n    // pool에 넣으려는 bitmap의 사이즈를 얻어온다.\n    final int size = strategy.getSize(bitmap);\n    strategy.put(bitmap);\n    tracker.add(bitmap);\n\n    puts++;\n    currentSize += size;\n\n    if (Log.isLoggable(TAG, Log.VERBOSE)) {\n        Log.v(TAG, \"Put bitmap in pool=\" + strategy.logBitmap(bitmap));\n    }\n    dump();\n\n    evict();\n}\n```\n\nBitmap을 Pool에 넣을 수 있는 조건을 충족시킨다면, strategy & tracker에 bitmap이 들어가게된다. \n\n> **참고** Lru 기반인 strategy 는 최근에 들어온 bitmap일수록 리스트의 맨 앞으로 배치시켜야하는데, 그 로직이 `LruPoolStrategy` 구현체 내부에 존재하게 된다.\n\n```java\n// Pool의 최대 사용량을 넘기면 크기를 줄여준다.\nprivate synchronized void trimToSize(long size) {\n    while (currentSize > size) {\n        //LRU List에서 삭제한다.\n        final Bitmap removed = strategy.removeLast();\n        if (removed == null) {\n            if (Log.isLoggable(TAG, Log.WARN)) {\n                Log.w(TAG, \"Size mismatch, resetting\");\n                dumpUnchecked();\n            }\n            currentSize = 0;\n            return;\n        }\n        // BitmapList에서 삭제한다. \n        tracker.remove(removed);\n        currentSize -= strategy.getSize(removed);\n        evictions++;\n        if (Log.isLoggable(TAG, Log.DEBUG)) {\n            Log.d(TAG, \"Evicting bitmap=\" + strategy.logBitmap(removed));\n        }\n        dump();\n        removed.recycle();\n    }\n}\n```\n\ntrimToSize()를 이용하면 pool이 최대사용량을 넘어선 경우 참조를 가장 적게하고 있는 lastIndex 부터 객체를 지워가며 크기를 줄여줄 수 있다. \n\n```java\n@Override\n@Nullable\npublic Bitmap get(int width, int height, Bitmap.Config config) {\n    final int size = Util.getBitmapByteSize(width, height, config);\n    Key key = keyPool.get(size);\n\n    Integer possibleSize = sortedSizes.ceilingKey(size);\n    if (possibleSize != null && possibleSize != size && possibleSize <= size * MAX_SIZE_MULTIPLE) {\n        keyPool.offer(key);\n        key = keyPool.get(possibleSize);\n    }\n\n    final Bitmap result = groupedMap.get(key);\n    // 비트맵을 찾은 경우, pool에서 제거한다.\n    if (result != null) {\n        result.reconfigure(width, height, config);\n        decrementBitmapOfSize(possibleSize);\n    }\n    return result;\n}\n```\n\n이미지를 로드하기 위해 pool에서 필요한 비트맵을 가져온다.\n\n## Jetpack Compose에서 이미지 라이브러리 사용하기\n\nGoogle 에서는 Jetpack Compose를 보다 편하게 사용하기 위한 라이브러리를 묶어서 제공한다.\n\n**Accompanist** 라고 하는 GroupId를 가진 라이브러리 모음이다.\n\n> **참고** [Google#Accompanist Repository](https://github.com/google/accompanist)\n\nAccompanist에서는 Glide와 Coil을 지원하고 있다.\n\n의존성 설정은 아래와 같다.\n\n```gradle\ndependencies {\n    ...\n    implementation \"com.google.accompanist:accompanist-glide:0.11.1\"\n    implementation \"com.google.accompanist:accompanist-coil:0.11.1\"\n    ...\n}\n```\n\nGlide는 아래와 같이 적용한다.\n\n```kotlin\nImage(\n    painter = rememberGlidePainter(\n        request = \"https://picsum.photos/300/300\",\n        // placeHolder\n    ),\n    contentDescription = stringResource(R.string.image_content_desc)\n)\nImage(\n    painter = rememberGlidePainter(\n        request = \"https://cataas.com/cat/gif\",\n        // placeHolder\n    ),\n    contentDescription = null\n)\n```\n\nCoil은 아래와 같이 적용한다.\n\n```kotlin\nImage(\n    painter = rememberCoilPainter(\n        request = \"https://picsum.photos/300/300\",\n        // placeHolder\n    ),\n    contentDescription = null\n)\n```\n\nCoil에서 gif를 렌더링하기 위해선 `coil-gif` 의존성을 추가한다.\n\n```gradle\ndependencies {\n    ...\n    implementation \"com.google.accompanist:accompanist-glide:0.11.1\"\n    implementation \"com.google.accompanist:accompanist-coil:0.11.1\"\n    // Coil 에서 gif 를 사용하기 위해서 추가\n    implementation \"io.coil-kt:coil-gif:1.2.2\"\n    ...\n}\n```\n\n아래와 같이 별도의 ImageLoader를 설정한다.\n\n```kotlin\nfun gifImageLoader(context: Context) = ImageLoader.Builder(context)\n    .componentRegistry {\n    if (SDK_INT >= 28) {\n        add(ImageDecoderDecoder(context))\n    } else {\n        add(GifDecoder())\n        }\n    }\n    .build()\n```\n\nImage의 적용은 아래와 같이 적용한다.\n\n```kotlin\nImage(\n    painter = rememberCoilPainter(\n        request = \"https://cataas.com/cat/gif\",\n        imageLoader = gifImageLoader(LocalContext*.current),\n    ),\n    contentDescription = null\n)\n```","slug":"2021-06-24 Image Loading and Caching Library Part 2","published":1,"updated":"2021-07-25T13:29:10.314Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cksagj7lt001s3lre6183g4z6","content":"<article class=\"message message-immersive is-primary\">\n    <div class=\"message-body\">\n        <i class=\"fas fa-pen-fancy mr-2\"></i>Writers<br>\n        by 곽욱현 @Knowre<br>\n        by 김남훈 @Naver<br>\n        by 배희성 @RocketPunch<br>\n        by 송시영 @SmartStudy<br>\n        by 옥수환 @Naver<br>\n        by 이기정 @BankSalad<br>\n        by 정세희 @BankSalad\n    </div>\n</article>\n\n<span id=\"more\"></span>\n<h2 id=\"Image-Library의-동작-방식\"><a href=\"#Image-Library의-동작-방식\" class=\"headerlink\" title=\"Image Library의 동작 방식\"></a>Image Library의 동작 방식</h2><p>Android 에서 가장 많이 쓰이는 <code>Glide</code>를 기준으로 이미지 라이브러리의 동작 방식을 살펴보자.</p>\n<p>먼저 Part 1에서 다루었던 기본 예제를 수정하도록 하자.</p>\n<h3 id=\"Glide-의존성-설정\"><a href=\"#Glide-의존성-설정\" class=\"headerlink\" title=\"Glide 의존성 설정\"></a>Glide 의존성 설정</h3><figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">dependencies</span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    implementation <span class=\"string\">&#x27;com.github.bumptech.glide:glide:4.12.0&#x27;</span></span><br><span class=\"line\">    annotationProcessor <span class=\"string\">&#x27;com.github.bumptech.glide:compiler:4.12.0&#x27;</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"인터넷-사용-권한-부여\"><a href=\"#인터넷-사용-권한-부여\" class=\"headerlink\" title=\"인터넷 사용 권한 부여\"></a>인터넷 사용 권한 부여</h3><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">manifest</span> </span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">xmlns:android</span>=<span class=\"string\">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">package</span>=<span class=\"string\">&quot;android.deepdive.raw&quot;</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">uses-permission</span> <span class=\"attr\">android:name</span>=<span class=\"string\">&quot;android.permission.INTERNET&quot;</span>/&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- ... --&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"레이아웃-파일에서-이미지-소스-제거\"><a href=\"#레이아웃-파일에서-이미지-소스-제거\" class=\"headerlink\" title=\"레이아웃 파일에서 이미지 소스 제거\"></a>레이아웃 파일에서 이미지 소스 제거</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;ImageView</span><br><span class=\"line\">    <span class=\"attr\">android</span>:id=<span class=\"string\">&quot;@+id/imageView&quot;</span></span><br><span class=\"line\">    <span class=\"attr\">android</span>:layout_width=<span class=\"string\">&quot;wrap_content&quot;</span></span><br><span class=\"line\">    <span class=\"attr\">android</span>:layout_height=<span class=\"string\">&quot;wrap_content&quot;</span></span><br><span class=\"line\">    <span class=\"attr\">app</span>:layout_constraintBottom_toBottomOf=<span class=\"string\">&quot;parent&quot;</span></span><br><span class=\"line\">    <span class=\"attr\">app</span>:layout_constraintLeft_toLeftOf=<span class=\"string\">&quot;parent&quot;</span></span><br><span class=\"line\">    <span class=\"attr\">app</span>:layout_constraintRight_toRightOf=<span class=\"string\">&quot;parent&quot;</span></span><br><span class=\"line\">    <span class=\"attr\">app</span>:layout_constraintTop_toTopOf=<span class=\"string\">&quot;parent&quot;</span>/&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"코드에-Glide-예제-적용\"><a href=\"#코드에-Glide-예제-적용\" class=\"headerlink\" title=\"코드에 Glide 예제 적용\"></a>코드에 Glide 예제 적용</h3><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MainActivity</span> : <span class=\"type\">AppCompatActivity</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onCreate</span><span class=\"params\">(savedInstanceState: <span class=\"type\">Bundle</span>?)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onCreate(savedInstanceState)</span><br><span class=\"line\">        setContentView(R.layout.activity_main)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">var</span> imageView: ImageView = findViewById(R.id.imageView)</span><br><span class=\"line\"></span><br><span class=\"line\">        Glide</span><br><span class=\"line\">            .with(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">            .load(<span class=\"string\">&quot;https://goo.gl/gEgYUd&quot;</span>)</span><br><span class=\"line\">            .into(imageView)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>위와 같이 작업을 하고 나면 아래와 같은 화면을 렌더링할 수 있다.</p>\n<img src=\"/Team-Blog/2021/06/24/2021-06-24%20Image%20Loading%20and%20Caching%20Library%20Part%202/Screenshot_1624078627.png\" class=\"\" width=\"350\" title=\"[Screenshot_1624078627]\">\n\n<h2 id=\"기능-톺아보기\"><a href=\"#기능-톺아보기\" class=\"headerlink\" title=\"기능 톺아보기\"></a>기능 톺아보기</h2><h3 id=\"이미지-렌더링-방식\"><a href=\"#이미지-렌더링-방식\" class=\"headerlink\" title=\"이미지 렌더링 방식\"></a>이미지 렌더링 방식</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Glide</span><br><span class=\"line\">    .with(this)</span><br><span class=\"line\">    .load(&quot;https://goo.gl/gEgYUd&quot;)</span><br><span class=\"line\">    .into(imageView)</span><br></pre></td></tr></table></figure>\n\n<p>개발자 입장에서는 매우 간단하게 이미지를 렌더링할 수 있게 해준다.</p>\n<p>Glide 문서에서 최소로 요구되고 있는 <code>with()</code>와 <code>load()</code>, <code>into()</code>의 내부 구조를 한 번 살펴보자.</p>\n<h4 id=\"1-with-메서드\"><a href=\"#1-with-메서드\" class=\"headerlink\" title=\"1. with 메서드\"></a>1. with 메서드</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@NonNull</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> RequestManager <span class=\"title\">with</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> FragmentActivity activity)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> getRetriever(activity).get(activity);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@NonNull</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> RequestManagerRetriever <span class=\"title\">getRetriever</span><span class=\"params\">(<span class=\"meta\">@Nullable</span> Context context)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Context could be null for other reasons (ie the user passes in null), but in practice it will</span></span><br><span class=\"line\">    <span class=\"comment\">// only occur due to errors with the Fragment lifecycle.</span></span><br><span class=\"line\">    Preconditions.checkNotNull(</span><br><span class=\"line\">        context,</span><br><span class=\"line\">        <span class=\"string\">&quot;You cannot start a load on a not yet attached View or a Fragment where getActivity() &quot;</span></span><br><span class=\"line\">            + <span class=\"string\">&quot;returns null (which usually occurs when getActivity() is called before the Fragment &quot;</span></span><br><span class=\"line\">            + <span class=\"string\">&quot;is attached or after the Fragment is destroyed).&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Glide.get(context).getRequestManagerRetriever();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>with()</code>메서드를 호출하면 <code>getRetriever()</code> 메서드를 통해 <code>RequestManagerRetriever</code> 객체를 획득한다.</p>\n<p>이후 <code>get()</code> 메서드를 이용해 <code>RequestManager</code> 객체를 생성하는 코드도 연달아 호출하게 된다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@NonNull</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> RequestManager <span class=\"title\">get</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Context context)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (context == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">&quot;You cannot start a load on a null Context&quot;</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (Util.isOnMainThread() &amp;&amp; !(context <span class=\"keyword\">instanceof</span> Application)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (context <span class=\"keyword\">instanceof</span> FragmentActivity) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> get((FragmentActivity) context);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (context <span class=\"keyword\">instanceof</span> Activity) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> get((Activity) context);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (context <span class=\"keyword\">instanceof</span> ContextWrapper</span><br><span class=\"line\">            <span class=\"comment\">// Only unwrap a ContextWrapper if the baseContext has a non-null application context.</span></span><br><span class=\"line\">            <span class=\"comment\">// Context#createPackageContext may return a Context without an Application instance,</span></span><br><span class=\"line\">            <span class=\"comment\">// in which case a ContextWrapper may be used to attach one.</span></span><br><span class=\"line\">            &amp;&amp; ((ContextWrapper) context).getBaseContext().getApplicationContext() != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> get(((ContextWrapper) context).getBaseContext());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> getApplicationManager(context);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Context의 instance type에 대한 처리후 제일 마지막에 <code>getApplicationManager()</code>를 호출한다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@NonNull</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> RequestManager <span class=\"title\">getApplicationManager</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Context context)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Either an application context or we&#x27;re on a background thread.</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (applicationManager == <span class=\"keyword\">null</span>) &#123;  </span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (applicationManager == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// Normally pause/resume is taken care of by the fragment we add to the fragment or</span></span><br><span class=\"line\">            <span class=\"comment\">// activity. However, in this case since the manager attached to the application will not</span></span><br><span class=\"line\">            <span class=\"comment\">// receive lifecycle events, we must force the manager to start resumed using</span></span><br><span class=\"line\">            <span class=\"comment\">// ApplicationLifecycle.</span></span><br><span class=\"line\"></span><br><span class=\"line\">          <span class=\"comment\">// T  ODO(b/27524013): Factor out this Glide.get() call.</span></span><br><span class=\"line\">            Glide glide = Glide.get(context.getApplicationContext());</span><br><span class=\"line\">            applicationManager =</span><br><span class=\"line\">                factory.build(</span><br><span class=\"line\">                    glide,</span><br><span class=\"line\">                    <span class=\"keyword\">new</span> ApplicationLifecycle(),</span><br><span class=\"line\">                    <span class=\"keyword\">new</span> EmptyRequestManagerTreeNode(),</span><br><span class=\"line\">                    context.getApplicationContext());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> applicationManager;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>with()</code> 메서드는 Global Scope에서 애플리케이션의 생명주기와 연동하여 Glide의 싱글턴 객체를 획득하는 것이 목적이라고 볼 수 있다.</p>\n<h4 id=\"2-load-메서드\"><a href=\"#2-load-메서드\" class=\"headerlink\" title=\"2. load 메서드\"></a>2. load 메서드</h4><p>두 번째로 <code>load()</code> 메서드를 살펴보자.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@NonNull</span></span><br><span class=\"line\"><span class=\"meta\">@CheckResult</span></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> RequestBuilder&lt;Drawable&gt; <span class=\"title\">load</span><span class=\"params\">(<span class=\"meta\">@Nullable</span> String string)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> asDrawable().load(string);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>단순힌 <code>asDrawable()</code>을 호출해 <code>RequestBuilder</code> 객체를 만들고, <code>load()</code>를 호출한다고만 명세되어있다.</p>\n<p><code>asDrawable()</code> 구현체를 살펴보자.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@NonNull</span></span><br><span class=\"line\"><span class=\"meta\">@CheckResult</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> RequestBuilder&lt;Drawable&gt; <span class=\"title\">asDrawable</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> as(Drawable.class);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>android.graphics.drawable.Drawable</code> 타입을 <code>as()</code>에 파라미터로 넘겨주고 있다.</p>\n<p><code>as()</code> 구현체를 살펴보자.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@NonNull</span></span><br><span class=\"line\"><span class=\"meta\">@CheckResult</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;ResourceType&gt; <span class=\"function\">RequestBuilder&lt;ResourceType&gt; <span class=\"title\">as</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Class&lt;ResourceType&gt; resourceClass)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> RequestBuilder&lt;&gt;(glide, <span class=\"keyword\">this</span>, resourceClass, context);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>파라미터로 주어진 객체 타입(여기서는 <code>android.graphics.drawable.Drawable</code>)으로 디코딩하여 반환한다.</p>\n<p>여기서 쓰이는 디코더는 <code>com.bumptech.glide.load.ResourceDecoders</code>이다.</p>\n<p><code>Drawable.class</code>로 고정되어있지 않은 이유는 리소스 클래스의 서브클래스들도 호환하기 위해서이다.</p>\n<p><code>Glide.load()</code>에서 호출하는 <code>asDrawable()</code>이 디코딩할 리소스 클래스를 생성하였다면 바로 뒤에 붙은 <code>RequestBuilder.load()</code> 메서드에서 데이터를 불러올 것임을 추측할 수 있다.</p>\n<p><code>RequestBuilder.load()</code> 메서드의 호출 구조를 살펴보자.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@NonNull</span></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"meta\">@CheckResult</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> RequestBuilder&lt;TranscodeType&gt; <span class=\"title\">load</span><span class=\"params\">(<span class=\"meta\">@Nullable</span> String string)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> loadGeneric(string);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>load()</code>의 파라미터로 주어진 <code>string</code>값을 key로 사용해 데이터를 캐시하는 영역이다.</p>\n<p>동일 이미지의 반복적인 렌더링 작업에 대해 처리한 부분임을 알 수 있다.</p>\n<p>이후 <code>loadGeneric()</code>을 호출한다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@NonNull</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> RequestBuilder&lt;TranscodeType&gt; <span class=\"title\">loadGeneric</span><span class=\"params\">(<span class=\"meta\">@Nullable</span> Object model)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isAutoCloneEnabled()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> clone().loadGeneric(model);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.model = model;</span><br><span class=\"line\">    isModelSet = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> selfOrThrowIfLocked();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>파라미터의 타입이 <code>String</code>에서 <code>Object</code>로 변경되었다.</p>\n<p>이 <code>model</code>은 <code>com.bumptech.glide.load.model.UriLoader</code> 객체에서 핸들링하게 된다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@NonNull</span></span><br><span class=\"line\"><span class=\"meta\">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> T <span class=\"title\">selfOrThrowIfLocked</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isLocked) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">&quot;You cannot modify locked T, consider clone()&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> self();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> T <span class=\"title\">self</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (T) <span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>이후 <code>RequestBuilder.load()</code>는 최종적으로 <code>RequestBuilder</code> 객체를 반환해주게 된다.</p>\n<h4 id=\"3-into-메서드\"><a href=\"#3-into-메서드\" class=\"headerlink\" title=\"3. into 메서드\"></a>3. into 메서드</h4><p>현재까지 <code>with()</code>에서 <code>RequestManager</code>객체를 생성한 뒤, 이 객체의 <code>load()</code> 메서드를 호출하여 <code>RequestBuilder</code> 객체를 획득하는 과정까지 진행되었다.</p>\n<p>이제 <code>RequestBuilder</code>에서 <code>into()</code> 메서드를 호출해 <code>ImageView</code>에 리소스를 할당하는 마지막 작업이다.</p>\n<p>리소스를 할당할 ImageView를 파라미터로 요구한다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@NonNull</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> ViewTarget&lt;ImageView, TranscodeType&gt; <span class=\"title\">into</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> ImageView view)</span> </span>&#123;</span><br><span class=\"line\">    Util.assertMainThread();</span><br><span class=\"line\">    Preconditions.checkNotNull(view);</span><br><span class=\"line\"></span><br><span class=\"line\">    BaseRequestOptions&lt;?&gt; requestOptions = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!requestOptions.isTransformationSet()</span><br><span class=\"line\">        &amp;&amp; requestOptions.isTransformationAllowed()</span><br><span class=\"line\">        &amp;&amp; view.getScaleType() != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Clone in this method so that if we use this RequestBuilder to load into a View and then</span></span><br><span class=\"line\">        <span class=\"comment\">// into a different target, we don&#x27;t retain the transformation applied based on the previous</span></span><br><span class=\"line\">        <span class=\"comment\">// View&#x27;s scale type.</span></span><br><span class=\"line\">        <span class=\"keyword\">switch</span> (view.getScaleType()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> CENTER_CROP:</span><br><span class=\"line\">            requestOptions = requestOptions.clone().optionalCenterCrop();</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> CENTER_INSIDE:</span><br><span class=\"line\">            requestOptions = requestOptions.clone().optionalCenterInside();</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> FIT_CENTER:</span><br><span class=\"line\">        <span class=\"keyword\">case</span> FIT_START:</span><br><span class=\"line\">        <span class=\"keyword\">case</span> FIT_END:</span><br><span class=\"line\">            requestOptions = requestOptions.clone().optionalFitCenter();</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> FIT_XY:</span><br><span class=\"line\">            requestOptions = requestOptions.clone().optionalCenterInside();</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> CENTER:</span><br><span class=\"line\">        <span class=\"keyword\">case</span> MATRIX:</span><br><span class=\"line\">        <span class=\"keyword\">default</span>:</span><br><span class=\"line\">            <span class=\"comment\">// Do nothing.</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> into(</span><br><span class=\"line\">        glideContext.buildImageViewTarget(view, transcodeClass),</span><br><span class=\"line\">        <span class=\"comment\">/*targetListener=*/</span> <span class=\"keyword\">null</span>,</span><br><span class=\"line\">        requestOptions,</span><br><span class=\"line\">        Executors.mainThreadExecutor());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>Util.assertMainThread()</code>에서 메인 쓰레드 여부를 검증한 뒤, <code>Preconditions.checkNotNull(view)</code>에서 파라미터로 주어진 ImageView에 대한 null check를 수행한다.</p>\n<p>이후 ImageView의 scaleType에 대한 처리 후, <code>into(target, targetListener, options, callbackExecutor)</code>를 호출한다.</p>\n<p>이때 <code>target</code> 자리에 <code>GlideContext.buildImageViewTarget()</code>이라는 메서드를 주입하는데, 파라미터로 주어진 ImageView를 이용해 <code>BitmapImageViewTarget</code>이나 <code>DrawableImageViewTarget</code>으로 변환하는 작업을 수행한다.</p>\n<p><code>GlideContext.buildImageViewTarget()</code>의 두 번째 파라미터인 <code>transcodeClass</code>의 값은 <code>Glide.load()</code>를 호출하였을 때 수행하는 <code>as()</code> 메소드의 파라미터인 <code>Drawable.class</code>로 이미 주입되어있다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> &lt;Y extends Target&lt;TranscodeType&gt;&gt; <span class=\"function\">Y <span class=\"title\">into</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    <span class=\"meta\">@NonNull</span> Y target,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    <span class=\"meta\">@Nullable</span> RequestListener&lt;TranscodeType&gt; targetListener,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    BaseRequestOptions&lt;?&gt; options,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    Executor callbackExecutor)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    Preconditions.checkNotNull(target);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isModelSet) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">&quot;You must call #load() before calling #into()&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    Request request = buildRequest(target, targetListener, options, callbackExecutor);</span><br><span class=\"line\">    Request previous = target.getRequest();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (request.isEquivalentTo(previous) &amp;&amp; !isSkipMemoryCacheWithCompletePreviousRequest(options, previous)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// If the request is completed, beginning again will ensure the result is re-delivered,</span></span><br><span class=\"line\">        <span class=\"comment\">// triggering RequestListeners and Targets. If the request is failed, beginning again will</span></span><br><span class=\"line\">        <span class=\"comment\">// restart the request, giving it another chance to complete. If the request is already</span></span><br><span class=\"line\">        <span class=\"comment\">// running, we can let it continue running without interruption.</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!Preconditions.checkNotNull(previous).isRunning()) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// Use the previous request rather than the new one to allow for optimizations like skipping</span></span><br><span class=\"line\">            <span class=\"comment\">// setting placeholders, tracking and un-tracking Targets, and obtaining View dimensions</span></span><br><span class=\"line\">            <span class=\"comment\">// that are done in the individual Request.</span></span><br><span class=\"line\">            previous.begin();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> target;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    requestManager.clear(target);</span><br><span class=\"line\">    target.setRequest(request);</span><br><span class=\"line\">    requestManager.track(target, request);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> target;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>target</code>으로 주어진 ImageView에 리소스를 세팅하는 곳인데, 특기할만한 부분은 <code>requestManager.clear(target)</code>이다.</p>\n<p>해당 메서드를 호출하면 현재 target으로 설정된 뷰에 대한 모든 로딩을 취소하고 모든 리소스를 해제한다.</p>\n<h2 id=\"Memory-amp-Footprint\"><a href=\"#Memory-amp-Footprint\" class=\"headerlink\" title=\"Memory &amp; Footprint\"></a>Memory &amp; Footprint</h2><p>Bitmap를 다루다보면 필연적으로 OOM 관련하여 메모리 이슈를 피할 수 없다.</p>\n<p>Image Library를 사용하지 않은 상태에서 많은 이미지를 사용하거나 고해상도 이미지를 이미지뷰에 로드해야하는 경우 메모리 부족으로 OOM이 발생하게 된다.</p>\n<p>요즘 나오는 스마트폰은 굉장히 많은 메모리를 가지고 태어나는데 <strong>왜 이정도도 못 버티지(?)</strong> 라는 생각을 한다면, 안드로이드는 앱 내에서 사용할 수 있는 힙 메모리가 정해져있기 때문이다.</p>\n<img src=\"/Team-Blog/2021/06/24/2021-06-24%20Image%20Loading%20and%20Caching%20Library%20Part%202/IMG_06A0242D2ABE-1.jpg\" class=\"\" title=\"[IMG_06A0242D2ABE-1]\">\n\n<p>Android의 메모리 모델은 운영체제 버전에 따라 두가지로 나뉘게 된다. </p>\n<ul>\n<li>Dalvik heap 영역 : java 객체를 저장하는 메모리</li>\n<li>External 영역 : native heap의 일종으로 네이티브의 비트맵 객체를 저장하는 메모리<br>Dalvik heap 영역와 External 영역의 <code>Dalvik heap footprint + External Limit</code>을 합쳐 프로세스당 메모리 한계를 초과하면 OOM이 발생하게 된다.</li>\n</ul>\n<h3 id=\"Footprint\"><a href=\"#Footprint\" class=\"headerlink\" title=\"Footprint\"></a>Footprint</h3><p>java의 footprint는 한 번 증가하면 크기가 다시 감소되지 않기 때문에, footprint가 과도하게 커지지 않게끔 잘 관리해야한다. </p>\n<img src=\"/Team-Blog/2021/06/24/2021-06-24%20Image%20Loading%20and%20Caching%20Library%20Part%202/image.png\" class=\"\" title=\"[image]\">\n\n<p>Dalvik VM은 처음에 동작에 필요한 만큼만 프로세스에 Heap을 할당하게 되고, 프로세스에 할당된 메모리보다 많은 메모리를 필요하게될 때마다 Dalvit Footfrint도 증가하게된다. 하지만 증가된 Footfrint는 결코 감소하지 않기 때문에 java 객체가 사용가능한 메모리 공간의 여유가 있어도, External heap의 크기가 증가되면 OOM이 발생할 수 있다. 하지만 이런 문제도 Honeycomb 이후부터는 Dalvik heap 과 External 영역이 합쳐졌기 때문에, 고려할 필요가 없어졌다. </p>\n<p>External 영역을 사용하는 Honeycomb 미만 버전에서는 이미지를 많이 사용하고있는 화면에서 화면을 전환하는 행동이 발생했을 때도 OOM이 발생하면서 앱이 중지될 것이다. 화면을 전환하면 이전 액티비티 인스턴스에 있던 이미지뷰나 할당되었던 비트맵이 함께 소멸되어 메모리가 회수되고 새로운 액티비티 인스턴스를 생성할텐데, 이 과정에서 이전 액티비티 인스턴스의 비트맵 객체가 회수되지 않아 메모리 누수가 발생했기 때문이다. </p>\n<p>비트맵 객체에 대한 참조가 없는데도 왜 회수가 될 수 없을까? Honeycomb 미만 버전에서는 Java 비트맵 객체는 실제 비트맵 데이터를 가지고 있는 곳을 가리키는 포인터일 뿐이고 실제 데이터는 External 영역인 Native Heap 영역에 저장되기 때문이다. Java 비트맵 객체는 참조가 없을 때 GC에 의해 회수되지만 Native Heap 영역은 GC 수행영역 밖이기 때문에 메모리 소멸 시점이 다르다. </p>\n<p>이러한 문제점 때문에, Honeycomb 이후 버전에서는 External 영역이 없어지면서 Dalvik heap 영역에 비트맵 메모리를 올릴 수 있게 되었고 GC도 접근할 수 있게 되었다.</p>\n<p>다시 돌아와, 만약 고해상도 이미지를 로드할 때 OOM이 발생하는 경우 BitmapFactory 객체를 이용해 다운샘플링, 디코딩 방식을 선택해 적절하게 뷰에 로드하면 된다. 하지만 많은 이미지를 사용하게 되면서 OOM이 발생한다면, <code>이미지 캐싱</code>을 이용해보는 것이 어떨까?</p>\n<h3 id=\"Bitmap-Caching\"><a href=\"#Bitmap-Caching\" class=\"headerlink\" title=\"Bitmap Caching\"></a>Bitmap Caching</h3><p>이미지가 화면에서 사라지고 다시 구성할 때 이미지를 매번 로드하는 것은 성능상으로나 사용자 경험에 좋지 않다. 이럴 때 메모리와 디스크 캐시를 이용하여 어디에선가 저장되어있던 비트맵을 다시 가져온다면 다시 로드하는 시간도 단축시킬 수 있으며 성능 개선도 가능할 것이다. 이 때 캐싱을 위해 <code>Memory Cache</code>와 <code>Disk Cache</code> 사용을 추천하는데 두가지가 어떤 차이점이 있는지 알아보자.</p>\n<h4 id=\"1-Memory-Cache\"><a href=\"#1-Memory-Cache\" class=\"headerlink\" title=\"1. Memory Cache\"></a>1. Memory Cache</h4><p>Memory Cache는 어플리케이션 내에 존재하는 메모리에 비트맵을 캐싱하고, 필요할 때 빠르게 접근가능하다. 하지만 Memory Cache도 곧 어플리케이션 용량을 키우는 주범이 될 수 있기 때문에 많은 캐싱을 요구하는 비트맵의 경우에는 Disk Cache에 넣는 것이 더 좋을 수 있다.</p>\n<h4 id=\"2-Disk-Cache\"><a href=\"#2-Disk-Cache\" class=\"headerlink\" title=\"2. Disk Cache\"></a>2. Disk Cache</h4><p>Memory Cache에 넣기엔 많은 캐시를 요구하는 경우, 혹은 앱이 백그라운드로 전환되어도 적재한 캐시가 삭제되지 않기를 바란다면 Disk Cache를 이용하는 것이 좋다. 하지만 Disk로부터 캐싱된 비트맵을 가져올 때는 Memory에서 로드하는 것보다 오랜시간이 걸린다.</p>\n<h3 id=\"BitmapPool\"><a href=\"#BitmapPool\" class=\"headerlink\" title=\"BitmapPool\"></a>BitmapPool</h3><p>Memory Cache의 예시를 위해 소개할 것은 <code>BitmapPool</code>이다. <code>BitmapPool</code>의 원리는 사용하지 않는 Bitmap을 리스트에 넣어놓고, 추후에 동일한 이미지를 로드할 때 다시 메모리에 적재하지 않고 pool에 있는 이미지를 가져와 재사용하는 것이다. </p>\n<p>보통 BitmapPool을 이용해 재사용 Pool을 만들게 될 때, LRU 캐싱 알고리즘으로 구현된 LinkedList <code>(lruBItmapList)</code>와 Byte Size 순으로 정렬된 LinkedList<code>(bitmapList)</code>를 사용하여 구현하게 된다. 이 둘은 들어있는 비트맵의 순서만 다를 뿐, 같은 비트맵이 담기게된다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">val</span> lruBitmapList = LinkedList&lt;Bitmap&gt;()</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">val</span> bitmapList = LinkedList&lt;Bitmap&gt;()</span><br></pre></td></tr></table></figure>\n\n<p>LRU 알고리즘을 이용해 오랫동안 참조되지않은 비트맵 객체는 맨 뒤로 밀리게되고, <code>맨 뒤에있는 객체를 회수</code>하면서 BitmapPool을 유지시키는 것이다. LRU 알고리즘을 이용하지 않는다면 처음 BitmapPool이 가득 찰 때까지는 문제없이 동작하지만, 비트맵을 재사용하는 시점부터는 특정 비트맵만 재사용될 수 있으며, 앱이 끝날 때까지 메모리가 줄어들지 않게된다. 자세한 내용은 <a href=\"https://jamssoft.tistory.com/195\">이 블로그</a>를 참고하길 바란다.</p>\n<p>대표적인 이미지 로더 라이브러리인 <code>Glide</code>에서 구현한 LruBitmapPool Class 내부를 보며, LruBitmapList와 bitmapList가 어떻게 쓰이고있는지 살펴보자. </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LruBitmapPool</span> <span class=\"keyword\">implements</span> <span class=\"title\">BitmapPool</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String TAG = <span class=\"string\">&quot;LruBitmapPool&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Bitmap.Config DEFAULT_CONFIG = Bitmap.Config.ARGB_8888;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> LruPoolStrategy strategy;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Set&lt;Bitmap.Config&gt; allowedConfigs;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> BitmapTracker tracker;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Pool에 들어올수 있는 최대 크기</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">long</span> maxSize;</span><br><span class=\"line\">    <span class=\"comment\">// 현재 pool에 들어간 bitmap byte 크기</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">long</span> currentSize;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br></pre></td></tr></table></figure>\n\n<p>Glide내 LruBitmapPool Class 에서는 strategy(LruPoolStrategy)가 곧 LRU 기반으로 구현된 리스트이며, tracker(BitmapTracker)가 Bitmap size 순으로 정렬된 리스트이다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">put</span><span class=\"params\">(Bitmap bitmap)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (bitmap == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException(<span class=\"string\">&quot;Bitmap must not be null&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// isRecycled: 재활용된 bitmap인지 여부</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (bitmap.isRecycled()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">&quot;Cannot pool recycled bitmap&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// isMutable: canvas를 얻을 수 있는 bitmap 인지 여부.</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!bitmap.isMutable()</span><br><span class=\"line\">        || strategy.getSize(bitmap) &gt; maxSize</span><br><span class=\"line\">        || !allowedConfigs.contains(bitmap.getConfig())) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class=\"line\">            Log.v(</span><br><span class=\"line\">                TAG,</span><br><span class=\"line\">                <span class=\"string\">&quot;Reject bitmap from pool&quot;</span></span><br><span class=\"line\">                + <span class=\"string\">&quot;, bitmap: &quot;</span></span><br><span class=\"line\">                + strategy.logBitmap(bitmap)</span><br><span class=\"line\">                + <span class=\"string\">&quot;, is mutable: &quot;</span></span><br><span class=\"line\">                + bitmap.isMutable()</span><br><span class=\"line\">                + <span class=\"string\">&quot;, is allowed config: &quot;</span></span><br><span class=\"line\">                + allowedConfigs.contains(bitmap.getConfig()));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        bitmap.recycle();</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// pool에 넣으려는 bitmap의 사이즈를 얻어온다.</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> size = strategy.getSize(bitmap);</span><br><span class=\"line\">    strategy.put(bitmap);</span><br><span class=\"line\">    tracker.add(bitmap);</span><br><span class=\"line\"></span><br><span class=\"line\">    puts++;</span><br><span class=\"line\">    currentSize += size;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class=\"line\">        Log.v(TAG, <span class=\"string\">&quot;Put bitmap in pool=&quot;</span> + strategy.logBitmap(bitmap));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    dump();</span><br><span class=\"line\"></span><br><span class=\"line\">    evict();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Bitmap을 Pool에 넣을 수 있는 조건을 충족시킨다면, strategy &amp; tracker에 bitmap이 들어가게된다. </p>\n<blockquote>\n<p><strong>참고</strong> Lru 기반인 strategy 는 최근에 들어온 bitmap일수록 리스트의 맨 앞으로 배치시켜야하는데, 그 로직이 <code>LruPoolStrategy</code> 구현체 내부에 존재하게 된다.</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Pool의 최대 사용량을 넘기면 크기를 줄여준다.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">trimToSize</span><span class=\"params\">(<span class=\"keyword\">long</span> size)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (currentSize &gt; size) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//LRU List에서 삭제한다.</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> Bitmap removed = strategy.removeLast();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (removed == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (Log.isLoggable(TAG, Log.WARN)) &#123;</span><br><span class=\"line\">                Log.w(TAG, <span class=\"string\">&quot;Size mismatch, resetting&quot;</span>);</span><br><span class=\"line\">                dumpUnchecked();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            currentSize = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// BitmapList에서 삭제한다. </span></span><br><span class=\"line\">        tracker.remove(removed);</span><br><span class=\"line\">        currentSize -= strategy.getSize(removed);</span><br><span class=\"line\">        evictions++;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (Log.isLoggable(TAG, Log.DEBUG)) &#123;</span><br><span class=\"line\">            Log.d(TAG, <span class=\"string\">&quot;Evicting bitmap=&quot;</span> + strategy.logBitmap(removed));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        dump();</span><br><span class=\"line\">        removed.recycle();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>trimToSize()를 이용하면 pool이 최대사용량을 넘어선 경우 참조를 가장 적게하고 있는 lastIndex 부터 객체를 지워가며 크기를 줄여줄 수 있다. </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"meta\">@Nullable</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Bitmap <span class=\"title\">get</span><span class=\"params\">(<span class=\"keyword\">int</span> width, <span class=\"keyword\">int</span> height, Bitmap.Config config)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> size = Util.getBitmapByteSize(width, height, config);</span><br><span class=\"line\">    Key key = keyPool.get(size);</span><br><span class=\"line\"></span><br><span class=\"line\">    Integer possibleSize = sortedSizes.ceilingKey(size);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (possibleSize != <span class=\"keyword\">null</span> &amp;&amp; possibleSize != size &amp;&amp; possibleSize &lt;= size * MAX_SIZE_MULTIPLE) &#123;</span><br><span class=\"line\">        keyPool.offer(key);</span><br><span class=\"line\">        key = keyPool.get(possibleSize);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">final</span> Bitmap result = groupedMap.get(key);</span><br><span class=\"line\">    <span class=\"comment\">// 비트맵을 찾은 경우, pool에서 제거한다.</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (result != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        result.reconfigure(width, height, config);</span><br><span class=\"line\">        decrementBitmapOfSize(possibleSize);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>이미지를 로드하기 위해 pool에서 필요한 비트맵을 가져온다.</p>\n<h2 id=\"Jetpack-Compose에서-이미지-라이브러리-사용하기\"><a href=\"#Jetpack-Compose에서-이미지-라이브러리-사용하기\" class=\"headerlink\" title=\"Jetpack Compose에서 이미지 라이브러리 사용하기\"></a>Jetpack Compose에서 이미지 라이브러리 사용하기</h2><p>Google 에서는 Jetpack Compose를 보다 편하게 사용하기 위한 라이브러리를 묶어서 제공한다.</p>\n<p><strong>Accompanist</strong> 라고 하는 GroupId를 가진 라이브러리 모음이다.</p>\n<blockquote>\n<p><strong>참고</strong> <a href=\"https://github.com/google/accompanist\">Google#Accompanist Repository</a></p>\n</blockquote>\n<p>Accompanist에서는 Glide와 Coil을 지원하고 있다.</p>\n<p>의존성 설정은 아래와 같다.</p>\n<figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">dependencies</span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    implementation <span class=\"string\">&quot;com.google.accompanist:accompanist-glide:0.11.1&quot;</span></span><br><span class=\"line\">    implementation <span class=\"string\">&quot;com.google.accompanist:accompanist-coil:0.11.1&quot;</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Glide는 아래와 같이 적용한다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Image(</span><br><span class=\"line\">    painter = rememberGlidePainter(</span><br><span class=\"line\">        request = <span class=\"string\">&quot;https://picsum.photos/300/300&quot;</span>,</span><br><span class=\"line\">        <span class=\"comment\">// placeHolder</span></span><br><span class=\"line\">    ),</span><br><span class=\"line\">    contentDescription = stringResource(R.string.image_content_desc)</span><br><span class=\"line\">)</span><br><span class=\"line\">Image(</span><br><span class=\"line\">    painter = rememberGlidePainter(</span><br><span class=\"line\">        request = <span class=\"string\">&quot;https://cataas.com/cat/gif&quot;</span>,</span><br><span class=\"line\">        <span class=\"comment\">// placeHolder</span></span><br><span class=\"line\">    ),</span><br><span class=\"line\">    contentDescription = <span class=\"literal\">null</span></span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<p>Coil은 아래와 같이 적용한다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Image(</span><br><span class=\"line\">    painter = rememberCoilPainter(</span><br><span class=\"line\">        request = <span class=\"string\">&quot;https://picsum.photos/300/300&quot;</span>,</span><br><span class=\"line\">        <span class=\"comment\">// placeHolder</span></span><br><span class=\"line\">    ),</span><br><span class=\"line\">    contentDescription = <span class=\"literal\">null</span></span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<p>Coil에서 gif를 렌더링하기 위해선 <code>coil-gif</code> 의존성을 추가한다.</p>\n<figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">dependencies</span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    implementation <span class=\"string\">&quot;com.google.accompanist:accompanist-glide:0.11.1&quot;</span></span><br><span class=\"line\">    implementation <span class=\"string\">&quot;com.google.accompanist:accompanist-coil:0.11.1&quot;</span></span><br><span class=\"line\">    <span class=\"comment\">// Coil 에서 gif 를 사용하기 위해서 추가</span></span><br><span class=\"line\">    implementation <span class=\"string\">&quot;io.coil-kt:coil-gif:1.2.2&quot;</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>아래와 같이 별도의 ImageLoader를 설정한다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">gifImageLoader</span><span class=\"params\">(context: <span class=\"type\">Context</span>)</span></span> = ImageLoader.Builder(context)</span><br><span class=\"line\">    .componentRegistry &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (SDK_INT &gt;= <span class=\"number\">28</span>) &#123;</span><br><span class=\"line\">        add(ImageDecoderDecoder(context))</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        add(GifDecoder())</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    .build()</span><br></pre></td></tr></table></figure>\n\n<p>Image의 적용은 아래와 같이 적용한다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Image(</span><br><span class=\"line\">    painter = rememberCoilPainter(</span><br><span class=\"line\">        request = <span class=\"string\">&quot;https://cataas.com/cat/gif&quot;</span>,</span><br><span class=\"line\">        imageLoader = gifImageLoader(LocalContext*.current),</span><br><span class=\"line\">    ),</span><br><span class=\"line\">    contentDescription = <span class=\"literal\">null</span></span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<article class=\"message message-immersive is-primary\">\n    <div class=\"message-body\">\n        <i class=\"fas fa-pen-fancy mr-2\"></i>Writers<br>\n        by 곽욱현 @Knowre<br>\n        by 김남훈 @Naver<br>\n        by 배희성 @RocketPunch<br>\n        by 송시영 @SmartStudy<br>\n        by 옥수환 @Naver<br>\n        by 이기정 @BankSalad<br>\n        by 정세희 @BankSalad\n    </div>\n</article>","more":"<h2 id=\"Image-Library의-동작-방식\"><a href=\"#Image-Library의-동작-방식\" class=\"headerlink\" title=\"Image Library의 동작 방식\"></a>Image Library의 동작 방식</h2><p>Android 에서 가장 많이 쓰이는 <code>Glide</code>를 기준으로 이미지 라이브러리의 동작 방식을 살펴보자.</p>\n<p>먼저 Part 1에서 다루었던 기본 예제를 수정하도록 하자.</p>\n<h3 id=\"Glide-의존성-설정\"><a href=\"#Glide-의존성-설정\" class=\"headerlink\" title=\"Glide 의존성 설정\"></a>Glide 의존성 설정</h3><figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">dependencies</span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    implementation <span class=\"string\">&#x27;com.github.bumptech.glide:glide:4.12.0&#x27;</span></span><br><span class=\"line\">    annotationProcessor <span class=\"string\">&#x27;com.github.bumptech.glide:compiler:4.12.0&#x27;</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"인터넷-사용-권한-부여\"><a href=\"#인터넷-사용-권한-부여\" class=\"headerlink\" title=\"인터넷 사용 권한 부여\"></a>인터넷 사용 권한 부여</h3><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">manifest</span> </span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">xmlns:android</span>=<span class=\"string\">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">package</span>=<span class=\"string\">&quot;android.deepdive.raw&quot;</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">uses-permission</span> <span class=\"attr\">android:name</span>=<span class=\"string\">&quot;android.permission.INTERNET&quot;</span>/&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- ... --&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"레이아웃-파일에서-이미지-소스-제거\"><a href=\"#레이아웃-파일에서-이미지-소스-제거\" class=\"headerlink\" title=\"레이아웃 파일에서 이미지 소스 제거\"></a>레이아웃 파일에서 이미지 소스 제거</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;ImageView</span><br><span class=\"line\">    <span class=\"attr\">android</span>:id=<span class=\"string\">&quot;@+id/imageView&quot;</span></span><br><span class=\"line\">    <span class=\"attr\">android</span>:layout_width=<span class=\"string\">&quot;wrap_content&quot;</span></span><br><span class=\"line\">    <span class=\"attr\">android</span>:layout_height=<span class=\"string\">&quot;wrap_content&quot;</span></span><br><span class=\"line\">    <span class=\"attr\">app</span>:layout_constraintBottom_toBottomOf=<span class=\"string\">&quot;parent&quot;</span></span><br><span class=\"line\">    <span class=\"attr\">app</span>:layout_constraintLeft_toLeftOf=<span class=\"string\">&quot;parent&quot;</span></span><br><span class=\"line\">    <span class=\"attr\">app</span>:layout_constraintRight_toRightOf=<span class=\"string\">&quot;parent&quot;</span></span><br><span class=\"line\">    <span class=\"attr\">app</span>:layout_constraintTop_toTopOf=<span class=\"string\">&quot;parent&quot;</span>/&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"코드에-Glide-예제-적용\"><a href=\"#코드에-Glide-예제-적용\" class=\"headerlink\" title=\"코드에 Glide 예제 적용\"></a>코드에 Glide 예제 적용</h3><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MainActivity</span> : <span class=\"type\">AppCompatActivity</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onCreate</span><span class=\"params\">(savedInstanceState: <span class=\"type\">Bundle</span>?)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onCreate(savedInstanceState)</span><br><span class=\"line\">        setContentView(R.layout.activity_main)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">var</span> imageView: ImageView = findViewById(R.id.imageView)</span><br><span class=\"line\"></span><br><span class=\"line\">        Glide</span><br><span class=\"line\">            .with(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">            .load(<span class=\"string\">&quot;https://goo.gl/gEgYUd&quot;</span>)</span><br><span class=\"line\">            .into(imageView)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>위와 같이 작업을 하고 나면 아래와 같은 화면을 렌더링할 수 있다.</p>\n<img src=\"/Team-Blog/2021/06/24/2021-06-24%20Image%20Loading%20and%20Caching%20Library%20Part%202/Screenshot_1624078627.png\" class=\"\" width=\"350\" title=\"[Screenshot_1624078627]\">\n\n<h2 id=\"기능-톺아보기\"><a href=\"#기능-톺아보기\" class=\"headerlink\" title=\"기능 톺아보기\"></a>기능 톺아보기</h2><h3 id=\"이미지-렌더링-방식\"><a href=\"#이미지-렌더링-방식\" class=\"headerlink\" title=\"이미지 렌더링 방식\"></a>이미지 렌더링 방식</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Glide</span><br><span class=\"line\">    .with(this)</span><br><span class=\"line\">    .load(&quot;https://goo.gl/gEgYUd&quot;)</span><br><span class=\"line\">    .into(imageView)</span><br></pre></td></tr></table></figure>\n\n<p>개발자 입장에서는 매우 간단하게 이미지를 렌더링할 수 있게 해준다.</p>\n<p>Glide 문서에서 최소로 요구되고 있는 <code>with()</code>와 <code>load()</code>, <code>into()</code>의 내부 구조를 한 번 살펴보자.</p>\n<h4 id=\"1-with-메서드\"><a href=\"#1-with-메서드\" class=\"headerlink\" title=\"1. with 메서드\"></a>1. with 메서드</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@NonNull</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> RequestManager <span class=\"title\">with</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> FragmentActivity activity)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> getRetriever(activity).get(activity);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@NonNull</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> RequestManagerRetriever <span class=\"title\">getRetriever</span><span class=\"params\">(<span class=\"meta\">@Nullable</span> Context context)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Context could be null for other reasons (ie the user passes in null), but in practice it will</span></span><br><span class=\"line\">    <span class=\"comment\">// only occur due to errors with the Fragment lifecycle.</span></span><br><span class=\"line\">    Preconditions.checkNotNull(</span><br><span class=\"line\">        context,</span><br><span class=\"line\">        <span class=\"string\">&quot;You cannot start a load on a not yet attached View or a Fragment where getActivity() &quot;</span></span><br><span class=\"line\">            + <span class=\"string\">&quot;returns null (which usually occurs when getActivity() is called before the Fragment &quot;</span></span><br><span class=\"line\">            + <span class=\"string\">&quot;is attached or after the Fragment is destroyed).&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Glide.get(context).getRequestManagerRetriever();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>with()</code>메서드를 호출하면 <code>getRetriever()</code> 메서드를 통해 <code>RequestManagerRetriever</code> 객체를 획득한다.</p>\n<p>이후 <code>get()</code> 메서드를 이용해 <code>RequestManager</code> 객체를 생성하는 코드도 연달아 호출하게 된다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@NonNull</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> RequestManager <span class=\"title\">get</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Context context)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (context == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">&quot;You cannot start a load on a null Context&quot;</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (Util.isOnMainThread() &amp;&amp; !(context <span class=\"keyword\">instanceof</span> Application)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (context <span class=\"keyword\">instanceof</span> FragmentActivity) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> get((FragmentActivity) context);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (context <span class=\"keyword\">instanceof</span> Activity) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> get((Activity) context);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (context <span class=\"keyword\">instanceof</span> ContextWrapper</span><br><span class=\"line\">            <span class=\"comment\">// Only unwrap a ContextWrapper if the baseContext has a non-null application context.</span></span><br><span class=\"line\">            <span class=\"comment\">// Context#createPackageContext may return a Context without an Application instance,</span></span><br><span class=\"line\">            <span class=\"comment\">// in which case a ContextWrapper may be used to attach one.</span></span><br><span class=\"line\">            &amp;&amp; ((ContextWrapper) context).getBaseContext().getApplicationContext() != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> get(((ContextWrapper) context).getBaseContext());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> getApplicationManager(context);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Context의 instance type에 대한 처리후 제일 마지막에 <code>getApplicationManager()</code>를 호출한다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@NonNull</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> RequestManager <span class=\"title\">getApplicationManager</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Context context)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Either an application context or we&#x27;re on a background thread.</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (applicationManager == <span class=\"keyword\">null</span>) &#123;  </span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (applicationManager == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// Normally pause/resume is taken care of by the fragment we add to the fragment or</span></span><br><span class=\"line\">            <span class=\"comment\">// activity. However, in this case since the manager attached to the application will not</span></span><br><span class=\"line\">            <span class=\"comment\">// receive lifecycle events, we must force the manager to start resumed using</span></span><br><span class=\"line\">            <span class=\"comment\">// ApplicationLifecycle.</span></span><br><span class=\"line\"></span><br><span class=\"line\">          <span class=\"comment\">// T  ODO(b/27524013): Factor out this Glide.get() call.</span></span><br><span class=\"line\">            Glide glide = Glide.get(context.getApplicationContext());</span><br><span class=\"line\">            applicationManager =</span><br><span class=\"line\">                factory.build(</span><br><span class=\"line\">                    glide,</span><br><span class=\"line\">                    <span class=\"keyword\">new</span> ApplicationLifecycle(),</span><br><span class=\"line\">                    <span class=\"keyword\">new</span> EmptyRequestManagerTreeNode(),</span><br><span class=\"line\">                    context.getApplicationContext());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> applicationManager;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>with()</code> 메서드는 Global Scope에서 애플리케이션의 생명주기와 연동하여 Glide의 싱글턴 객체를 획득하는 것이 목적이라고 볼 수 있다.</p>\n<h4 id=\"2-load-메서드\"><a href=\"#2-load-메서드\" class=\"headerlink\" title=\"2. load 메서드\"></a>2. load 메서드</h4><p>두 번째로 <code>load()</code> 메서드를 살펴보자.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@NonNull</span></span><br><span class=\"line\"><span class=\"meta\">@CheckResult</span></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> RequestBuilder&lt;Drawable&gt; <span class=\"title\">load</span><span class=\"params\">(<span class=\"meta\">@Nullable</span> String string)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> asDrawable().load(string);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>단순힌 <code>asDrawable()</code>을 호출해 <code>RequestBuilder</code> 객체를 만들고, <code>load()</code>를 호출한다고만 명세되어있다.</p>\n<p><code>asDrawable()</code> 구현체를 살펴보자.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@NonNull</span></span><br><span class=\"line\"><span class=\"meta\">@CheckResult</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> RequestBuilder&lt;Drawable&gt; <span class=\"title\">asDrawable</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> as(Drawable.class);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>android.graphics.drawable.Drawable</code> 타입을 <code>as()</code>에 파라미터로 넘겨주고 있다.</p>\n<p><code>as()</code> 구현체를 살펴보자.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@NonNull</span></span><br><span class=\"line\"><span class=\"meta\">@CheckResult</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;ResourceType&gt; <span class=\"function\">RequestBuilder&lt;ResourceType&gt; <span class=\"title\">as</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Class&lt;ResourceType&gt; resourceClass)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> RequestBuilder&lt;&gt;(glide, <span class=\"keyword\">this</span>, resourceClass, context);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>파라미터로 주어진 객체 타입(여기서는 <code>android.graphics.drawable.Drawable</code>)으로 디코딩하여 반환한다.</p>\n<p>여기서 쓰이는 디코더는 <code>com.bumptech.glide.load.ResourceDecoders</code>이다.</p>\n<p><code>Drawable.class</code>로 고정되어있지 않은 이유는 리소스 클래스의 서브클래스들도 호환하기 위해서이다.</p>\n<p><code>Glide.load()</code>에서 호출하는 <code>asDrawable()</code>이 디코딩할 리소스 클래스를 생성하였다면 바로 뒤에 붙은 <code>RequestBuilder.load()</code> 메서드에서 데이터를 불러올 것임을 추측할 수 있다.</p>\n<p><code>RequestBuilder.load()</code> 메서드의 호출 구조를 살펴보자.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@NonNull</span></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"meta\">@CheckResult</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> RequestBuilder&lt;TranscodeType&gt; <span class=\"title\">load</span><span class=\"params\">(<span class=\"meta\">@Nullable</span> String string)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> loadGeneric(string);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>load()</code>의 파라미터로 주어진 <code>string</code>값을 key로 사용해 데이터를 캐시하는 영역이다.</p>\n<p>동일 이미지의 반복적인 렌더링 작업에 대해 처리한 부분임을 알 수 있다.</p>\n<p>이후 <code>loadGeneric()</code>을 호출한다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@NonNull</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> RequestBuilder&lt;TranscodeType&gt; <span class=\"title\">loadGeneric</span><span class=\"params\">(<span class=\"meta\">@Nullable</span> Object model)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isAutoCloneEnabled()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> clone().loadGeneric(model);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.model = model;</span><br><span class=\"line\">    isModelSet = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> selfOrThrowIfLocked();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>파라미터의 타입이 <code>String</code>에서 <code>Object</code>로 변경되었다.</p>\n<p>이 <code>model</code>은 <code>com.bumptech.glide.load.model.UriLoader</code> 객체에서 핸들링하게 된다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@NonNull</span></span><br><span class=\"line\"><span class=\"meta\">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> T <span class=\"title\">selfOrThrowIfLocked</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isLocked) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">&quot;You cannot modify locked T, consider clone()&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> self();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> T <span class=\"title\">self</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (T) <span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>이후 <code>RequestBuilder.load()</code>는 최종적으로 <code>RequestBuilder</code> 객체를 반환해주게 된다.</p>\n<h4 id=\"3-into-메서드\"><a href=\"#3-into-메서드\" class=\"headerlink\" title=\"3. into 메서드\"></a>3. into 메서드</h4><p>현재까지 <code>with()</code>에서 <code>RequestManager</code>객체를 생성한 뒤, 이 객체의 <code>load()</code> 메서드를 호출하여 <code>RequestBuilder</code> 객체를 획득하는 과정까지 진행되었다.</p>\n<p>이제 <code>RequestBuilder</code>에서 <code>into()</code> 메서드를 호출해 <code>ImageView</code>에 리소스를 할당하는 마지막 작업이다.</p>\n<p>리소스를 할당할 ImageView를 파라미터로 요구한다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@NonNull</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> ViewTarget&lt;ImageView, TranscodeType&gt; <span class=\"title\">into</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> ImageView view)</span> </span>&#123;</span><br><span class=\"line\">    Util.assertMainThread();</span><br><span class=\"line\">    Preconditions.checkNotNull(view);</span><br><span class=\"line\"></span><br><span class=\"line\">    BaseRequestOptions&lt;?&gt; requestOptions = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!requestOptions.isTransformationSet()</span><br><span class=\"line\">        &amp;&amp; requestOptions.isTransformationAllowed()</span><br><span class=\"line\">        &amp;&amp; view.getScaleType() != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Clone in this method so that if we use this RequestBuilder to load into a View and then</span></span><br><span class=\"line\">        <span class=\"comment\">// into a different target, we don&#x27;t retain the transformation applied based on the previous</span></span><br><span class=\"line\">        <span class=\"comment\">// View&#x27;s scale type.</span></span><br><span class=\"line\">        <span class=\"keyword\">switch</span> (view.getScaleType()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> CENTER_CROP:</span><br><span class=\"line\">            requestOptions = requestOptions.clone().optionalCenterCrop();</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> CENTER_INSIDE:</span><br><span class=\"line\">            requestOptions = requestOptions.clone().optionalCenterInside();</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> FIT_CENTER:</span><br><span class=\"line\">        <span class=\"keyword\">case</span> FIT_START:</span><br><span class=\"line\">        <span class=\"keyword\">case</span> FIT_END:</span><br><span class=\"line\">            requestOptions = requestOptions.clone().optionalFitCenter();</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> FIT_XY:</span><br><span class=\"line\">            requestOptions = requestOptions.clone().optionalCenterInside();</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> CENTER:</span><br><span class=\"line\">        <span class=\"keyword\">case</span> MATRIX:</span><br><span class=\"line\">        <span class=\"keyword\">default</span>:</span><br><span class=\"line\">            <span class=\"comment\">// Do nothing.</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> into(</span><br><span class=\"line\">        glideContext.buildImageViewTarget(view, transcodeClass),</span><br><span class=\"line\">        <span class=\"comment\">/*targetListener=*/</span> <span class=\"keyword\">null</span>,</span><br><span class=\"line\">        requestOptions,</span><br><span class=\"line\">        Executors.mainThreadExecutor());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>Util.assertMainThread()</code>에서 메인 쓰레드 여부를 검증한 뒤, <code>Preconditions.checkNotNull(view)</code>에서 파라미터로 주어진 ImageView에 대한 null check를 수행한다.</p>\n<p>이후 ImageView의 scaleType에 대한 처리 후, <code>into(target, targetListener, options, callbackExecutor)</code>를 호출한다.</p>\n<p>이때 <code>target</code> 자리에 <code>GlideContext.buildImageViewTarget()</code>이라는 메서드를 주입하는데, 파라미터로 주어진 ImageView를 이용해 <code>BitmapImageViewTarget</code>이나 <code>DrawableImageViewTarget</code>으로 변환하는 작업을 수행한다.</p>\n<p><code>GlideContext.buildImageViewTarget()</code>의 두 번째 파라미터인 <code>transcodeClass</code>의 값은 <code>Glide.load()</code>를 호출하였을 때 수행하는 <code>as()</code> 메소드의 파라미터인 <code>Drawable.class</code>로 이미 주입되어있다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> &lt;Y extends Target&lt;TranscodeType&gt;&gt; <span class=\"function\">Y <span class=\"title\">into</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    <span class=\"meta\">@NonNull</span> Y target,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    <span class=\"meta\">@Nullable</span> RequestListener&lt;TranscodeType&gt; targetListener,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    BaseRequestOptions&lt;?&gt; options,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    Executor callbackExecutor)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    Preconditions.checkNotNull(target);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isModelSet) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">&quot;You must call #load() before calling #into()&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    Request request = buildRequest(target, targetListener, options, callbackExecutor);</span><br><span class=\"line\">    Request previous = target.getRequest();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (request.isEquivalentTo(previous) &amp;&amp; !isSkipMemoryCacheWithCompletePreviousRequest(options, previous)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// If the request is completed, beginning again will ensure the result is re-delivered,</span></span><br><span class=\"line\">        <span class=\"comment\">// triggering RequestListeners and Targets. If the request is failed, beginning again will</span></span><br><span class=\"line\">        <span class=\"comment\">// restart the request, giving it another chance to complete. If the request is already</span></span><br><span class=\"line\">        <span class=\"comment\">// running, we can let it continue running without interruption.</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!Preconditions.checkNotNull(previous).isRunning()) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// Use the previous request rather than the new one to allow for optimizations like skipping</span></span><br><span class=\"line\">            <span class=\"comment\">// setting placeholders, tracking and un-tracking Targets, and obtaining View dimensions</span></span><br><span class=\"line\">            <span class=\"comment\">// that are done in the individual Request.</span></span><br><span class=\"line\">            previous.begin();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> target;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    requestManager.clear(target);</span><br><span class=\"line\">    target.setRequest(request);</span><br><span class=\"line\">    requestManager.track(target, request);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> target;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>target</code>으로 주어진 ImageView에 리소스를 세팅하는 곳인데, 특기할만한 부분은 <code>requestManager.clear(target)</code>이다.</p>\n<p>해당 메서드를 호출하면 현재 target으로 설정된 뷰에 대한 모든 로딩을 취소하고 모든 리소스를 해제한다.</p>\n<h2 id=\"Memory-amp-Footprint\"><a href=\"#Memory-amp-Footprint\" class=\"headerlink\" title=\"Memory &amp; Footprint\"></a>Memory &amp; Footprint</h2><p>Bitmap를 다루다보면 필연적으로 OOM 관련하여 메모리 이슈를 피할 수 없다.</p>\n<p>Image Library를 사용하지 않은 상태에서 많은 이미지를 사용하거나 고해상도 이미지를 이미지뷰에 로드해야하는 경우 메모리 부족으로 OOM이 발생하게 된다.</p>\n<p>요즘 나오는 스마트폰은 굉장히 많은 메모리를 가지고 태어나는데 <strong>왜 이정도도 못 버티지(?)</strong> 라는 생각을 한다면, 안드로이드는 앱 내에서 사용할 수 있는 힙 메모리가 정해져있기 때문이다.</p>\n<img src=\"/Team-Blog/2021/06/24/2021-06-24%20Image%20Loading%20and%20Caching%20Library%20Part%202/IMG_06A0242D2ABE-1.jpg\" class=\"\" title=\"[IMG_06A0242D2ABE-1]\">\n\n<p>Android의 메모리 모델은 운영체제 버전에 따라 두가지로 나뉘게 된다. </p>\n<ul>\n<li>Dalvik heap 영역 : java 객체를 저장하는 메모리</li>\n<li>External 영역 : native heap의 일종으로 네이티브의 비트맵 객체를 저장하는 메모리<br>Dalvik heap 영역와 External 영역의 <code>Dalvik heap footprint + External Limit</code>을 합쳐 프로세스당 메모리 한계를 초과하면 OOM이 발생하게 된다.</li>\n</ul>\n<h3 id=\"Footprint\"><a href=\"#Footprint\" class=\"headerlink\" title=\"Footprint\"></a>Footprint</h3><p>java의 footprint는 한 번 증가하면 크기가 다시 감소되지 않기 때문에, footprint가 과도하게 커지지 않게끔 잘 관리해야한다. </p>\n<img src=\"/Team-Blog/2021/06/24/2021-06-24%20Image%20Loading%20and%20Caching%20Library%20Part%202/image.png\" class=\"\" title=\"[image]\">\n\n<p>Dalvik VM은 처음에 동작에 필요한 만큼만 프로세스에 Heap을 할당하게 되고, 프로세스에 할당된 메모리보다 많은 메모리를 필요하게될 때마다 Dalvit Footfrint도 증가하게된다. 하지만 증가된 Footfrint는 결코 감소하지 않기 때문에 java 객체가 사용가능한 메모리 공간의 여유가 있어도, External heap의 크기가 증가되면 OOM이 발생할 수 있다. 하지만 이런 문제도 Honeycomb 이후부터는 Dalvik heap 과 External 영역이 합쳐졌기 때문에, 고려할 필요가 없어졌다. </p>\n<p>External 영역을 사용하는 Honeycomb 미만 버전에서는 이미지를 많이 사용하고있는 화면에서 화면을 전환하는 행동이 발생했을 때도 OOM이 발생하면서 앱이 중지될 것이다. 화면을 전환하면 이전 액티비티 인스턴스에 있던 이미지뷰나 할당되었던 비트맵이 함께 소멸되어 메모리가 회수되고 새로운 액티비티 인스턴스를 생성할텐데, 이 과정에서 이전 액티비티 인스턴스의 비트맵 객체가 회수되지 않아 메모리 누수가 발생했기 때문이다. </p>\n<p>비트맵 객체에 대한 참조가 없는데도 왜 회수가 될 수 없을까? Honeycomb 미만 버전에서는 Java 비트맵 객체는 실제 비트맵 데이터를 가지고 있는 곳을 가리키는 포인터일 뿐이고 실제 데이터는 External 영역인 Native Heap 영역에 저장되기 때문이다. Java 비트맵 객체는 참조가 없을 때 GC에 의해 회수되지만 Native Heap 영역은 GC 수행영역 밖이기 때문에 메모리 소멸 시점이 다르다. </p>\n<p>이러한 문제점 때문에, Honeycomb 이후 버전에서는 External 영역이 없어지면서 Dalvik heap 영역에 비트맵 메모리를 올릴 수 있게 되었고 GC도 접근할 수 있게 되었다.</p>\n<p>다시 돌아와, 만약 고해상도 이미지를 로드할 때 OOM이 발생하는 경우 BitmapFactory 객체를 이용해 다운샘플링, 디코딩 방식을 선택해 적절하게 뷰에 로드하면 된다. 하지만 많은 이미지를 사용하게 되면서 OOM이 발생한다면, <code>이미지 캐싱</code>을 이용해보는 것이 어떨까?</p>\n<h3 id=\"Bitmap-Caching\"><a href=\"#Bitmap-Caching\" class=\"headerlink\" title=\"Bitmap Caching\"></a>Bitmap Caching</h3><p>이미지가 화면에서 사라지고 다시 구성할 때 이미지를 매번 로드하는 것은 성능상으로나 사용자 경험에 좋지 않다. 이럴 때 메모리와 디스크 캐시를 이용하여 어디에선가 저장되어있던 비트맵을 다시 가져온다면 다시 로드하는 시간도 단축시킬 수 있으며 성능 개선도 가능할 것이다. 이 때 캐싱을 위해 <code>Memory Cache</code>와 <code>Disk Cache</code> 사용을 추천하는데 두가지가 어떤 차이점이 있는지 알아보자.</p>\n<h4 id=\"1-Memory-Cache\"><a href=\"#1-Memory-Cache\" class=\"headerlink\" title=\"1. Memory Cache\"></a>1. Memory Cache</h4><p>Memory Cache는 어플리케이션 내에 존재하는 메모리에 비트맵을 캐싱하고, 필요할 때 빠르게 접근가능하다. 하지만 Memory Cache도 곧 어플리케이션 용량을 키우는 주범이 될 수 있기 때문에 많은 캐싱을 요구하는 비트맵의 경우에는 Disk Cache에 넣는 것이 더 좋을 수 있다.</p>\n<h4 id=\"2-Disk-Cache\"><a href=\"#2-Disk-Cache\" class=\"headerlink\" title=\"2. Disk Cache\"></a>2. Disk Cache</h4><p>Memory Cache에 넣기엔 많은 캐시를 요구하는 경우, 혹은 앱이 백그라운드로 전환되어도 적재한 캐시가 삭제되지 않기를 바란다면 Disk Cache를 이용하는 것이 좋다. 하지만 Disk로부터 캐싱된 비트맵을 가져올 때는 Memory에서 로드하는 것보다 오랜시간이 걸린다.</p>\n<h3 id=\"BitmapPool\"><a href=\"#BitmapPool\" class=\"headerlink\" title=\"BitmapPool\"></a>BitmapPool</h3><p>Memory Cache의 예시를 위해 소개할 것은 <code>BitmapPool</code>이다. <code>BitmapPool</code>의 원리는 사용하지 않는 Bitmap을 리스트에 넣어놓고, 추후에 동일한 이미지를 로드할 때 다시 메모리에 적재하지 않고 pool에 있는 이미지를 가져와 재사용하는 것이다. </p>\n<p>보통 BitmapPool을 이용해 재사용 Pool을 만들게 될 때, LRU 캐싱 알고리즘으로 구현된 LinkedList <code>(lruBItmapList)</code>와 Byte Size 순으로 정렬된 LinkedList<code>(bitmapList)</code>를 사용하여 구현하게 된다. 이 둘은 들어있는 비트맵의 순서만 다를 뿐, 같은 비트맵이 담기게된다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">val</span> lruBitmapList = LinkedList&lt;Bitmap&gt;()</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">val</span> bitmapList = LinkedList&lt;Bitmap&gt;()</span><br></pre></td></tr></table></figure>\n\n<p>LRU 알고리즘을 이용해 오랫동안 참조되지않은 비트맵 객체는 맨 뒤로 밀리게되고, <code>맨 뒤에있는 객체를 회수</code>하면서 BitmapPool을 유지시키는 것이다. LRU 알고리즘을 이용하지 않는다면 처음 BitmapPool이 가득 찰 때까지는 문제없이 동작하지만, 비트맵을 재사용하는 시점부터는 특정 비트맵만 재사용될 수 있으며, 앱이 끝날 때까지 메모리가 줄어들지 않게된다. 자세한 내용은 <a href=\"https://jamssoft.tistory.com/195\">이 블로그</a>를 참고하길 바란다.</p>\n<p>대표적인 이미지 로더 라이브러리인 <code>Glide</code>에서 구현한 LruBitmapPool Class 내부를 보며, LruBitmapList와 bitmapList가 어떻게 쓰이고있는지 살펴보자. </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LruBitmapPool</span> <span class=\"keyword\">implements</span> <span class=\"title\">BitmapPool</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String TAG = <span class=\"string\">&quot;LruBitmapPool&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Bitmap.Config DEFAULT_CONFIG = Bitmap.Config.ARGB_8888;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> LruPoolStrategy strategy;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Set&lt;Bitmap.Config&gt; allowedConfigs;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> BitmapTracker tracker;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Pool에 들어올수 있는 최대 크기</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">long</span> maxSize;</span><br><span class=\"line\">    <span class=\"comment\">// 현재 pool에 들어간 bitmap byte 크기</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">long</span> currentSize;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br></pre></td></tr></table></figure>\n\n<p>Glide내 LruBitmapPool Class 에서는 strategy(LruPoolStrategy)가 곧 LRU 기반으로 구현된 리스트이며, tracker(BitmapTracker)가 Bitmap size 순으로 정렬된 리스트이다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">put</span><span class=\"params\">(Bitmap bitmap)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (bitmap == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException(<span class=\"string\">&quot;Bitmap must not be null&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// isRecycled: 재활용된 bitmap인지 여부</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (bitmap.isRecycled()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">&quot;Cannot pool recycled bitmap&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// isMutable: canvas를 얻을 수 있는 bitmap 인지 여부.</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!bitmap.isMutable()</span><br><span class=\"line\">        || strategy.getSize(bitmap) &gt; maxSize</span><br><span class=\"line\">        || !allowedConfigs.contains(bitmap.getConfig())) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class=\"line\">            Log.v(</span><br><span class=\"line\">                TAG,</span><br><span class=\"line\">                <span class=\"string\">&quot;Reject bitmap from pool&quot;</span></span><br><span class=\"line\">                + <span class=\"string\">&quot;, bitmap: &quot;</span></span><br><span class=\"line\">                + strategy.logBitmap(bitmap)</span><br><span class=\"line\">                + <span class=\"string\">&quot;, is mutable: &quot;</span></span><br><span class=\"line\">                + bitmap.isMutable()</span><br><span class=\"line\">                + <span class=\"string\">&quot;, is allowed config: &quot;</span></span><br><span class=\"line\">                + allowedConfigs.contains(bitmap.getConfig()));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        bitmap.recycle();</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// pool에 넣으려는 bitmap의 사이즈를 얻어온다.</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> size = strategy.getSize(bitmap);</span><br><span class=\"line\">    strategy.put(bitmap);</span><br><span class=\"line\">    tracker.add(bitmap);</span><br><span class=\"line\"></span><br><span class=\"line\">    puts++;</span><br><span class=\"line\">    currentSize += size;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class=\"line\">        Log.v(TAG, <span class=\"string\">&quot;Put bitmap in pool=&quot;</span> + strategy.logBitmap(bitmap));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    dump();</span><br><span class=\"line\"></span><br><span class=\"line\">    evict();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Bitmap을 Pool에 넣을 수 있는 조건을 충족시킨다면, strategy &amp; tracker에 bitmap이 들어가게된다. </p>\n<blockquote>\n<p><strong>참고</strong> Lru 기반인 strategy 는 최근에 들어온 bitmap일수록 리스트의 맨 앞으로 배치시켜야하는데, 그 로직이 <code>LruPoolStrategy</code> 구현체 내부에 존재하게 된다.</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Pool의 최대 사용량을 넘기면 크기를 줄여준다.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">trimToSize</span><span class=\"params\">(<span class=\"keyword\">long</span> size)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (currentSize &gt; size) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//LRU List에서 삭제한다.</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> Bitmap removed = strategy.removeLast();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (removed == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (Log.isLoggable(TAG, Log.WARN)) &#123;</span><br><span class=\"line\">                Log.w(TAG, <span class=\"string\">&quot;Size mismatch, resetting&quot;</span>);</span><br><span class=\"line\">                dumpUnchecked();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            currentSize = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// BitmapList에서 삭제한다. </span></span><br><span class=\"line\">        tracker.remove(removed);</span><br><span class=\"line\">        currentSize -= strategy.getSize(removed);</span><br><span class=\"line\">        evictions++;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (Log.isLoggable(TAG, Log.DEBUG)) &#123;</span><br><span class=\"line\">            Log.d(TAG, <span class=\"string\">&quot;Evicting bitmap=&quot;</span> + strategy.logBitmap(removed));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        dump();</span><br><span class=\"line\">        removed.recycle();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>trimToSize()를 이용하면 pool이 최대사용량을 넘어선 경우 참조를 가장 적게하고 있는 lastIndex 부터 객체를 지워가며 크기를 줄여줄 수 있다. </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"meta\">@Nullable</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Bitmap <span class=\"title\">get</span><span class=\"params\">(<span class=\"keyword\">int</span> width, <span class=\"keyword\">int</span> height, Bitmap.Config config)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> size = Util.getBitmapByteSize(width, height, config);</span><br><span class=\"line\">    Key key = keyPool.get(size);</span><br><span class=\"line\"></span><br><span class=\"line\">    Integer possibleSize = sortedSizes.ceilingKey(size);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (possibleSize != <span class=\"keyword\">null</span> &amp;&amp; possibleSize != size &amp;&amp; possibleSize &lt;= size * MAX_SIZE_MULTIPLE) &#123;</span><br><span class=\"line\">        keyPool.offer(key);</span><br><span class=\"line\">        key = keyPool.get(possibleSize);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">final</span> Bitmap result = groupedMap.get(key);</span><br><span class=\"line\">    <span class=\"comment\">// 비트맵을 찾은 경우, pool에서 제거한다.</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (result != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        result.reconfigure(width, height, config);</span><br><span class=\"line\">        decrementBitmapOfSize(possibleSize);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>이미지를 로드하기 위해 pool에서 필요한 비트맵을 가져온다.</p>\n<h2 id=\"Jetpack-Compose에서-이미지-라이브러리-사용하기\"><a href=\"#Jetpack-Compose에서-이미지-라이브러리-사용하기\" class=\"headerlink\" title=\"Jetpack Compose에서 이미지 라이브러리 사용하기\"></a>Jetpack Compose에서 이미지 라이브러리 사용하기</h2><p>Google 에서는 Jetpack Compose를 보다 편하게 사용하기 위한 라이브러리를 묶어서 제공한다.</p>\n<p><strong>Accompanist</strong> 라고 하는 GroupId를 가진 라이브러리 모음이다.</p>\n<blockquote>\n<p><strong>참고</strong> <a href=\"https://github.com/google/accompanist\">Google#Accompanist Repository</a></p>\n</blockquote>\n<p>Accompanist에서는 Glide와 Coil을 지원하고 있다.</p>\n<p>의존성 설정은 아래와 같다.</p>\n<figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">dependencies</span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    implementation <span class=\"string\">&quot;com.google.accompanist:accompanist-glide:0.11.1&quot;</span></span><br><span class=\"line\">    implementation <span class=\"string\">&quot;com.google.accompanist:accompanist-coil:0.11.1&quot;</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Glide는 아래와 같이 적용한다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Image(</span><br><span class=\"line\">    painter = rememberGlidePainter(</span><br><span class=\"line\">        request = <span class=\"string\">&quot;https://picsum.photos/300/300&quot;</span>,</span><br><span class=\"line\">        <span class=\"comment\">// placeHolder</span></span><br><span class=\"line\">    ),</span><br><span class=\"line\">    contentDescription = stringResource(R.string.image_content_desc)</span><br><span class=\"line\">)</span><br><span class=\"line\">Image(</span><br><span class=\"line\">    painter = rememberGlidePainter(</span><br><span class=\"line\">        request = <span class=\"string\">&quot;https://cataas.com/cat/gif&quot;</span>,</span><br><span class=\"line\">        <span class=\"comment\">// placeHolder</span></span><br><span class=\"line\">    ),</span><br><span class=\"line\">    contentDescription = <span class=\"literal\">null</span></span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<p>Coil은 아래와 같이 적용한다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Image(</span><br><span class=\"line\">    painter = rememberCoilPainter(</span><br><span class=\"line\">        request = <span class=\"string\">&quot;https://picsum.photos/300/300&quot;</span>,</span><br><span class=\"line\">        <span class=\"comment\">// placeHolder</span></span><br><span class=\"line\">    ),</span><br><span class=\"line\">    contentDescription = <span class=\"literal\">null</span></span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<p>Coil에서 gif를 렌더링하기 위해선 <code>coil-gif</code> 의존성을 추가한다.</p>\n<figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">dependencies</span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    implementation <span class=\"string\">&quot;com.google.accompanist:accompanist-glide:0.11.1&quot;</span></span><br><span class=\"line\">    implementation <span class=\"string\">&quot;com.google.accompanist:accompanist-coil:0.11.1&quot;</span></span><br><span class=\"line\">    <span class=\"comment\">// Coil 에서 gif 를 사용하기 위해서 추가</span></span><br><span class=\"line\">    implementation <span class=\"string\">&quot;io.coil-kt:coil-gif:1.2.2&quot;</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>아래와 같이 별도의 ImageLoader를 설정한다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">gifImageLoader</span><span class=\"params\">(context: <span class=\"type\">Context</span>)</span></span> = ImageLoader.Builder(context)</span><br><span class=\"line\">    .componentRegistry &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (SDK_INT &gt;= <span class=\"number\">28</span>) &#123;</span><br><span class=\"line\">        add(ImageDecoderDecoder(context))</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        add(GifDecoder())</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    .build()</span><br></pre></td></tr></table></figure>\n\n<p>Image의 적용은 아래와 같이 적용한다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Image(</span><br><span class=\"line\">    painter = rememberCoilPainter(</span><br><span class=\"line\">        request = <span class=\"string\">&quot;https://cataas.com/cat/gif&quot;</span>,</span><br><span class=\"line\">        imageLoader = gifImageLoader(LocalContext*.current),</span><br><span class=\"line\">    ),</span><br><span class=\"line\">    contentDescription = <span class=\"literal\">null</span></span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>"},{"title":"Image Loading and Caching Library Part 3 — Performance Test","date":"2021-06-23T18:00:00.000Z","cover":"https://androiddeepdive.github.io/Team-Blog/images/cover_image_library.png","_content":"\n<article class=\"message message-immersive is-primary\">\n    <div class=\"message-body\">\n        <i class=\"fas fa-pen-fancy mr-2\"></i>Writers<br>\n        by 곽욱현 @Knowre<br>\n        by 김남훈 @Naver<br>\n        by 배희성 @RocketPunch<br>\n        by 송시영 @SmartStudy<br>\n        by 옥수환 @Naver<br>\n        by 이기정 @BankSalad<br>\n        by 정세희 @BankSalad\n    </div>\n</article>\n\n<!-- more -->\n이미지 라이브러리들 중 Glide, Fresco, Coil에 대해서 성능 테스트를 해보자.\n\n성능 테스트에 사용한 기기는 `Pixel 4a`, 값의 측정은 `Android Studio Profiler`를 사용하였다.\n\n각 세트는 동일한 조건에서 테스트하였으며, 별도의 추가 옵션없이 각 라이브러리의 기본 세팅으로 테스트를 수행하였다.\n\n측정값은 이미지 로딩 전후로 CPU, Memory, Disk를 10번씩 측정한 후의 평균값이다.\n\n테스트 애플리케이션의 스토리지가 증가한 뒤, 스토리지를 비우고 다시 측정하였다.\n\n> **참고** 기본 세팅이니만큼 Picasso의 경우 거대한 이미지를 대부분 불러오지 못했다.\n\n### Case 1) 하나의 거대한 이미지를 출력하는 경우\n\n테스트에 쓰인 이미지는 `7,680 x 4,320`의 사이즈와 `4.29mb`의 용량을 가진 24-bit의 color depth를 가진 이미지이다.\n\n{% asset_img m7itaqy.png [one big image profiling] %}\n\n| Library | CPU | Memory | Disk |\n|:--:|:--:|:--:|:--:|\n|Coil|38.3%|4.26MB|X|\n|Glide|40.8%|3.41MB|0.21MB|\n|Fresco|40.2%|8.14MB|X|\n\n1개의 거대한 이미지의 경우 특기할만한 성능 차이는 존재하지 않았다.\n\n### Case 2) 동일한 이미지를 여러 번 출력하는 경우 \n\nCase 1의 이미지를 ScrollView에 50개 추가하여 테스트하였다.\n\n{% asset_img BntHJ2Y.png [50 big image profiling] %}\n\n| Library | CPU | Memory | Disk |\n|:--:|:--:|:--:|:--:|\n|Coil|93.6%|350.8MB|X|\n|Glide|45.4%|4.6MB|0.21MB|\n|Fresco|72.4%|8.4MB|X|\n\nCoil의 Cpu, Memory 사용량이 매우 크게 증가하였다.\n\nGlide는 앱을 끈 후 다시 로딩했을 때 딜레이가 없었어 재로딩 했을 때 매우 효율적으로 동작하였다.\n\n아래 세부 프로파일링을 보면 Coil이 Coroutine을 사용할 때 CPU, Memory가 정말 많이 사용된다는 것을 알 수 있다.\n\n아래는 Coil로 테스트하였을 때의 프로파일링 결과이다.\n\n{% asset_img rb1bMMt.png [50 big image profiling coil] %}\n\n아래는 Glide로 테스트하였을 때의 프로파일링 결과이다.\n\n{% asset_img 0oDUU69.png [50 big image profiling glide] %}\n\nGlide가 하나의 이미지를 여러개 불러올 때 제일 효율이 좋은 것으로 나타났다.\n\n### Case 3) 여러 이미지를 각각 출력해보는 경우 (feat_ ScrollView)\n\n2mb ~ 10mb 사이의 각기 다른 용량을 가진 이미지 10개를 ScrollView에 추가하여 테스트하였다.\n\n{% asset_img TIrybR8.png [10 different image profiling] %}\n\n| Library | CPU | Memory | Disk |\n|:--:|:--:|:--:|:--:|\n|Coil|88.6%|800MB|X|\n|Glide|89%|303.3MB|4.6MB|\n|Fresco|92.6%|276MB|X|\n\n캐싱을 기대할 수 없는 만큼 대체적으로 모두 CPU, Memory사용량이 올라갔다.\n\n그 중 Coil이 제일 많은 Memory를 사용하였다.\n\n### Case 4) 여러 이미지를 각각 출력해보는 경우 (feat_ RecyclerView)\n\nCase 3에서 사용한 이미지를 RecyclerView에 추가하여 테스트하였다.\n\n{% asset_img QafKUB1.png [10 different image recyclerView profiling] %}\n\n| Library | CPU | Memory | Disk |\n|:--:|:--:|:--:|:--:|\n|Coil|94%|800MB|X|\n|Glide|94%|270MB|4.52MB|\n|Fresco|94.6%|281MB|X|\n\nCoil의 경우 ScrollView에 로딩할 때보다 CPU 사용량이 증가한 것을 확인할 수 있었다.\n\n### 마무리 \n\nCoil이 Coroutine으로 만들어져 기대를 많이 하고 테스트를 해보았는데 생각보다 CPU, Memory의 사용량이 많았다.\n\nGilde는 정말로 모든 부분에서 최적화가 잘 되어있는 것으로 보이는 것에 비해, Picasso는 잘 사용하고 싶다면 정말 커스텀을 많이, 잘 해야될 필요가 있어보인다.\n\nFresco는 최적화가 정말 잘 되어있지만 러닝커브가 높다. 퍼포먼스 측면에서는 Glide와 제일 비슷하였다.\n\n## References\n\n### Members of Study\n- https://namhoon.kim/2021/05/25/android_deep_dive/017_Image%20Loading%20and%20Caching%20Library%20Part%201/\n- https://namhoon.kim/2021/06/01/android_deep_dive/018_Image%20Loading%20and%20Caching%20Library%20Part%202/\n- https://velog.io/@jshme/Android-Image-Loader-Library\n- https://velog.io/@jshme/Android-Hello-Out-Of-Memory\n- https://www.charlezz.com/wordpress/wp-content/uploads/2020/10/www.charlezz.com-glide-v4-glide-v4--by-charlezz.pdf\n\n### Official\n\n- [Android Developers#Drawble Resources](https://developer.android.com/guide/topics/resources/drawable-resource.html)\n- [Android Developers#Handling bitmaps](https://developer.android.com/topic/performance/graphics/index.html)\n- [Android Developers#LruCache](https://developer.android.com/reference/android/util/LruCache)\n- [androidx.collection.LruCache](https://developer.android.com/reference/androidx/collection/LruCache)\n- [Cache replacement policies#recently used](https://en.wikipedia.org/wiki/Cache_replacement_policies#Least_recently_used_(LRU))\n- [Google#Accompanist Repository](https://github.com/google/accompanist)\n\n- https://square.github.io/picasso/\n- https://bumptech.github.io/glide/\n- https://github.com/coil-kt/coil\n- https://frescolib.org\n- https://github.com/nostra13/Android-Universal-Image-Loader/wiki\n\n### ETC\n\n- https://futurestud.io/tutorials/glide-caching-basics\n- https://wooooooak.github.io/%EB%B2%88%EC%97%AD%ED%95%98%EB%A9%B0%20%EA%B3%B5%EB%B6%80%ED%95%98%EA%B8%B0/2021/02/21/How-The-Android-Image-Loading-Library-Glide-and-Fresco-Works/\n","source":"_posts/2021-06-24 Image Loading and Caching Library Part 3.md","raw":"---\ntitle: Image Loading and Caching Library Part 3 — Performance Test\ndate: 2021-06-24 03:00\ncover: https://androiddeepdive.github.io/Team-Blog/images/cover_image_library.png\ncategories:\n- Image Library\ntags:\n- Android\n- Image\n- Library\n---\n\n<article class=\"message message-immersive is-primary\">\n    <div class=\"message-body\">\n        <i class=\"fas fa-pen-fancy mr-2\"></i>Writers<br>\n        by 곽욱현 @Knowre<br>\n        by 김남훈 @Naver<br>\n        by 배희성 @RocketPunch<br>\n        by 송시영 @SmartStudy<br>\n        by 옥수환 @Naver<br>\n        by 이기정 @BankSalad<br>\n        by 정세희 @BankSalad\n    </div>\n</article>\n\n<!-- more -->\n이미지 라이브러리들 중 Glide, Fresco, Coil에 대해서 성능 테스트를 해보자.\n\n성능 테스트에 사용한 기기는 `Pixel 4a`, 값의 측정은 `Android Studio Profiler`를 사용하였다.\n\n각 세트는 동일한 조건에서 테스트하였으며, 별도의 추가 옵션없이 각 라이브러리의 기본 세팅으로 테스트를 수행하였다.\n\n측정값은 이미지 로딩 전후로 CPU, Memory, Disk를 10번씩 측정한 후의 평균값이다.\n\n테스트 애플리케이션의 스토리지가 증가한 뒤, 스토리지를 비우고 다시 측정하였다.\n\n> **참고** 기본 세팅이니만큼 Picasso의 경우 거대한 이미지를 대부분 불러오지 못했다.\n\n### Case 1) 하나의 거대한 이미지를 출력하는 경우\n\n테스트에 쓰인 이미지는 `7,680 x 4,320`의 사이즈와 `4.29mb`의 용량을 가진 24-bit의 color depth를 가진 이미지이다.\n\n{% asset_img m7itaqy.png [one big image profiling] %}\n\n| Library | CPU | Memory | Disk |\n|:--:|:--:|:--:|:--:|\n|Coil|38.3%|4.26MB|X|\n|Glide|40.8%|3.41MB|0.21MB|\n|Fresco|40.2%|8.14MB|X|\n\n1개의 거대한 이미지의 경우 특기할만한 성능 차이는 존재하지 않았다.\n\n### Case 2) 동일한 이미지를 여러 번 출력하는 경우 \n\nCase 1의 이미지를 ScrollView에 50개 추가하여 테스트하였다.\n\n{% asset_img BntHJ2Y.png [50 big image profiling] %}\n\n| Library | CPU | Memory | Disk |\n|:--:|:--:|:--:|:--:|\n|Coil|93.6%|350.8MB|X|\n|Glide|45.4%|4.6MB|0.21MB|\n|Fresco|72.4%|8.4MB|X|\n\nCoil의 Cpu, Memory 사용량이 매우 크게 증가하였다.\n\nGlide는 앱을 끈 후 다시 로딩했을 때 딜레이가 없었어 재로딩 했을 때 매우 효율적으로 동작하였다.\n\n아래 세부 프로파일링을 보면 Coil이 Coroutine을 사용할 때 CPU, Memory가 정말 많이 사용된다는 것을 알 수 있다.\n\n아래는 Coil로 테스트하였을 때의 프로파일링 결과이다.\n\n{% asset_img rb1bMMt.png [50 big image profiling coil] %}\n\n아래는 Glide로 테스트하였을 때의 프로파일링 결과이다.\n\n{% asset_img 0oDUU69.png [50 big image profiling glide] %}\n\nGlide가 하나의 이미지를 여러개 불러올 때 제일 효율이 좋은 것으로 나타났다.\n\n### Case 3) 여러 이미지를 각각 출력해보는 경우 (feat_ ScrollView)\n\n2mb ~ 10mb 사이의 각기 다른 용량을 가진 이미지 10개를 ScrollView에 추가하여 테스트하였다.\n\n{% asset_img TIrybR8.png [10 different image profiling] %}\n\n| Library | CPU | Memory | Disk |\n|:--:|:--:|:--:|:--:|\n|Coil|88.6%|800MB|X|\n|Glide|89%|303.3MB|4.6MB|\n|Fresco|92.6%|276MB|X|\n\n캐싱을 기대할 수 없는 만큼 대체적으로 모두 CPU, Memory사용량이 올라갔다.\n\n그 중 Coil이 제일 많은 Memory를 사용하였다.\n\n### Case 4) 여러 이미지를 각각 출력해보는 경우 (feat_ RecyclerView)\n\nCase 3에서 사용한 이미지를 RecyclerView에 추가하여 테스트하였다.\n\n{% asset_img QafKUB1.png [10 different image recyclerView profiling] %}\n\n| Library | CPU | Memory | Disk |\n|:--:|:--:|:--:|:--:|\n|Coil|94%|800MB|X|\n|Glide|94%|270MB|4.52MB|\n|Fresco|94.6%|281MB|X|\n\nCoil의 경우 ScrollView에 로딩할 때보다 CPU 사용량이 증가한 것을 확인할 수 있었다.\n\n### 마무리 \n\nCoil이 Coroutine으로 만들어져 기대를 많이 하고 테스트를 해보았는데 생각보다 CPU, Memory의 사용량이 많았다.\n\nGilde는 정말로 모든 부분에서 최적화가 잘 되어있는 것으로 보이는 것에 비해, Picasso는 잘 사용하고 싶다면 정말 커스텀을 많이, 잘 해야될 필요가 있어보인다.\n\nFresco는 최적화가 정말 잘 되어있지만 러닝커브가 높다. 퍼포먼스 측면에서는 Glide와 제일 비슷하였다.\n\n## References\n\n### Members of Study\n- https://namhoon.kim/2021/05/25/android_deep_dive/017_Image%20Loading%20and%20Caching%20Library%20Part%201/\n- https://namhoon.kim/2021/06/01/android_deep_dive/018_Image%20Loading%20and%20Caching%20Library%20Part%202/\n- https://velog.io/@jshme/Android-Image-Loader-Library\n- https://velog.io/@jshme/Android-Hello-Out-Of-Memory\n- https://www.charlezz.com/wordpress/wp-content/uploads/2020/10/www.charlezz.com-glide-v4-glide-v4--by-charlezz.pdf\n\n### Official\n\n- [Android Developers#Drawble Resources](https://developer.android.com/guide/topics/resources/drawable-resource.html)\n- [Android Developers#Handling bitmaps](https://developer.android.com/topic/performance/graphics/index.html)\n- [Android Developers#LruCache](https://developer.android.com/reference/android/util/LruCache)\n- [androidx.collection.LruCache](https://developer.android.com/reference/androidx/collection/LruCache)\n- [Cache replacement policies#recently used](https://en.wikipedia.org/wiki/Cache_replacement_policies#Least_recently_used_(LRU))\n- [Google#Accompanist Repository](https://github.com/google/accompanist)\n\n- https://square.github.io/picasso/\n- https://bumptech.github.io/glide/\n- https://github.com/coil-kt/coil\n- https://frescolib.org\n- https://github.com/nostra13/Android-Universal-Image-Loader/wiki\n\n### ETC\n\n- https://futurestud.io/tutorials/glide-caching-basics\n- https://wooooooak.github.io/%EB%B2%88%EC%97%AD%ED%95%98%EB%A9%B0%20%EA%B3%B5%EB%B6%80%ED%95%98%EA%B8%B0/2021/02/21/How-The-Android-Image-Loading-Library-Glide-and-Fresco-Works/\n","slug":"2021-06-24 Image Loading and Caching Library Part 3","published":1,"updated":"2021-07-25T13:29:15.183Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cksagj7lv001v3lrebxc2cl09","content":"<article class=\"message message-immersive is-primary\">\n    <div class=\"message-body\">\n        <i class=\"fas fa-pen-fancy mr-2\"></i>Writers<br>\n        by 곽욱현 @Knowre<br>\n        by 김남훈 @Naver<br>\n        by 배희성 @RocketPunch<br>\n        by 송시영 @SmartStudy<br>\n        by 옥수환 @Naver<br>\n        by 이기정 @BankSalad<br>\n        by 정세희 @BankSalad\n    </div>\n</article>\n\n<span id=\"more\"></span>\n<p>이미지 라이브러리들 중 Glide, Fresco, Coil에 대해서 성능 테스트를 해보자.</p>\n<p>성능 테스트에 사용한 기기는 <code>Pixel 4a</code>, 값의 측정은 <code>Android Studio Profiler</code>를 사용하였다.</p>\n<p>각 세트는 동일한 조건에서 테스트하였으며, 별도의 추가 옵션없이 각 라이브러리의 기본 세팅으로 테스트를 수행하였다.</p>\n<p>측정값은 이미지 로딩 전후로 CPU, Memory, Disk를 10번씩 측정한 후의 평균값이다.</p>\n<p>테스트 애플리케이션의 스토리지가 증가한 뒤, 스토리지를 비우고 다시 측정하였다.</p>\n<blockquote>\n<p><strong>참고</strong> 기본 세팅이니만큼 Picasso의 경우 거대한 이미지를 대부분 불러오지 못했다.</p>\n</blockquote>\n<h3 id=\"Case-1-하나의-거대한-이미지를-출력하는-경우\"><a href=\"#Case-1-하나의-거대한-이미지를-출력하는-경우\" class=\"headerlink\" title=\"Case 1) 하나의 거대한 이미지를 출력하는 경우\"></a>Case 1) 하나의 거대한 이미지를 출력하는 경우</h3><p>테스트에 쓰인 이미지는 <code>7,680 x 4,320</code>의 사이즈와 <code>4.29mb</code>의 용량을 가진 24-bit의 color depth를 가진 이미지이다.</p>\n<img src=\"/Team-Blog/2021/06/24/2021-06-24%20Image%20Loading%20and%20Caching%20Library%20Part%203/m7itaqy.png\" class=\"\" title=\"[one big image profiling]\">\n\n<table>\n<thead>\n<tr>\n<th align=\"center\">Library</th>\n<th align=\"center\">CPU</th>\n<th align=\"center\">Memory</th>\n<th align=\"center\">Disk</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">Coil</td>\n<td align=\"center\">38.3%</td>\n<td align=\"center\">4.26MB</td>\n<td align=\"center\">X</td>\n</tr>\n<tr>\n<td align=\"center\">Glide</td>\n<td align=\"center\">40.8%</td>\n<td align=\"center\">3.41MB</td>\n<td align=\"center\">0.21MB</td>\n</tr>\n<tr>\n<td align=\"center\">Fresco</td>\n<td align=\"center\">40.2%</td>\n<td align=\"center\">8.14MB</td>\n<td align=\"center\">X</td>\n</tr>\n</tbody></table>\n<p>1개의 거대한 이미지의 경우 특기할만한 성능 차이는 존재하지 않았다.</p>\n<h3 id=\"Case-2-동일한-이미지를-여러-번-출력하는-경우\"><a href=\"#Case-2-동일한-이미지를-여러-번-출력하는-경우\" class=\"headerlink\" title=\"Case 2) 동일한 이미지를 여러 번 출력하는 경우\"></a>Case 2) 동일한 이미지를 여러 번 출력하는 경우</h3><p>Case 1의 이미지를 ScrollView에 50개 추가하여 테스트하였다.</p>\n<img src=\"/Team-Blog/2021/06/24/2021-06-24%20Image%20Loading%20and%20Caching%20Library%20Part%203/BntHJ2Y.png\" class=\"\" title=\"[50 big image profiling]\">\n\n<table>\n<thead>\n<tr>\n<th align=\"center\">Library</th>\n<th align=\"center\">CPU</th>\n<th align=\"center\">Memory</th>\n<th align=\"center\">Disk</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">Coil</td>\n<td align=\"center\">93.6%</td>\n<td align=\"center\">350.8MB</td>\n<td align=\"center\">X</td>\n</tr>\n<tr>\n<td align=\"center\">Glide</td>\n<td align=\"center\">45.4%</td>\n<td align=\"center\">4.6MB</td>\n<td align=\"center\">0.21MB</td>\n</tr>\n<tr>\n<td align=\"center\">Fresco</td>\n<td align=\"center\">72.4%</td>\n<td align=\"center\">8.4MB</td>\n<td align=\"center\">X</td>\n</tr>\n</tbody></table>\n<p>Coil의 Cpu, Memory 사용량이 매우 크게 증가하였다.</p>\n<p>Glide는 앱을 끈 후 다시 로딩했을 때 딜레이가 없었어 재로딩 했을 때 매우 효율적으로 동작하였다.</p>\n<p>아래 세부 프로파일링을 보면 Coil이 Coroutine을 사용할 때 CPU, Memory가 정말 많이 사용된다는 것을 알 수 있다.</p>\n<p>아래는 Coil로 테스트하였을 때의 프로파일링 결과이다.</p>\n<img src=\"/Team-Blog/2021/06/24/2021-06-24%20Image%20Loading%20and%20Caching%20Library%20Part%203/rb1bMMt.png\" class=\"\" title=\"[50 big image profiling coil]\">\n\n<p>아래는 Glide로 테스트하였을 때의 프로파일링 결과이다.</p>\n<img src=\"/Team-Blog/2021/06/24/2021-06-24%20Image%20Loading%20and%20Caching%20Library%20Part%203/0oDUU69.png\" class=\"\" title=\"[50 big image profiling glide]\">\n\n<p>Glide가 하나의 이미지를 여러개 불러올 때 제일 효율이 좋은 것으로 나타났다.</p>\n<h3 id=\"Case-3-여러-이미지를-각각-출력해보는-경우-feat-ScrollView\"><a href=\"#Case-3-여러-이미지를-각각-출력해보는-경우-feat-ScrollView\" class=\"headerlink\" title=\"Case 3) 여러 이미지를 각각 출력해보는 경우 (feat_ ScrollView)\"></a>Case 3) 여러 이미지를 각각 출력해보는 경우 (feat_ ScrollView)</h3><p>2mb ~ 10mb 사이의 각기 다른 용량을 가진 이미지 10개를 ScrollView에 추가하여 테스트하였다.</p>\n<img src=\"/Team-Blog/2021/06/24/2021-06-24%20Image%20Loading%20and%20Caching%20Library%20Part%203/TIrybR8.png\" class=\"\" title=\"[10 different image profiling]\">\n\n<table>\n<thead>\n<tr>\n<th align=\"center\">Library</th>\n<th align=\"center\">CPU</th>\n<th align=\"center\">Memory</th>\n<th align=\"center\">Disk</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">Coil</td>\n<td align=\"center\">88.6%</td>\n<td align=\"center\">800MB</td>\n<td align=\"center\">X</td>\n</tr>\n<tr>\n<td align=\"center\">Glide</td>\n<td align=\"center\">89%</td>\n<td align=\"center\">303.3MB</td>\n<td align=\"center\">4.6MB</td>\n</tr>\n<tr>\n<td align=\"center\">Fresco</td>\n<td align=\"center\">92.6%</td>\n<td align=\"center\">276MB</td>\n<td align=\"center\">X</td>\n</tr>\n</tbody></table>\n<p>캐싱을 기대할 수 없는 만큼 대체적으로 모두 CPU, Memory사용량이 올라갔다.</p>\n<p>그 중 Coil이 제일 많은 Memory를 사용하였다.</p>\n<h3 id=\"Case-4-여러-이미지를-각각-출력해보는-경우-feat-RecyclerView\"><a href=\"#Case-4-여러-이미지를-각각-출력해보는-경우-feat-RecyclerView\" class=\"headerlink\" title=\"Case 4) 여러 이미지를 각각 출력해보는 경우 (feat_ RecyclerView)\"></a>Case 4) 여러 이미지를 각각 출력해보는 경우 (feat_ RecyclerView)</h3><p>Case 3에서 사용한 이미지를 RecyclerView에 추가하여 테스트하였다.</p>\n<img src=\"/Team-Blog/2021/06/24/2021-06-24%20Image%20Loading%20and%20Caching%20Library%20Part%203/QafKUB1.png\" class=\"\" title=\"[10 different image recyclerView profiling]\">\n\n<table>\n<thead>\n<tr>\n<th align=\"center\">Library</th>\n<th align=\"center\">CPU</th>\n<th align=\"center\">Memory</th>\n<th align=\"center\">Disk</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">Coil</td>\n<td align=\"center\">94%</td>\n<td align=\"center\">800MB</td>\n<td align=\"center\">X</td>\n</tr>\n<tr>\n<td align=\"center\">Glide</td>\n<td align=\"center\">94%</td>\n<td align=\"center\">270MB</td>\n<td align=\"center\">4.52MB</td>\n</tr>\n<tr>\n<td align=\"center\">Fresco</td>\n<td align=\"center\">94.6%</td>\n<td align=\"center\">281MB</td>\n<td align=\"center\">X</td>\n</tr>\n</tbody></table>\n<p>Coil의 경우 ScrollView에 로딩할 때보다 CPU 사용량이 증가한 것을 확인할 수 있었다.</p>\n<h3 id=\"마무리\"><a href=\"#마무리\" class=\"headerlink\" title=\"마무리\"></a>마무리</h3><p>Coil이 Coroutine으로 만들어져 기대를 많이 하고 테스트를 해보았는데 생각보다 CPU, Memory의 사용량이 많았다.</p>\n<p>Gilde는 정말로 모든 부분에서 최적화가 잘 되어있는 것으로 보이는 것에 비해, Picasso는 잘 사용하고 싶다면 정말 커스텀을 많이, 잘 해야될 필요가 있어보인다.</p>\n<p>Fresco는 최적화가 정말 잘 되어있지만 러닝커브가 높다. 퍼포먼스 측면에서는 Glide와 제일 비슷하였다.</p>\n<h2 id=\"References\"><a href=\"#References\" class=\"headerlink\" title=\"References\"></a>References</h2><h3 id=\"Members-of-Study\"><a href=\"#Members-of-Study\" class=\"headerlink\" title=\"Members of Study\"></a>Members of Study</h3><ul>\n<li><a href=\"https://namhoon.kim/2021/05/25/android_deep_dive/017_Image%20Loading%20and%20Caching%20Library%20Part%201/\">https://namhoon.kim/2021/05/25/android_deep_dive/017_Image%20Loading%20and%20Caching%20Library%20Part%201/</a></li>\n<li><a href=\"https://namhoon.kim/2021/06/01/android_deep_dive/018_Image%20Loading%20and%20Caching%20Library%20Part%202/\">https://namhoon.kim/2021/06/01/android_deep_dive/018_Image%20Loading%20and%20Caching%20Library%20Part%202/</a></li>\n<li><a href=\"https://velog.io/@jshme/Android-Image-Loader-Library\">https://velog.io/@jshme/Android-Image-Loader-Library</a></li>\n<li><a href=\"https://velog.io/@jshme/Android-Hello-Out-Of-Memory\">https://velog.io/@jshme/Android-Hello-Out-Of-Memory</a></li>\n<li><a href=\"https://www.charlezz.com/wordpress/wp-content/uploads/2020/10/www.charlezz.com-glide-v4-glide-v4--by-charlezz.pdf\">https://www.charlezz.com/wordpress/wp-content/uploads/2020/10/www.charlezz.com-glide-v4-glide-v4--by-charlezz.pdf</a></li>\n</ul>\n<h3 id=\"Official\"><a href=\"#Official\" class=\"headerlink\" title=\"Official\"></a>Official</h3><ul>\n<li><p><a href=\"https://developer.android.com/guide/topics/resources/drawable-resource.html\">Android Developers#Drawble Resources</a></p>\n</li>\n<li><p><a href=\"https://developer.android.com/topic/performance/graphics/index.html\">Android Developers#Handling bitmaps</a></p>\n</li>\n<li><p><a href=\"https://developer.android.com/reference/android/util/LruCache\">Android Developers#LruCache</a></p>\n</li>\n<li><p><a href=\"https://developer.android.com/reference/androidx/collection/LruCache\">androidx.collection.LruCache</a></p>\n</li>\n<li><p><a href=\"https://en.wikipedia.org/wiki/Cache_replacement_policies#Least_recently_used_(LRU)\">Cache replacement policies#recently used</a></p>\n</li>\n<li><p><a href=\"https://github.com/google/accompanist\">Google#Accompanist Repository</a></p>\n</li>\n<li><p><a href=\"https://square.github.io/picasso/\">https://square.github.io/picasso/</a></p>\n</li>\n<li><p><a href=\"https://bumptech.github.io/glide/\">https://bumptech.github.io/glide/</a></p>\n</li>\n<li><p><a href=\"https://github.com/coil-kt/coil\">https://github.com/coil-kt/coil</a></p>\n</li>\n<li><p><a href=\"https://frescolib.org/\">https://frescolib.org</a></p>\n</li>\n<li><p><a href=\"https://github.com/nostra13/Android-Universal-Image-Loader/wiki\">https://github.com/nostra13/Android-Universal-Image-Loader/wiki</a></p>\n</li>\n</ul>\n<h3 id=\"ETC\"><a href=\"#ETC\" class=\"headerlink\" title=\"ETC\"></a>ETC</h3><ul>\n<li><a href=\"https://futurestud.io/tutorials/glide-caching-basics\">https://futurestud.io/tutorials/glide-caching-basics</a></li>\n<li><a href=\"https://wooooooak.github.io/%EB%B2%88%EC%97%AD%ED%95%98%EB%A9%B0%20%EA%B3%B5%EB%B6%80%ED%95%98%EA%B8%B0/2021/02/21/How-The-Android-Image-Loading-Library-Glide-and-Fresco-Works/\">https://wooooooak.github.io/%EB%B2%88%EC%97%AD%ED%95%98%EB%A9%B0%20%EA%B3%B5%EB%B6%80%ED%95%98%EA%B8%B0/2021/02/21/How-The-Android-Image-Loading-Library-Glide-and-Fresco-Works/</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<article class=\"message message-immersive is-primary\">\n    <div class=\"message-body\">\n        <i class=\"fas fa-pen-fancy mr-2\"></i>Writers<br>\n        by 곽욱현 @Knowre<br>\n        by 김남훈 @Naver<br>\n        by 배희성 @RocketPunch<br>\n        by 송시영 @SmartStudy<br>\n        by 옥수환 @Naver<br>\n        by 이기정 @BankSalad<br>\n        by 정세희 @BankSalad\n    </div>\n</article>","more":"<p>이미지 라이브러리들 중 Glide, Fresco, Coil에 대해서 성능 테스트를 해보자.</p>\n<p>성능 테스트에 사용한 기기는 <code>Pixel 4a</code>, 값의 측정은 <code>Android Studio Profiler</code>를 사용하였다.</p>\n<p>각 세트는 동일한 조건에서 테스트하였으며, 별도의 추가 옵션없이 각 라이브러리의 기본 세팅으로 테스트를 수행하였다.</p>\n<p>측정값은 이미지 로딩 전후로 CPU, Memory, Disk를 10번씩 측정한 후의 평균값이다.</p>\n<p>테스트 애플리케이션의 스토리지가 증가한 뒤, 스토리지를 비우고 다시 측정하였다.</p>\n<blockquote>\n<p><strong>참고</strong> 기본 세팅이니만큼 Picasso의 경우 거대한 이미지를 대부분 불러오지 못했다.</p>\n</blockquote>\n<h3 id=\"Case-1-하나의-거대한-이미지를-출력하는-경우\"><a href=\"#Case-1-하나의-거대한-이미지를-출력하는-경우\" class=\"headerlink\" title=\"Case 1) 하나의 거대한 이미지를 출력하는 경우\"></a>Case 1) 하나의 거대한 이미지를 출력하는 경우</h3><p>테스트에 쓰인 이미지는 <code>7,680 x 4,320</code>의 사이즈와 <code>4.29mb</code>의 용량을 가진 24-bit의 color depth를 가진 이미지이다.</p>\n<img src=\"/Team-Blog/2021/06/24/2021-06-24%20Image%20Loading%20and%20Caching%20Library%20Part%203/m7itaqy.png\" class=\"\" title=\"[one big image profiling]\">\n\n<table>\n<thead>\n<tr>\n<th align=\"center\">Library</th>\n<th align=\"center\">CPU</th>\n<th align=\"center\">Memory</th>\n<th align=\"center\">Disk</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">Coil</td>\n<td align=\"center\">38.3%</td>\n<td align=\"center\">4.26MB</td>\n<td align=\"center\">X</td>\n</tr>\n<tr>\n<td align=\"center\">Glide</td>\n<td align=\"center\">40.8%</td>\n<td align=\"center\">3.41MB</td>\n<td align=\"center\">0.21MB</td>\n</tr>\n<tr>\n<td align=\"center\">Fresco</td>\n<td align=\"center\">40.2%</td>\n<td align=\"center\">8.14MB</td>\n<td align=\"center\">X</td>\n</tr>\n</tbody></table>\n<p>1개의 거대한 이미지의 경우 특기할만한 성능 차이는 존재하지 않았다.</p>\n<h3 id=\"Case-2-동일한-이미지를-여러-번-출력하는-경우\"><a href=\"#Case-2-동일한-이미지를-여러-번-출력하는-경우\" class=\"headerlink\" title=\"Case 2) 동일한 이미지를 여러 번 출력하는 경우\"></a>Case 2) 동일한 이미지를 여러 번 출력하는 경우</h3><p>Case 1의 이미지를 ScrollView에 50개 추가하여 테스트하였다.</p>\n<img src=\"/Team-Blog/2021/06/24/2021-06-24%20Image%20Loading%20and%20Caching%20Library%20Part%203/BntHJ2Y.png\" class=\"\" title=\"[50 big image profiling]\">\n\n<table>\n<thead>\n<tr>\n<th align=\"center\">Library</th>\n<th align=\"center\">CPU</th>\n<th align=\"center\">Memory</th>\n<th align=\"center\">Disk</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">Coil</td>\n<td align=\"center\">93.6%</td>\n<td align=\"center\">350.8MB</td>\n<td align=\"center\">X</td>\n</tr>\n<tr>\n<td align=\"center\">Glide</td>\n<td align=\"center\">45.4%</td>\n<td align=\"center\">4.6MB</td>\n<td align=\"center\">0.21MB</td>\n</tr>\n<tr>\n<td align=\"center\">Fresco</td>\n<td align=\"center\">72.4%</td>\n<td align=\"center\">8.4MB</td>\n<td align=\"center\">X</td>\n</tr>\n</tbody></table>\n<p>Coil의 Cpu, Memory 사용량이 매우 크게 증가하였다.</p>\n<p>Glide는 앱을 끈 후 다시 로딩했을 때 딜레이가 없었어 재로딩 했을 때 매우 효율적으로 동작하였다.</p>\n<p>아래 세부 프로파일링을 보면 Coil이 Coroutine을 사용할 때 CPU, Memory가 정말 많이 사용된다는 것을 알 수 있다.</p>\n<p>아래는 Coil로 테스트하였을 때의 프로파일링 결과이다.</p>\n<img src=\"/Team-Blog/2021/06/24/2021-06-24%20Image%20Loading%20and%20Caching%20Library%20Part%203/rb1bMMt.png\" class=\"\" title=\"[50 big image profiling coil]\">\n\n<p>아래는 Glide로 테스트하였을 때의 프로파일링 결과이다.</p>\n<img src=\"/Team-Blog/2021/06/24/2021-06-24%20Image%20Loading%20and%20Caching%20Library%20Part%203/0oDUU69.png\" class=\"\" title=\"[50 big image profiling glide]\">\n\n<p>Glide가 하나의 이미지를 여러개 불러올 때 제일 효율이 좋은 것으로 나타났다.</p>\n<h3 id=\"Case-3-여러-이미지를-각각-출력해보는-경우-feat-ScrollView\"><a href=\"#Case-3-여러-이미지를-각각-출력해보는-경우-feat-ScrollView\" class=\"headerlink\" title=\"Case 3) 여러 이미지를 각각 출력해보는 경우 (feat_ ScrollView)\"></a>Case 3) 여러 이미지를 각각 출력해보는 경우 (feat_ ScrollView)</h3><p>2mb ~ 10mb 사이의 각기 다른 용량을 가진 이미지 10개를 ScrollView에 추가하여 테스트하였다.</p>\n<img src=\"/Team-Blog/2021/06/24/2021-06-24%20Image%20Loading%20and%20Caching%20Library%20Part%203/TIrybR8.png\" class=\"\" title=\"[10 different image profiling]\">\n\n<table>\n<thead>\n<tr>\n<th align=\"center\">Library</th>\n<th align=\"center\">CPU</th>\n<th align=\"center\">Memory</th>\n<th align=\"center\">Disk</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">Coil</td>\n<td align=\"center\">88.6%</td>\n<td align=\"center\">800MB</td>\n<td align=\"center\">X</td>\n</tr>\n<tr>\n<td align=\"center\">Glide</td>\n<td align=\"center\">89%</td>\n<td align=\"center\">303.3MB</td>\n<td align=\"center\">4.6MB</td>\n</tr>\n<tr>\n<td align=\"center\">Fresco</td>\n<td align=\"center\">92.6%</td>\n<td align=\"center\">276MB</td>\n<td align=\"center\">X</td>\n</tr>\n</tbody></table>\n<p>캐싱을 기대할 수 없는 만큼 대체적으로 모두 CPU, Memory사용량이 올라갔다.</p>\n<p>그 중 Coil이 제일 많은 Memory를 사용하였다.</p>\n<h3 id=\"Case-4-여러-이미지를-각각-출력해보는-경우-feat-RecyclerView\"><a href=\"#Case-4-여러-이미지를-각각-출력해보는-경우-feat-RecyclerView\" class=\"headerlink\" title=\"Case 4) 여러 이미지를 각각 출력해보는 경우 (feat_ RecyclerView)\"></a>Case 4) 여러 이미지를 각각 출력해보는 경우 (feat_ RecyclerView)</h3><p>Case 3에서 사용한 이미지를 RecyclerView에 추가하여 테스트하였다.</p>\n<img src=\"/Team-Blog/2021/06/24/2021-06-24%20Image%20Loading%20and%20Caching%20Library%20Part%203/QafKUB1.png\" class=\"\" title=\"[10 different image recyclerView profiling]\">\n\n<table>\n<thead>\n<tr>\n<th align=\"center\">Library</th>\n<th align=\"center\">CPU</th>\n<th align=\"center\">Memory</th>\n<th align=\"center\">Disk</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">Coil</td>\n<td align=\"center\">94%</td>\n<td align=\"center\">800MB</td>\n<td align=\"center\">X</td>\n</tr>\n<tr>\n<td align=\"center\">Glide</td>\n<td align=\"center\">94%</td>\n<td align=\"center\">270MB</td>\n<td align=\"center\">4.52MB</td>\n</tr>\n<tr>\n<td align=\"center\">Fresco</td>\n<td align=\"center\">94.6%</td>\n<td align=\"center\">281MB</td>\n<td align=\"center\">X</td>\n</tr>\n</tbody></table>\n<p>Coil의 경우 ScrollView에 로딩할 때보다 CPU 사용량이 증가한 것을 확인할 수 있었다.</p>\n<h3 id=\"마무리\"><a href=\"#마무리\" class=\"headerlink\" title=\"마무리\"></a>마무리</h3><p>Coil이 Coroutine으로 만들어져 기대를 많이 하고 테스트를 해보았는데 생각보다 CPU, Memory의 사용량이 많았다.</p>\n<p>Gilde는 정말로 모든 부분에서 최적화가 잘 되어있는 것으로 보이는 것에 비해, Picasso는 잘 사용하고 싶다면 정말 커스텀을 많이, 잘 해야될 필요가 있어보인다.</p>\n<p>Fresco는 최적화가 정말 잘 되어있지만 러닝커브가 높다. 퍼포먼스 측면에서는 Glide와 제일 비슷하였다.</p>\n<h2 id=\"References\"><a href=\"#References\" class=\"headerlink\" title=\"References\"></a>References</h2><h3 id=\"Members-of-Study\"><a href=\"#Members-of-Study\" class=\"headerlink\" title=\"Members of Study\"></a>Members of Study</h3><ul>\n<li><a href=\"https://namhoon.kim/2021/05/25/android_deep_dive/017_Image%20Loading%20and%20Caching%20Library%20Part%201/\">https://namhoon.kim/2021/05/25/android_deep_dive/017_Image%20Loading%20and%20Caching%20Library%20Part%201/</a></li>\n<li><a href=\"https://namhoon.kim/2021/06/01/android_deep_dive/018_Image%20Loading%20and%20Caching%20Library%20Part%202/\">https://namhoon.kim/2021/06/01/android_deep_dive/018_Image%20Loading%20and%20Caching%20Library%20Part%202/</a></li>\n<li><a href=\"https://velog.io/@jshme/Android-Image-Loader-Library\">https://velog.io/@jshme/Android-Image-Loader-Library</a></li>\n<li><a href=\"https://velog.io/@jshme/Android-Hello-Out-Of-Memory\">https://velog.io/@jshme/Android-Hello-Out-Of-Memory</a></li>\n<li><a href=\"https://www.charlezz.com/wordpress/wp-content/uploads/2020/10/www.charlezz.com-glide-v4-glide-v4--by-charlezz.pdf\">https://www.charlezz.com/wordpress/wp-content/uploads/2020/10/www.charlezz.com-glide-v4-glide-v4--by-charlezz.pdf</a></li>\n</ul>\n<h3 id=\"Official\"><a href=\"#Official\" class=\"headerlink\" title=\"Official\"></a>Official</h3><ul>\n<li><p><a href=\"https://developer.android.com/guide/topics/resources/drawable-resource.html\">Android Developers#Drawble Resources</a></p>\n</li>\n<li><p><a href=\"https://developer.android.com/topic/performance/graphics/index.html\">Android Developers#Handling bitmaps</a></p>\n</li>\n<li><p><a href=\"https://developer.android.com/reference/android/util/LruCache\">Android Developers#LruCache</a></p>\n</li>\n<li><p><a href=\"https://developer.android.com/reference/androidx/collection/LruCache\">androidx.collection.LruCache</a></p>\n</li>\n<li><p><a href=\"https://en.wikipedia.org/wiki/Cache_replacement_policies#Least_recently_used_(LRU)\">Cache replacement policies#recently used</a></p>\n</li>\n<li><p><a href=\"https://github.com/google/accompanist\">Google#Accompanist Repository</a></p>\n</li>\n<li><p><a href=\"https://square.github.io/picasso/\">https://square.github.io/picasso/</a></p>\n</li>\n<li><p><a href=\"https://bumptech.github.io/glide/\">https://bumptech.github.io/glide/</a></p>\n</li>\n<li><p><a href=\"https://github.com/coil-kt/coil\">https://github.com/coil-kt/coil</a></p>\n</li>\n<li><p><a href=\"https://frescolib.org/\">https://frescolib.org</a></p>\n</li>\n<li><p><a href=\"https://github.com/nostra13/Android-Universal-Image-Loader/wiki\">https://github.com/nostra13/Android-Universal-Image-Loader/wiki</a></p>\n</li>\n</ul>\n<h3 id=\"ETC\"><a href=\"#ETC\" class=\"headerlink\" title=\"ETC\"></a>ETC</h3><ul>\n<li><a href=\"https://futurestud.io/tutorials/glide-caching-basics\">https://futurestud.io/tutorials/glide-caching-basics</a></li>\n<li><a href=\"https://wooooooak.github.io/%EB%B2%88%EC%97%AD%ED%95%98%EB%A9%B0%20%EA%B3%B5%EB%B6%80%ED%95%98%EA%B8%B0/2021/02/21/How-The-Android-Image-Loading-Library-Glide-and-Fresco-Works/\">https://wooooooak.github.io/%EB%B2%88%EC%97%AD%ED%95%98%EB%A9%B0%20%EA%B3%B5%EB%B6%80%ED%95%98%EA%B8%B0/2021/02/21/How-The-Android-Image-Loading-Library-Glide-and-Fresco-Works/</a></li>\n</ul>"},{"title":"Kotlin Symbol Processing Api Part 1 — Annotation과 KAPT","date":"2021-07-20T16:00:00.000Z","cover":"https://androiddeepdive.github.io/Team-Blog/images/cover_ksp.png","_content":"\n<article class=\"message message-immersive is-primary\">\n    <div class=\"message-body\">\n        <i class=\"fas fa-pen-fancy mr-2\"></i>Writers<br>\n        by 곽욱현 @Knowre<br>\n        by 김남훈 @Naver<br>\n        by 송시영 @SmartStudy<br>\n        by 옥수환 @Naver<br>\n        by 이기정 @BankSalad<br>\n        by 정세희 @BankSalad\n    </div>\n</article>\n\n\n<!-- more -->\n\n## Annotation\n\n`Annotation Processor`이란 용어는 낯설더라도, 아래와 같은 코드들은 개발하면서 종종 보았을 것이다.\n\n```java\n@Overide\n@NonNull\n@Nallable\n```\n\n이러한 코드를 **Annotation**이라고 한다. \n\n**Annotation** 은 소스 코드에 추가 할 수 있는 메타데이터의 한 형태로 컴파일러가 이를 참조 할 수 있도록 한다.\n\n이 참조를 통해 미리 지정된 코드를 생성하기 위한 용도로 사용된다. Android 뿐만 아니라 Spring Framework 등을 개발할때에도 자주 활용한다.\n\n다음의 오라클 문서에서 발췌한 Annotation의 정의를 살펴보자.\n\n> Annotations, a form of metadata, provide data about a program that is not part of the program itself. Annotations have no direct effect on the operation of the code they annotate.\n\n문서의 내용을 해석하면 \n\n> Annotation은 일종의 메타데이터 형태이며, 프로그램의 일부가 아니라 프로그램에 대한 정보를 제공한다.\n> Annotation 자체로는 실행되는 코드에 직접적인 영향을 미치지 않는다.\n\nAnnotation은 Java 5부터 지원하고 있으며, 주로 다음과 같은 용도로 사용된다.\n\n**1. Information for the compiler**\n컴파일러가 에러를 검출하거나, 경고를 표시하지 않도록 사전에 정보를 전달한다.\n\n**2. Compile-time and deployment-time processing**\n코드나 xml 파일 등을 컴파일 타임에 생성할 수 있도록 처리한다.\n\n**3. Runtime processing**\n몇몇 annotation들은 런타임에도 검사를 수행하도록 처리해준다.\n\n> **참고** [Oracle JavaDoc#Annotations](https://docs.oracle.com/javase/tutorial/java/annotations/index.html)\n\n### 이미 정의된 Annotation 살펴보기\n\n`java.lang` 패키지에는 자바에서 제공하는 Annotation들이 있다. 대표적인 것 두 가지만 가지 살펴보자.\n\n- `@Deprecated` : deprecated 됐음을 의미하며 더 이상 쓰지 말 것을 권장할 때 사용한다. 이 Annotation이 달린 코드를 사용하면 컴파일러는 경고를 내뱉는다.\n\n- `@SuppressWarnings` : 이 Annotation은 컴파일러가 생성할 경고를 억제하도록 지시한다.\n\n  ```java\n  @SuppressWarnings(\"deprecation\")\n  void useDeprecatedMethod() {\n    // deprecation warning\n    // - suppressed\n    objectOne.deprecatedMethod();\n  }\n  ```\n\n`java.lang` 하위의 `annotation` 패키지 즉 `java.lang.annotation` 패키지에서는 **Meta Annotation** 이라고 불리는 것들이 존재한다.\n\n- `@Retention` : Retention Annotation은 표기된 Annotation이 저장되는 방법을 지정한다.\n  - `RetentionPolicy.SOURCE` : 소스 코드에서만 유지되며, 컴파일러에서는 무시된다.\n  - `RetentionPolicy.CLASS` : 컴파일 타임에 컴파일러에 의해 유지되지만, JVM에서는 무시된다.\n  - `RetentionPolicy.RUNTIME` : JVM에 의해서 유지되므로 런타임에서 사용가능하다.\n- `@Documented` : Annotation이 사용될 때 마다 해당 element가 Javadoc에 문서화 되어야 함을 나타낸다.\n- `@Target` : Annotation을 적용할 수 있는 Java Elements 종류를 제한한다.\n- `@Inherited` : super class 로부터 상속될 수 있는 Annotation 타입이다. class 선언시에만 적용.\n\n이 Meta Annotation의 특징은 다른 Annotation에 적용이 가능한 Annotation이라는 점이다.\n\nAndroid 앱 개발시에는 `java.lang` 대신 `androidx.annotation` 패키지를 참조하면 다양한 Annotation을 활용할 수 있다.\n\n`androidx.annotation` 패키지에 속한 annotation 목록은 아래 링크를 참고하자.\n\n> **참고** [Android Developers#androidx.annotation](https://developer.android.com/reference/androidx/annotation/package-summary)\n\n\n### Annotation Processor\n\n앞서 소개한 Annotation의 용도를 사용하기 위해서 **Annotation Processor**가 필요하다. \n\nAnnotation Processor는 Java 컴파일러 플러그인의 일종으로, 컴파일러에게 어떠한 요소(클래스, 메서드, 필드 등)에 annotation이 추가 되어있는지 확인하도록 한다.\n\n컴파일러는 컴파일 타임에 코드베이스를 검사하거나 확인된 정보를 통해 새로운 코드를 생성하는 식으로 동작하며, 주로 개발자가 정의한 태스크를 자동화하거나 보일러 플레이트 작성을 줄이는 용도로 사용된다.\n\nAnnotation Processor의 특징을 정리하자면 다음과 같다.\n\n- 컴파일 타임에 특정 작업을 수행한다.\n- 리플렉션없이 프로그램의 의미 및 구조를 파악할 수 있게 된다.\n- 자동으로 보일러 플레이트를 생성할 수 있게 된다.\n\n#### Annotation processor 실행 순서\n\nAnnotation processor는 여러 라운드에 걸쳐 수행된다.\n\n{% asset_img processing_rounds.png [Processing rounds] %}\n\n실행 순서를 간단히 정리하자면 다음과 같다.\n\n1. 등록된 Annotation processor들과 함께 컴파일러가 시작된다.\n2. Annotation processor들이 작성된 Annotation을 기반으로 코드 검사 및 생성을 수행한다.\n3. 컴파일러가 모든 Annotation processor의 작업이 끝났는지 확인하고, 그렇지 않다면 2번을 반복한다.\n4. 모든 처리가 끝난다면 전체 코드에 대한 컴파일을 시작한다. (이후 프로세스는 기존과 동일)\n\n#### Android에서 Annotation Processor를 사용하는 라이브러리들\n\n**Room** \n\nAndroid에서 SQLite에 대한 추상화를 제공하는 Room 라이브러리에도 Annotation Processor가 적용되어 있다.\n\n아래는 대표적인 예제인 User 관련 코드이다.\n\n```kotlin\n// User.kt\n@Entity\ndata class User(\n    @PrimaryKey val uid: Int,\n    @ColumnInfo(name = \"first_name\") val firstName: String?,\n    @ColumnInfo(name = \"last_name\") val lastName: String?\n)\n```\n\n```kotlin\n// UserDao.kt\n@Dao\ninterface UserDao {\n    @Query(\"SELECT * FROM user\")\n    fun getAll(): List<User>\n\n    @Query(\"SELECT * FROM user WHERE uid IN (:userIds)\")\n    fun loadAllByIds(userIds: IntArray): List<User>\n\n    @Query(\"SELECT * FROM user WHERE first_name LIKE :first AND \" +\n            \"last_name LIKE :last LIMIT 1\")\n    fun findByName(first: String, last: String): User\n\n    @Insert\n    fun insertAll(vararg users: User)\n\n    @Delete\n    fun delete(user: User)\n}\n```\n\n```kotlin\n// AppDatabase.kt\n@Database(entities = arrayOf(User::class), version = 1)\nabstract class AppDatabase : RoomDatabase() {\n    abstract fun userDao(): UserDao\n}\n```\n\n위의 에졔에서 쓰인 Annotation들은 `@Entity`, `@PrimaryKey`, `@ColumnInfo`, `@Dao`, `@Query`, `@Insert`, `@Delete`이다.\n\n이 Annotation들의 구현체를 확인해보자.\n\n```java\n// Entity.java\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.CLASS)\npublic @interface Entity {\n    String tableName() default \"\";\n    Index[] indices() default {};\n    boolean inheritSuperIndices() default false;\n    String[] primaryKeys() default {};\n    ForeignKey[] foreignKeys() default {};\n    String[] ignoredColumns() default {};\n}\n```\n\n```java\n// PrimaryKey.java\n@Target({ElementType.FIELD, ElementType.METHOD})\n@Retention(RetentionPolicy.CLASS)\npublic @interface PrimaryKey {\n    boolean autoGenerate() default false;\n}\n```\n\n```java\n// ColumnInfo.java\n@Target({ElementType.FIELD, ElementType.METHOD})\n@Retention(RetentionPolicy.CLASS)\npublic @interface ColumnInfo {\n    String name() default INHERIT_FIELD_NAME;\n    @SuppressWarnings(\"unused\") @SQLiteTypeAffinity int typeAffinity() default UNDEFINED;\n    boolean index() default false;\n    String defaultValue() default VALUE_UNSPECIFIED;\n    String INHERIT_FIELD_NAME = \"[field-name]\";\n\n\n    int UNDEFINED = 1;\n    int TEXT = 2;\n    int INTEGER = 3;\n    int REAL = 4;\n    int BLOB = 5;\n    @IntDef({UNDEFINED, TEXT, INTEGER, REAL, BLOB})\n    @Retention(RetentionPolicy.CLASS)\n    @interface SQLiteTypeAffinity {\n    }\n\n    int UNSPECIFIED = 1;\n    int BINARY = 2;\n    int NOCASE = 3;\n    int RTRIM = 4;\n    @RequiresApi(21)\n    int LOCALIZED = 5;\n    @RequiresApi(21)\n    int UNICODE = 6;\n    @IntDef({UNSPECIFIED, BINARY, NOCASE, RTRIM, LOCALIZED, UNICODE})\n    @Retention(RetentionPolicy.CLASS)\n    @interface Collate {\n    }\n    String VALUE_UNSPECIFIED = \"[value-unspecified]\";\n}\n```\n\n이 외에도 `@Dao`, `@Query`, `@Insert`, `@Delete`과 같은 Annotation들은 각자 인터페이스, 구현체 값들을 이미 가지고 있다.\n\n **Room** 뿐만 아니라 범용적으로 사용되는 **Dagger**, **Glide**와 같은 라이브러리들도 Annotation(Processor)을 기반으로 동작한다. \n\n<br>\n<br>\n<br>\n\n## KAPT (Kotlin Annotation Processing Tool)\n\n코틀린 프로젝트를 컴파일 할 때는 javac가 아닌 kotlinc로 컴파일을 하기 때문에 Java로 작성한 애노테이션 프로세서(AbstractProcessor)가 동작하지 않는다. \n\n따라서 코틀린에서는 이러한 애노테이션 처리기를 위해 [KAPT(Kotlin Annotation Processing Tool)](https://kotlinlang.org/docs/kapt.html)를 제공한다. \n\nKAPT를 사용하기 위해 모듈의 build.gradle에 다음과 같은 코드를 추가한다.\n\n```groovy\n// Groovy DSL\napply plugin: 'kotlin-android'\napply plugin: 'kotlin-kapt'\n```\n\n이 때 kotlin-android 설정을 먼저 해줘야 kotlin-kapt를 쓸 수 있다.\n\nAnnotation processor가 포함된 라이브러리를 추가한다면 다음과 같이 의존성을 추가한다.\n\n```groovy\ndependencies {\n // 기존 annotationProcessor 대신 kapt로 대체\n // annotationProcessor 'groupId:artifactId:version'\n    kapt 'groupId:artifactId:version'\n}\n```\n\nhilt로 예시를 바꿔보면 아래와 같다.\n\n```groovy\ndependencies{\n  //annotationProcessor \"com.google.dagger:hilt-android-compiler:$hilt_version\"\n  kapt \"com.google.dagger:hilt-android-compiler:$hilt_version\"\n}\n```\n\n### Pluggable Annotation Processing API (JSR#269)\n\n자바 이외의 언어에서 어노테이션을 지원하기 위해서는 몇가지 옵션이 있다.\n\n자바의 컴파일러와 어노테이션 프로세스를 위한 플러그인 대상 API가 필요한데, 이를 정리한 스펙 문서가 JSR 269이다.\n\n> **참고** [JSR 269 : Pluggable Annotation Processing API in JCP](https://jcp.org/en/jsr/detail?id=269)\n\n이 플러그인 API를 사용하면 특정 어노테이션이 정의되었을때, 컴파일러에게 어노테이션에 작성된 클래스, 메서드, 필드 등의 구성 요소를 질의하고\n\n컴파일러는 해당 구성 요소를 나타내는 객체의 컬렉션을 반환하게 된다.\n\n이후 프로세서가 이 컬렉션을 검증하고, 새로운 코드(=Stub)을 생성하게 된다.\n\n코틀린의 경우 빌드한 바이너리가 자바이기 때문에, 코틀린 컴파일러의 실행후 자바 컴파일러가 바이너리 파일인 `*.class`를 인식한다.\n\n이때 컴파일러는 코틀린과 자바에서 생성된 각 바이너리에 대해서 구별할 수는 없다.\n\n다만, 코틀린은 언어의 특성상 Processor가 생성한 선언을 참조할 수 없고, 바이너리에는 주석이 포함되지않기때문에 이를 해결하기 위해 **KAPT**를 사용하는 것이다.\n\n**KAPT**를 사용하면 APT와 똑같이 Stub을 생성하고 자바의 의존성을 가지는 대신 구현이 상대적으로 쉽다는 장점이 있다.\n\n자바와 코틀린간의 간극을 없애주는 **KAPT**의 대표적인 예시로 Android의 DI를 위해 사용하는 Dagger나 Databinding을 코틀린에서도 사용할 수 있는 점을 들 수 있다.\n\n하지만 **KAPT** 도 APT와 마찬가지로 결국 Stub을 생성하기 위해 많은 컴파일 및 빌트 타임을 소모하게 되는 문제점은 그대로 남아있게 된다.\n\n이번 포스팅의 주제이자, 위의 문제를 해결하기 위해 나온 **KSP**를 다음 파트에서 자세히 알아보자.","source":"_posts/2021-07-21 Kotlin Symbol Processing Api Part 1.md","raw":"---\ntitle: Kotlin Symbol Processing Api Part 1 — Annotation과 KAPT\ndate: 2021-07-21 01:00\ncover: https://androiddeepdive.github.io/Team-Blog/images/cover_ksp.png\ncategories:\n- KSP\ntags:\n- KSP\n- Kotlin\n- Symbol\n- Processing\n- KAPT\n- Annotation\n---\n\n<article class=\"message message-immersive is-primary\">\n    <div class=\"message-body\">\n        <i class=\"fas fa-pen-fancy mr-2\"></i>Writers<br>\n        by 곽욱현 @Knowre<br>\n        by 김남훈 @Naver<br>\n        by 송시영 @SmartStudy<br>\n        by 옥수환 @Naver<br>\n        by 이기정 @BankSalad<br>\n        by 정세희 @BankSalad\n    </div>\n</article>\n\n\n<!-- more -->\n\n## Annotation\n\n`Annotation Processor`이란 용어는 낯설더라도, 아래와 같은 코드들은 개발하면서 종종 보았을 것이다.\n\n```java\n@Overide\n@NonNull\n@Nallable\n```\n\n이러한 코드를 **Annotation**이라고 한다. \n\n**Annotation** 은 소스 코드에 추가 할 수 있는 메타데이터의 한 형태로 컴파일러가 이를 참조 할 수 있도록 한다.\n\n이 참조를 통해 미리 지정된 코드를 생성하기 위한 용도로 사용된다. Android 뿐만 아니라 Spring Framework 등을 개발할때에도 자주 활용한다.\n\n다음의 오라클 문서에서 발췌한 Annotation의 정의를 살펴보자.\n\n> Annotations, a form of metadata, provide data about a program that is not part of the program itself. Annotations have no direct effect on the operation of the code they annotate.\n\n문서의 내용을 해석하면 \n\n> Annotation은 일종의 메타데이터 형태이며, 프로그램의 일부가 아니라 프로그램에 대한 정보를 제공한다.\n> Annotation 자체로는 실행되는 코드에 직접적인 영향을 미치지 않는다.\n\nAnnotation은 Java 5부터 지원하고 있으며, 주로 다음과 같은 용도로 사용된다.\n\n**1. Information for the compiler**\n컴파일러가 에러를 검출하거나, 경고를 표시하지 않도록 사전에 정보를 전달한다.\n\n**2. Compile-time and deployment-time processing**\n코드나 xml 파일 등을 컴파일 타임에 생성할 수 있도록 처리한다.\n\n**3. Runtime processing**\n몇몇 annotation들은 런타임에도 검사를 수행하도록 처리해준다.\n\n> **참고** [Oracle JavaDoc#Annotations](https://docs.oracle.com/javase/tutorial/java/annotations/index.html)\n\n### 이미 정의된 Annotation 살펴보기\n\n`java.lang` 패키지에는 자바에서 제공하는 Annotation들이 있다. 대표적인 것 두 가지만 가지 살펴보자.\n\n- `@Deprecated` : deprecated 됐음을 의미하며 더 이상 쓰지 말 것을 권장할 때 사용한다. 이 Annotation이 달린 코드를 사용하면 컴파일러는 경고를 내뱉는다.\n\n- `@SuppressWarnings` : 이 Annotation은 컴파일러가 생성할 경고를 억제하도록 지시한다.\n\n  ```java\n  @SuppressWarnings(\"deprecation\")\n  void useDeprecatedMethod() {\n    // deprecation warning\n    // - suppressed\n    objectOne.deprecatedMethod();\n  }\n  ```\n\n`java.lang` 하위의 `annotation` 패키지 즉 `java.lang.annotation` 패키지에서는 **Meta Annotation** 이라고 불리는 것들이 존재한다.\n\n- `@Retention` : Retention Annotation은 표기된 Annotation이 저장되는 방법을 지정한다.\n  - `RetentionPolicy.SOURCE` : 소스 코드에서만 유지되며, 컴파일러에서는 무시된다.\n  - `RetentionPolicy.CLASS` : 컴파일 타임에 컴파일러에 의해 유지되지만, JVM에서는 무시된다.\n  - `RetentionPolicy.RUNTIME` : JVM에 의해서 유지되므로 런타임에서 사용가능하다.\n- `@Documented` : Annotation이 사용될 때 마다 해당 element가 Javadoc에 문서화 되어야 함을 나타낸다.\n- `@Target` : Annotation을 적용할 수 있는 Java Elements 종류를 제한한다.\n- `@Inherited` : super class 로부터 상속될 수 있는 Annotation 타입이다. class 선언시에만 적용.\n\n이 Meta Annotation의 특징은 다른 Annotation에 적용이 가능한 Annotation이라는 점이다.\n\nAndroid 앱 개발시에는 `java.lang` 대신 `androidx.annotation` 패키지를 참조하면 다양한 Annotation을 활용할 수 있다.\n\n`androidx.annotation` 패키지에 속한 annotation 목록은 아래 링크를 참고하자.\n\n> **참고** [Android Developers#androidx.annotation](https://developer.android.com/reference/androidx/annotation/package-summary)\n\n\n### Annotation Processor\n\n앞서 소개한 Annotation의 용도를 사용하기 위해서 **Annotation Processor**가 필요하다. \n\nAnnotation Processor는 Java 컴파일러 플러그인의 일종으로, 컴파일러에게 어떠한 요소(클래스, 메서드, 필드 등)에 annotation이 추가 되어있는지 확인하도록 한다.\n\n컴파일러는 컴파일 타임에 코드베이스를 검사하거나 확인된 정보를 통해 새로운 코드를 생성하는 식으로 동작하며, 주로 개발자가 정의한 태스크를 자동화하거나 보일러 플레이트 작성을 줄이는 용도로 사용된다.\n\nAnnotation Processor의 특징을 정리하자면 다음과 같다.\n\n- 컴파일 타임에 특정 작업을 수행한다.\n- 리플렉션없이 프로그램의 의미 및 구조를 파악할 수 있게 된다.\n- 자동으로 보일러 플레이트를 생성할 수 있게 된다.\n\n#### Annotation processor 실행 순서\n\nAnnotation processor는 여러 라운드에 걸쳐 수행된다.\n\n{% asset_img processing_rounds.png [Processing rounds] %}\n\n실행 순서를 간단히 정리하자면 다음과 같다.\n\n1. 등록된 Annotation processor들과 함께 컴파일러가 시작된다.\n2. Annotation processor들이 작성된 Annotation을 기반으로 코드 검사 및 생성을 수행한다.\n3. 컴파일러가 모든 Annotation processor의 작업이 끝났는지 확인하고, 그렇지 않다면 2번을 반복한다.\n4. 모든 처리가 끝난다면 전체 코드에 대한 컴파일을 시작한다. (이후 프로세스는 기존과 동일)\n\n#### Android에서 Annotation Processor를 사용하는 라이브러리들\n\n**Room** \n\nAndroid에서 SQLite에 대한 추상화를 제공하는 Room 라이브러리에도 Annotation Processor가 적용되어 있다.\n\n아래는 대표적인 예제인 User 관련 코드이다.\n\n```kotlin\n// User.kt\n@Entity\ndata class User(\n    @PrimaryKey val uid: Int,\n    @ColumnInfo(name = \"first_name\") val firstName: String?,\n    @ColumnInfo(name = \"last_name\") val lastName: String?\n)\n```\n\n```kotlin\n// UserDao.kt\n@Dao\ninterface UserDao {\n    @Query(\"SELECT * FROM user\")\n    fun getAll(): List<User>\n\n    @Query(\"SELECT * FROM user WHERE uid IN (:userIds)\")\n    fun loadAllByIds(userIds: IntArray): List<User>\n\n    @Query(\"SELECT * FROM user WHERE first_name LIKE :first AND \" +\n            \"last_name LIKE :last LIMIT 1\")\n    fun findByName(first: String, last: String): User\n\n    @Insert\n    fun insertAll(vararg users: User)\n\n    @Delete\n    fun delete(user: User)\n}\n```\n\n```kotlin\n// AppDatabase.kt\n@Database(entities = arrayOf(User::class), version = 1)\nabstract class AppDatabase : RoomDatabase() {\n    abstract fun userDao(): UserDao\n}\n```\n\n위의 에졔에서 쓰인 Annotation들은 `@Entity`, `@PrimaryKey`, `@ColumnInfo`, `@Dao`, `@Query`, `@Insert`, `@Delete`이다.\n\n이 Annotation들의 구현체를 확인해보자.\n\n```java\n// Entity.java\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.CLASS)\npublic @interface Entity {\n    String tableName() default \"\";\n    Index[] indices() default {};\n    boolean inheritSuperIndices() default false;\n    String[] primaryKeys() default {};\n    ForeignKey[] foreignKeys() default {};\n    String[] ignoredColumns() default {};\n}\n```\n\n```java\n// PrimaryKey.java\n@Target({ElementType.FIELD, ElementType.METHOD})\n@Retention(RetentionPolicy.CLASS)\npublic @interface PrimaryKey {\n    boolean autoGenerate() default false;\n}\n```\n\n```java\n// ColumnInfo.java\n@Target({ElementType.FIELD, ElementType.METHOD})\n@Retention(RetentionPolicy.CLASS)\npublic @interface ColumnInfo {\n    String name() default INHERIT_FIELD_NAME;\n    @SuppressWarnings(\"unused\") @SQLiteTypeAffinity int typeAffinity() default UNDEFINED;\n    boolean index() default false;\n    String defaultValue() default VALUE_UNSPECIFIED;\n    String INHERIT_FIELD_NAME = \"[field-name]\";\n\n\n    int UNDEFINED = 1;\n    int TEXT = 2;\n    int INTEGER = 3;\n    int REAL = 4;\n    int BLOB = 5;\n    @IntDef({UNDEFINED, TEXT, INTEGER, REAL, BLOB})\n    @Retention(RetentionPolicy.CLASS)\n    @interface SQLiteTypeAffinity {\n    }\n\n    int UNSPECIFIED = 1;\n    int BINARY = 2;\n    int NOCASE = 3;\n    int RTRIM = 4;\n    @RequiresApi(21)\n    int LOCALIZED = 5;\n    @RequiresApi(21)\n    int UNICODE = 6;\n    @IntDef({UNSPECIFIED, BINARY, NOCASE, RTRIM, LOCALIZED, UNICODE})\n    @Retention(RetentionPolicy.CLASS)\n    @interface Collate {\n    }\n    String VALUE_UNSPECIFIED = \"[value-unspecified]\";\n}\n```\n\n이 외에도 `@Dao`, `@Query`, `@Insert`, `@Delete`과 같은 Annotation들은 각자 인터페이스, 구현체 값들을 이미 가지고 있다.\n\n **Room** 뿐만 아니라 범용적으로 사용되는 **Dagger**, **Glide**와 같은 라이브러리들도 Annotation(Processor)을 기반으로 동작한다. \n\n<br>\n<br>\n<br>\n\n## KAPT (Kotlin Annotation Processing Tool)\n\n코틀린 프로젝트를 컴파일 할 때는 javac가 아닌 kotlinc로 컴파일을 하기 때문에 Java로 작성한 애노테이션 프로세서(AbstractProcessor)가 동작하지 않는다. \n\n따라서 코틀린에서는 이러한 애노테이션 처리기를 위해 [KAPT(Kotlin Annotation Processing Tool)](https://kotlinlang.org/docs/kapt.html)를 제공한다. \n\nKAPT를 사용하기 위해 모듈의 build.gradle에 다음과 같은 코드를 추가한다.\n\n```groovy\n// Groovy DSL\napply plugin: 'kotlin-android'\napply plugin: 'kotlin-kapt'\n```\n\n이 때 kotlin-android 설정을 먼저 해줘야 kotlin-kapt를 쓸 수 있다.\n\nAnnotation processor가 포함된 라이브러리를 추가한다면 다음과 같이 의존성을 추가한다.\n\n```groovy\ndependencies {\n // 기존 annotationProcessor 대신 kapt로 대체\n // annotationProcessor 'groupId:artifactId:version'\n    kapt 'groupId:artifactId:version'\n}\n```\n\nhilt로 예시를 바꿔보면 아래와 같다.\n\n```groovy\ndependencies{\n  //annotationProcessor \"com.google.dagger:hilt-android-compiler:$hilt_version\"\n  kapt \"com.google.dagger:hilt-android-compiler:$hilt_version\"\n}\n```\n\n### Pluggable Annotation Processing API (JSR#269)\n\n자바 이외의 언어에서 어노테이션을 지원하기 위해서는 몇가지 옵션이 있다.\n\n자바의 컴파일러와 어노테이션 프로세스를 위한 플러그인 대상 API가 필요한데, 이를 정리한 스펙 문서가 JSR 269이다.\n\n> **참고** [JSR 269 : Pluggable Annotation Processing API in JCP](https://jcp.org/en/jsr/detail?id=269)\n\n이 플러그인 API를 사용하면 특정 어노테이션이 정의되었을때, 컴파일러에게 어노테이션에 작성된 클래스, 메서드, 필드 등의 구성 요소를 질의하고\n\n컴파일러는 해당 구성 요소를 나타내는 객체의 컬렉션을 반환하게 된다.\n\n이후 프로세서가 이 컬렉션을 검증하고, 새로운 코드(=Stub)을 생성하게 된다.\n\n코틀린의 경우 빌드한 바이너리가 자바이기 때문에, 코틀린 컴파일러의 실행후 자바 컴파일러가 바이너리 파일인 `*.class`를 인식한다.\n\n이때 컴파일러는 코틀린과 자바에서 생성된 각 바이너리에 대해서 구별할 수는 없다.\n\n다만, 코틀린은 언어의 특성상 Processor가 생성한 선언을 참조할 수 없고, 바이너리에는 주석이 포함되지않기때문에 이를 해결하기 위해 **KAPT**를 사용하는 것이다.\n\n**KAPT**를 사용하면 APT와 똑같이 Stub을 생성하고 자바의 의존성을 가지는 대신 구현이 상대적으로 쉽다는 장점이 있다.\n\n자바와 코틀린간의 간극을 없애주는 **KAPT**의 대표적인 예시로 Android의 DI를 위해 사용하는 Dagger나 Databinding을 코틀린에서도 사용할 수 있는 점을 들 수 있다.\n\n하지만 **KAPT** 도 APT와 마찬가지로 결국 Stub을 생성하기 위해 많은 컴파일 및 빌트 타임을 소모하게 되는 문제점은 그대로 남아있게 된다.\n\n이번 포스팅의 주제이자, 위의 문제를 해결하기 위해 나온 **KSP**를 다음 파트에서 자세히 알아보자.","slug":"2021-07-21 Kotlin Symbol Processing Api Part 1","published":1,"updated":"2021-08-13T14:40:08.375Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cksagj7lw001w3lre4mfub16y","content":"<article class=\"message message-immersive is-primary\">\n    <div class=\"message-body\">\n        <i class=\"fas fa-pen-fancy mr-2\"></i>Writers<br>\n        by 곽욱현 @Knowre<br>\n        by 김남훈 @Naver<br>\n        by 송시영 @SmartStudy<br>\n        by 옥수환 @Naver<br>\n        by 이기정 @BankSalad<br>\n        by 정세희 @BankSalad\n    </div>\n</article>\n\n\n<span id=\"more\"></span>\n\n<h2 id=\"Annotation\"><a href=\"#Annotation\" class=\"headerlink\" title=\"Annotation\"></a>Annotation</h2><p><code>Annotation Processor</code>이란 용어는 낯설더라도, 아래와 같은 코드들은 개발하면서 종종 보았을 것이다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Overide</span></span><br><span class=\"line\"><span class=\"meta\">@NonNull</span></span><br><span class=\"line\"><span class=\"meta\">@Nallable</span></span><br></pre></td></tr></table></figure>\n\n<p>이러한 코드를 <strong>Annotation</strong>이라고 한다. </p>\n<p><strong>Annotation</strong> 은 소스 코드에 추가 할 수 있는 메타데이터의 한 형태로 컴파일러가 이를 참조 할 수 있도록 한다.</p>\n<p>이 참조를 통해 미리 지정된 코드를 생성하기 위한 용도로 사용된다. Android 뿐만 아니라 Spring Framework 등을 개발할때에도 자주 활용한다.</p>\n<p>다음의 오라클 문서에서 발췌한 Annotation의 정의를 살펴보자.</p>\n<blockquote>\n<p>Annotations, a form of metadata, provide data about a program that is not part of the program itself. Annotations have no direct effect on the operation of the code they annotate.</p>\n</blockquote>\n<p>문서의 내용을 해석하면 </p>\n<blockquote>\n<p>Annotation은 일종의 메타데이터 형태이며, 프로그램의 일부가 아니라 프로그램에 대한 정보를 제공한다.<br>Annotation 자체로는 실행되는 코드에 직접적인 영향을 미치지 않는다.</p>\n</blockquote>\n<p>Annotation은 Java 5부터 지원하고 있으며, 주로 다음과 같은 용도로 사용된다.</p>\n<p><strong>1. Information for the compiler</strong><br>컴파일러가 에러를 검출하거나, 경고를 표시하지 않도록 사전에 정보를 전달한다.</p>\n<p><strong>2. Compile-time and deployment-time processing</strong><br>코드나 xml 파일 등을 컴파일 타임에 생성할 수 있도록 처리한다.</p>\n<p><strong>3. Runtime processing</strong><br>몇몇 annotation들은 런타임에도 검사를 수행하도록 처리해준다.</p>\n<blockquote>\n<p><strong>참고</strong> <a href=\"https://docs.oracle.com/javase/tutorial/java/annotations/index.html\">Oracle JavaDoc#Annotations</a></p>\n</blockquote>\n<h3 id=\"이미-정의된-Annotation-살펴보기\"><a href=\"#이미-정의된-Annotation-살펴보기\" class=\"headerlink\" title=\"이미 정의된 Annotation 살펴보기\"></a>이미 정의된 Annotation 살펴보기</h3><p><code>java.lang</code> 패키지에는 자바에서 제공하는 Annotation들이 있다. 대표적인 것 두 가지만 가지 살펴보자.</p>\n<ul>\n<li><p><code>@Deprecated</code> : deprecated 됐음을 의미하며 더 이상 쓰지 말 것을 권장할 때 사용한다. 이 Annotation이 달린 코드를 사용하면 컴파일러는 경고를 내뱉는다.</p>\n</li>\n<li><p><code>@SuppressWarnings</code> : 이 Annotation은 컴파일러가 생성할 경고를 억제하도록 지시한다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@SuppressWarnings(&quot;deprecation&quot;)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">useDeprecatedMethod</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// deprecation warning</span></span><br><span class=\"line\">  <span class=\"comment\">// - suppressed</span></span><br><span class=\"line\">  objectOne.deprecatedMethod();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<p><code>java.lang</code> 하위의 <code>annotation</code> 패키지 즉 <code>java.lang.annotation</code> 패키지에서는 <strong>Meta Annotation</strong> 이라고 불리는 것들이 존재한다.</p>\n<ul>\n<li><code>@Retention</code> : Retention Annotation은 표기된 Annotation이 저장되는 방법을 지정한다.<ul>\n<li><code>RetentionPolicy.SOURCE</code> : 소스 코드에서만 유지되며, 컴파일러에서는 무시된다.</li>\n<li><code>RetentionPolicy.CLASS</code> : 컴파일 타임에 컴파일러에 의해 유지되지만, JVM에서는 무시된다.</li>\n<li><code>RetentionPolicy.RUNTIME</code> : JVM에 의해서 유지되므로 런타임에서 사용가능하다.</li>\n</ul>\n</li>\n<li><code>@Documented</code> : Annotation이 사용될 때 마다 해당 element가 Javadoc에 문서화 되어야 함을 나타낸다.</li>\n<li><code>@Target</code> : Annotation을 적용할 수 있는 Java Elements 종류를 제한한다.</li>\n<li><code>@Inherited</code> : super class 로부터 상속될 수 있는 Annotation 타입이다. class 선언시에만 적용.</li>\n</ul>\n<p>이 Meta Annotation의 특징은 다른 Annotation에 적용이 가능한 Annotation이라는 점이다.</p>\n<p>Android 앱 개발시에는 <code>java.lang</code> 대신 <code>androidx.annotation</code> 패키지를 참조하면 다양한 Annotation을 활용할 수 있다.</p>\n<p><code>androidx.annotation</code> 패키지에 속한 annotation 목록은 아래 링크를 참고하자.</p>\n<blockquote>\n<p><strong>참고</strong> <a href=\"https://developer.android.com/reference/androidx/annotation/package-summary\">Android Developers#androidx.annotation</a></p>\n</blockquote>\n<h3 id=\"Annotation-Processor\"><a href=\"#Annotation-Processor\" class=\"headerlink\" title=\"Annotation Processor\"></a>Annotation Processor</h3><p>앞서 소개한 Annotation의 용도를 사용하기 위해서 <strong>Annotation Processor</strong>가 필요하다. </p>\n<p>Annotation Processor는 Java 컴파일러 플러그인의 일종으로, 컴파일러에게 어떠한 요소(클래스, 메서드, 필드 등)에 annotation이 추가 되어있는지 확인하도록 한다.</p>\n<p>컴파일러는 컴파일 타임에 코드베이스를 검사하거나 확인된 정보를 통해 새로운 코드를 생성하는 식으로 동작하며, 주로 개발자가 정의한 태스크를 자동화하거나 보일러 플레이트 작성을 줄이는 용도로 사용된다.</p>\n<p>Annotation Processor의 특징을 정리하자면 다음과 같다.</p>\n<ul>\n<li>컴파일 타임에 특정 작업을 수행한다.</li>\n<li>리플렉션없이 프로그램의 의미 및 구조를 파악할 수 있게 된다.</li>\n<li>자동으로 보일러 플레이트를 생성할 수 있게 된다.</li>\n</ul>\n<h4 id=\"Annotation-processor-실행-순서\"><a href=\"#Annotation-processor-실행-순서\" class=\"headerlink\" title=\"Annotation processor 실행 순서\"></a>Annotation processor 실행 순서</h4><p>Annotation processor는 여러 라운드에 걸쳐 수행된다.</p>\n<img src=\"/Team-Blog/2021/07/21/2021-07-21%20Kotlin%20Symbol%20Processing%20Api%20Part%201/processing_rounds.png\" class=\"\" title=\"[Processing rounds]\">\n\n<p>실행 순서를 간단히 정리하자면 다음과 같다.</p>\n<ol>\n<li>등록된 Annotation processor들과 함께 컴파일러가 시작된다.</li>\n<li>Annotation processor들이 작성된 Annotation을 기반으로 코드 검사 및 생성을 수행한다.</li>\n<li>컴파일러가 모든 Annotation processor의 작업이 끝났는지 확인하고, 그렇지 않다면 2번을 반복한다.</li>\n<li>모든 처리가 끝난다면 전체 코드에 대한 컴파일을 시작한다. (이후 프로세스는 기존과 동일)</li>\n</ol>\n<h4 id=\"Android에서-Annotation-Processor를-사용하는-라이브러리들\"><a href=\"#Android에서-Annotation-Processor를-사용하는-라이브러리들\" class=\"headerlink\" title=\"Android에서 Annotation Processor를 사용하는 라이브러리들\"></a>Android에서 Annotation Processor를 사용하는 라이브러리들</h4><p><strong>Room</strong> </p>\n<p>Android에서 SQLite에 대한 추상화를 제공하는 Room 라이브러리에도 Annotation Processor가 적용되어 있다.</p>\n<p>아래는 대표적인 예제인 User 관련 코드이다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// User.kt</span></span><br><span class=\"line\"><span class=\"meta\">@Entity</span></span><br><span class=\"line\"><span class=\"keyword\">data</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span></span>(</span><br><span class=\"line\">    <span class=\"meta\">@PrimaryKey</span> <span class=\"keyword\">val</span> uid: <span class=\"built_in\">Int</span>,</span><br><span class=\"line\">    <span class=\"meta\">@ColumnInfo(name = <span class=\"meta-string\">&quot;first_name&quot;</span>)</span> <span class=\"keyword\">val</span> firstName: String?,</span><br><span class=\"line\">    <span class=\"meta\">@ColumnInfo(name = <span class=\"meta-string\">&quot;last_name&quot;</span>)</span> <span class=\"keyword\">val</span> lastName: String?</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// UserDao.kt</span></span><br><span class=\"line\"><span class=\"meta\">@Dao</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">UserDao</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Query(<span class=\"meta-string\">&quot;SELECT * FROM user&quot;</span>)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getAll</span><span class=\"params\">()</span></span>: List&lt;User&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Query(<span class=\"meta-string\">&quot;SELECT * FROM user WHERE uid IN (:userIds)&quot;</span>)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">loadAllByIds</span><span class=\"params\">(userIds: <span class=\"type\">IntArray</span>)</span></span>: List&lt;User&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Query(<span class=\"meta-string\">&quot;SELECT * FROM user WHERE first_name LIKE :first AND &quot;</span> +</span></span><br><span class=\"line\"><span class=\"meta\">            <span class=\"meta-string\">&quot;last_name LIKE :last LIMIT 1&quot;</span>)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">findByName</span><span class=\"params\">(first: <span class=\"type\">String</span>, last: <span class=\"type\">String</span>)</span></span>: User</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Insert</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">insertAll</span><span class=\"params\">(<span class=\"keyword\">vararg</span> users: <span class=\"type\">User</span>)</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Delete</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">delete</span><span class=\"params\">(user: <span class=\"type\">User</span>)</span></span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// AppDatabase.kt</span></span><br><span class=\"line\"><span class=\"meta\">@Database(entities = arrayOf(User::class)</span>, version = <span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AppDatabase</span> : <span class=\"type\">RoomDatabase</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">abstract</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">userDao</span><span class=\"params\">()</span></span>: UserDao</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>위의 에졔에서 쓰인 Annotation들은 <code>@Entity</code>, <code>@PrimaryKey</code>, <code>@ColumnInfo</code>, <code>@Dao</code>, <code>@Query</code>, <code>@Insert</code>, <code>@Delete</code>이다.</p>\n<p>이 Annotation들의 구현체를 확인해보자.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Entity.java</span></span><br><span class=\"line\"><span class=\"meta\">@Target(ElementType.TYPE)</span></span><br><span class=\"line\"><span class=\"meta\">@Retention(RetentionPolicy.CLASS)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> Entity &#123;</span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">tableName</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> &quot;&quot;</span>;</span><br><span class=\"line\">    Index[] indices() <span class=\"keyword\">default</span> &#123;&#125;;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">inheritSuperIndices</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> <span class=\"keyword\">false</span></span>;</span><br><span class=\"line\">    String[] primaryKeys() <span class=\"keyword\">default</span> &#123;&#125;;</span><br><span class=\"line\">    ForeignKey[] foreignKeys() <span class=\"keyword\">default</span> &#123;&#125;;</span><br><span class=\"line\">    String[] ignoredColumns() <span class=\"keyword\">default</span> &#123;&#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// PrimaryKey.java</span></span><br><span class=\"line\"><span class=\"meta\">@Target(&#123;ElementType.FIELD, ElementType.METHOD&#125;)</span></span><br><span class=\"line\"><span class=\"meta\">@Retention(RetentionPolicy.CLASS)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> PrimaryKey &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">autoGenerate</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> <span class=\"keyword\">false</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ColumnInfo.java</span></span><br><span class=\"line\"><span class=\"meta\">@Target(&#123;ElementType.FIELD, ElementType.METHOD&#125;)</span></span><br><span class=\"line\"><span class=\"meta\">@Retention(RetentionPolicy.CLASS)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> ColumnInfo &#123;</span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">name</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> INHERIT_FIELD_NAME</span>;</span><br><span class=\"line\">    <span class=\"meta\">@SuppressWarnings(&quot;unused&quot;)</span> <span class=\"meta\">@SQLiteTypeAffinity</span> <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">typeAffinity</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> UNDEFINED</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">index</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> <span class=\"keyword\">false</span></span>;</span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">defaultValue</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> VALUE_UNSPECIFIED</span>;</span><br><span class=\"line\">    String INHERIT_FIELD_NAME = <span class=\"string\">&quot;[field-name]&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> UNDEFINED = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> TEXT = <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> INTEGER = <span class=\"number\">3</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> REAL = <span class=\"number\">4</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> BLOB = <span class=\"number\">5</span>;</span><br><span class=\"line\">    <span class=\"meta\">@IntDef(&#123;UNDEFINED, TEXT, INTEGER, REAL, BLOB&#125;)</span></span><br><span class=\"line\">    <span class=\"meta\">@Retention(RetentionPolicy.CLASS)</span></span><br><span class=\"line\">    <span class=\"meta\">@interface</span> SQLiteTypeAffinity &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> UNSPECIFIED = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> BINARY = <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> NOCASE = <span class=\"number\">3</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> RTRIM = <span class=\"number\">4</span>;</span><br><span class=\"line\">    <span class=\"meta\">@RequiresApi(21)</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> LOCALIZED = <span class=\"number\">5</span>;</span><br><span class=\"line\">    <span class=\"meta\">@RequiresApi(21)</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> UNICODE = <span class=\"number\">6</span>;</span><br><span class=\"line\">    <span class=\"meta\">@IntDef(&#123;UNSPECIFIED, BINARY, NOCASE, RTRIM, LOCALIZED, UNICODE&#125;)</span></span><br><span class=\"line\">    <span class=\"meta\">@Retention(RetentionPolicy.CLASS)</span></span><br><span class=\"line\">    <span class=\"meta\">@interface</span> Collate &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    String VALUE_UNSPECIFIED = <span class=\"string\">&quot;[value-unspecified]&quot;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>이 외에도 <code>@Dao</code>, <code>@Query</code>, <code>@Insert</code>, <code>@Delete</code>과 같은 Annotation들은 각자 인터페이스, 구현체 값들을 이미 가지고 있다.</p>\n<p> <strong>Room</strong> 뿐만 아니라 범용적으로 사용되는 <strong>Dagger</strong>, <strong>Glide</strong>와 같은 라이브러리들도 Annotation(Processor)을 기반으로 동작한다. </p>\n<br>\n<br>\n<br>\n\n<h2 id=\"KAPT-Kotlin-Annotation-Processing-Tool\"><a href=\"#KAPT-Kotlin-Annotation-Processing-Tool\" class=\"headerlink\" title=\"KAPT (Kotlin Annotation Processing Tool)\"></a>KAPT (Kotlin Annotation Processing Tool)</h2><p>코틀린 프로젝트를 컴파일 할 때는 javac가 아닌 kotlinc로 컴파일을 하기 때문에 Java로 작성한 애노테이션 프로세서(AbstractProcessor)가 동작하지 않는다. </p>\n<p>따라서 코틀린에서는 이러한 애노테이션 처리기를 위해 <a href=\"https://kotlinlang.org/docs/kapt.html\">KAPT(Kotlin Annotation Processing Tool)</a>를 제공한다. </p>\n<p>KAPT를 사용하기 위해 모듈의 build.gradle에 다음과 같은 코드를 추가한다.</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Groovy DSL</span></span><br><span class=\"line\">apply <span class=\"attr\">plugin:</span> <span class=\"string\">&#x27;kotlin-android&#x27;</span></span><br><span class=\"line\">apply <span class=\"attr\">plugin:</span> <span class=\"string\">&#x27;kotlin-kapt&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>이 때 kotlin-android 설정을 먼저 해줘야 kotlin-kapt를 쓸 수 있다.</p>\n<p>Annotation processor가 포함된 라이브러리를 추가한다면 다음과 같이 의존성을 추가한다.</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dependencies &#123;</span><br><span class=\"line\"> <span class=\"comment\">// 기존 annotationProcessor 대신 kapt로 대체</span></span><br><span class=\"line\"> <span class=\"comment\">// annotationProcessor &#x27;groupId:artifactId:version&#x27;</span></span><br><span class=\"line\">    kapt <span class=\"string\">&#x27;groupId:artifactId:version&#x27;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>hilt로 예시를 바꿔보면 아래와 같다.</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dependencies&#123;</span><br><span class=\"line\">  <span class=\"comment\">//annotationProcessor &quot;com.google.dagger:hilt-android-compiler:$hilt_version&quot;</span></span><br><span class=\"line\">  kapt <span class=\"string\">&quot;com.google.dagger:hilt-android-compiler:$hilt_version&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Pluggable-Annotation-Processing-API-JSR-269\"><a href=\"#Pluggable-Annotation-Processing-API-JSR-269\" class=\"headerlink\" title=\"Pluggable Annotation Processing API (JSR#269)\"></a>Pluggable Annotation Processing API (JSR#269)</h3><p>자바 이외의 언어에서 어노테이션을 지원하기 위해서는 몇가지 옵션이 있다.</p>\n<p>자바의 컴파일러와 어노테이션 프로세스를 위한 플러그인 대상 API가 필요한데, 이를 정리한 스펙 문서가 JSR 269이다.</p>\n<blockquote>\n<p><strong>참고</strong> <a href=\"https://jcp.org/en/jsr/detail?id=269\">JSR 269 : Pluggable Annotation Processing API in JCP</a></p>\n</blockquote>\n<p>이 플러그인 API를 사용하면 특정 어노테이션이 정의되었을때, 컴파일러에게 어노테이션에 작성된 클래스, 메서드, 필드 등의 구성 요소를 질의하고</p>\n<p>컴파일러는 해당 구성 요소를 나타내는 객체의 컬렉션을 반환하게 된다.</p>\n<p>이후 프로세서가 이 컬렉션을 검증하고, 새로운 코드(=Stub)을 생성하게 된다.</p>\n<p>코틀린의 경우 빌드한 바이너리가 자바이기 때문에, 코틀린 컴파일러의 실행후 자바 컴파일러가 바이너리 파일인 <code>*.class</code>를 인식한다.</p>\n<p>이때 컴파일러는 코틀린과 자바에서 생성된 각 바이너리에 대해서 구별할 수는 없다.</p>\n<p>다만, 코틀린은 언어의 특성상 Processor가 생성한 선언을 참조할 수 없고, 바이너리에는 주석이 포함되지않기때문에 이를 해결하기 위해 <strong>KAPT</strong>를 사용하는 것이다.</p>\n<p><strong>KAPT</strong>를 사용하면 APT와 똑같이 Stub을 생성하고 자바의 의존성을 가지는 대신 구현이 상대적으로 쉽다는 장점이 있다.</p>\n<p>자바와 코틀린간의 간극을 없애주는 <strong>KAPT</strong>의 대표적인 예시로 Android의 DI를 위해 사용하는 Dagger나 Databinding을 코틀린에서도 사용할 수 있는 점을 들 수 있다.</p>\n<p>하지만 <strong>KAPT</strong> 도 APT와 마찬가지로 결국 Stub을 생성하기 위해 많은 컴파일 및 빌트 타임을 소모하게 되는 문제점은 그대로 남아있게 된다.</p>\n<p>이번 포스팅의 주제이자, 위의 문제를 해결하기 위해 나온 <strong>KSP</strong>를 다음 파트에서 자세히 알아보자.</p>\n","site":{"data":{}},"excerpt":"<article class=\"message message-immersive is-primary\">\n    <div class=\"message-body\">\n        <i class=\"fas fa-pen-fancy mr-2\"></i>Writers<br>\n        by 곽욱현 @Knowre<br>\n        by 김남훈 @Naver<br>\n        by 송시영 @SmartStudy<br>\n        by 옥수환 @Naver<br>\n        by 이기정 @BankSalad<br>\n        by 정세희 @BankSalad\n    </div>\n</article>","more":"<h2 id=\"Annotation\"><a href=\"#Annotation\" class=\"headerlink\" title=\"Annotation\"></a>Annotation</h2><p><code>Annotation Processor</code>이란 용어는 낯설더라도, 아래와 같은 코드들은 개발하면서 종종 보았을 것이다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Overide</span></span><br><span class=\"line\"><span class=\"meta\">@NonNull</span></span><br><span class=\"line\"><span class=\"meta\">@Nallable</span></span><br></pre></td></tr></table></figure>\n\n<p>이러한 코드를 <strong>Annotation</strong>이라고 한다. </p>\n<p><strong>Annotation</strong> 은 소스 코드에 추가 할 수 있는 메타데이터의 한 형태로 컴파일러가 이를 참조 할 수 있도록 한다.</p>\n<p>이 참조를 통해 미리 지정된 코드를 생성하기 위한 용도로 사용된다. Android 뿐만 아니라 Spring Framework 등을 개발할때에도 자주 활용한다.</p>\n<p>다음의 오라클 문서에서 발췌한 Annotation의 정의를 살펴보자.</p>\n<blockquote>\n<p>Annotations, a form of metadata, provide data about a program that is not part of the program itself. Annotations have no direct effect on the operation of the code they annotate.</p>\n</blockquote>\n<p>문서의 내용을 해석하면 </p>\n<blockquote>\n<p>Annotation은 일종의 메타데이터 형태이며, 프로그램의 일부가 아니라 프로그램에 대한 정보를 제공한다.<br>Annotation 자체로는 실행되는 코드에 직접적인 영향을 미치지 않는다.</p>\n</blockquote>\n<p>Annotation은 Java 5부터 지원하고 있으며, 주로 다음과 같은 용도로 사용된다.</p>\n<p><strong>1. Information for the compiler</strong><br>컴파일러가 에러를 검출하거나, 경고를 표시하지 않도록 사전에 정보를 전달한다.</p>\n<p><strong>2. Compile-time and deployment-time processing</strong><br>코드나 xml 파일 등을 컴파일 타임에 생성할 수 있도록 처리한다.</p>\n<p><strong>3. Runtime processing</strong><br>몇몇 annotation들은 런타임에도 검사를 수행하도록 처리해준다.</p>\n<blockquote>\n<p><strong>참고</strong> <a href=\"https://docs.oracle.com/javase/tutorial/java/annotations/index.html\">Oracle JavaDoc#Annotations</a></p>\n</blockquote>\n<h3 id=\"이미-정의된-Annotation-살펴보기\"><a href=\"#이미-정의된-Annotation-살펴보기\" class=\"headerlink\" title=\"이미 정의된 Annotation 살펴보기\"></a>이미 정의된 Annotation 살펴보기</h3><p><code>java.lang</code> 패키지에는 자바에서 제공하는 Annotation들이 있다. 대표적인 것 두 가지만 가지 살펴보자.</p>\n<ul>\n<li><p><code>@Deprecated</code> : deprecated 됐음을 의미하며 더 이상 쓰지 말 것을 권장할 때 사용한다. 이 Annotation이 달린 코드를 사용하면 컴파일러는 경고를 내뱉는다.</p>\n</li>\n<li><p><code>@SuppressWarnings</code> : 이 Annotation은 컴파일러가 생성할 경고를 억제하도록 지시한다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@SuppressWarnings(&quot;deprecation&quot;)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">useDeprecatedMethod</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// deprecation warning</span></span><br><span class=\"line\">  <span class=\"comment\">// - suppressed</span></span><br><span class=\"line\">  objectOne.deprecatedMethod();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<p><code>java.lang</code> 하위의 <code>annotation</code> 패키지 즉 <code>java.lang.annotation</code> 패키지에서는 <strong>Meta Annotation</strong> 이라고 불리는 것들이 존재한다.</p>\n<ul>\n<li><code>@Retention</code> : Retention Annotation은 표기된 Annotation이 저장되는 방법을 지정한다.<ul>\n<li><code>RetentionPolicy.SOURCE</code> : 소스 코드에서만 유지되며, 컴파일러에서는 무시된다.</li>\n<li><code>RetentionPolicy.CLASS</code> : 컴파일 타임에 컴파일러에 의해 유지되지만, JVM에서는 무시된다.</li>\n<li><code>RetentionPolicy.RUNTIME</code> : JVM에 의해서 유지되므로 런타임에서 사용가능하다.</li>\n</ul>\n</li>\n<li><code>@Documented</code> : Annotation이 사용될 때 마다 해당 element가 Javadoc에 문서화 되어야 함을 나타낸다.</li>\n<li><code>@Target</code> : Annotation을 적용할 수 있는 Java Elements 종류를 제한한다.</li>\n<li><code>@Inherited</code> : super class 로부터 상속될 수 있는 Annotation 타입이다. class 선언시에만 적용.</li>\n</ul>\n<p>이 Meta Annotation의 특징은 다른 Annotation에 적용이 가능한 Annotation이라는 점이다.</p>\n<p>Android 앱 개발시에는 <code>java.lang</code> 대신 <code>androidx.annotation</code> 패키지를 참조하면 다양한 Annotation을 활용할 수 있다.</p>\n<p><code>androidx.annotation</code> 패키지에 속한 annotation 목록은 아래 링크를 참고하자.</p>\n<blockquote>\n<p><strong>참고</strong> <a href=\"https://developer.android.com/reference/androidx/annotation/package-summary\">Android Developers#androidx.annotation</a></p>\n</blockquote>\n<h3 id=\"Annotation-Processor\"><a href=\"#Annotation-Processor\" class=\"headerlink\" title=\"Annotation Processor\"></a>Annotation Processor</h3><p>앞서 소개한 Annotation의 용도를 사용하기 위해서 <strong>Annotation Processor</strong>가 필요하다. </p>\n<p>Annotation Processor는 Java 컴파일러 플러그인의 일종으로, 컴파일러에게 어떠한 요소(클래스, 메서드, 필드 등)에 annotation이 추가 되어있는지 확인하도록 한다.</p>\n<p>컴파일러는 컴파일 타임에 코드베이스를 검사하거나 확인된 정보를 통해 새로운 코드를 생성하는 식으로 동작하며, 주로 개발자가 정의한 태스크를 자동화하거나 보일러 플레이트 작성을 줄이는 용도로 사용된다.</p>\n<p>Annotation Processor의 특징을 정리하자면 다음과 같다.</p>\n<ul>\n<li>컴파일 타임에 특정 작업을 수행한다.</li>\n<li>리플렉션없이 프로그램의 의미 및 구조를 파악할 수 있게 된다.</li>\n<li>자동으로 보일러 플레이트를 생성할 수 있게 된다.</li>\n</ul>\n<h4 id=\"Annotation-processor-실행-순서\"><a href=\"#Annotation-processor-실행-순서\" class=\"headerlink\" title=\"Annotation processor 실행 순서\"></a>Annotation processor 실행 순서</h4><p>Annotation processor는 여러 라운드에 걸쳐 수행된다.</p>\n<img src=\"/Team-Blog/2021/07/21/2021-07-21%20Kotlin%20Symbol%20Processing%20Api%20Part%201/processing_rounds.png\" class=\"\" title=\"[Processing rounds]\">\n\n<p>실행 순서를 간단히 정리하자면 다음과 같다.</p>\n<ol>\n<li>등록된 Annotation processor들과 함께 컴파일러가 시작된다.</li>\n<li>Annotation processor들이 작성된 Annotation을 기반으로 코드 검사 및 생성을 수행한다.</li>\n<li>컴파일러가 모든 Annotation processor의 작업이 끝났는지 확인하고, 그렇지 않다면 2번을 반복한다.</li>\n<li>모든 처리가 끝난다면 전체 코드에 대한 컴파일을 시작한다. (이후 프로세스는 기존과 동일)</li>\n</ol>\n<h4 id=\"Android에서-Annotation-Processor를-사용하는-라이브러리들\"><a href=\"#Android에서-Annotation-Processor를-사용하는-라이브러리들\" class=\"headerlink\" title=\"Android에서 Annotation Processor를 사용하는 라이브러리들\"></a>Android에서 Annotation Processor를 사용하는 라이브러리들</h4><p><strong>Room</strong> </p>\n<p>Android에서 SQLite에 대한 추상화를 제공하는 Room 라이브러리에도 Annotation Processor가 적용되어 있다.</p>\n<p>아래는 대표적인 예제인 User 관련 코드이다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// User.kt</span></span><br><span class=\"line\"><span class=\"meta\">@Entity</span></span><br><span class=\"line\"><span class=\"keyword\">data</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span></span>(</span><br><span class=\"line\">    <span class=\"meta\">@PrimaryKey</span> <span class=\"keyword\">val</span> uid: <span class=\"built_in\">Int</span>,</span><br><span class=\"line\">    <span class=\"meta\">@ColumnInfo(name = <span class=\"meta-string\">&quot;first_name&quot;</span>)</span> <span class=\"keyword\">val</span> firstName: String?,</span><br><span class=\"line\">    <span class=\"meta\">@ColumnInfo(name = <span class=\"meta-string\">&quot;last_name&quot;</span>)</span> <span class=\"keyword\">val</span> lastName: String?</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// UserDao.kt</span></span><br><span class=\"line\"><span class=\"meta\">@Dao</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">UserDao</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Query(<span class=\"meta-string\">&quot;SELECT * FROM user&quot;</span>)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getAll</span><span class=\"params\">()</span></span>: List&lt;User&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Query(<span class=\"meta-string\">&quot;SELECT * FROM user WHERE uid IN (:userIds)&quot;</span>)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">loadAllByIds</span><span class=\"params\">(userIds: <span class=\"type\">IntArray</span>)</span></span>: List&lt;User&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Query(<span class=\"meta-string\">&quot;SELECT * FROM user WHERE first_name LIKE :first AND &quot;</span> +</span></span><br><span class=\"line\"><span class=\"meta\">            <span class=\"meta-string\">&quot;last_name LIKE :last LIMIT 1&quot;</span>)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">findByName</span><span class=\"params\">(first: <span class=\"type\">String</span>, last: <span class=\"type\">String</span>)</span></span>: User</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Insert</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">insertAll</span><span class=\"params\">(<span class=\"keyword\">vararg</span> users: <span class=\"type\">User</span>)</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Delete</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">delete</span><span class=\"params\">(user: <span class=\"type\">User</span>)</span></span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// AppDatabase.kt</span></span><br><span class=\"line\"><span class=\"meta\">@Database(entities = arrayOf(User::class)</span>, version = <span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AppDatabase</span> : <span class=\"type\">RoomDatabase</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">abstract</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">userDao</span><span class=\"params\">()</span></span>: UserDao</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>위의 에졔에서 쓰인 Annotation들은 <code>@Entity</code>, <code>@PrimaryKey</code>, <code>@ColumnInfo</code>, <code>@Dao</code>, <code>@Query</code>, <code>@Insert</code>, <code>@Delete</code>이다.</p>\n<p>이 Annotation들의 구현체를 확인해보자.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Entity.java</span></span><br><span class=\"line\"><span class=\"meta\">@Target(ElementType.TYPE)</span></span><br><span class=\"line\"><span class=\"meta\">@Retention(RetentionPolicy.CLASS)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> Entity &#123;</span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">tableName</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> &quot;&quot;</span>;</span><br><span class=\"line\">    Index[] indices() <span class=\"keyword\">default</span> &#123;&#125;;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">inheritSuperIndices</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> <span class=\"keyword\">false</span></span>;</span><br><span class=\"line\">    String[] primaryKeys() <span class=\"keyword\">default</span> &#123;&#125;;</span><br><span class=\"line\">    ForeignKey[] foreignKeys() <span class=\"keyword\">default</span> &#123;&#125;;</span><br><span class=\"line\">    String[] ignoredColumns() <span class=\"keyword\">default</span> &#123;&#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// PrimaryKey.java</span></span><br><span class=\"line\"><span class=\"meta\">@Target(&#123;ElementType.FIELD, ElementType.METHOD&#125;)</span></span><br><span class=\"line\"><span class=\"meta\">@Retention(RetentionPolicy.CLASS)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> PrimaryKey &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">autoGenerate</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> <span class=\"keyword\">false</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ColumnInfo.java</span></span><br><span class=\"line\"><span class=\"meta\">@Target(&#123;ElementType.FIELD, ElementType.METHOD&#125;)</span></span><br><span class=\"line\"><span class=\"meta\">@Retention(RetentionPolicy.CLASS)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> ColumnInfo &#123;</span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">name</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> INHERIT_FIELD_NAME</span>;</span><br><span class=\"line\">    <span class=\"meta\">@SuppressWarnings(&quot;unused&quot;)</span> <span class=\"meta\">@SQLiteTypeAffinity</span> <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">typeAffinity</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> UNDEFINED</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">index</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> <span class=\"keyword\">false</span></span>;</span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">defaultValue</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> VALUE_UNSPECIFIED</span>;</span><br><span class=\"line\">    String INHERIT_FIELD_NAME = <span class=\"string\">&quot;[field-name]&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> UNDEFINED = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> TEXT = <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> INTEGER = <span class=\"number\">3</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> REAL = <span class=\"number\">4</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> BLOB = <span class=\"number\">5</span>;</span><br><span class=\"line\">    <span class=\"meta\">@IntDef(&#123;UNDEFINED, TEXT, INTEGER, REAL, BLOB&#125;)</span></span><br><span class=\"line\">    <span class=\"meta\">@Retention(RetentionPolicy.CLASS)</span></span><br><span class=\"line\">    <span class=\"meta\">@interface</span> SQLiteTypeAffinity &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> UNSPECIFIED = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> BINARY = <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> NOCASE = <span class=\"number\">3</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> RTRIM = <span class=\"number\">4</span>;</span><br><span class=\"line\">    <span class=\"meta\">@RequiresApi(21)</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> LOCALIZED = <span class=\"number\">5</span>;</span><br><span class=\"line\">    <span class=\"meta\">@RequiresApi(21)</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> UNICODE = <span class=\"number\">6</span>;</span><br><span class=\"line\">    <span class=\"meta\">@IntDef(&#123;UNSPECIFIED, BINARY, NOCASE, RTRIM, LOCALIZED, UNICODE&#125;)</span></span><br><span class=\"line\">    <span class=\"meta\">@Retention(RetentionPolicy.CLASS)</span></span><br><span class=\"line\">    <span class=\"meta\">@interface</span> Collate &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    String VALUE_UNSPECIFIED = <span class=\"string\">&quot;[value-unspecified]&quot;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>이 외에도 <code>@Dao</code>, <code>@Query</code>, <code>@Insert</code>, <code>@Delete</code>과 같은 Annotation들은 각자 인터페이스, 구현체 값들을 이미 가지고 있다.</p>\n<p> <strong>Room</strong> 뿐만 아니라 범용적으로 사용되는 <strong>Dagger</strong>, <strong>Glide</strong>와 같은 라이브러리들도 Annotation(Processor)을 기반으로 동작한다. </p>\n<br>\n<br>\n<br>\n\n<h2 id=\"KAPT-Kotlin-Annotation-Processing-Tool\"><a href=\"#KAPT-Kotlin-Annotation-Processing-Tool\" class=\"headerlink\" title=\"KAPT (Kotlin Annotation Processing Tool)\"></a>KAPT (Kotlin Annotation Processing Tool)</h2><p>코틀린 프로젝트를 컴파일 할 때는 javac가 아닌 kotlinc로 컴파일을 하기 때문에 Java로 작성한 애노테이션 프로세서(AbstractProcessor)가 동작하지 않는다. </p>\n<p>따라서 코틀린에서는 이러한 애노테이션 처리기를 위해 <a href=\"https://kotlinlang.org/docs/kapt.html\">KAPT(Kotlin Annotation Processing Tool)</a>를 제공한다. </p>\n<p>KAPT를 사용하기 위해 모듈의 build.gradle에 다음과 같은 코드를 추가한다.</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Groovy DSL</span></span><br><span class=\"line\">apply <span class=\"attr\">plugin:</span> <span class=\"string\">&#x27;kotlin-android&#x27;</span></span><br><span class=\"line\">apply <span class=\"attr\">plugin:</span> <span class=\"string\">&#x27;kotlin-kapt&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>이 때 kotlin-android 설정을 먼저 해줘야 kotlin-kapt를 쓸 수 있다.</p>\n<p>Annotation processor가 포함된 라이브러리를 추가한다면 다음과 같이 의존성을 추가한다.</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dependencies &#123;</span><br><span class=\"line\"> <span class=\"comment\">// 기존 annotationProcessor 대신 kapt로 대체</span></span><br><span class=\"line\"> <span class=\"comment\">// annotationProcessor &#x27;groupId:artifactId:version&#x27;</span></span><br><span class=\"line\">    kapt <span class=\"string\">&#x27;groupId:artifactId:version&#x27;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>hilt로 예시를 바꿔보면 아래와 같다.</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dependencies&#123;</span><br><span class=\"line\">  <span class=\"comment\">//annotationProcessor &quot;com.google.dagger:hilt-android-compiler:$hilt_version&quot;</span></span><br><span class=\"line\">  kapt <span class=\"string\">&quot;com.google.dagger:hilt-android-compiler:$hilt_version&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Pluggable-Annotation-Processing-API-JSR-269\"><a href=\"#Pluggable-Annotation-Processing-API-JSR-269\" class=\"headerlink\" title=\"Pluggable Annotation Processing API (JSR#269)\"></a>Pluggable Annotation Processing API (JSR#269)</h3><p>자바 이외의 언어에서 어노테이션을 지원하기 위해서는 몇가지 옵션이 있다.</p>\n<p>자바의 컴파일러와 어노테이션 프로세스를 위한 플러그인 대상 API가 필요한데, 이를 정리한 스펙 문서가 JSR 269이다.</p>\n<blockquote>\n<p><strong>참고</strong> <a href=\"https://jcp.org/en/jsr/detail?id=269\">JSR 269 : Pluggable Annotation Processing API in JCP</a></p>\n</blockquote>\n<p>이 플러그인 API를 사용하면 특정 어노테이션이 정의되었을때, 컴파일러에게 어노테이션에 작성된 클래스, 메서드, 필드 등의 구성 요소를 질의하고</p>\n<p>컴파일러는 해당 구성 요소를 나타내는 객체의 컬렉션을 반환하게 된다.</p>\n<p>이후 프로세서가 이 컬렉션을 검증하고, 새로운 코드(=Stub)을 생성하게 된다.</p>\n<p>코틀린의 경우 빌드한 바이너리가 자바이기 때문에, 코틀린 컴파일러의 실행후 자바 컴파일러가 바이너리 파일인 <code>*.class</code>를 인식한다.</p>\n<p>이때 컴파일러는 코틀린과 자바에서 생성된 각 바이너리에 대해서 구별할 수는 없다.</p>\n<p>다만, 코틀린은 언어의 특성상 Processor가 생성한 선언을 참조할 수 없고, 바이너리에는 주석이 포함되지않기때문에 이를 해결하기 위해 <strong>KAPT</strong>를 사용하는 것이다.</p>\n<p><strong>KAPT</strong>를 사용하면 APT와 똑같이 Stub을 생성하고 자바의 의존성을 가지는 대신 구현이 상대적으로 쉽다는 장점이 있다.</p>\n<p>자바와 코틀린간의 간극을 없애주는 <strong>KAPT</strong>의 대표적인 예시로 Android의 DI를 위해 사용하는 Dagger나 Databinding을 코틀린에서도 사용할 수 있는 점을 들 수 있다.</p>\n<p>하지만 <strong>KAPT</strong> 도 APT와 마찬가지로 결국 Stub을 생성하기 위해 많은 컴파일 및 빌트 타임을 소모하게 되는 문제점은 그대로 남아있게 된다.</p>\n<p>이번 포스팅의 주제이자, 위의 문제를 해결하기 위해 나온 <strong>KSP</strong>를 다음 파트에서 자세히 알아보자.</p>"},{"title":"Kotlin Symbol Processing Api Part 2 — What is it?","date":"2021-07-20T17:00:00.000Z","cover":"https://androiddeepdive.github.io/Team-Blog/images/cover_ksp.png","_content":"\n<article class=\"message message-immersive is-primary\">\n    <div class=\"message-body\">\n        <i class=\"fas fa-pen-fancy mr-2\"></i>Writers<br>\n        by 곽욱현 @Knowre<br>\n        by 김남훈 @Naver<br>\n        by 송시영 @SmartStudy<br>\n        by 옥수환 @Naver<br>\n        by 이기정 @BankSalad<br>\n        by 정세희 @BankSalad\n    </div>\n</article>\n\n\n<!-- more -->\n\n## KSP란 무엇인가?\n\n**KSP(Kotlin Symbol Processing)** 은 2021년 2월 10일 구글이 발표한 코틀린에서 경량화된 컴파일러 플러그인을 개발할 수 있는 API다. \n\n학습곡선을 최소한으로 줄이고, 코틀린의 기능을 활용할 수 있는 단순화된 API를 제공한다. 여러 플랫폼에 호환성을 염두하고 만들어졌으며, 코틀린 1.4.30 버전 이상부터 호환된다. \n\nKSP는 코틀린 언어가 갖는 특징인 확장 함수, 로컬 함수 같은 기능을 이해한다. \n\n또한 KSP는 타입을 명시적으로 다루고, 기본적인 타입 검사와 동등성 검사를 지원한다. \n\nAPI는 코틀린 문법에 따라 symbol 수준에서 코틀린 프로그램 구조를 모델링 한다. \n\nKSP 기반 플러그인이 소스 프로그램을 처리할 때 클래스, 클래스 멤버, 함수 및 관련 매개 변수와 같은 구성은 프로세서에서 쉽게 접근할 수 있기 때문에 코틀린 개발자들에게 편리하다. \n\n개념적으로 KSP는 Kotlin 리플렉션의 KType과 유사하다. API 를 사용하면 프로세서가 클래스 선언에서 특정 타입 인자가 있는 해당 타입, 또는 그 반대로 탐색할 수 있다.\n\nKAPT와 비교했을 때 KSP를 사용하는 [Annotation Processor](https://www.charlezz.com/?p=1167)는 최대 **2배** 더 빠르게 실행할 수 있다. \n\n자세한 내용은 [Google KSP repository](https://github.com/google/ksp)에서 소스코드 및 문서를 확인할 수 있다. \n\n### 왜 KSP를 사용해야 할까?\n\n컴파일러 플러그인은 코드 작성 방법을 크게 향상시킬 수 있는 강력한 메타프로그래밍 도구이다. \n\n컴파일러 플러그인은 컴파일러를 라이브러리로 직접 호출하여 입력 프로그램을 분석하고 편집하여 다양한 용도로 쓰일 수 있는 산출물들을 생성한다.. \n\n예를 들어, Boiler Plate를 생성하거나 Parcelble과 같은 특별히 마크된 프로그램 요소에 대한 전체 구현을 생성할 수도 있다. \n\n플러그인은 다양한 용도로 사용되며 언어로 직접 제공되지 않는 기능을 구현하고 미세 조정하는 데 사용할 수도 있다. \n\n다만 컴파일러 플러그인은 컴파일러에 대한 배경 지식 및 특정 컴파일러의 구현 세부 사항에 대한 숙련도를 어느정도 필요로 하므로 어느 정도의 진입 장벽이 요구된다.\n\n이 진입 장벽을 최대한 낮추고자 KSP 는 컴파일러의 변경사항을 은닉하도록 설계되어 최소한의 유지 보수로 플러그인을 개발할 수 있게 해준다.\n\n또한 JVM에 종속되지않도록 설계되었으므로, 다른 플랫폼에 적용하는 것도 용이하다.\n\n무엇보다 KSP는 빌드시간을 최소화하는 것이 가장 큰 장점이다.\n\nGlide 와 같은 일부 Processor의 경우 KSP는 KAPT와 비교할 때 컴파일 시간을 25%까지 줄이는 것으로 확인되었다.\n\n#### **kotlinc** 컴파일러 플러그인과의 비교\n\n`kotlinc` 컴파일러 플러그인의 경우 강력한 기능을 제공하는 것은 맞지만, 그만큼 컴파일러에 대한 의존성이 크기때문에 유지보수에 대한 용이성이 떨어진다. 반면 KSP는 대부분의 컴파일러 변경사항을 은닉하여 api를 통해 접근할 수 있도록 해준다. 물론 한 단계를 더 건너야하는 만큼 `kotlinc`의 모든 기능을 지원하지는 않지만, 기술 부채를 고려하였을 때 합리적인 선택이 될 것이다.\n\n#### **kotlin.reflect** 와의 비교\n\nKSP는 `kotlin.reflect`와 유사하게 생겼지만, KSP는 타입에 대한 참조를 명시적으로 지정해주어야 한다.\n\n### KSP의 한계점\n\nKSP는 기존의 Annotation Processor에 비해 상대적으로 간단한 방법론을 제공하기 위해 몇 가지 절충한 부분이 존재한다.\n\n따라서 아래의 기능들은 KSP에서 제공하고자 하는 대상이 아니다.\n\n1. 소스 코드의 표현 수준 정보를 조사하기\n2. 소스 코드 수정하기\n3. Java Annotation Processing API와 100% 호환하기\n4. IDE와 통합하기 (현재는 IDE가 생성 된 코드를 읽지 못함)\n\n특히 4번 항목때문에 Android Studio에서 KSP를 개발하여 사용하고자 하는 경우엔 아래와 같은 경로를 명시해야 한다.\n\n```kotlin\nbuild/generated/ksp/debug/kotlin\n```\n\nbuild.gradle.kts 예시\n\n```kotlin\nandroid {\n    buildTypes {\n        getByName(\"debug\") {\n            sourceSets {\n                getByName(\"main\") {\n                    java.srcDir(File(\"build/generated/ksp/debug/kotlin\"))\n                }\n            }\n        }\n    }\n}\n```\n\n### KSP 내부 살펴보기\n\n{% asset_img ClassDiagram.svg [ClassDiagram] %}\n\n위의 그림은 매우 복잡하고 사이즈가 크니, 클릭해서 크게 보는 것을 권장한다.\n\n> **참고** [KSP API definition](https://github.com/google/ksp/blob/main/api/src/main/kotlin/com/google/devtools/ksp)\n\n> **참고** [KSP Symbol definition](https://github.com/google/ksp/blob/main/api/src/main/kotlin/com/google/devtools/ksp/symbol)\n\nKSP 모델에 대한 딥다이브를 해보자.\n\n먼저 KSP의 전체 구조는 아래와 같다.\n\n#### KSP가 파일을 파싱하는 구조\n\nKSP를 사용하기 위해 작업하는 경우 아래와 같은 구조로 작성해야 한다.\n\n복잡해보이지만 `KS`는 prefix일 뿐이고, kotlin으로 작성한 파일 구조를 추종한다는 것을 알 수 있다.\n\n\n```kotlin\nKSFile\n    /**\n     * File의 정보\n     * - Package Name / File Name / 적용된 Anootation 리스트\n     * - simpleName, qualifiedName 등을 포함한 선언 정보\n     */\n    packageName: KSName\n    fileName: String\n    annotations: List<KSAnnotation>  (File annotations)\n    declarations: List<KSDeclaration>\n   \n    /**\n     * Class / Interface / Object\n     */\n    KSClassDeclaration\n        simpleName: KSName\n        qualifiedName: KSName\n        containingFile: String\n        typeParameters: KSTypeParameter\n        parentDeclaration: KSDeclaration\n        classKind: ClassKind\n        primaryConstructor: KSFunctionDeclaration\n        superTypes: List<KSTypeReference>\n        declarations: List<KSDeclaration> // contains inner classes, member functions, properties, etc.\n\n    /**\n     * Top-Level Funtion\n     */\n    KSFunctionDeclaration\n        simpleName: KSName\n        qualifiedName: KSName\n        containingFile: String\n        typeParameters: KSTypeParameter\n        parentDeclaration: KSDeclaration\n        functionKind: FunctionKind\n        extensionReceiver: KSTypeReference?\n        returnType: KSTypeReference\n        parameters: List<KSValueParameter>\n        declarations: List<KSDeclaration> // contains local classes, local functions, local variables, etc.\n\n    /*\n     * Global Variable\n     */\n    KSPropertyDeclaration \n        simpleName: KSName\n    qualifiedName: KSName\n    containingFile: String\n    typeParameters: KSTypeParameter\n    parentDeclaration: KSDeclaration\n    extensionReceiver: KSTypeReference?\n    type: KSTypeReference\n    getter: KSPropertyGetter\n        returnType: KSTypeReference\n    setter: KSPropertySetter\n        parameter: KSValueParameter\n```\n\n위의 파일 구조를 실제 구조에 대입하여 파악해보자.\n\n`AppcompatActivity`를 상속한 `SampleActivity`가 있다고 할때, \n\nAnnotation이 붙여진 `어떠한 것`이 변수인지, 함수인지, 클래스인지를 알고 싶다면, 위 구성을 이해하면 된다. 아래와 같이 Activity를 구성했다고 가정해보자.\n\n``` kotlin\n// KSFile\npackage com.jshme.kspsample\n\nimport androidx.appcompat.app.AppCompatActivity\nimport android.os.Bundle\n\n@TestAnnotation //KClassDeclaration \nclass SampleActivity : AppCompatActivity() {\n\n    @Test //KSPropertyDeclaration\n    var number: Int = 0\n\n    @Test //KSPropertyDeclaration\n    var str: String = \"\"\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_sample)\n        \n        number = 2\n        str = \"Test Sample\"\n    }\n}\n```\n\n`@TestAnnotation` 이 달린 곳은 클래스 타입이므로 KClassDeclaration으로 구성될 것이고, \n\n@Test` 가 달린 곳은 KSPropertyDeclaration으로 구성될 것이다. 파일 내부를 돌면서 클래스, 함수, 변수타입을 구별해내 `KSDeclaration` 으로 정의하는 것이다. \n\n이 구조도와 예제를 통해 `KSClassDeclaration`, `KSFunctionDeclaration`, `KSPropertyDeclaration` \n\n세 가지 타입의 경우 `KSDeclaration`를 상속받고 있기때문에 타입 캐스팅을 사용할 수 있기때문에, 리스트 형태로 관리할 수 있음을 확인할 수 있다.\n\n#### KSP의 타입 참조 프로세스\n\nKSP에서 타입에 대한 참조는 몇 가지 예외를 제외하면 명시적으로 지정하도록 되어있다.\n\n`KSFunctionDeclaration.returnType` 혹은 `KSAnnotation.annotationType`과 같이 타입을 참조하는 경우, \n\n타입은 항상 annotation과 modifier가 포함된 `KSReferenceElement` 기반의 `KSTypeReference`이다.\n\n```kotlin\ninterface KSFunctionDeclaration : ... {\n    val returnType: KSTypeReference?\n    ...\n}\n\ninterface KSTypeReference : KSAnnotated, KSModifierListOwner {\n    val type: KSReferenceElement\n}\n```\n\n`KSTypeReference`는 Kotlin의 타입 시스템의 `KSType`으로 `resolve()`할 수 있고, Kotlin 문법과 일치하는 `KSReferenceElement`를 가지고 있다.\n\n이번엔 `KSReferenceElement`다.\n\n\n```kotlin\ninterface KSReferenceElement : KSNode {\n    val typeArguments: List<KSTypeArgument>\n}\n```\n\n`KSReferenceElement`는 유용한 정보를 많이 포함하고 있는 `KSClassifierReference` 혹은 `KSCallableReference`가 될 수 있다.\n\n```kotlin\ninterface KSClassifierReference : KSReferenceElement {\n    val qualifier: KSClassifierReference?\n    fun referencedName(): String\n\n    override fun <D, R> accept(visitor: KSVisitor<D, R>, data: D): R {\n        return visitor.visitClassifierReference(this, data)\n    }\n}\n```\n\n예를 들어 `KSClassifierReference`는 `referencedName`라는 속성을 가지고 있으며,\n\n```kotlin\ninterface KSCallableReference : KSReferenceElement {\n    val receiverType: KSTypeReference?\n    val functionParameters: List<KSValueParameter>\n    val returnType: KSTypeReference\n\n    override fun <D, R> accept(visitor: KSVisitor<D, R>, data: D): R {\n        return visitor.visitCallableReference(this, data)\n    }\n}\n```\n\n`KSCallableReference`는 `receiverType`과 `functionArguments` 그리고 `returnType`을 가지고 있다.\n\n`KSTypeReference`에서 참조되는 타입의 선언이 필요한 경우 아래와 같은 순서로 접근한다.\n\n```kotlin\nKSTypeReference -> .resolve() -> KSType -> .declaration -> KSDeclaration\n```\n\n`resolve()`를 통해 `KSType`으로 접근하고, `declaration` 속성을 통해 `KSDeclaration` 객체를 획득한다.\n\n#### Java Annotation Processing에 대응하는 KSP 레퍼런스\n\n기존에 Annotation processor를 작성해 본 경험이 있다면 아래의 내용을 참조하면 좋다. 내용이 방대하여 링크로 대체한다.\n\n> **참고** [Github ksp#references](https://github.com/google/ksp/blob/main/docs/reference.md)\n\n<br>\n<br>\n<br>\n\n## KSP 개발 프로세스\n\nKSP repository에도 playground가 있지만, 공식 repo와 문서가 자세하거나 친절하게 작성되어있지않아 임의로 개발 프로세스를 예제 기반으로 명세해보았다.\n\n개략적인 내용은 ksp repository의 QuickStart 문서에 나와있다.\n\n> **참고** [Github ksp#quickstart](https://github.com/google/ksp/blob/main/docs/quickstart.md)\n\nKSP 개발을 위한 환경은 갖추어져 있다고 가정한다.\n\n**Step 1**\nYou'll need to implement `com.google.devtools.ksp.processing.SymbolProcessor` and `com.google.devtools.ksp.processing.SymbolProcessorProvider`. \n\nYour implementation of `SymbolProcessorProvider` will be loaded as a service to instantiate the `SymbolProcessor` you implement.\n\n먼저 `SymbolProcessor`를 상속받은 구현체를 작성한다.\n\n```kotlin\n// BuilderProcessor.kt\nclass BuilderProcessor(\n    val codeGenerator: CodeGenerator,\n    val logger: KSPLogger\n) : SymbolProcessor {\n    // ...\n}\n```\n\n그리고 `SymbolProcessorProvider`를 상속받은 구현체도 선언한다.\n\n```kotlin\n// BuilderProcessorProvider.kt\nclass BuilderProcessorProvider : SymbolProcessorProvider {\n    // ...\n}\n```\n\n**Step 2**\nImplement `SymbolProcessorProvider.create()` to create a `SymbolProcessor`. \n\nDependencies your processor needs (e.g. `CodeGenerator`, processor options) are passed through the parameters of `SymbolProcessorProvider.create()`.\n\n`BuilderProcessorProvider` 클래스에 `SymbolProcessorProvider.create()` 메소드를 구현한다.\n\n```kotlin\n// BuilderProcessorProvider.kt\nclass BuilderProcessorProvider : SymbolProcessorProvider {\n    override fun create(environment: SymbolProcessorEnvironment): SymbolProcessor {\n        return BuilderProcessor(environment.codeGenerator, environment.logger)\n    }\n}\n```\n\n**Step 3**\nYour main logic should be in the SymbolProcessor.process() method.\n\n`BuilderProcessor`의 핵심 로직인 `SymbolProcessor.process()` 메서드를 오버라이딩 한다.\n\n```kotlin\nclass BuilderProcessor : SymbolProcessor {\n\n    override fun process(resolver: Resolver): List<KSAnnotated> {\n        // ...\n    }\n    // ...\n}\n```\n\n**Step 4**\nUse resolver.getSymbolsWithAnnotation() to get the symbols you want to process, given the fully-qualified name of an annotation.\n\nStep 3에서 선언한 `BuilderProcessor` 클래스의 `process()`에 파라미터로 주어지는 `resolver`에 `getSymbolsWithAnnotation()` 메소드를 호출하여 KSP를 명시한다.\n\n```kotlin\nclass BuilderProcessor(\n    val codeGenerator: CodeGenerator,\n    val logger: KSPLogger\n) : SymbolProcessor {\n\n    override fun process(resolver: Resolver): List<KSAnnotated> {\n        val symbols = resolver.getSymbolsWithAnnotation(\"android.deepdive.ksp.builder.Builder\")\n        val ret = symbols.filter { !it.validate() }.toList()\n\n        symbols\n            .filter { it is KSClassDeclaration && it.validate() }\n            .forEach { it.accept(BuilderVisitor(), Unit) }\n        return ret\n    }\n    // ...\n}\n```\n\n**Step 5**\nA common use case for KSP is to implement a customized visitor (interface com.google.devtools.ksp.symbol.KSVisitor) for operating on symbols. A simple template visitor is com.google.devtools.ksp.symbol.KSDefaultVisitor.\n\n`com.google.devtools.ksp.symbol.KSDefaultVisitor`를 참조하여 Visiter 클래스를 작성한다.\n\n```kotlin\nclass BuilderProcessor(\n    val codeGenerator: CodeGenerator,\n    val logger: KSPLogger\n) : SymbolProcessor {\n    // ...\n    inner class BuilderVisitor : KSVisitorVoid() {\n        override fun visitClassDeclaration(classDeclaration: KSClassDeclaration, data: Unit) {\n            classDeclaration.primaryConstructor!!.accept(this, data)\n        }\n\n        override fun visitFunctionDeclaration(function: KSFunctionDeclaration, data: Unit) {\n            val parent = function.parentDeclaration as KSClassDeclaration\n            val packageName = parent.containingFile!!.packageName.asString()\n            val className = \"${parent.simpleName.asString()}Builder\"\n            val file = codeGenerator.createNewFile(Dependencies(true, function.containingFile!!), packageName, className)\n\n            file.appendText(\"package $packageName\\n\\n\")\n            file.appendText(\"import HELLO\\n\\n\")\n            file.appendText(\"class $className{\\n\")\n\n            function.parameters.forEach {\n                val name = it.name!!.asString()\n                val typeName = StringBuilder(it.type.resolve().declaration.qualifiedName?.asString() ?: \"<ERROR>\")\n                val typeArgs = it.type.element!!.typeArguments\n\n                if (it.type.element!!.typeArguments.isNotEmpty()) {\n                    typeName.append(\"<\")\n                    typeName.append(\n                        typeArgs.map {\n                            val type = it.type?.resolve()\n                            \"${it.variance.label} ${type?.declaration?.qualifiedName?.asString() ?: \"ERROR\"}\" +\n                                    if (type?.nullability == Nullability.NULLABLE) \"?\" else \"\"\n                        }.joinToString(\", \")\n                    )\n                    typeName.append(\">\")\n                }\n                file.appendText(\"    private var $name: $typeName? = null\\n\")\n                file.appendText(\"    internal fun with${name.capitalize()}($name: $typeName): $className {\\n\")\n                file.appendText(\"        this.$name = $name\\n\")\n                file.appendText(\"        return this\\n\")\n                file.appendText(\"    }\\n\\n\")\n            }\n\n            file.appendText(\"    internal fun build(): ${parent.qualifiedName!!.asString()} {\\n\")\n            file.appendText(\"        return ${parent.qualifiedName!!.asString()}(\")\n            file.appendText(\n                function.parameters.map {\n                    \"${it.name!!.asString()}!!\"\n                }.joinToString(\", \")\n            )\n            file.appendText(\")\\n\")\n            file.appendText(\"    }\\n\")\n            file.appendText(\"}\\n\")\n            file.close()\n        }\n    }\n    // ...\n}\n```\n\n**Step 6**\nFor sample implementations of the SymbolProcessorProvider and SymbolProcessor interfaces, see the following files in the sample project.\n- src/main/kotlin/BuilderProcessor.kt\n- src/main/kotlin/TestProcessor.kt\n\n작성한 클래스는 아래와 같다.\n\n- src/main/java/android/deepdive/ksp/builder/BuilderProcessor.kt\n- src/main/java/android/deepdive/ksp/builder/BuilderProcessorProvider.kt\n\n**Step 7**\nAfter writing your own processor, register your processor provider to the package by including its fully-qualified name in resources/META-INF/services/com.google.devtools.ksp.processing.SymbolProcessorProvider.\n\n`META-INF`에 작성한 `BuilderProcessorProvider`의 path를 명시한다.\n\n```\n// path : src/main/resources/META-INF/services/com.google.devtools.ksp.processing.SymbolProcessorProvider\nandroid.deepdive.ksp.builder.BuilderProcessorProvider\n```\n\n실제 스터디를 진행하면서 만들어본 KSP 예제는 아래 링크를 참조하면 된다.\n\n- [Android Deep Dive#Kotlin-Symbol-Processing-Api](https://github.com/AndroidDeepDive/ADD-Kotlin-Symbol-Processing-Api)\n- [Charlezz#IntentBuilderSample](https://github.com/Charlezz/IntentBuilderSample)\n- [SODA1127#KSPImplementationExample](https://github.com/SODA1127/KSPImplementationExample)\n- [jsh-me#KSPWebViewLoader](https://github.com/jsh-me/KSPWebViewLoader)","source":"_posts/2021-07-21 Kotlin Symbol Processing Api Part 2.md","raw":"---\ntitle: Kotlin Symbol Processing Api Part 2 — What is it?\ndate: 2021-07-21 02:00\ncover: https://androiddeepdive.github.io/Team-Blog/images/cover_ksp.png\ncategories:\n- KSP\ntags:\n- KSP\n- Kotlin\n- Symbol\n- Processing\n- KAPT\n- Annotation\n---\n\n<article class=\"message message-immersive is-primary\">\n    <div class=\"message-body\">\n        <i class=\"fas fa-pen-fancy mr-2\"></i>Writers<br>\n        by 곽욱현 @Knowre<br>\n        by 김남훈 @Naver<br>\n        by 송시영 @SmartStudy<br>\n        by 옥수환 @Naver<br>\n        by 이기정 @BankSalad<br>\n        by 정세희 @BankSalad\n    </div>\n</article>\n\n\n<!-- more -->\n\n## KSP란 무엇인가?\n\n**KSP(Kotlin Symbol Processing)** 은 2021년 2월 10일 구글이 발표한 코틀린에서 경량화된 컴파일러 플러그인을 개발할 수 있는 API다. \n\n학습곡선을 최소한으로 줄이고, 코틀린의 기능을 활용할 수 있는 단순화된 API를 제공한다. 여러 플랫폼에 호환성을 염두하고 만들어졌으며, 코틀린 1.4.30 버전 이상부터 호환된다. \n\nKSP는 코틀린 언어가 갖는 특징인 확장 함수, 로컬 함수 같은 기능을 이해한다. \n\n또한 KSP는 타입을 명시적으로 다루고, 기본적인 타입 검사와 동등성 검사를 지원한다. \n\nAPI는 코틀린 문법에 따라 symbol 수준에서 코틀린 프로그램 구조를 모델링 한다. \n\nKSP 기반 플러그인이 소스 프로그램을 처리할 때 클래스, 클래스 멤버, 함수 및 관련 매개 변수와 같은 구성은 프로세서에서 쉽게 접근할 수 있기 때문에 코틀린 개발자들에게 편리하다. \n\n개념적으로 KSP는 Kotlin 리플렉션의 KType과 유사하다. API 를 사용하면 프로세서가 클래스 선언에서 특정 타입 인자가 있는 해당 타입, 또는 그 반대로 탐색할 수 있다.\n\nKAPT와 비교했을 때 KSP를 사용하는 [Annotation Processor](https://www.charlezz.com/?p=1167)는 최대 **2배** 더 빠르게 실행할 수 있다. \n\n자세한 내용은 [Google KSP repository](https://github.com/google/ksp)에서 소스코드 및 문서를 확인할 수 있다. \n\n### 왜 KSP를 사용해야 할까?\n\n컴파일러 플러그인은 코드 작성 방법을 크게 향상시킬 수 있는 강력한 메타프로그래밍 도구이다. \n\n컴파일러 플러그인은 컴파일러를 라이브러리로 직접 호출하여 입력 프로그램을 분석하고 편집하여 다양한 용도로 쓰일 수 있는 산출물들을 생성한다.. \n\n예를 들어, Boiler Plate를 생성하거나 Parcelble과 같은 특별히 마크된 프로그램 요소에 대한 전체 구현을 생성할 수도 있다. \n\n플러그인은 다양한 용도로 사용되며 언어로 직접 제공되지 않는 기능을 구현하고 미세 조정하는 데 사용할 수도 있다. \n\n다만 컴파일러 플러그인은 컴파일러에 대한 배경 지식 및 특정 컴파일러의 구현 세부 사항에 대한 숙련도를 어느정도 필요로 하므로 어느 정도의 진입 장벽이 요구된다.\n\n이 진입 장벽을 최대한 낮추고자 KSP 는 컴파일러의 변경사항을 은닉하도록 설계되어 최소한의 유지 보수로 플러그인을 개발할 수 있게 해준다.\n\n또한 JVM에 종속되지않도록 설계되었으므로, 다른 플랫폼에 적용하는 것도 용이하다.\n\n무엇보다 KSP는 빌드시간을 최소화하는 것이 가장 큰 장점이다.\n\nGlide 와 같은 일부 Processor의 경우 KSP는 KAPT와 비교할 때 컴파일 시간을 25%까지 줄이는 것으로 확인되었다.\n\n#### **kotlinc** 컴파일러 플러그인과의 비교\n\n`kotlinc` 컴파일러 플러그인의 경우 강력한 기능을 제공하는 것은 맞지만, 그만큼 컴파일러에 대한 의존성이 크기때문에 유지보수에 대한 용이성이 떨어진다. 반면 KSP는 대부분의 컴파일러 변경사항을 은닉하여 api를 통해 접근할 수 있도록 해준다. 물론 한 단계를 더 건너야하는 만큼 `kotlinc`의 모든 기능을 지원하지는 않지만, 기술 부채를 고려하였을 때 합리적인 선택이 될 것이다.\n\n#### **kotlin.reflect** 와의 비교\n\nKSP는 `kotlin.reflect`와 유사하게 생겼지만, KSP는 타입에 대한 참조를 명시적으로 지정해주어야 한다.\n\n### KSP의 한계점\n\nKSP는 기존의 Annotation Processor에 비해 상대적으로 간단한 방법론을 제공하기 위해 몇 가지 절충한 부분이 존재한다.\n\n따라서 아래의 기능들은 KSP에서 제공하고자 하는 대상이 아니다.\n\n1. 소스 코드의 표현 수준 정보를 조사하기\n2. 소스 코드 수정하기\n3. Java Annotation Processing API와 100% 호환하기\n4. IDE와 통합하기 (현재는 IDE가 생성 된 코드를 읽지 못함)\n\n특히 4번 항목때문에 Android Studio에서 KSP를 개발하여 사용하고자 하는 경우엔 아래와 같은 경로를 명시해야 한다.\n\n```kotlin\nbuild/generated/ksp/debug/kotlin\n```\n\nbuild.gradle.kts 예시\n\n```kotlin\nandroid {\n    buildTypes {\n        getByName(\"debug\") {\n            sourceSets {\n                getByName(\"main\") {\n                    java.srcDir(File(\"build/generated/ksp/debug/kotlin\"))\n                }\n            }\n        }\n    }\n}\n```\n\n### KSP 내부 살펴보기\n\n{% asset_img ClassDiagram.svg [ClassDiagram] %}\n\n위의 그림은 매우 복잡하고 사이즈가 크니, 클릭해서 크게 보는 것을 권장한다.\n\n> **참고** [KSP API definition](https://github.com/google/ksp/blob/main/api/src/main/kotlin/com/google/devtools/ksp)\n\n> **참고** [KSP Symbol definition](https://github.com/google/ksp/blob/main/api/src/main/kotlin/com/google/devtools/ksp/symbol)\n\nKSP 모델에 대한 딥다이브를 해보자.\n\n먼저 KSP의 전체 구조는 아래와 같다.\n\n#### KSP가 파일을 파싱하는 구조\n\nKSP를 사용하기 위해 작업하는 경우 아래와 같은 구조로 작성해야 한다.\n\n복잡해보이지만 `KS`는 prefix일 뿐이고, kotlin으로 작성한 파일 구조를 추종한다는 것을 알 수 있다.\n\n\n```kotlin\nKSFile\n    /**\n     * File의 정보\n     * - Package Name / File Name / 적용된 Anootation 리스트\n     * - simpleName, qualifiedName 등을 포함한 선언 정보\n     */\n    packageName: KSName\n    fileName: String\n    annotations: List<KSAnnotation>  (File annotations)\n    declarations: List<KSDeclaration>\n   \n    /**\n     * Class / Interface / Object\n     */\n    KSClassDeclaration\n        simpleName: KSName\n        qualifiedName: KSName\n        containingFile: String\n        typeParameters: KSTypeParameter\n        parentDeclaration: KSDeclaration\n        classKind: ClassKind\n        primaryConstructor: KSFunctionDeclaration\n        superTypes: List<KSTypeReference>\n        declarations: List<KSDeclaration> // contains inner classes, member functions, properties, etc.\n\n    /**\n     * Top-Level Funtion\n     */\n    KSFunctionDeclaration\n        simpleName: KSName\n        qualifiedName: KSName\n        containingFile: String\n        typeParameters: KSTypeParameter\n        parentDeclaration: KSDeclaration\n        functionKind: FunctionKind\n        extensionReceiver: KSTypeReference?\n        returnType: KSTypeReference\n        parameters: List<KSValueParameter>\n        declarations: List<KSDeclaration> // contains local classes, local functions, local variables, etc.\n\n    /*\n     * Global Variable\n     */\n    KSPropertyDeclaration \n        simpleName: KSName\n    qualifiedName: KSName\n    containingFile: String\n    typeParameters: KSTypeParameter\n    parentDeclaration: KSDeclaration\n    extensionReceiver: KSTypeReference?\n    type: KSTypeReference\n    getter: KSPropertyGetter\n        returnType: KSTypeReference\n    setter: KSPropertySetter\n        parameter: KSValueParameter\n```\n\n위의 파일 구조를 실제 구조에 대입하여 파악해보자.\n\n`AppcompatActivity`를 상속한 `SampleActivity`가 있다고 할때, \n\nAnnotation이 붙여진 `어떠한 것`이 변수인지, 함수인지, 클래스인지를 알고 싶다면, 위 구성을 이해하면 된다. 아래와 같이 Activity를 구성했다고 가정해보자.\n\n``` kotlin\n// KSFile\npackage com.jshme.kspsample\n\nimport androidx.appcompat.app.AppCompatActivity\nimport android.os.Bundle\n\n@TestAnnotation //KClassDeclaration \nclass SampleActivity : AppCompatActivity() {\n\n    @Test //KSPropertyDeclaration\n    var number: Int = 0\n\n    @Test //KSPropertyDeclaration\n    var str: String = \"\"\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_sample)\n        \n        number = 2\n        str = \"Test Sample\"\n    }\n}\n```\n\n`@TestAnnotation` 이 달린 곳은 클래스 타입이므로 KClassDeclaration으로 구성될 것이고, \n\n@Test` 가 달린 곳은 KSPropertyDeclaration으로 구성될 것이다. 파일 내부를 돌면서 클래스, 함수, 변수타입을 구별해내 `KSDeclaration` 으로 정의하는 것이다. \n\n이 구조도와 예제를 통해 `KSClassDeclaration`, `KSFunctionDeclaration`, `KSPropertyDeclaration` \n\n세 가지 타입의 경우 `KSDeclaration`를 상속받고 있기때문에 타입 캐스팅을 사용할 수 있기때문에, 리스트 형태로 관리할 수 있음을 확인할 수 있다.\n\n#### KSP의 타입 참조 프로세스\n\nKSP에서 타입에 대한 참조는 몇 가지 예외를 제외하면 명시적으로 지정하도록 되어있다.\n\n`KSFunctionDeclaration.returnType` 혹은 `KSAnnotation.annotationType`과 같이 타입을 참조하는 경우, \n\n타입은 항상 annotation과 modifier가 포함된 `KSReferenceElement` 기반의 `KSTypeReference`이다.\n\n```kotlin\ninterface KSFunctionDeclaration : ... {\n    val returnType: KSTypeReference?\n    ...\n}\n\ninterface KSTypeReference : KSAnnotated, KSModifierListOwner {\n    val type: KSReferenceElement\n}\n```\n\n`KSTypeReference`는 Kotlin의 타입 시스템의 `KSType`으로 `resolve()`할 수 있고, Kotlin 문법과 일치하는 `KSReferenceElement`를 가지고 있다.\n\n이번엔 `KSReferenceElement`다.\n\n\n```kotlin\ninterface KSReferenceElement : KSNode {\n    val typeArguments: List<KSTypeArgument>\n}\n```\n\n`KSReferenceElement`는 유용한 정보를 많이 포함하고 있는 `KSClassifierReference` 혹은 `KSCallableReference`가 될 수 있다.\n\n```kotlin\ninterface KSClassifierReference : KSReferenceElement {\n    val qualifier: KSClassifierReference?\n    fun referencedName(): String\n\n    override fun <D, R> accept(visitor: KSVisitor<D, R>, data: D): R {\n        return visitor.visitClassifierReference(this, data)\n    }\n}\n```\n\n예를 들어 `KSClassifierReference`는 `referencedName`라는 속성을 가지고 있으며,\n\n```kotlin\ninterface KSCallableReference : KSReferenceElement {\n    val receiverType: KSTypeReference?\n    val functionParameters: List<KSValueParameter>\n    val returnType: KSTypeReference\n\n    override fun <D, R> accept(visitor: KSVisitor<D, R>, data: D): R {\n        return visitor.visitCallableReference(this, data)\n    }\n}\n```\n\n`KSCallableReference`는 `receiverType`과 `functionArguments` 그리고 `returnType`을 가지고 있다.\n\n`KSTypeReference`에서 참조되는 타입의 선언이 필요한 경우 아래와 같은 순서로 접근한다.\n\n```kotlin\nKSTypeReference -> .resolve() -> KSType -> .declaration -> KSDeclaration\n```\n\n`resolve()`를 통해 `KSType`으로 접근하고, `declaration` 속성을 통해 `KSDeclaration` 객체를 획득한다.\n\n#### Java Annotation Processing에 대응하는 KSP 레퍼런스\n\n기존에 Annotation processor를 작성해 본 경험이 있다면 아래의 내용을 참조하면 좋다. 내용이 방대하여 링크로 대체한다.\n\n> **참고** [Github ksp#references](https://github.com/google/ksp/blob/main/docs/reference.md)\n\n<br>\n<br>\n<br>\n\n## KSP 개발 프로세스\n\nKSP repository에도 playground가 있지만, 공식 repo와 문서가 자세하거나 친절하게 작성되어있지않아 임의로 개발 프로세스를 예제 기반으로 명세해보았다.\n\n개략적인 내용은 ksp repository의 QuickStart 문서에 나와있다.\n\n> **참고** [Github ksp#quickstart](https://github.com/google/ksp/blob/main/docs/quickstart.md)\n\nKSP 개발을 위한 환경은 갖추어져 있다고 가정한다.\n\n**Step 1**\nYou'll need to implement `com.google.devtools.ksp.processing.SymbolProcessor` and `com.google.devtools.ksp.processing.SymbolProcessorProvider`. \n\nYour implementation of `SymbolProcessorProvider` will be loaded as a service to instantiate the `SymbolProcessor` you implement.\n\n먼저 `SymbolProcessor`를 상속받은 구현체를 작성한다.\n\n```kotlin\n// BuilderProcessor.kt\nclass BuilderProcessor(\n    val codeGenerator: CodeGenerator,\n    val logger: KSPLogger\n) : SymbolProcessor {\n    // ...\n}\n```\n\n그리고 `SymbolProcessorProvider`를 상속받은 구현체도 선언한다.\n\n```kotlin\n// BuilderProcessorProvider.kt\nclass BuilderProcessorProvider : SymbolProcessorProvider {\n    // ...\n}\n```\n\n**Step 2**\nImplement `SymbolProcessorProvider.create()` to create a `SymbolProcessor`. \n\nDependencies your processor needs (e.g. `CodeGenerator`, processor options) are passed through the parameters of `SymbolProcessorProvider.create()`.\n\n`BuilderProcessorProvider` 클래스에 `SymbolProcessorProvider.create()` 메소드를 구현한다.\n\n```kotlin\n// BuilderProcessorProvider.kt\nclass BuilderProcessorProvider : SymbolProcessorProvider {\n    override fun create(environment: SymbolProcessorEnvironment): SymbolProcessor {\n        return BuilderProcessor(environment.codeGenerator, environment.logger)\n    }\n}\n```\n\n**Step 3**\nYour main logic should be in the SymbolProcessor.process() method.\n\n`BuilderProcessor`의 핵심 로직인 `SymbolProcessor.process()` 메서드를 오버라이딩 한다.\n\n```kotlin\nclass BuilderProcessor : SymbolProcessor {\n\n    override fun process(resolver: Resolver): List<KSAnnotated> {\n        // ...\n    }\n    // ...\n}\n```\n\n**Step 4**\nUse resolver.getSymbolsWithAnnotation() to get the symbols you want to process, given the fully-qualified name of an annotation.\n\nStep 3에서 선언한 `BuilderProcessor` 클래스의 `process()`에 파라미터로 주어지는 `resolver`에 `getSymbolsWithAnnotation()` 메소드를 호출하여 KSP를 명시한다.\n\n```kotlin\nclass BuilderProcessor(\n    val codeGenerator: CodeGenerator,\n    val logger: KSPLogger\n) : SymbolProcessor {\n\n    override fun process(resolver: Resolver): List<KSAnnotated> {\n        val symbols = resolver.getSymbolsWithAnnotation(\"android.deepdive.ksp.builder.Builder\")\n        val ret = symbols.filter { !it.validate() }.toList()\n\n        symbols\n            .filter { it is KSClassDeclaration && it.validate() }\n            .forEach { it.accept(BuilderVisitor(), Unit) }\n        return ret\n    }\n    // ...\n}\n```\n\n**Step 5**\nA common use case for KSP is to implement a customized visitor (interface com.google.devtools.ksp.symbol.KSVisitor) for operating on symbols. A simple template visitor is com.google.devtools.ksp.symbol.KSDefaultVisitor.\n\n`com.google.devtools.ksp.symbol.KSDefaultVisitor`를 참조하여 Visiter 클래스를 작성한다.\n\n```kotlin\nclass BuilderProcessor(\n    val codeGenerator: CodeGenerator,\n    val logger: KSPLogger\n) : SymbolProcessor {\n    // ...\n    inner class BuilderVisitor : KSVisitorVoid() {\n        override fun visitClassDeclaration(classDeclaration: KSClassDeclaration, data: Unit) {\n            classDeclaration.primaryConstructor!!.accept(this, data)\n        }\n\n        override fun visitFunctionDeclaration(function: KSFunctionDeclaration, data: Unit) {\n            val parent = function.parentDeclaration as KSClassDeclaration\n            val packageName = parent.containingFile!!.packageName.asString()\n            val className = \"${parent.simpleName.asString()}Builder\"\n            val file = codeGenerator.createNewFile(Dependencies(true, function.containingFile!!), packageName, className)\n\n            file.appendText(\"package $packageName\\n\\n\")\n            file.appendText(\"import HELLO\\n\\n\")\n            file.appendText(\"class $className{\\n\")\n\n            function.parameters.forEach {\n                val name = it.name!!.asString()\n                val typeName = StringBuilder(it.type.resolve().declaration.qualifiedName?.asString() ?: \"<ERROR>\")\n                val typeArgs = it.type.element!!.typeArguments\n\n                if (it.type.element!!.typeArguments.isNotEmpty()) {\n                    typeName.append(\"<\")\n                    typeName.append(\n                        typeArgs.map {\n                            val type = it.type?.resolve()\n                            \"${it.variance.label} ${type?.declaration?.qualifiedName?.asString() ?: \"ERROR\"}\" +\n                                    if (type?.nullability == Nullability.NULLABLE) \"?\" else \"\"\n                        }.joinToString(\", \")\n                    )\n                    typeName.append(\">\")\n                }\n                file.appendText(\"    private var $name: $typeName? = null\\n\")\n                file.appendText(\"    internal fun with${name.capitalize()}($name: $typeName): $className {\\n\")\n                file.appendText(\"        this.$name = $name\\n\")\n                file.appendText(\"        return this\\n\")\n                file.appendText(\"    }\\n\\n\")\n            }\n\n            file.appendText(\"    internal fun build(): ${parent.qualifiedName!!.asString()} {\\n\")\n            file.appendText(\"        return ${parent.qualifiedName!!.asString()}(\")\n            file.appendText(\n                function.parameters.map {\n                    \"${it.name!!.asString()}!!\"\n                }.joinToString(\", \")\n            )\n            file.appendText(\")\\n\")\n            file.appendText(\"    }\\n\")\n            file.appendText(\"}\\n\")\n            file.close()\n        }\n    }\n    // ...\n}\n```\n\n**Step 6**\nFor sample implementations of the SymbolProcessorProvider and SymbolProcessor interfaces, see the following files in the sample project.\n- src/main/kotlin/BuilderProcessor.kt\n- src/main/kotlin/TestProcessor.kt\n\n작성한 클래스는 아래와 같다.\n\n- src/main/java/android/deepdive/ksp/builder/BuilderProcessor.kt\n- src/main/java/android/deepdive/ksp/builder/BuilderProcessorProvider.kt\n\n**Step 7**\nAfter writing your own processor, register your processor provider to the package by including its fully-qualified name in resources/META-INF/services/com.google.devtools.ksp.processing.SymbolProcessorProvider.\n\n`META-INF`에 작성한 `BuilderProcessorProvider`의 path를 명시한다.\n\n```\n// path : src/main/resources/META-INF/services/com.google.devtools.ksp.processing.SymbolProcessorProvider\nandroid.deepdive.ksp.builder.BuilderProcessorProvider\n```\n\n실제 스터디를 진행하면서 만들어본 KSP 예제는 아래 링크를 참조하면 된다.\n\n- [Android Deep Dive#Kotlin-Symbol-Processing-Api](https://github.com/AndroidDeepDive/ADD-Kotlin-Symbol-Processing-Api)\n- [Charlezz#IntentBuilderSample](https://github.com/Charlezz/IntentBuilderSample)\n- [SODA1127#KSPImplementationExample](https://github.com/SODA1127/KSPImplementationExample)\n- [jsh-me#KSPWebViewLoader](https://github.com/jsh-me/KSPWebViewLoader)","slug":"2021-07-21 Kotlin Symbol Processing Api Part 2","published":1,"updated":"2021-08-13T14:40:08.375Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cksagj7lx001x3lreg56deplf","content":"<article class=\"message message-immersive is-primary\">\n    <div class=\"message-body\">\n        <i class=\"fas fa-pen-fancy mr-2\"></i>Writers<br>\n        by 곽욱현 @Knowre<br>\n        by 김남훈 @Naver<br>\n        by 송시영 @SmartStudy<br>\n        by 옥수환 @Naver<br>\n        by 이기정 @BankSalad<br>\n        by 정세희 @BankSalad\n    </div>\n</article>\n\n\n<span id=\"more\"></span>\n\n<h2 id=\"KSP란-무엇인가\"><a href=\"#KSP란-무엇인가\" class=\"headerlink\" title=\"KSP란 무엇인가?\"></a>KSP란 무엇인가?</h2><p><strong>KSP(Kotlin Symbol Processing)</strong> 은 2021년 2월 10일 구글이 발표한 코틀린에서 경량화된 컴파일러 플러그인을 개발할 수 있는 API다. </p>\n<p>학습곡선을 최소한으로 줄이고, 코틀린의 기능을 활용할 수 있는 단순화된 API를 제공한다. 여러 플랫폼에 호환성을 염두하고 만들어졌으며, 코틀린 1.4.30 버전 이상부터 호환된다. </p>\n<p>KSP는 코틀린 언어가 갖는 특징인 확장 함수, 로컬 함수 같은 기능을 이해한다. </p>\n<p>또한 KSP는 타입을 명시적으로 다루고, 기본적인 타입 검사와 동등성 검사를 지원한다. </p>\n<p>API는 코틀린 문법에 따라 symbol 수준에서 코틀린 프로그램 구조를 모델링 한다. </p>\n<p>KSP 기반 플러그인이 소스 프로그램을 처리할 때 클래스, 클래스 멤버, 함수 및 관련 매개 변수와 같은 구성은 프로세서에서 쉽게 접근할 수 있기 때문에 코틀린 개발자들에게 편리하다. </p>\n<p>개념적으로 KSP는 Kotlin 리플렉션의 KType과 유사하다. API 를 사용하면 프로세서가 클래스 선언에서 특정 타입 인자가 있는 해당 타입, 또는 그 반대로 탐색할 수 있다.</p>\n<p>KAPT와 비교했을 때 KSP를 사용하는 <a href=\"https://www.charlezz.com/?p=1167\">Annotation Processor</a>는 최대 <strong>2배</strong> 더 빠르게 실행할 수 있다. </p>\n<p>자세한 내용은 <a href=\"https://github.com/google/ksp\">Google KSP repository</a>에서 소스코드 및 문서를 확인할 수 있다. </p>\n<h3 id=\"왜-KSP를-사용해야-할까\"><a href=\"#왜-KSP를-사용해야-할까\" class=\"headerlink\" title=\"왜 KSP를 사용해야 할까?\"></a>왜 KSP를 사용해야 할까?</h3><p>컴파일러 플러그인은 코드 작성 방법을 크게 향상시킬 수 있는 강력한 메타프로그래밍 도구이다. </p>\n<p>컴파일러 플러그인은 컴파일러를 라이브러리로 직접 호출하여 입력 프로그램을 분석하고 편집하여 다양한 용도로 쓰일 수 있는 산출물들을 생성한다.. </p>\n<p>예를 들어, Boiler Plate를 생성하거나 Parcelble과 같은 특별히 마크된 프로그램 요소에 대한 전체 구현을 생성할 수도 있다. </p>\n<p>플러그인은 다양한 용도로 사용되며 언어로 직접 제공되지 않는 기능을 구현하고 미세 조정하는 데 사용할 수도 있다. </p>\n<p>다만 컴파일러 플러그인은 컴파일러에 대한 배경 지식 및 특정 컴파일러의 구현 세부 사항에 대한 숙련도를 어느정도 필요로 하므로 어느 정도의 진입 장벽이 요구된다.</p>\n<p>이 진입 장벽을 최대한 낮추고자 KSP 는 컴파일러의 변경사항을 은닉하도록 설계되어 최소한의 유지 보수로 플러그인을 개발할 수 있게 해준다.</p>\n<p>또한 JVM에 종속되지않도록 설계되었으므로, 다른 플랫폼에 적용하는 것도 용이하다.</p>\n<p>무엇보다 KSP는 빌드시간을 최소화하는 것이 가장 큰 장점이다.</p>\n<p>Glide 와 같은 일부 Processor의 경우 KSP는 KAPT와 비교할 때 컴파일 시간을 25%까지 줄이는 것으로 확인되었다.</p>\n<h4 id=\"kotlinc-컴파일러-플러그인과의-비교\"><a href=\"#kotlinc-컴파일러-플러그인과의-비교\" class=\"headerlink\" title=\"kotlinc 컴파일러 플러그인과의 비교\"></a><strong>kotlinc</strong> 컴파일러 플러그인과의 비교</h4><p><code>kotlinc</code> 컴파일러 플러그인의 경우 강력한 기능을 제공하는 것은 맞지만, 그만큼 컴파일러에 대한 의존성이 크기때문에 유지보수에 대한 용이성이 떨어진다. 반면 KSP는 대부분의 컴파일러 변경사항을 은닉하여 api를 통해 접근할 수 있도록 해준다. 물론 한 단계를 더 건너야하는 만큼 <code>kotlinc</code>의 모든 기능을 지원하지는 않지만, 기술 부채를 고려하였을 때 합리적인 선택이 될 것이다.</p>\n<h4 id=\"kotlin-reflect-와의-비교\"><a href=\"#kotlin-reflect-와의-비교\" class=\"headerlink\" title=\"kotlin.reflect 와의 비교\"></a><strong>kotlin.reflect</strong> 와의 비교</h4><p>KSP는 <code>kotlin.reflect</code>와 유사하게 생겼지만, KSP는 타입에 대한 참조를 명시적으로 지정해주어야 한다.</p>\n<h3 id=\"KSP의-한계점\"><a href=\"#KSP의-한계점\" class=\"headerlink\" title=\"KSP의 한계점\"></a>KSP의 한계점</h3><p>KSP는 기존의 Annotation Processor에 비해 상대적으로 간단한 방법론을 제공하기 위해 몇 가지 절충한 부분이 존재한다.</p>\n<p>따라서 아래의 기능들은 KSP에서 제공하고자 하는 대상이 아니다.</p>\n<ol>\n<li>소스 코드의 표현 수준 정보를 조사하기</li>\n<li>소스 코드 수정하기</li>\n<li>Java Annotation Processing API와 100% 호환하기</li>\n<li>IDE와 통합하기 (현재는 IDE가 생성 된 코드를 읽지 못함)</li>\n</ol>\n<p>특히 4번 항목때문에 Android Studio에서 KSP를 개발하여 사용하고자 하는 경우엔 아래와 같은 경로를 명시해야 한다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">build/generated/ksp/debug/kotlin</span><br></pre></td></tr></table></figure>\n\n<p>build.gradle.kts 예시</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">android &#123;</span><br><span class=\"line\">    buildTypes &#123;</span><br><span class=\"line\">        getByName(<span class=\"string\">&quot;debug&quot;</span>) &#123;</span><br><span class=\"line\">            sourceSets &#123;</span><br><span class=\"line\">                getByName(<span class=\"string\">&quot;main&quot;</span>) &#123;</span><br><span class=\"line\">                    java.srcDir(File(<span class=\"string\">&quot;build/generated/ksp/debug/kotlin&quot;</span>))</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"KSP-내부-살펴보기\"><a href=\"#KSP-내부-살펴보기\" class=\"headerlink\" title=\"KSP 내부 살펴보기\"></a>KSP 내부 살펴보기</h3><img src=\"/Team-Blog/2021/07/21/2021-07-21%20Kotlin%20Symbol%20Processing%20Api%20Part%202/ClassDiagram.svg\" class=\"\" title=\"[ClassDiagram]\">\n\n<p>위의 그림은 매우 복잡하고 사이즈가 크니, 클릭해서 크게 보는 것을 권장한다.</p>\n<blockquote>\n<p><strong>참고</strong> <a href=\"https://github.com/google/ksp/blob/main/api/src/main/kotlin/com/google/devtools/ksp\">KSP API definition</a></p>\n</blockquote>\n<blockquote>\n<p><strong>참고</strong> <a href=\"https://github.com/google/ksp/blob/main/api/src/main/kotlin/com/google/devtools/ksp/symbol\">KSP Symbol definition</a></p>\n</blockquote>\n<p>KSP 모델에 대한 딥다이브를 해보자.</p>\n<p>먼저 KSP의 전체 구조는 아래와 같다.</p>\n<h4 id=\"KSP가-파일을-파싱하는-구조\"><a href=\"#KSP가-파일을-파싱하는-구조\" class=\"headerlink\" title=\"KSP가 파일을 파싱하는 구조\"></a>KSP가 파일을 파싱하는 구조</h4><p>KSP를 사용하기 위해 작업하는 경우 아래와 같은 구조로 작성해야 한다.</p>\n<p>복잡해보이지만 <code>KS</code>는 prefix일 뿐이고, kotlin으로 작성한 파일 구조를 추종한다는 것을 알 수 있다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">KSFile</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * File의 정보</span></span><br><span class=\"line\"><span class=\"comment\">     * - Package Name / File Name / 적용된 Anootation 리스트</span></span><br><span class=\"line\"><span class=\"comment\">     * - simpleName, qualifiedName 등을 포함한 선언 정보</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    packageName: KSName</span><br><span class=\"line\">    fileName: String</span><br><span class=\"line\">    annotations: List&lt;KSAnnotation&gt;  (File annotations)</span><br><span class=\"line\">    declarations: List&lt;KSDeclaration&gt;</span><br><span class=\"line\">   </span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Class / Interface / Object</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    KSClassDeclaration</span><br><span class=\"line\">        simpleName: KSName</span><br><span class=\"line\">        qualifiedName: KSName</span><br><span class=\"line\">        containingFile: String</span><br><span class=\"line\">        typeParameters: KSTypeParameter</span><br><span class=\"line\">        parentDeclaration: KSDeclaration</span><br><span class=\"line\">        classKind: ClassKind</span><br><span class=\"line\">        primaryConstructor: KSFunctionDeclaration</span><br><span class=\"line\">        superTypes: List&lt;KSTypeReference&gt;</span><br><span class=\"line\">        declarations: List&lt;KSDeclaration&gt; <span class=\"comment\">// contains inner classes, member functions, properties, etc.</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Top-Level Funtion</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    KSFunctionDeclaration</span><br><span class=\"line\">        simpleName: KSName</span><br><span class=\"line\">        qualifiedName: KSName</span><br><span class=\"line\">        containingFile: String</span><br><span class=\"line\">        typeParameters: KSTypeParameter</span><br><span class=\"line\">        parentDeclaration: KSDeclaration</span><br><span class=\"line\">        functionKind: FunctionKind</span><br><span class=\"line\">        extensionReceiver: KSTypeReference?</span><br><span class=\"line\">        returnType: KSTypeReference</span><br><span class=\"line\">        parameters: List&lt;KSValueParameter&gt;</span><br><span class=\"line\">        declarations: List&lt;KSDeclaration&gt; <span class=\"comment\">// contains local classes, local functions, local variables, etc.</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">     * Global Variable</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    KSPropertyDeclaration </span><br><span class=\"line\">        simpleName: KSName</span><br><span class=\"line\">    qualifiedName: KSName</span><br><span class=\"line\">    containingFile: String</span><br><span class=\"line\">    typeParameters: KSTypeParameter</span><br><span class=\"line\">    parentDeclaration: KSDeclaration</span><br><span class=\"line\">    extensionReceiver: KSTypeReference?</span><br><span class=\"line\">    type: KSTypeReference</span><br><span class=\"line\">    getter: KSPropertyGetter</span><br><span class=\"line\">        returnType: KSTypeReference</span><br><span class=\"line\">    setter: KSPropertySetter</span><br><span class=\"line\">        parameter: KSValueParameter</span><br></pre></td></tr></table></figure>\n\n<p>위의 파일 구조를 실제 구조에 대입하여 파악해보자.</p>\n<p><code>AppcompatActivity</code>를 상속한 <code>SampleActivity</code>가 있다고 할때, </p>\n<p>Annotation이 붙여진 <code>어떠한 것</code>이 변수인지, 함수인지, 클래스인지를 알고 싶다면, 위 구성을 이해하면 된다. 아래와 같이 Activity를 구성했다고 가정해보자.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// KSFile</span></span><br><span class=\"line\"><span class=\"keyword\">package</span> com.jshme.kspsample</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> androidx.appcompat.app.AppCompatActivity</span><br><span class=\"line\"><span class=\"keyword\">import</span> android.os.Bundle</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@TestAnnotation</span> <span class=\"comment\">//KClassDeclaration </span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SampleActivity</span> : <span class=\"type\">AppCompatActivity</span></span>() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span> <span class=\"comment\">//KSPropertyDeclaration</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> number: <span class=\"built_in\">Int</span> = <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span> <span class=\"comment\">//KSPropertyDeclaration</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> str: String = <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onCreate</span><span class=\"params\">(savedInstanceState: <span class=\"type\">Bundle</span>?)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onCreate(savedInstanceState)</span><br><span class=\"line\">        setContentView(R.layout.activity_sample)</span><br><span class=\"line\">        </span><br><span class=\"line\">        number = <span class=\"number\">2</span></span><br><span class=\"line\">        str = <span class=\"string\">&quot;Test Sample&quot;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>@TestAnnotation</code> 이 달린 곳은 클래스 타입이므로 KClassDeclaration으로 구성될 것이고, </p>\n<p>@Test<code>가 달린 곳은 KSPropertyDeclaration으로 구성될 것이다. 파일 내부를 돌면서 클래스, 함수, 변수타입을 구별해내</code>KSDeclaration` 으로 정의하는 것이다. </p>\n<p>이 구조도와 예제를 통해 <code>KSClassDeclaration</code>, <code>KSFunctionDeclaration</code>, <code>KSPropertyDeclaration</code> </p>\n<p>세 가지 타입의 경우 <code>KSDeclaration</code>를 상속받고 있기때문에 타입 캐스팅을 사용할 수 있기때문에, 리스트 형태로 관리할 수 있음을 확인할 수 있다.</p>\n<h4 id=\"KSP의-타입-참조-프로세스\"><a href=\"#KSP의-타입-참조-프로세스\" class=\"headerlink\" title=\"KSP의 타입 참조 프로세스\"></a>KSP의 타입 참조 프로세스</h4><p>KSP에서 타입에 대한 참조는 몇 가지 예외를 제외하면 명시적으로 지정하도록 되어있다.</p>\n<p><code>KSFunctionDeclaration.returnType</code> 혹은 <code>KSAnnotation.annotationType</code>과 같이 타입을 참조하는 경우, </p>\n<p>타입은 항상 annotation과 modifier가 포함된 <code>KSReferenceElement</code> 기반의 <code>KSTypeReference</code>이다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">KSFunctionDeclaration</span> : <span class=\"type\">... &#123;</span></span></span><br><span class=\"line\">    <span class=\"keyword\">val</span> returnType: KSTypeReference?</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">KSTypeReference</span> : <span class=\"type\">KSAnnotated</span>, <span class=\"type\">KSModifierListOwner &#123;</span></span></span><br><span class=\"line\">    <span class=\"keyword\">val</span> type: KSReferenceElement</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>KSTypeReference</code>는 Kotlin의 타입 시스템의 <code>KSType</code>으로 <code>resolve()</code>할 수 있고, Kotlin 문법과 일치하는 <code>KSReferenceElement</code>를 가지고 있다.</p>\n<p>이번엔 <code>KSReferenceElement</code>다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">KSReferenceElement</span> : <span class=\"type\">KSNode &#123;</span></span></span><br><span class=\"line\">    <span class=\"keyword\">val</span> typeArguments: List&lt;KSTypeArgument&gt;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>KSReferenceElement</code>는 유용한 정보를 많이 포함하고 있는 <code>KSClassifierReference</code> 혹은 <code>KSCallableReference</code>가 될 수 있다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">KSClassifierReference</span> : <span class=\"type\">KSReferenceElement &#123;</span></span></span><br><span class=\"line\">    <span class=\"keyword\">val</span> qualifier: KSClassifierReference?</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">referencedName</span><span class=\"params\">()</span></span>: String</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"type\">&lt;D, R&gt;</span> <span class=\"title\">accept</span><span class=\"params\">(visitor: <span class=\"type\">KSVisitor</span>&lt;<span class=\"type\">D</span>, R&gt;, <span class=\"keyword\">data</span>: <span class=\"type\">D</span>)</span></span>: R &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> visitor.visitClassifierReference(<span class=\"keyword\">this</span>, <span class=\"keyword\">data</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>예를 들어 <code>KSClassifierReference</code>는 <code>referencedName</code>라는 속성을 가지고 있으며,</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">KSCallableReference</span> : <span class=\"type\">KSReferenceElement &#123;</span></span></span><br><span class=\"line\">    <span class=\"keyword\">val</span> receiverType: KSTypeReference?</span><br><span class=\"line\">    <span class=\"keyword\">val</span> functionParameters: List&lt;KSValueParameter&gt;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> returnType: KSTypeReference</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"type\">&lt;D, R&gt;</span> <span class=\"title\">accept</span><span class=\"params\">(visitor: <span class=\"type\">KSVisitor</span>&lt;<span class=\"type\">D</span>, R&gt;, <span class=\"keyword\">data</span>: <span class=\"type\">D</span>)</span></span>: R &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> visitor.visitCallableReference(<span class=\"keyword\">this</span>, <span class=\"keyword\">data</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>KSCallableReference</code>는 <code>receiverType</code>과 <code>functionArguments</code> 그리고 <code>returnType</code>을 가지고 있다.</p>\n<p><code>KSTypeReference</code>에서 참조되는 타입의 선언이 필요한 경우 아래와 같은 순서로 접근한다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">KSTypeReference -&gt; .resolve() -&gt; KSType -&gt; .declaration -&gt; KSDeclaration</span><br></pre></td></tr></table></figure>\n\n<p><code>resolve()</code>를 통해 <code>KSType</code>으로 접근하고, <code>declaration</code> 속성을 통해 <code>KSDeclaration</code> 객체를 획득한다.</p>\n<h4 id=\"Java-Annotation-Processing에-대응하는-KSP-레퍼런스\"><a href=\"#Java-Annotation-Processing에-대응하는-KSP-레퍼런스\" class=\"headerlink\" title=\"Java Annotation Processing에 대응하는 KSP 레퍼런스\"></a>Java Annotation Processing에 대응하는 KSP 레퍼런스</h4><p>기존에 Annotation processor를 작성해 본 경험이 있다면 아래의 내용을 참조하면 좋다. 내용이 방대하여 링크로 대체한다.</p>\n<blockquote>\n<p><strong>참고</strong> <a href=\"https://github.com/google/ksp/blob/main/docs/reference.md\">Github ksp#references</a></p>\n</blockquote>\n<br>\n<br>\n<br>\n\n<h2 id=\"KSP-개발-프로세스\"><a href=\"#KSP-개발-프로세스\" class=\"headerlink\" title=\"KSP 개발 프로세스\"></a>KSP 개발 프로세스</h2><p>KSP repository에도 playground가 있지만, 공식 repo와 문서가 자세하거나 친절하게 작성되어있지않아 임의로 개발 프로세스를 예제 기반으로 명세해보았다.</p>\n<p>개략적인 내용은 ksp repository의 QuickStart 문서에 나와있다.</p>\n<blockquote>\n<p><strong>참고</strong> <a href=\"https://github.com/google/ksp/blob/main/docs/quickstart.md\">Github ksp#quickstart</a></p>\n</blockquote>\n<p>KSP 개발을 위한 환경은 갖추어져 있다고 가정한다.</p>\n<p><strong>Step 1</strong><br>You’ll need to implement <code>com.google.devtools.ksp.processing.SymbolProcessor</code> and <code>com.google.devtools.ksp.processing.SymbolProcessorProvider</code>. </p>\n<p>Your implementation of <code>SymbolProcessorProvider</code> will be loaded as a service to instantiate the <code>SymbolProcessor</code> you implement.</p>\n<p>먼저 <code>SymbolProcessor</code>를 상속받은 구현체를 작성한다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// BuilderProcessor.kt</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BuilderProcessor</span></span>(</span><br><span class=\"line\">    <span class=\"keyword\">val</span> codeGenerator: CodeGenerator,</span><br><span class=\"line\">    <span class=\"keyword\">val</span> logger: KSPLogger</span><br><span class=\"line\">) : SymbolProcessor &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>그리고 <code>SymbolProcessorProvider</code>를 상속받은 구현체도 선언한다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// BuilderProcessorProvider.kt</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BuilderProcessorProvider</span> : <span class=\"type\">SymbolProcessorProvider &#123;</span></span></span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>Step 2</strong><br>Implement <code>SymbolProcessorProvider.create()</code> to create a <code>SymbolProcessor</code>. </p>\n<p>Dependencies your processor needs (e.g. <code>CodeGenerator</code>, processor options) are passed through the parameters of <code>SymbolProcessorProvider.create()</code>.</p>\n<p><code>BuilderProcessorProvider</code> 클래스에 <code>SymbolProcessorProvider.create()</code> 메소드를 구현한다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// BuilderProcessorProvider.kt</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BuilderProcessorProvider</span> : <span class=\"type\">SymbolProcessorProvider &#123;</span></span></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">create</span><span class=\"params\">(environment: <span class=\"type\">SymbolProcessorEnvironment</span>)</span></span>: SymbolProcessor &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> BuilderProcessor(environment.codeGenerator, environment.logger)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>Step 3</strong><br>Your main logic should be in the SymbolProcessor.process() method.</p>\n<p><code>BuilderProcessor</code>의 핵심 로직인 <code>SymbolProcessor.process()</code> 메서드를 오버라이딩 한다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BuilderProcessor</span> : <span class=\"type\">SymbolProcessor &#123;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">process</span><span class=\"params\">(resolver: <span class=\"type\">Resolver</span>)</span></span>: List&lt;KSAnnotated&gt; &#123;</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>Step 4</strong><br>Use resolver.getSymbolsWithAnnotation() to get the symbols you want to process, given the fully-qualified name of an annotation.</p>\n<p>Step 3에서 선언한 <code>BuilderProcessor</code> 클래스의 <code>process()</code>에 파라미터로 주어지는 <code>resolver</code>에 <code>getSymbolsWithAnnotation()</code> 메소드를 호출하여 KSP를 명시한다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BuilderProcessor</span></span>(</span><br><span class=\"line\">    <span class=\"keyword\">val</span> codeGenerator: CodeGenerator,</span><br><span class=\"line\">    <span class=\"keyword\">val</span> logger: KSPLogger</span><br><span class=\"line\">) : SymbolProcessor &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">process</span><span class=\"params\">(resolver: <span class=\"type\">Resolver</span>)</span></span>: List&lt;KSAnnotated&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">val</span> symbols = resolver.getSymbolsWithAnnotation(<span class=\"string\">&quot;android.deepdive.ksp.builder.Builder&quot;</span>)</span><br><span class=\"line\">        <span class=\"keyword\">val</span> ret = symbols.filter &#123; !it.validate() &#125;.toList()</span><br><span class=\"line\"></span><br><span class=\"line\">        symbols</span><br><span class=\"line\">            .filter &#123; it <span class=\"keyword\">is</span> KSClassDeclaration &amp;&amp; it.validate() &#125;</span><br><span class=\"line\">            .forEach &#123; it.accept(BuilderVisitor(), <span class=\"built_in\">Unit</span>) &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>Step 5</strong><br>A common use case for KSP is to implement a customized visitor (interface com.google.devtools.ksp.symbol.KSVisitor) for operating on symbols. A simple template visitor is com.google.devtools.ksp.symbol.KSDefaultVisitor.</p>\n<p><code>com.google.devtools.ksp.symbol.KSDefaultVisitor</code>를 참조하여 Visiter 클래스를 작성한다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BuilderProcessor</span></span>(</span><br><span class=\"line\">    <span class=\"keyword\">val</span> codeGenerator: CodeGenerator,</span><br><span class=\"line\">    <span class=\"keyword\">val</span> logger: KSPLogger</span><br><span class=\"line\">) : SymbolProcessor &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"keyword\">inner</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BuilderVisitor</span> : <span class=\"type\">KSVisitorVoid</span></span>() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">visitClassDeclaration</span><span class=\"params\">(classDeclaration: <span class=\"type\">KSClassDeclaration</span>, <span class=\"keyword\">data</span>: <span class=\"type\">Unit</span>)</span></span> &#123;</span><br><span class=\"line\">            classDeclaration.primaryConstructor!!.accept(<span class=\"keyword\">this</span>, <span class=\"keyword\">data</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">visitFunctionDeclaration</span><span class=\"params\">(function: <span class=\"type\">KSFunctionDeclaration</span>, <span class=\"keyword\">data</span>: <span class=\"type\">Unit</span>)</span></span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">val</span> parent = function.parentDeclaration <span class=\"keyword\">as</span> KSClassDeclaration</span><br><span class=\"line\">            <span class=\"keyword\">val</span> packageName = parent.containingFile!!.packageName.asString()</span><br><span class=\"line\">            <span class=\"keyword\">val</span> className = <span class=\"string\">&quot;<span class=\"subst\">$&#123;parent.simpleName.asString()&#125;</span>Builder&quot;</span></span><br><span class=\"line\">            <span class=\"keyword\">val</span> file = codeGenerator.createNewFile(Dependencies(<span class=\"literal\">true</span>, function.containingFile!!), packageName, className)</span><br><span class=\"line\"></span><br><span class=\"line\">            file.appendText(<span class=\"string\">&quot;package <span class=\"variable\">$packageName</span>\\n\\n&quot;</span>)</span><br><span class=\"line\">            file.appendText(<span class=\"string\">&quot;import HELLO\\n\\n&quot;</span>)</span><br><span class=\"line\">            file.appendText(<span class=\"string\">&quot;class <span class=\"variable\">$className</span>&#123;\\n&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">            function.parameters.forEach &#123;</span><br><span class=\"line\">                <span class=\"keyword\">val</span> name = it.name!!.asString()</span><br><span class=\"line\">                <span class=\"keyword\">val</span> typeName = StringBuilder(it.type.resolve().declaration.qualifiedName?.asString() ?: <span class=\"string\">&quot;&lt;ERROR&gt;&quot;</span>)</span><br><span class=\"line\">                <span class=\"keyword\">val</span> typeArgs = it.type.element!!.typeArguments</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (it.type.element!!.typeArguments.isNotEmpty()) &#123;</span><br><span class=\"line\">                    typeName.append(<span class=\"string\">&quot;&lt;&quot;</span>)</span><br><span class=\"line\">                    typeName.append(</span><br><span class=\"line\">                        typeArgs.map &#123;</span><br><span class=\"line\">                            <span class=\"keyword\">val</span> type = it.type?.resolve()</span><br><span class=\"line\">                            <span class=\"string\">&quot;<span class=\"subst\">$&#123;it.variance.label&#125;</span> <span class=\"subst\">$&#123;type?.declaration?.qualifiedName?.asString() ?: <span class=\"string\">&quot;ERROR&quot;</span>&#125;</span>&quot;</span> +</span><br><span class=\"line\">                                    <span class=\"keyword\">if</span> (type?.nullability == Nullability.NULLABLE) <span class=\"string\">&quot;?&quot;</span> <span class=\"keyword\">else</span> <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\">                        &#125;.joinToString(<span class=\"string\">&quot;, &quot;</span>)</span><br><span class=\"line\">                    )</span><br><span class=\"line\">                    typeName.append(<span class=\"string\">&quot;&gt;&quot;</span>)</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                file.appendText(<span class=\"string\">&quot;    private var <span class=\"variable\">$name</span>: <span class=\"variable\">$typeName</span>? = null\\n&quot;</span>)</span><br><span class=\"line\">                file.appendText(<span class=\"string\">&quot;    internal fun with<span class=\"subst\">$&#123;name.capitalize()&#125;</span>(<span class=\"variable\">$name</span>: <span class=\"variable\">$typeName</span>): <span class=\"variable\">$className</span> &#123;\\n&quot;</span>)</span><br><span class=\"line\">                file.appendText(<span class=\"string\">&quot;        this.<span class=\"variable\">$name</span> = <span class=\"variable\">$name</span>\\n&quot;</span>)</span><br><span class=\"line\">                file.appendText(<span class=\"string\">&quot;        return this\\n&quot;</span>)</span><br><span class=\"line\">                file.appendText(<span class=\"string\">&quot;    &#125;\\n\\n&quot;</span>)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            file.appendText(<span class=\"string\">&quot;    internal fun build(): <span class=\"subst\">$&#123;parent.qualifiedName!!.asString()&#125;</span> &#123;\\n&quot;</span>)</span><br><span class=\"line\">            file.appendText(<span class=\"string\">&quot;        return <span class=\"subst\">$&#123;parent.qualifiedName!!.asString()&#125;</span>(&quot;</span>)</span><br><span class=\"line\">            file.appendText(</span><br><span class=\"line\">                function.parameters.map &#123;</span><br><span class=\"line\">                    <span class=\"string\">&quot;<span class=\"subst\">$&#123;it.name!!.asString()&#125;</span>!!&quot;</span></span><br><span class=\"line\">                &#125;.joinToString(<span class=\"string\">&quot;, &quot;</span>)</span><br><span class=\"line\">            )</span><br><span class=\"line\">            file.appendText(<span class=\"string\">&quot;)\\n&quot;</span>)</span><br><span class=\"line\">            file.appendText(<span class=\"string\">&quot;    &#125;\\n&quot;</span>)</span><br><span class=\"line\">            file.appendText(<span class=\"string\">&quot;&#125;\\n&quot;</span>)</span><br><span class=\"line\">            file.close()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>Step 6</strong><br>For sample implementations of the SymbolProcessorProvider and SymbolProcessor interfaces, see the following files in the sample project.</p>\n<ul>\n<li>src/main/kotlin/BuilderProcessor.kt</li>\n<li>src/main/kotlin/TestProcessor.kt</li>\n</ul>\n<p>작성한 클래스는 아래와 같다.</p>\n<ul>\n<li>src/main/java/android/deepdive/ksp/builder/BuilderProcessor.kt</li>\n<li>src/main/java/android/deepdive/ksp/builder/BuilderProcessorProvider.kt</li>\n</ul>\n<p><strong>Step 7</strong><br>After writing your own processor, register your processor provider to the package by including its fully-qualified name in resources/META-INF/services/com.google.devtools.ksp.processing.SymbolProcessorProvider.</p>\n<p><code>META-INF</code>에 작성한 <code>BuilderProcessorProvider</code>의 path를 명시한다.</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// path : src/main/resources/META-INF/services/com.google.devtools.ksp.processing.SymbolProcessorProvider</span><br><span class=\"line\">android.deepdive.ksp.builder.BuilderProcessorProvider</span><br></pre></td></tr></table></figure>\n\n<p>실제 스터디를 진행하면서 만들어본 KSP 예제는 아래 링크를 참조하면 된다.</p>\n<ul>\n<li><a href=\"https://github.com/AndroidDeepDive/ADD-Kotlin-Symbol-Processing-Api\">Android Deep Dive#Kotlin-Symbol-Processing-Api</a></li>\n<li><a href=\"https://github.com/Charlezz/IntentBuilderSample\">Charlezz#IntentBuilderSample</a></li>\n<li><a href=\"https://github.com/SODA1127/KSPImplementationExample\">SODA1127#KSPImplementationExample</a></li>\n<li><a href=\"https://github.com/jsh-me/KSPWebViewLoader\">jsh-me#KSPWebViewLoader</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<article class=\"message message-immersive is-primary\">\n    <div class=\"message-body\">\n        <i class=\"fas fa-pen-fancy mr-2\"></i>Writers<br>\n        by 곽욱현 @Knowre<br>\n        by 김남훈 @Naver<br>\n        by 송시영 @SmartStudy<br>\n        by 옥수환 @Naver<br>\n        by 이기정 @BankSalad<br>\n        by 정세희 @BankSalad\n    </div>\n</article>","more":"<h2 id=\"KSP란-무엇인가\"><a href=\"#KSP란-무엇인가\" class=\"headerlink\" title=\"KSP란 무엇인가?\"></a>KSP란 무엇인가?</h2><p><strong>KSP(Kotlin Symbol Processing)</strong> 은 2021년 2월 10일 구글이 발표한 코틀린에서 경량화된 컴파일러 플러그인을 개발할 수 있는 API다. </p>\n<p>학습곡선을 최소한으로 줄이고, 코틀린의 기능을 활용할 수 있는 단순화된 API를 제공한다. 여러 플랫폼에 호환성을 염두하고 만들어졌으며, 코틀린 1.4.30 버전 이상부터 호환된다. </p>\n<p>KSP는 코틀린 언어가 갖는 특징인 확장 함수, 로컬 함수 같은 기능을 이해한다. </p>\n<p>또한 KSP는 타입을 명시적으로 다루고, 기본적인 타입 검사와 동등성 검사를 지원한다. </p>\n<p>API는 코틀린 문법에 따라 symbol 수준에서 코틀린 프로그램 구조를 모델링 한다. </p>\n<p>KSP 기반 플러그인이 소스 프로그램을 처리할 때 클래스, 클래스 멤버, 함수 및 관련 매개 변수와 같은 구성은 프로세서에서 쉽게 접근할 수 있기 때문에 코틀린 개발자들에게 편리하다. </p>\n<p>개념적으로 KSP는 Kotlin 리플렉션의 KType과 유사하다. API 를 사용하면 프로세서가 클래스 선언에서 특정 타입 인자가 있는 해당 타입, 또는 그 반대로 탐색할 수 있다.</p>\n<p>KAPT와 비교했을 때 KSP를 사용하는 <a href=\"https://www.charlezz.com/?p=1167\">Annotation Processor</a>는 최대 <strong>2배</strong> 더 빠르게 실행할 수 있다. </p>\n<p>자세한 내용은 <a href=\"https://github.com/google/ksp\">Google KSP repository</a>에서 소스코드 및 문서를 확인할 수 있다. </p>\n<h3 id=\"왜-KSP를-사용해야-할까\"><a href=\"#왜-KSP를-사용해야-할까\" class=\"headerlink\" title=\"왜 KSP를 사용해야 할까?\"></a>왜 KSP를 사용해야 할까?</h3><p>컴파일러 플러그인은 코드 작성 방법을 크게 향상시킬 수 있는 강력한 메타프로그래밍 도구이다. </p>\n<p>컴파일러 플러그인은 컴파일러를 라이브러리로 직접 호출하여 입력 프로그램을 분석하고 편집하여 다양한 용도로 쓰일 수 있는 산출물들을 생성한다.. </p>\n<p>예를 들어, Boiler Plate를 생성하거나 Parcelble과 같은 특별히 마크된 프로그램 요소에 대한 전체 구현을 생성할 수도 있다. </p>\n<p>플러그인은 다양한 용도로 사용되며 언어로 직접 제공되지 않는 기능을 구현하고 미세 조정하는 데 사용할 수도 있다. </p>\n<p>다만 컴파일러 플러그인은 컴파일러에 대한 배경 지식 및 특정 컴파일러의 구현 세부 사항에 대한 숙련도를 어느정도 필요로 하므로 어느 정도의 진입 장벽이 요구된다.</p>\n<p>이 진입 장벽을 최대한 낮추고자 KSP 는 컴파일러의 변경사항을 은닉하도록 설계되어 최소한의 유지 보수로 플러그인을 개발할 수 있게 해준다.</p>\n<p>또한 JVM에 종속되지않도록 설계되었으므로, 다른 플랫폼에 적용하는 것도 용이하다.</p>\n<p>무엇보다 KSP는 빌드시간을 최소화하는 것이 가장 큰 장점이다.</p>\n<p>Glide 와 같은 일부 Processor의 경우 KSP는 KAPT와 비교할 때 컴파일 시간을 25%까지 줄이는 것으로 확인되었다.</p>\n<h4 id=\"kotlinc-컴파일러-플러그인과의-비교\"><a href=\"#kotlinc-컴파일러-플러그인과의-비교\" class=\"headerlink\" title=\"kotlinc 컴파일러 플러그인과의 비교\"></a><strong>kotlinc</strong> 컴파일러 플러그인과의 비교</h4><p><code>kotlinc</code> 컴파일러 플러그인의 경우 강력한 기능을 제공하는 것은 맞지만, 그만큼 컴파일러에 대한 의존성이 크기때문에 유지보수에 대한 용이성이 떨어진다. 반면 KSP는 대부분의 컴파일러 변경사항을 은닉하여 api를 통해 접근할 수 있도록 해준다. 물론 한 단계를 더 건너야하는 만큼 <code>kotlinc</code>의 모든 기능을 지원하지는 않지만, 기술 부채를 고려하였을 때 합리적인 선택이 될 것이다.</p>\n<h4 id=\"kotlin-reflect-와의-비교\"><a href=\"#kotlin-reflect-와의-비교\" class=\"headerlink\" title=\"kotlin.reflect 와의 비교\"></a><strong>kotlin.reflect</strong> 와의 비교</h4><p>KSP는 <code>kotlin.reflect</code>와 유사하게 생겼지만, KSP는 타입에 대한 참조를 명시적으로 지정해주어야 한다.</p>\n<h3 id=\"KSP의-한계점\"><a href=\"#KSP의-한계점\" class=\"headerlink\" title=\"KSP의 한계점\"></a>KSP의 한계점</h3><p>KSP는 기존의 Annotation Processor에 비해 상대적으로 간단한 방법론을 제공하기 위해 몇 가지 절충한 부분이 존재한다.</p>\n<p>따라서 아래의 기능들은 KSP에서 제공하고자 하는 대상이 아니다.</p>\n<ol>\n<li>소스 코드의 표현 수준 정보를 조사하기</li>\n<li>소스 코드 수정하기</li>\n<li>Java Annotation Processing API와 100% 호환하기</li>\n<li>IDE와 통합하기 (현재는 IDE가 생성 된 코드를 읽지 못함)</li>\n</ol>\n<p>특히 4번 항목때문에 Android Studio에서 KSP를 개발하여 사용하고자 하는 경우엔 아래와 같은 경로를 명시해야 한다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">build/generated/ksp/debug/kotlin</span><br></pre></td></tr></table></figure>\n\n<p>build.gradle.kts 예시</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">android &#123;</span><br><span class=\"line\">    buildTypes &#123;</span><br><span class=\"line\">        getByName(<span class=\"string\">&quot;debug&quot;</span>) &#123;</span><br><span class=\"line\">            sourceSets &#123;</span><br><span class=\"line\">                getByName(<span class=\"string\">&quot;main&quot;</span>) &#123;</span><br><span class=\"line\">                    java.srcDir(File(<span class=\"string\">&quot;build/generated/ksp/debug/kotlin&quot;</span>))</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"KSP-내부-살펴보기\"><a href=\"#KSP-내부-살펴보기\" class=\"headerlink\" title=\"KSP 내부 살펴보기\"></a>KSP 내부 살펴보기</h3><img src=\"/Team-Blog/2021/07/21/2021-07-21%20Kotlin%20Symbol%20Processing%20Api%20Part%202/ClassDiagram.svg\" class=\"\" title=\"[ClassDiagram]\">\n\n<p>위의 그림은 매우 복잡하고 사이즈가 크니, 클릭해서 크게 보는 것을 권장한다.</p>\n<blockquote>\n<p><strong>참고</strong> <a href=\"https://github.com/google/ksp/blob/main/api/src/main/kotlin/com/google/devtools/ksp\">KSP API definition</a></p>\n</blockquote>\n<blockquote>\n<p><strong>참고</strong> <a href=\"https://github.com/google/ksp/blob/main/api/src/main/kotlin/com/google/devtools/ksp/symbol\">KSP Symbol definition</a></p>\n</blockquote>\n<p>KSP 모델에 대한 딥다이브를 해보자.</p>\n<p>먼저 KSP의 전체 구조는 아래와 같다.</p>\n<h4 id=\"KSP가-파일을-파싱하는-구조\"><a href=\"#KSP가-파일을-파싱하는-구조\" class=\"headerlink\" title=\"KSP가 파일을 파싱하는 구조\"></a>KSP가 파일을 파싱하는 구조</h4><p>KSP를 사용하기 위해 작업하는 경우 아래와 같은 구조로 작성해야 한다.</p>\n<p>복잡해보이지만 <code>KS</code>는 prefix일 뿐이고, kotlin으로 작성한 파일 구조를 추종한다는 것을 알 수 있다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">KSFile</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * File의 정보</span></span><br><span class=\"line\"><span class=\"comment\">     * - Package Name / File Name / 적용된 Anootation 리스트</span></span><br><span class=\"line\"><span class=\"comment\">     * - simpleName, qualifiedName 등을 포함한 선언 정보</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    packageName: KSName</span><br><span class=\"line\">    fileName: String</span><br><span class=\"line\">    annotations: List&lt;KSAnnotation&gt;  (File annotations)</span><br><span class=\"line\">    declarations: List&lt;KSDeclaration&gt;</span><br><span class=\"line\">   </span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Class / Interface / Object</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    KSClassDeclaration</span><br><span class=\"line\">        simpleName: KSName</span><br><span class=\"line\">        qualifiedName: KSName</span><br><span class=\"line\">        containingFile: String</span><br><span class=\"line\">        typeParameters: KSTypeParameter</span><br><span class=\"line\">        parentDeclaration: KSDeclaration</span><br><span class=\"line\">        classKind: ClassKind</span><br><span class=\"line\">        primaryConstructor: KSFunctionDeclaration</span><br><span class=\"line\">        superTypes: List&lt;KSTypeReference&gt;</span><br><span class=\"line\">        declarations: List&lt;KSDeclaration&gt; <span class=\"comment\">// contains inner classes, member functions, properties, etc.</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Top-Level Funtion</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    KSFunctionDeclaration</span><br><span class=\"line\">        simpleName: KSName</span><br><span class=\"line\">        qualifiedName: KSName</span><br><span class=\"line\">        containingFile: String</span><br><span class=\"line\">        typeParameters: KSTypeParameter</span><br><span class=\"line\">        parentDeclaration: KSDeclaration</span><br><span class=\"line\">        functionKind: FunctionKind</span><br><span class=\"line\">        extensionReceiver: KSTypeReference?</span><br><span class=\"line\">        returnType: KSTypeReference</span><br><span class=\"line\">        parameters: List&lt;KSValueParameter&gt;</span><br><span class=\"line\">        declarations: List&lt;KSDeclaration&gt; <span class=\"comment\">// contains local classes, local functions, local variables, etc.</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">     * Global Variable</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    KSPropertyDeclaration </span><br><span class=\"line\">        simpleName: KSName</span><br><span class=\"line\">    qualifiedName: KSName</span><br><span class=\"line\">    containingFile: String</span><br><span class=\"line\">    typeParameters: KSTypeParameter</span><br><span class=\"line\">    parentDeclaration: KSDeclaration</span><br><span class=\"line\">    extensionReceiver: KSTypeReference?</span><br><span class=\"line\">    type: KSTypeReference</span><br><span class=\"line\">    getter: KSPropertyGetter</span><br><span class=\"line\">        returnType: KSTypeReference</span><br><span class=\"line\">    setter: KSPropertySetter</span><br><span class=\"line\">        parameter: KSValueParameter</span><br></pre></td></tr></table></figure>\n\n<p>위의 파일 구조를 실제 구조에 대입하여 파악해보자.</p>\n<p><code>AppcompatActivity</code>를 상속한 <code>SampleActivity</code>가 있다고 할때, </p>\n<p>Annotation이 붙여진 <code>어떠한 것</code>이 변수인지, 함수인지, 클래스인지를 알고 싶다면, 위 구성을 이해하면 된다. 아래와 같이 Activity를 구성했다고 가정해보자.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// KSFile</span></span><br><span class=\"line\"><span class=\"keyword\">package</span> com.jshme.kspsample</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> androidx.appcompat.app.AppCompatActivity</span><br><span class=\"line\"><span class=\"keyword\">import</span> android.os.Bundle</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@TestAnnotation</span> <span class=\"comment\">//KClassDeclaration </span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SampleActivity</span> : <span class=\"type\">AppCompatActivity</span></span>() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span> <span class=\"comment\">//KSPropertyDeclaration</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> number: <span class=\"built_in\">Int</span> = <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span> <span class=\"comment\">//KSPropertyDeclaration</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> str: String = <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onCreate</span><span class=\"params\">(savedInstanceState: <span class=\"type\">Bundle</span>?)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onCreate(savedInstanceState)</span><br><span class=\"line\">        setContentView(R.layout.activity_sample)</span><br><span class=\"line\">        </span><br><span class=\"line\">        number = <span class=\"number\">2</span></span><br><span class=\"line\">        str = <span class=\"string\">&quot;Test Sample&quot;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>@TestAnnotation</code> 이 달린 곳은 클래스 타입이므로 KClassDeclaration으로 구성될 것이고, </p>\n<p>@Test<code>가 달린 곳은 KSPropertyDeclaration으로 구성될 것이다. 파일 내부를 돌면서 클래스, 함수, 변수타입을 구별해내</code>KSDeclaration` 으로 정의하는 것이다. </p>\n<p>이 구조도와 예제를 통해 <code>KSClassDeclaration</code>, <code>KSFunctionDeclaration</code>, <code>KSPropertyDeclaration</code> </p>\n<p>세 가지 타입의 경우 <code>KSDeclaration</code>를 상속받고 있기때문에 타입 캐스팅을 사용할 수 있기때문에, 리스트 형태로 관리할 수 있음을 확인할 수 있다.</p>\n<h4 id=\"KSP의-타입-참조-프로세스\"><a href=\"#KSP의-타입-참조-프로세스\" class=\"headerlink\" title=\"KSP의 타입 참조 프로세스\"></a>KSP의 타입 참조 프로세스</h4><p>KSP에서 타입에 대한 참조는 몇 가지 예외를 제외하면 명시적으로 지정하도록 되어있다.</p>\n<p><code>KSFunctionDeclaration.returnType</code> 혹은 <code>KSAnnotation.annotationType</code>과 같이 타입을 참조하는 경우, </p>\n<p>타입은 항상 annotation과 modifier가 포함된 <code>KSReferenceElement</code> 기반의 <code>KSTypeReference</code>이다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">KSFunctionDeclaration</span> : <span class=\"type\">... &#123;</span></span></span><br><span class=\"line\">    <span class=\"keyword\">val</span> returnType: KSTypeReference?</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">KSTypeReference</span> : <span class=\"type\">KSAnnotated</span>, <span class=\"type\">KSModifierListOwner &#123;</span></span></span><br><span class=\"line\">    <span class=\"keyword\">val</span> type: KSReferenceElement</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>KSTypeReference</code>는 Kotlin의 타입 시스템의 <code>KSType</code>으로 <code>resolve()</code>할 수 있고, Kotlin 문법과 일치하는 <code>KSReferenceElement</code>를 가지고 있다.</p>\n<p>이번엔 <code>KSReferenceElement</code>다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">KSReferenceElement</span> : <span class=\"type\">KSNode &#123;</span></span></span><br><span class=\"line\">    <span class=\"keyword\">val</span> typeArguments: List&lt;KSTypeArgument&gt;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>KSReferenceElement</code>는 유용한 정보를 많이 포함하고 있는 <code>KSClassifierReference</code> 혹은 <code>KSCallableReference</code>가 될 수 있다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">KSClassifierReference</span> : <span class=\"type\">KSReferenceElement &#123;</span></span></span><br><span class=\"line\">    <span class=\"keyword\">val</span> qualifier: KSClassifierReference?</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">referencedName</span><span class=\"params\">()</span></span>: String</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"type\">&lt;D, R&gt;</span> <span class=\"title\">accept</span><span class=\"params\">(visitor: <span class=\"type\">KSVisitor</span>&lt;<span class=\"type\">D</span>, R&gt;, <span class=\"keyword\">data</span>: <span class=\"type\">D</span>)</span></span>: R &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> visitor.visitClassifierReference(<span class=\"keyword\">this</span>, <span class=\"keyword\">data</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>예를 들어 <code>KSClassifierReference</code>는 <code>referencedName</code>라는 속성을 가지고 있으며,</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">KSCallableReference</span> : <span class=\"type\">KSReferenceElement &#123;</span></span></span><br><span class=\"line\">    <span class=\"keyword\">val</span> receiverType: KSTypeReference?</span><br><span class=\"line\">    <span class=\"keyword\">val</span> functionParameters: List&lt;KSValueParameter&gt;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> returnType: KSTypeReference</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"type\">&lt;D, R&gt;</span> <span class=\"title\">accept</span><span class=\"params\">(visitor: <span class=\"type\">KSVisitor</span>&lt;<span class=\"type\">D</span>, R&gt;, <span class=\"keyword\">data</span>: <span class=\"type\">D</span>)</span></span>: R &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> visitor.visitCallableReference(<span class=\"keyword\">this</span>, <span class=\"keyword\">data</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>KSCallableReference</code>는 <code>receiverType</code>과 <code>functionArguments</code> 그리고 <code>returnType</code>을 가지고 있다.</p>\n<p><code>KSTypeReference</code>에서 참조되는 타입의 선언이 필요한 경우 아래와 같은 순서로 접근한다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">KSTypeReference -&gt; .resolve() -&gt; KSType -&gt; .declaration -&gt; KSDeclaration</span><br></pre></td></tr></table></figure>\n\n<p><code>resolve()</code>를 통해 <code>KSType</code>으로 접근하고, <code>declaration</code> 속성을 통해 <code>KSDeclaration</code> 객체를 획득한다.</p>\n<h4 id=\"Java-Annotation-Processing에-대응하는-KSP-레퍼런스\"><a href=\"#Java-Annotation-Processing에-대응하는-KSP-레퍼런스\" class=\"headerlink\" title=\"Java Annotation Processing에 대응하는 KSP 레퍼런스\"></a>Java Annotation Processing에 대응하는 KSP 레퍼런스</h4><p>기존에 Annotation processor를 작성해 본 경험이 있다면 아래의 내용을 참조하면 좋다. 내용이 방대하여 링크로 대체한다.</p>\n<blockquote>\n<p><strong>참고</strong> <a href=\"https://github.com/google/ksp/blob/main/docs/reference.md\">Github ksp#references</a></p>\n</blockquote>\n<br>\n<br>\n<br>\n\n<h2 id=\"KSP-개발-프로세스\"><a href=\"#KSP-개발-프로세스\" class=\"headerlink\" title=\"KSP 개발 프로세스\"></a>KSP 개발 프로세스</h2><p>KSP repository에도 playground가 있지만, 공식 repo와 문서가 자세하거나 친절하게 작성되어있지않아 임의로 개발 프로세스를 예제 기반으로 명세해보았다.</p>\n<p>개략적인 내용은 ksp repository의 QuickStart 문서에 나와있다.</p>\n<blockquote>\n<p><strong>참고</strong> <a href=\"https://github.com/google/ksp/blob/main/docs/quickstart.md\">Github ksp#quickstart</a></p>\n</blockquote>\n<p>KSP 개발을 위한 환경은 갖추어져 있다고 가정한다.</p>\n<p><strong>Step 1</strong><br>You’ll need to implement <code>com.google.devtools.ksp.processing.SymbolProcessor</code> and <code>com.google.devtools.ksp.processing.SymbolProcessorProvider</code>. </p>\n<p>Your implementation of <code>SymbolProcessorProvider</code> will be loaded as a service to instantiate the <code>SymbolProcessor</code> you implement.</p>\n<p>먼저 <code>SymbolProcessor</code>를 상속받은 구현체를 작성한다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// BuilderProcessor.kt</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BuilderProcessor</span></span>(</span><br><span class=\"line\">    <span class=\"keyword\">val</span> codeGenerator: CodeGenerator,</span><br><span class=\"line\">    <span class=\"keyword\">val</span> logger: KSPLogger</span><br><span class=\"line\">) : SymbolProcessor &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>그리고 <code>SymbolProcessorProvider</code>를 상속받은 구현체도 선언한다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// BuilderProcessorProvider.kt</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BuilderProcessorProvider</span> : <span class=\"type\">SymbolProcessorProvider &#123;</span></span></span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>Step 2</strong><br>Implement <code>SymbolProcessorProvider.create()</code> to create a <code>SymbolProcessor</code>. </p>\n<p>Dependencies your processor needs (e.g. <code>CodeGenerator</code>, processor options) are passed through the parameters of <code>SymbolProcessorProvider.create()</code>.</p>\n<p><code>BuilderProcessorProvider</code> 클래스에 <code>SymbolProcessorProvider.create()</code> 메소드를 구현한다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// BuilderProcessorProvider.kt</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BuilderProcessorProvider</span> : <span class=\"type\">SymbolProcessorProvider &#123;</span></span></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">create</span><span class=\"params\">(environment: <span class=\"type\">SymbolProcessorEnvironment</span>)</span></span>: SymbolProcessor &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> BuilderProcessor(environment.codeGenerator, environment.logger)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>Step 3</strong><br>Your main logic should be in the SymbolProcessor.process() method.</p>\n<p><code>BuilderProcessor</code>의 핵심 로직인 <code>SymbolProcessor.process()</code> 메서드를 오버라이딩 한다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BuilderProcessor</span> : <span class=\"type\">SymbolProcessor &#123;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">process</span><span class=\"params\">(resolver: <span class=\"type\">Resolver</span>)</span></span>: List&lt;KSAnnotated&gt; &#123;</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>Step 4</strong><br>Use resolver.getSymbolsWithAnnotation() to get the symbols you want to process, given the fully-qualified name of an annotation.</p>\n<p>Step 3에서 선언한 <code>BuilderProcessor</code> 클래스의 <code>process()</code>에 파라미터로 주어지는 <code>resolver</code>에 <code>getSymbolsWithAnnotation()</code> 메소드를 호출하여 KSP를 명시한다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BuilderProcessor</span></span>(</span><br><span class=\"line\">    <span class=\"keyword\">val</span> codeGenerator: CodeGenerator,</span><br><span class=\"line\">    <span class=\"keyword\">val</span> logger: KSPLogger</span><br><span class=\"line\">) : SymbolProcessor &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">process</span><span class=\"params\">(resolver: <span class=\"type\">Resolver</span>)</span></span>: List&lt;KSAnnotated&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">val</span> symbols = resolver.getSymbolsWithAnnotation(<span class=\"string\">&quot;android.deepdive.ksp.builder.Builder&quot;</span>)</span><br><span class=\"line\">        <span class=\"keyword\">val</span> ret = symbols.filter &#123; !it.validate() &#125;.toList()</span><br><span class=\"line\"></span><br><span class=\"line\">        symbols</span><br><span class=\"line\">            .filter &#123; it <span class=\"keyword\">is</span> KSClassDeclaration &amp;&amp; it.validate() &#125;</span><br><span class=\"line\">            .forEach &#123; it.accept(BuilderVisitor(), <span class=\"built_in\">Unit</span>) &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>Step 5</strong><br>A common use case for KSP is to implement a customized visitor (interface com.google.devtools.ksp.symbol.KSVisitor) for operating on symbols. A simple template visitor is com.google.devtools.ksp.symbol.KSDefaultVisitor.</p>\n<p><code>com.google.devtools.ksp.symbol.KSDefaultVisitor</code>를 참조하여 Visiter 클래스를 작성한다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BuilderProcessor</span></span>(</span><br><span class=\"line\">    <span class=\"keyword\">val</span> codeGenerator: CodeGenerator,</span><br><span class=\"line\">    <span class=\"keyword\">val</span> logger: KSPLogger</span><br><span class=\"line\">) : SymbolProcessor &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"keyword\">inner</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BuilderVisitor</span> : <span class=\"type\">KSVisitorVoid</span></span>() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">visitClassDeclaration</span><span class=\"params\">(classDeclaration: <span class=\"type\">KSClassDeclaration</span>, <span class=\"keyword\">data</span>: <span class=\"type\">Unit</span>)</span></span> &#123;</span><br><span class=\"line\">            classDeclaration.primaryConstructor!!.accept(<span class=\"keyword\">this</span>, <span class=\"keyword\">data</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">visitFunctionDeclaration</span><span class=\"params\">(function: <span class=\"type\">KSFunctionDeclaration</span>, <span class=\"keyword\">data</span>: <span class=\"type\">Unit</span>)</span></span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">val</span> parent = function.parentDeclaration <span class=\"keyword\">as</span> KSClassDeclaration</span><br><span class=\"line\">            <span class=\"keyword\">val</span> packageName = parent.containingFile!!.packageName.asString()</span><br><span class=\"line\">            <span class=\"keyword\">val</span> className = <span class=\"string\">&quot;<span class=\"subst\">$&#123;parent.simpleName.asString()&#125;</span>Builder&quot;</span></span><br><span class=\"line\">            <span class=\"keyword\">val</span> file = codeGenerator.createNewFile(Dependencies(<span class=\"literal\">true</span>, function.containingFile!!), packageName, className)</span><br><span class=\"line\"></span><br><span class=\"line\">            file.appendText(<span class=\"string\">&quot;package <span class=\"variable\">$packageName</span>\\n\\n&quot;</span>)</span><br><span class=\"line\">            file.appendText(<span class=\"string\">&quot;import HELLO\\n\\n&quot;</span>)</span><br><span class=\"line\">            file.appendText(<span class=\"string\">&quot;class <span class=\"variable\">$className</span>&#123;\\n&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">            function.parameters.forEach &#123;</span><br><span class=\"line\">                <span class=\"keyword\">val</span> name = it.name!!.asString()</span><br><span class=\"line\">                <span class=\"keyword\">val</span> typeName = StringBuilder(it.type.resolve().declaration.qualifiedName?.asString() ?: <span class=\"string\">&quot;&lt;ERROR&gt;&quot;</span>)</span><br><span class=\"line\">                <span class=\"keyword\">val</span> typeArgs = it.type.element!!.typeArguments</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (it.type.element!!.typeArguments.isNotEmpty()) &#123;</span><br><span class=\"line\">                    typeName.append(<span class=\"string\">&quot;&lt;&quot;</span>)</span><br><span class=\"line\">                    typeName.append(</span><br><span class=\"line\">                        typeArgs.map &#123;</span><br><span class=\"line\">                            <span class=\"keyword\">val</span> type = it.type?.resolve()</span><br><span class=\"line\">                            <span class=\"string\">&quot;<span class=\"subst\">$&#123;it.variance.label&#125;</span> <span class=\"subst\">$&#123;type?.declaration?.qualifiedName?.asString() ?: <span class=\"string\">&quot;ERROR&quot;</span>&#125;</span>&quot;</span> +</span><br><span class=\"line\">                                    <span class=\"keyword\">if</span> (type?.nullability == Nullability.NULLABLE) <span class=\"string\">&quot;?&quot;</span> <span class=\"keyword\">else</span> <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\">                        &#125;.joinToString(<span class=\"string\">&quot;, &quot;</span>)</span><br><span class=\"line\">                    )</span><br><span class=\"line\">                    typeName.append(<span class=\"string\">&quot;&gt;&quot;</span>)</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                file.appendText(<span class=\"string\">&quot;    private var <span class=\"variable\">$name</span>: <span class=\"variable\">$typeName</span>? = null\\n&quot;</span>)</span><br><span class=\"line\">                file.appendText(<span class=\"string\">&quot;    internal fun with<span class=\"subst\">$&#123;name.capitalize()&#125;</span>(<span class=\"variable\">$name</span>: <span class=\"variable\">$typeName</span>): <span class=\"variable\">$className</span> &#123;\\n&quot;</span>)</span><br><span class=\"line\">                file.appendText(<span class=\"string\">&quot;        this.<span class=\"variable\">$name</span> = <span class=\"variable\">$name</span>\\n&quot;</span>)</span><br><span class=\"line\">                file.appendText(<span class=\"string\">&quot;        return this\\n&quot;</span>)</span><br><span class=\"line\">                file.appendText(<span class=\"string\">&quot;    &#125;\\n\\n&quot;</span>)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            file.appendText(<span class=\"string\">&quot;    internal fun build(): <span class=\"subst\">$&#123;parent.qualifiedName!!.asString()&#125;</span> &#123;\\n&quot;</span>)</span><br><span class=\"line\">            file.appendText(<span class=\"string\">&quot;        return <span class=\"subst\">$&#123;parent.qualifiedName!!.asString()&#125;</span>(&quot;</span>)</span><br><span class=\"line\">            file.appendText(</span><br><span class=\"line\">                function.parameters.map &#123;</span><br><span class=\"line\">                    <span class=\"string\">&quot;<span class=\"subst\">$&#123;it.name!!.asString()&#125;</span>!!&quot;</span></span><br><span class=\"line\">                &#125;.joinToString(<span class=\"string\">&quot;, &quot;</span>)</span><br><span class=\"line\">            )</span><br><span class=\"line\">            file.appendText(<span class=\"string\">&quot;)\\n&quot;</span>)</span><br><span class=\"line\">            file.appendText(<span class=\"string\">&quot;    &#125;\\n&quot;</span>)</span><br><span class=\"line\">            file.appendText(<span class=\"string\">&quot;&#125;\\n&quot;</span>)</span><br><span class=\"line\">            file.close()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>Step 6</strong><br>For sample implementations of the SymbolProcessorProvider and SymbolProcessor interfaces, see the following files in the sample project.</p>\n<ul>\n<li>src/main/kotlin/BuilderProcessor.kt</li>\n<li>src/main/kotlin/TestProcessor.kt</li>\n</ul>\n<p>작성한 클래스는 아래와 같다.</p>\n<ul>\n<li>src/main/java/android/deepdive/ksp/builder/BuilderProcessor.kt</li>\n<li>src/main/java/android/deepdive/ksp/builder/BuilderProcessorProvider.kt</li>\n</ul>\n<p><strong>Step 7</strong><br>After writing your own processor, register your processor provider to the package by including its fully-qualified name in resources/META-INF/services/com.google.devtools.ksp.processing.SymbolProcessorProvider.</p>\n<p><code>META-INF</code>에 작성한 <code>BuilderProcessorProvider</code>의 path를 명시한다.</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// path : src/main/resources/META-INF/services/com.google.devtools.ksp.processing.SymbolProcessorProvider</span><br><span class=\"line\">android.deepdive.ksp.builder.BuilderProcessorProvider</span><br></pre></td></tr></table></figure>\n\n<p>실제 스터디를 진행하면서 만들어본 KSP 예제는 아래 링크를 참조하면 된다.</p>\n<ul>\n<li><a href=\"https://github.com/AndroidDeepDive/ADD-Kotlin-Symbol-Processing-Api\">Android Deep Dive#Kotlin-Symbol-Processing-Api</a></li>\n<li><a href=\"https://github.com/Charlezz/IntentBuilderSample\">Charlezz#IntentBuilderSample</a></li>\n<li><a href=\"https://github.com/SODA1127/KSPImplementationExample\">SODA1127#KSPImplementationExample</a></li>\n<li><a href=\"https://github.com/jsh-me/KSPWebViewLoader\">jsh-me#KSPWebViewLoader</a></li>\n</ul>"},{"title":"Kotlin Symbol Processing Api Part 3 — KSP vs KAPT","date":"2021-07-20T18:00:00.000Z","cover":"https://androiddeepdive.github.io/Team-Blog/images/cover_ksp.png","_content":"\n<article class=\"message message-immersive is-primary\">\n    <div class=\"message-body\">\n        <i class=\"fas fa-pen-fancy mr-2\"></i>Writers<br>\n        by 곽욱현 @Knowre<br>\n        by 김남훈 @Naver<br>\n        by 송시영 @SmartStudy<br>\n        by 옥수환 @Naver<br>\n        by 이기정 @BankSalad<br>\n        by 정세희 @BankSalad\n    </div>\n</article>\n\n\n<!-- more -->\n\n앞선 두 개의 포스팅에서 **KAPT** 와 **KSP** 에 대해서 다루었다.\n\n이번 포스팅에서는 **KAPT** 와 **KSP** 를 서로 비교해본다.\n\n\n## Better than KAPT\n\n앞선 포스팅에서 언급했듯 KAPT는 Kotlin 코드를 Java Annotation Processor를 수정하지 않기 위해 컴파일시 Java로 된 Stub을 생성하게 된다. \n\nStub을 생성하는 것은 kotlinc의 분석 비용의 3분의 1이나 차지하므로, 빌드시 필연적으로 많은 오버헤드가 발생하게 된다. \n\nKAPT와 달리 KSP는 Java 관점이 아닌 Kotlin의 관점에서 접근하며, `top-level function`과 같은 Kotlin의 고유 기능에 더 적합하다.\n\nKAPT와 좀 더 자세하게 비교해보면 아래로 정리할 수 있다.\n\n**1. 빠르다**\n\n기존에는 코틀린 전용 애노테이션 프로세서가 없었기 때문에, `javax.lang.model` 패키지에서 제공하는 API를 통해 애노테이션 프로세서를 작성했다. \n\n이 프로세서를 수행하기 위해 KAPT는 코틀린 코드를 **자바 Stub** 으로 컴파일하게 된다. \n\n이러한 Stub을 생성하려면 KAPT가 코틀린 프로그램의 모든 기호(symbol)들을 확인해야 한다. Stub 코드를 생성하는 비용은 컴파일 전체의 1/3을 차지한다. \n\n성능 평가를 위해 KSP에서 Glide의 단순화된 버전을 구현하여 **Tachiyomi** 프로젝트용 코드를 생성했는데 \n\n코틀린 컴파일 시간은 21.55초에서 KAPT가 코드를 생성하는데 8.67초, KSP가 코드를 생성하는데 1.15초가 걸렸다고 한다. \n\n> **참고** [Tachiyomi repository](https://github.com/tachiyomiorg/tachiyomi)\n\n**2. 쉽다**\n\nKSP는 코틀린 친화적이다. \n\nKSP는 코틀린만의 고유한 기능들인 확장 함수(extension function), 선언 위치 변환 (Declaration-Site Variance), 지역 함수(local functions) 등을 이해한다. \n\n또한 타입을 모델링하고 동등성 및 할당호환성(assign-comppatibility)과 같은 기본적인 타입을 검사하는 기능을 제공한다.\n\nKSP를 이용하여 소스코드를 처리할 때 클래스, 클래스 멤버, 함수 및 관련 매개변수와 같은 내용에 쉽게 접근이 가능하다. \n\n개념적으로는 코틀린 리플렉션의 KType과 유사하기 때문에 커스텀 SymbolProcessor 작성 시 AbstractProcessor와 비교하여 작성이 편하다는 느낌을 받게 된다.\n\n자세한 내용은 Part 2를 참고하자.\n\n**3. 호환성 및 유지보수**\n\nKSP는 JVM에 종속되지 않도록 설계되었기 때문에 향후 다른 플랫폼에 보다 쉽게 적용할 수 있다. \n\n또한 컴파일러 변경 사항을 숨기도록 설계되어 이를 사용하는 프로세서의 유지 관리 노력을 최소화 한다. \n\n<br>\n<br>\n<br>\n\n### KAPT vs KSP 실제로 빌드해보기 (Feat_ Room)\n\nRooom 라이브러리를 이용해 간단하게 테스트를 수행해보았다.\n\n테스트 조건은 아래와 같다.\n\n1. 프로젝트로 작성된 간단한 프로젝트 \n2. `RoomDatabase`를 상속받은 클래스 하나\n3. 3개의 DAO, 3개의 Entity 클래스\n\n#### KAPT 프로젝트\n\n빌드 스크립트에 `kotlin-kapt`를 추가한다.\n\n```kotlin\n// build.gradle (app)\nplugins {\n  ...\n  id 'kotlin-kapt'\n  ...\n}\n```\n\n의존성으로는 테스트할 Room 라이브러리를 추가하고, kapt에서 room을 사용하도록 처리한다.\n\n아래의 의존성으로 인해 Room 라이브러리는 Kotlin 어노테이션을 파싱한 뒤 SQLite를 사용하기 위한 자바 기반의 Stub 파일을 생성하게 된다.\n\n```kotlin\ndependencies {\n  // ...\n  implementation \"androidx.room:room-runtime:2.3.0\"\n  kapt \"androidx.room:room-compiler:2.3.0\"\n  implementation \"androidx.room:room-ktx:2.3.0\"\n  // ...\n}\n```\n\n이제 `RoomDatabase`를 상속한 `ApplicationDatabase` 클래스를 작성한다.\n\n```kotlin\n@Database(\n  entities = [AEntity::class, BEntity::class, CEntity::class],\n  version = 1,\n  exportSchema = false\n)\nabstract class ApplicationDatabase: RoomDatabase() {\n\n  companion object {\n    const val DB_NAME = \"ApplicationDataBase.db\"\n  }\n\n  abstract fun ADao(): ADao\n\n  abstract fun BDao(): BDao\n\n  abstract fun CDao(): CDao\n\n}\n```\n\nKotlin 코드는 다음과 같은 Java Stub 파일로 생성되게 된다.\n\n```java\n// ...\n  \n@SuppressWarnings({\"unchecked\", \"deprecation\"})\npublic final class ApplicationDatabase_Impl extends ApplicationDatabase {\n  private volatile ADao _aDao;\n\n  private volatile BDao _bDao;\n\n  private volatile CDao _cDao;\n\n  @Override\n  protected SupportSQLiteOpenHelper createOpenHelper(DatabaseConfiguration configuration) {\n    final SupportSQLiteOpenHelper.Callback _openCallback = new RoomOpenHelper(configuration, new RoomOpenHelper.Delegate(1) {\n      @Override\n      public void createAllTables(SupportSQLiteDatabase _db) {\n        // ...\n      }\n    }                              \n// ...                                                                              \n```\n\n**빌드 타임 측정**\n\n{% asset_img rcWvgv0.png [rcWvgv0] %}\n\n프로젝트 클린 후\n\nkaptGenerateStubsDebugKotlin으로 빌드시 **16.6s** 가 소요되었다.\n\n#### KSP 프로젝트\n\n위에서 작성한 KAPT 프로젝트를 KSP로 변경해보자.\n\n프로젝트 단위의 build.gradle 설정에서는 아래와 같이 의존성을 하나 더 추가해준다.\n\n```kotlin\n// build.gradle (root)\nbuildscript {\n  ext.kotlin_version = \"1.4.21\"\n  repositories {\n    google()\n  }\n  dependencies {\n    ...\n    classpath(\"com.google.devtools.ksp:com.google.devtools.ksp.gradle.plugin:1.5.20-1.0.0-beta04\")\n  }\n}\n```\n\napp의 build.gradle에 `com.google.devtools.ksp` 플러그인을 추가한다.\n\n```kotlin\nplugins {\n  ...\n  id 'kotlin-kapt'\n  id 'com.google.devtools.ksp'\n  ...\n}\n```\n\n이후 기존 kapt로 추가했던 `room-compiler` 의존성을 ksp로 교체한다.\n\n```kotlin\ndependencies {\n  // ...\n  implementation \"androidx.room:room-runtime:2.3.0\"\n  // kapt \"androidx.room:room-compiler:2.3.0\"\n  ksp \"androidx.room:room-compiler:2.3.0\"\n  implementation \"androidx.room:room-ktx:2.3.0\"\n  // ...\n}\n```\n\n**빌드 타임 측정**\n\n{% asset_img HyjEy1l.png [HyjEy1l] %}\n\n프로젝트 클린 후 빌드하면\n\nkaptGenerateStubsDebugKotlin이 **12.54s**\n\nkspDebugKotlin이 **5.49s** 만큼 시간이 소요되어 총합 **18.03s** 만큼 시간이 소요되었다.\n\nKSP를 써서 더 빨라질 것을 기대했는데 왜 더 걸린 것일까?\n\nAndroid Developer의 공식 블로그에 그 이유가 공개되어 있다.\n\n> **참고** [Announcing Kotlin Symbol Processing (KSP) Alpha](https://android-developers.googleblog.com/2021/02/announcing-kotlin-symbol-processing-ksp.html)\n\n위의 문서를 보면 아래와 같은 문구가 있다.\n\nThat said, using KAPT and KSP in the same module will likely slow down your build initially, so during this alpha period, it is best to use KSP and KAPT in separate modules.\n\n동일한 모듈 내에서 kapt와 ksp를 동시에 사용하면 초기 빌드 속도가 더 소요된다고 명시되어있고, \n\n이에 대한 해결책으로(ksp가 alpha인 동안은) kapt와 ksp를 별도의 모듈에서 사용하는 것을 권장하고 있다.\n\n현재 프로젝트에서 KAPT를 사용하는 의존성을 전부 게거한 뒤, Room에 대한 KAPT, KSP를 비교하면 아래와 같은 결과를 얻을 수 있다.\n\n**Compile Time By KAPT only using Room**\n{% asset_img NjWXyw6.png [Compile Time By KAPT only using Room] %}\n\n8.40s\n\n**Compile Time By KSP only using Room**\n\n{% asset_img 0HScWJk.png [Compile Time By KSP only using Room] %}\n\n0.71s\n\n한정적인 테스트지만 빌드 시간이 현격히 감소한 것을 확인할 수 있다.\n\n<br>\n<br>\n<br>\n\n## References\n\n### Members of Study\n- [찰스의 안드로이드 - [Android] Annotation Processor 만들기](https://www.charlezz.com/?p=1167)\n- [Namhoon Kims'Coding Log - KSP Api Part 1](https://namhoon.kim/2021/06/25/android_deep_dive/020_Kotlin%20Symbol%20Processing%20API%20Part%201/)\n- [Namhoon Kims'Coding Log - KSP Api Part 2](https://namhoon.kim/2021/06/27/android_deep_dive/021_Kotlin%20Symbol%20Processing%20API%20Part%202/)\n- [소다의 개발 블로그 - Introduce Kotlin Symbol Processing](https://soda1127.github.io/introduce-kotlin-symbol-processing/)\n- [소다의 개발 블로그 - Implement Kotlin Symbol Processing](https://soda1127.github.io/implement-kotlin-symbol-processing-example/)\n- [jsh-me.log - KSP(Kotlin Symbol Processor) 톺아보기](https://velog.io/@jshme/KSP-Kotlin-Symbol-Processor-%ED%86%BA%EC%95%84%EB%B3%B4%EA%B8%B0)\n\n### Official\n- [Android Developers#androidx.annotation](https://developer.android.com/reference/androidx/annotation/package-summary)\n- [Google KSP Repository](https://github.com/google/ksp)\n- [KSP API definition](https://github.com/google/ksp/blob/main/api/src/main/kotlin/com/google/devtools/ksp)\n- [KSP Symbol definition](https://github.com/google/ksp/blob/main/api/src/main/kotlin/com/google/devtools/ksp/symbol)\n- [KAPT(Kotlin Annotation Processing Tool)](https://kotlinlang.org/docs/kapt.html)\n- [Announcing Kotlin Symbol Processing (KSP) Alpha](https://android-developers.googleblog.com/2021/02/announcing-kotlin-symbol-processing-ksp.html)\n- [Oracle JavaDoc#Annotations](https://docs.oracle.com/javase/tutorial/java/annotations/index.html)\n- [kapt: Annotation Processing for Kotlin](https://blog.jetbrains.com/kotlin/2015/05/kapt-annotation-processing-for-kotlin)\n- [Using kapt](https://kotlinlang.org/docs/kapt.html#using-in-gradle)\n\n### Etc\n- [Tachiyomi](https://github.com/tachiyomiorg/tachiyomi)\n- [My first Kotlin Symbol Processing Tool for Android](https://jsuch2362.medium.com/my-first-kotlin-symbol-processing-tool-for-android-4eb3a2cfd600)\n- [KSP: Fact or kapt?](https://proandroiddev.com/ksp-fact-or-kapt-7c7e9218c575)\n- [Annotation Processing 101](https://hannesdorfmann.com/annotation-processing/annotationprocessing101/)\n- [Kotlin : Kotlin plugin should be enabled before ‘kotlin-kapt’](https://imstudio.medium.com/kotlin-kotlin-plugin-should-be-enabled-before-kotlin-kapt-d5879f45f09d)\n- [Pushing the limits of Kotlin annotation processing](https://medium.com/@workingkills/pushing-the-limits-of-kotlin-annotation-processing-8611027b6711)\n","source":"_posts/2021-07-21 Kotlin Symbol Processing Api Part 3.md","raw":"---\ntitle: Kotlin Symbol Processing Api Part 3 — KSP vs KAPT\ndate: 2021-07-21 03:00\ncover: https://androiddeepdive.github.io/Team-Blog/images/cover_ksp.png\ncategories:\n- KSP\ntags:\n- KSP\n- Kotlin\n- Symbol\n- Processing\n- KAPT\n- Annotation\n---\n\n<article class=\"message message-immersive is-primary\">\n    <div class=\"message-body\">\n        <i class=\"fas fa-pen-fancy mr-2\"></i>Writers<br>\n        by 곽욱현 @Knowre<br>\n        by 김남훈 @Naver<br>\n        by 송시영 @SmartStudy<br>\n        by 옥수환 @Naver<br>\n        by 이기정 @BankSalad<br>\n        by 정세희 @BankSalad\n    </div>\n</article>\n\n\n<!-- more -->\n\n앞선 두 개의 포스팅에서 **KAPT** 와 **KSP** 에 대해서 다루었다.\n\n이번 포스팅에서는 **KAPT** 와 **KSP** 를 서로 비교해본다.\n\n\n## Better than KAPT\n\n앞선 포스팅에서 언급했듯 KAPT는 Kotlin 코드를 Java Annotation Processor를 수정하지 않기 위해 컴파일시 Java로 된 Stub을 생성하게 된다. \n\nStub을 생성하는 것은 kotlinc의 분석 비용의 3분의 1이나 차지하므로, 빌드시 필연적으로 많은 오버헤드가 발생하게 된다. \n\nKAPT와 달리 KSP는 Java 관점이 아닌 Kotlin의 관점에서 접근하며, `top-level function`과 같은 Kotlin의 고유 기능에 더 적합하다.\n\nKAPT와 좀 더 자세하게 비교해보면 아래로 정리할 수 있다.\n\n**1. 빠르다**\n\n기존에는 코틀린 전용 애노테이션 프로세서가 없었기 때문에, `javax.lang.model` 패키지에서 제공하는 API를 통해 애노테이션 프로세서를 작성했다. \n\n이 프로세서를 수행하기 위해 KAPT는 코틀린 코드를 **자바 Stub** 으로 컴파일하게 된다. \n\n이러한 Stub을 생성하려면 KAPT가 코틀린 프로그램의 모든 기호(symbol)들을 확인해야 한다. Stub 코드를 생성하는 비용은 컴파일 전체의 1/3을 차지한다. \n\n성능 평가를 위해 KSP에서 Glide의 단순화된 버전을 구현하여 **Tachiyomi** 프로젝트용 코드를 생성했는데 \n\n코틀린 컴파일 시간은 21.55초에서 KAPT가 코드를 생성하는데 8.67초, KSP가 코드를 생성하는데 1.15초가 걸렸다고 한다. \n\n> **참고** [Tachiyomi repository](https://github.com/tachiyomiorg/tachiyomi)\n\n**2. 쉽다**\n\nKSP는 코틀린 친화적이다. \n\nKSP는 코틀린만의 고유한 기능들인 확장 함수(extension function), 선언 위치 변환 (Declaration-Site Variance), 지역 함수(local functions) 등을 이해한다. \n\n또한 타입을 모델링하고 동등성 및 할당호환성(assign-comppatibility)과 같은 기본적인 타입을 검사하는 기능을 제공한다.\n\nKSP를 이용하여 소스코드를 처리할 때 클래스, 클래스 멤버, 함수 및 관련 매개변수와 같은 내용에 쉽게 접근이 가능하다. \n\n개념적으로는 코틀린 리플렉션의 KType과 유사하기 때문에 커스텀 SymbolProcessor 작성 시 AbstractProcessor와 비교하여 작성이 편하다는 느낌을 받게 된다.\n\n자세한 내용은 Part 2를 참고하자.\n\n**3. 호환성 및 유지보수**\n\nKSP는 JVM에 종속되지 않도록 설계되었기 때문에 향후 다른 플랫폼에 보다 쉽게 적용할 수 있다. \n\n또한 컴파일러 변경 사항을 숨기도록 설계되어 이를 사용하는 프로세서의 유지 관리 노력을 최소화 한다. \n\n<br>\n<br>\n<br>\n\n### KAPT vs KSP 실제로 빌드해보기 (Feat_ Room)\n\nRooom 라이브러리를 이용해 간단하게 테스트를 수행해보았다.\n\n테스트 조건은 아래와 같다.\n\n1. 프로젝트로 작성된 간단한 프로젝트 \n2. `RoomDatabase`를 상속받은 클래스 하나\n3. 3개의 DAO, 3개의 Entity 클래스\n\n#### KAPT 프로젝트\n\n빌드 스크립트에 `kotlin-kapt`를 추가한다.\n\n```kotlin\n// build.gradle (app)\nplugins {\n  ...\n  id 'kotlin-kapt'\n  ...\n}\n```\n\n의존성으로는 테스트할 Room 라이브러리를 추가하고, kapt에서 room을 사용하도록 처리한다.\n\n아래의 의존성으로 인해 Room 라이브러리는 Kotlin 어노테이션을 파싱한 뒤 SQLite를 사용하기 위한 자바 기반의 Stub 파일을 생성하게 된다.\n\n```kotlin\ndependencies {\n  // ...\n  implementation \"androidx.room:room-runtime:2.3.0\"\n  kapt \"androidx.room:room-compiler:2.3.0\"\n  implementation \"androidx.room:room-ktx:2.3.0\"\n  // ...\n}\n```\n\n이제 `RoomDatabase`를 상속한 `ApplicationDatabase` 클래스를 작성한다.\n\n```kotlin\n@Database(\n  entities = [AEntity::class, BEntity::class, CEntity::class],\n  version = 1,\n  exportSchema = false\n)\nabstract class ApplicationDatabase: RoomDatabase() {\n\n  companion object {\n    const val DB_NAME = \"ApplicationDataBase.db\"\n  }\n\n  abstract fun ADao(): ADao\n\n  abstract fun BDao(): BDao\n\n  abstract fun CDao(): CDao\n\n}\n```\n\nKotlin 코드는 다음과 같은 Java Stub 파일로 생성되게 된다.\n\n```java\n// ...\n  \n@SuppressWarnings({\"unchecked\", \"deprecation\"})\npublic final class ApplicationDatabase_Impl extends ApplicationDatabase {\n  private volatile ADao _aDao;\n\n  private volatile BDao _bDao;\n\n  private volatile CDao _cDao;\n\n  @Override\n  protected SupportSQLiteOpenHelper createOpenHelper(DatabaseConfiguration configuration) {\n    final SupportSQLiteOpenHelper.Callback _openCallback = new RoomOpenHelper(configuration, new RoomOpenHelper.Delegate(1) {\n      @Override\n      public void createAllTables(SupportSQLiteDatabase _db) {\n        // ...\n      }\n    }                              \n// ...                                                                              \n```\n\n**빌드 타임 측정**\n\n{% asset_img rcWvgv0.png [rcWvgv0] %}\n\n프로젝트 클린 후\n\nkaptGenerateStubsDebugKotlin으로 빌드시 **16.6s** 가 소요되었다.\n\n#### KSP 프로젝트\n\n위에서 작성한 KAPT 프로젝트를 KSP로 변경해보자.\n\n프로젝트 단위의 build.gradle 설정에서는 아래와 같이 의존성을 하나 더 추가해준다.\n\n```kotlin\n// build.gradle (root)\nbuildscript {\n  ext.kotlin_version = \"1.4.21\"\n  repositories {\n    google()\n  }\n  dependencies {\n    ...\n    classpath(\"com.google.devtools.ksp:com.google.devtools.ksp.gradle.plugin:1.5.20-1.0.0-beta04\")\n  }\n}\n```\n\napp의 build.gradle에 `com.google.devtools.ksp` 플러그인을 추가한다.\n\n```kotlin\nplugins {\n  ...\n  id 'kotlin-kapt'\n  id 'com.google.devtools.ksp'\n  ...\n}\n```\n\n이후 기존 kapt로 추가했던 `room-compiler` 의존성을 ksp로 교체한다.\n\n```kotlin\ndependencies {\n  // ...\n  implementation \"androidx.room:room-runtime:2.3.0\"\n  // kapt \"androidx.room:room-compiler:2.3.0\"\n  ksp \"androidx.room:room-compiler:2.3.0\"\n  implementation \"androidx.room:room-ktx:2.3.0\"\n  // ...\n}\n```\n\n**빌드 타임 측정**\n\n{% asset_img HyjEy1l.png [HyjEy1l] %}\n\n프로젝트 클린 후 빌드하면\n\nkaptGenerateStubsDebugKotlin이 **12.54s**\n\nkspDebugKotlin이 **5.49s** 만큼 시간이 소요되어 총합 **18.03s** 만큼 시간이 소요되었다.\n\nKSP를 써서 더 빨라질 것을 기대했는데 왜 더 걸린 것일까?\n\nAndroid Developer의 공식 블로그에 그 이유가 공개되어 있다.\n\n> **참고** [Announcing Kotlin Symbol Processing (KSP) Alpha](https://android-developers.googleblog.com/2021/02/announcing-kotlin-symbol-processing-ksp.html)\n\n위의 문서를 보면 아래와 같은 문구가 있다.\n\nThat said, using KAPT and KSP in the same module will likely slow down your build initially, so during this alpha period, it is best to use KSP and KAPT in separate modules.\n\n동일한 모듈 내에서 kapt와 ksp를 동시에 사용하면 초기 빌드 속도가 더 소요된다고 명시되어있고, \n\n이에 대한 해결책으로(ksp가 alpha인 동안은) kapt와 ksp를 별도의 모듈에서 사용하는 것을 권장하고 있다.\n\n현재 프로젝트에서 KAPT를 사용하는 의존성을 전부 게거한 뒤, Room에 대한 KAPT, KSP를 비교하면 아래와 같은 결과를 얻을 수 있다.\n\n**Compile Time By KAPT only using Room**\n{% asset_img NjWXyw6.png [Compile Time By KAPT only using Room] %}\n\n8.40s\n\n**Compile Time By KSP only using Room**\n\n{% asset_img 0HScWJk.png [Compile Time By KSP only using Room] %}\n\n0.71s\n\n한정적인 테스트지만 빌드 시간이 현격히 감소한 것을 확인할 수 있다.\n\n<br>\n<br>\n<br>\n\n## References\n\n### Members of Study\n- [찰스의 안드로이드 - [Android] Annotation Processor 만들기](https://www.charlezz.com/?p=1167)\n- [Namhoon Kims'Coding Log - KSP Api Part 1](https://namhoon.kim/2021/06/25/android_deep_dive/020_Kotlin%20Symbol%20Processing%20API%20Part%201/)\n- [Namhoon Kims'Coding Log - KSP Api Part 2](https://namhoon.kim/2021/06/27/android_deep_dive/021_Kotlin%20Symbol%20Processing%20API%20Part%202/)\n- [소다의 개발 블로그 - Introduce Kotlin Symbol Processing](https://soda1127.github.io/introduce-kotlin-symbol-processing/)\n- [소다의 개발 블로그 - Implement Kotlin Symbol Processing](https://soda1127.github.io/implement-kotlin-symbol-processing-example/)\n- [jsh-me.log - KSP(Kotlin Symbol Processor) 톺아보기](https://velog.io/@jshme/KSP-Kotlin-Symbol-Processor-%ED%86%BA%EC%95%84%EB%B3%B4%EA%B8%B0)\n\n### Official\n- [Android Developers#androidx.annotation](https://developer.android.com/reference/androidx/annotation/package-summary)\n- [Google KSP Repository](https://github.com/google/ksp)\n- [KSP API definition](https://github.com/google/ksp/blob/main/api/src/main/kotlin/com/google/devtools/ksp)\n- [KSP Symbol definition](https://github.com/google/ksp/blob/main/api/src/main/kotlin/com/google/devtools/ksp/symbol)\n- [KAPT(Kotlin Annotation Processing Tool)](https://kotlinlang.org/docs/kapt.html)\n- [Announcing Kotlin Symbol Processing (KSP) Alpha](https://android-developers.googleblog.com/2021/02/announcing-kotlin-symbol-processing-ksp.html)\n- [Oracle JavaDoc#Annotations](https://docs.oracle.com/javase/tutorial/java/annotations/index.html)\n- [kapt: Annotation Processing for Kotlin](https://blog.jetbrains.com/kotlin/2015/05/kapt-annotation-processing-for-kotlin)\n- [Using kapt](https://kotlinlang.org/docs/kapt.html#using-in-gradle)\n\n### Etc\n- [Tachiyomi](https://github.com/tachiyomiorg/tachiyomi)\n- [My first Kotlin Symbol Processing Tool for Android](https://jsuch2362.medium.com/my-first-kotlin-symbol-processing-tool-for-android-4eb3a2cfd600)\n- [KSP: Fact or kapt?](https://proandroiddev.com/ksp-fact-or-kapt-7c7e9218c575)\n- [Annotation Processing 101](https://hannesdorfmann.com/annotation-processing/annotationprocessing101/)\n- [Kotlin : Kotlin plugin should be enabled before ‘kotlin-kapt’](https://imstudio.medium.com/kotlin-kotlin-plugin-should-be-enabled-before-kotlin-kapt-d5879f45f09d)\n- [Pushing the limits of Kotlin annotation processing](https://medium.com/@workingkills/pushing-the-limits-of-kotlin-annotation-processing-8611027b6711)\n","slug":"2021-07-21 Kotlin Symbol Processing Api Part 3","published":1,"updated":"2021-08-13T14:40:08.375Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cksagj7lz00203lre8lqf65qd","content":"<article class=\"message message-immersive is-primary\">\n    <div class=\"message-body\">\n        <i class=\"fas fa-pen-fancy mr-2\"></i>Writers<br>\n        by 곽욱현 @Knowre<br>\n        by 김남훈 @Naver<br>\n        by 송시영 @SmartStudy<br>\n        by 옥수환 @Naver<br>\n        by 이기정 @BankSalad<br>\n        by 정세희 @BankSalad\n    </div>\n</article>\n\n\n<span id=\"more\"></span>\n\n<p>앞선 두 개의 포스팅에서 <strong>KAPT</strong> 와 <strong>KSP</strong> 에 대해서 다루었다.</p>\n<p>이번 포스팅에서는 <strong>KAPT</strong> 와 <strong>KSP</strong> 를 서로 비교해본다.</p>\n<h2 id=\"Better-than-KAPT\"><a href=\"#Better-than-KAPT\" class=\"headerlink\" title=\"Better than KAPT\"></a>Better than KAPT</h2><p>앞선 포스팅에서 언급했듯 KAPT는 Kotlin 코드를 Java Annotation Processor를 수정하지 않기 위해 컴파일시 Java로 된 Stub을 생성하게 된다. </p>\n<p>Stub을 생성하는 것은 kotlinc의 분석 비용의 3분의 1이나 차지하므로, 빌드시 필연적으로 많은 오버헤드가 발생하게 된다. </p>\n<p>KAPT와 달리 KSP는 Java 관점이 아닌 Kotlin의 관점에서 접근하며, <code>top-level function</code>과 같은 Kotlin의 고유 기능에 더 적합하다.</p>\n<p>KAPT와 좀 더 자세하게 비교해보면 아래로 정리할 수 있다.</p>\n<p><strong>1. 빠르다</strong></p>\n<p>기존에는 코틀린 전용 애노테이션 프로세서가 없었기 때문에, <code>javax.lang.model</code> 패키지에서 제공하는 API를 통해 애노테이션 프로세서를 작성했다. </p>\n<p>이 프로세서를 수행하기 위해 KAPT는 코틀린 코드를 <strong>자바 Stub</strong> 으로 컴파일하게 된다. </p>\n<p>이러한 Stub을 생성하려면 KAPT가 코틀린 프로그램의 모든 기호(symbol)들을 확인해야 한다. Stub 코드를 생성하는 비용은 컴파일 전체의 1/3을 차지한다. </p>\n<p>성능 평가를 위해 KSP에서 Glide의 단순화된 버전을 구현하여 <strong>Tachiyomi</strong> 프로젝트용 코드를 생성했는데 </p>\n<p>코틀린 컴파일 시간은 21.55초에서 KAPT가 코드를 생성하는데 8.67초, KSP가 코드를 생성하는데 1.15초가 걸렸다고 한다. </p>\n<blockquote>\n<p><strong>참고</strong> <a href=\"https://github.com/tachiyomiorg/tachiyomi\">Tachiyomi repository</a></p>\n</blockquote>\n<p><strong>2. 쉽다</strong></p>\n<p>KSP는 코틀린 친화적이다. </p>\n<p>KSP는 코틀린만의 고유한 기능들인 확장 함수(extension function), 선언 위치 변환 (Declaration-Site Variance), 지역 함수(local functions) 등을 이해한다. </p>\n<p>또한 타입을 모델링하고 동등성 및 할당호환성(assign-comppatibility)과 같은 기본적인 타입을 검사하는 기능을 제공한다.</p>\n<p>KSP를 이용하여 소스코드를 처리할 때 클래스, 클래스 멤버, 함수 및 관련 매개변수와 같은 내용에 쉽게 접근이 가능하다. </p>\n<p>개념적으로는 코틀린 리플렉션의 KType과 유사하기 때문에 커스텀 SymbolProcessor 작성 시 AbstractProcessor와 비교하여 작성이 편하다는 느낌을 받게 된다.</p>\n<p>자세한 내용은 Part 2를 참고하자.</p>\n<p><strong>3. 호환성 및 유지보수</strong></p>\n<p>KSP는 JVM에 종속되지 않도록 설계되었기 때문에 향후 다른 플랫폼에 보다 쉽게 적용할 수 있다. </p>\n<p>또한 컴파일러 변경 사항을 숨기도록 설계되어 이를 사용하는 프로세서의 유지 관리 노력을 최소화 한다. </p>\n<br>\n<br>\n<br>\n\n<h3 id=\"KAPT-vs-KSP-실제로-빌드해보기-Feat-Room\"><a href=\"#KAPT-vs-KSP-실제로-빌드해보기-Feat-Room\" class=\"headerlink\" title=\"KAPT vs KSP 실제로 빌드해보기 (Feat_ Room)\"></a>KAPT vs KSP 실제로 빌드해보기 (Feat_ Room)</h3><p>Rooom 라이브러리를 이용해 간단하게 테스트를 수행해보았다.</p>\n<p>테스트 조건은 아래와 같다.</p>\n<ol>\n<li>프로젝트로 작성된 간단한 프로젝트 </li>\n<li><code>RoomDatabase</code>를 상속받은 클래스 하나</li>\n<li>3개의 DAO, 3개의 Entity 클래스</li>\n</ol>\n<h4 id=\"KAPT-프로젝트\"><a href=\"#KAPT-프로젝트\" class=\"headerlink\" title=\"KAPT 프로젝트\"></a>KAPT 프로젝트</h4><p>빌드 스크립트에 <code>kotlin-kapt</code>를 추가한다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// build.gradle (app)</span></span><br><span class=\"line\">plugins &#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  id <span class=\"string\">&#x27;kotlin-kapt&#x27;</span></span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>의존성으로는 테스트할 Room 라이브러리를 추가하고, kapt에서 room을 사용하도록 처리한다.</p>\n<p>아래의 의존성으로 인해 Room 라이브러리는 Kotlin 어노테이션을 파싱한 뒤 SQLite를 사용하기 위한 자바 기반의 Stub 파일을 생성하게 된다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  implementation <span class=\"string\">&quot;androidx.room:room-runtime:2.3.0&quot;</span></span><br><span class=\"line\">  kapt <span class=\"string\">&quot;androidx.room:room-compiler:2.3.0&quot;</span></span><br><span class=\"line\">  implementation <span class=\"string\">&quot;androidx.room:room-ktx:2.3.0&quot;</span></span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>이제 <code>RoomDatabase</code>를 상속한 <code>ApplicationDatabase</code> 클래스를 작성한다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Database(</span></span><br><span class=\"line\"><span class=\"meta\">  entities = [AEntity::class, BEntity::class, CEntity::class],</span></span><br><span class=\"line\"><span class=\"meta\">  version = 1,</span></span><br><span class=\"line\"><span class=\"meta\">  exportSchema = false</span></span><br><span class=\"line\"><span class=\"meta\">)</span></span><br><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ApplicationDatabase</span>: <span class=\"type\">RoomDatabase</span></span>() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">companion</span> <span class=\"keyword\">object</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">val</span> DB_NAME = <span class=\"string\">&quot;ApplicationDataBase.db&quot;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">abstract</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">ADao</span><span class=\"params\">()</span></span>: ADao</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">abstract</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">BDao</span><span class=\"params\">()</span></span>: BDao</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">abstract</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">CDao</span><span class=\"params\">()</span></span>: CDao</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Kotlin 코드는 다음과 같은 Java Stub 파일로 생성되게 된다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ...</span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"meta\">@SuppressWarnings(&#123;&quot;unchecked&quot;, &quot;deprecation&quot;&#125;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ApplicationDatabase_Impl</span> <span class=\"keyword\">extends</span> <span class=\"title\">ApplicationDatabase</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> ADao _aDao;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> BDao _bDao;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> CDao _cDao;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">protected</span> SupportSQLiteOpenHelper <span class=\"title\">createOpenHelper</span><span class=\"params\">(DatabaseConfiguration configuration)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> SupportSQLiteOpenHelper.Callback _openCallback = <span class=\"keyword\">new</span> RoomOpenHelper(configuration, <span class=\"keyword\">new</span> RoomOpenHelper.Delegate(<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">      <span class=\"meta\">@Override</span></span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">createAllTables</span><span class=\"params\">(SupportSQLiteDatabase _db)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;                              </span><br><span class=\"line\"><span class=\"comment\">// ...                                                                              </span></span><br></pre></td></tr></table></figure>\n\n<p><strong>빌드 타임 측정</strong></p>\n<img src=\"/Team-Blog/2021/07/21/2021-07-21%20Kotlin%20Symbol%20Processing%20Api%20Part%203/rcWvgv0.png\" class=\"\" title=\"[rcWvgv0]\">\n\n<p>프로젝트 클린 후</p>\n<p>kaptGenerateStubsDebugKotlin으로 빌드시 <strong>16.6s</strong> 가 소요되었다.</p>\n<h4 id=\"KSP-프로젝트\"><a href=\"#KSP-프로젝트\" class=\"headerlink\" title=\"KSP 프로젝트\"></a>KSP 프로젝트</h4><p>위에서 작성한 KAPT 프로젝트를 KSP로 변경해보자.</p>\n<p>프로젝트 단위의 build.gradle 설정에서는 아래와 같이 의존성을 하나 더 추가해준다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// build.gradle (root)</span></span><br><span class=\"line\">buildscript &#123;</span><br><span class=\"line\">  ext.kotlin_version = <span class=\"string\">&quot;1.4.21&quot;</span></span><br><span class=\"line\">  repositories &#123;</span><br><span class=\"line\">    google()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  dependencies &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    classpath(<span class=\"string\">&quot;com.google.devtools.ksp:com.google.devtools.ksp.gradle.plugin:1.5.20-1.0.0-beta04&quot;</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>app의 build.gradle에 <code>com.google.devtools.ksp</code> 플러그인을 추가한다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">plugins &#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  id <span class=\"string\">&#x27;kotlin-kapt&#x27;</span></span><br><span class=\"line\">  id <span class=\"string\">&#x27;com.google.devtools.ksp&#x27;</span></span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>이후 기존 kapt로 추가했던 <code>room-compiler</code> 의존성을 ksp로 교체한다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  implementation <span class=\"string\">&quot;androidx.room:room-runtime:2.3.0&quot;</span></span><br><span class=\"line\">  <span class=\"comment\">// kapt &quot;androidx.room:room-compiler:2.3.0&quot;</span></span><br><span class=\"line\">  ksp <span class=\"string\">&quot;androidx.room:room-compiler:2.3.0&quot;</span></span><br><span class=\"line\">  implementation <span class=\"string\">&quot;androidx.room:room-ktx:2.3.0&quot;</span></span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>빌드 타임 측정</strong></p>\n<img src=\"/Team-Blog/2021/07/21/2021-07-21%20Kotlin%20Symbol%20Processing%20Api%20Part%203/HyjEy1l.png\" class=\"\" title=\"[HyjEy1l]\">\n\n<p>프로젝트 클린 후 빌드하면</p>\n<p>kaptGenerateStubsDebugKotlin이 <strong>12.54s</strong></p>\n<p>kspDebugKotlin이 <strong>5.49s</strong> 만큼 시간이 소요되어 총합 <strong>18.03s</strong> 만큼 시간이 소요되었다.</p>\n<p>KSP를 써서 더 빨라질 것을 기대했는데 왜 더 걸린 것일까?</p>\n<p>Android Developer의 공식 블로그에 그 이유가 공개되어 있다.</p>\n<blockquote>\n<p><strong>참고</strong> <a href=\"https://android-developers.googleblog.com/2021/02/announcing-kotlin-symbol-processing-ksp.html\">Announcing Kotlin Symbol Processing (KSP) Alpha</a></p>\n</blockquote>\n<p>위의 문서를 보면 아래와 같은 문구가 있다.</p>\n<p>That said, using KAPT and KSP in the same module will likely slow down your build initially, so during this alpha period, it is best to use KSP and KAPT in separate modules.</p>\n<p>동일한 모듈 내에서 kapt와 ksp를 동시에 사용하면 초기 빌드 속도가 더 소요된다고 명시되어있고, </p>\n<p>이에 대한 해결책으로(ksp가 alpha인 동안은) kapt와 ksp를 별도의 모듈에서 사용하는 것을 권장하고 있다.</p>\n<p>현재 프로젝트에서 KAPT를 사용하는 의존성을 전부 게거한 뒤, Room에 대한 KAPT, KSP를 비교하면 아래와 같은 결과를 얻을 수 있다.</p>\n<p><strong>Compile Time By KAPT only using Room</strong></p>\n<img src=\"/Team-Blog/2021/07/21/2021-07-21%20Kotlin%20Symbol%20Processing%20Api%20Part%203/NjWXyw6.png\" class=\"\" title=\"[Compile Time By KAPT only using Room]\">\n\n<p>8.40s</p>\n<p><strong>Compile Time By KSP only using Room</strong></p>\n<img src=\"/Team-Blog/2021/07/21/2021-07-21%20Kotlin%20Symbol%20Processing%20Api%20Part%203/0HScWJk.png\" class=\"\" title=\"[Compile Time By KSP only using Room]\">\n\n<p>0.71s</p>\n<p>한정적인 테스트지만 빌드 시간이 현격히 감소한 것을 확인할 수 있다.</p>\n<br>\n<br>\n<br>\n\n<h2 id=\"References\"><a href=\"#References\" class=\"headerlink\" title=\"References\"></a>References</h2><h3 id=\"Members-of-Study\"><a href=\"#Members-of-Study\" class=\"headerlink\" title=\"Members of Study\"></a>Members of Study</h3><ul>\n<li><a href=\"https://www.charlezz.com/?p=1167\">찰스의 안드로이드 - [Android] Annotation Processor 만들기</a></li>\n<li><a href=\"https://namhoon.kim/2021/06/25/android_deep_dive/020_Kotlin%20Symbol%20Processing%20API%20Part%201/\">Namhoon Kims’Coding Log - KSP Api Part 1</a></li>\n<li><a href=\"https://namhoon.kim/2021/06/27/android_deep_dive/021_Kotlin%20Symbol%20Processing%20API%20Part%202/\">Namhoon Kims’Coding Log - KSP Api Part 2</a></li>\n<li><a href=\"https://soda1127.github.io/introduce-kotlin-symbol-processing/\">소다의 개발 블로그 - Introduce Kotlin Symbol Processing</a></li>\n<li><a href=\"https://soda1127.github.io/implement-kotlin-symbol-processing-example/\">소다의 개발 블로그 - Implement Kotlin Symbol Processing</a></li>\n<li><a href=\"https://velog.io/@jshme/KSP-Kotlin-Symbol-Processor-%ED%86%BA%EC%95%84%EB%B3%B4%EA%B8%B0\">jsh-me.log - KSP(Kotlin Symbol Processor) 톺아보기</a></li>\n</ul>\n<h3 id=\"Official\"><a href=\"#Official\" class=\"headerlink\" title=\"Official\"></a>Official</h3><ul>\n<li><a href=\"https://developer.android.com/reference/androidx/annotation/package-summary\">Android Developers#androidx.annotation</a></li>\n<li><a href=\"https://github.com/google/ksp\">Google KSP Repository</a></li>\n<li><a href=\"https://github.com/google/ksp/blob/main/api/src/main/kotlin/com/google/devtools/ksp\">KSP API definition</a></li>\n<li><a href=\"https://github.com/google/ksp/blob/main/api/src/main/kotlin/com/google/devtools/ksp/symbol\">KSP Symbol definition</a></li>\n<li><a href=\"https://kotlinlang.org/docs/kapt.html\">KAPT(Kotlin Annotation Processing Tool)</a></li>\n<li><a href=\"https://android-developers.googleblog.com/2021/02/announcing-kotlin-symbol-processing-ksp.html\">Announcing Kotlin Symbol Processing (KSP) Alpha</a></li>\n<li><a href=\"https://docs.oracle.com/javase/tutorial/java/annotations/index.html\">Oracle JavaDoc#Annotations</a></li>\n<li><a href=\"https://blog.jetbrains.com/kotlin/2015/05/kapt-annotation-processing-for-kotlin\">kapt: Annotation Processing for Kotlin</a></li>\n<li><a href=\"https://kotlinlang.org/docs/kapt.html#using-in-gradle\">Using kapt</a></li>\n</ul>\n<h3 id=\"Etc\"><a href=\"#Etc\" class=\"headerlink\" title=\"Etc\"></a>Etc</h3><ul>\n<li><a href=\"https://github.com/tachiyomiorg/tachiyomi\">Tachiyomi</a></li>\n<li><a href=\"https://jsuch2362.medium.com/my-first-kotlin-symbol-processing-tool-for-android-4eb3a2cfd600\">My first Kotlin Symbol Processing Tool for Android</a></li>\n<li><a href=\"https://proandroiddev.com/ksp-fact-or-kapt-7c7e9218c575\">KSP: Fact or kapt?</a></li>\n<li><a href=\"https://hannesdorfmann.com/annotation-processing/annotationprocessing101/\">Annotation Processing 101</a></li>\n<li><a href=\"https://imstudio.medium.com/kotlin-kotlin-plugin-should-be-enabled-before-kotlin-kapt-d5879f45f09d\">Kotlin : Kotlin plugin should be enabled before ‘kotlin-kapt’</a></li>\n<li><a href=\"https://medium.com/@workingkills/pushing-the-limits-of-kotlin-annotation-processing-8611027b6711\">Pushing the limits of Kotlin annotation processing</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<article class=\"message message-immersive is-primary\">\n    <div class=\"message-body\">\n        <i class=\"fas fa-pen-fancy mr-2\"></i>Writers<br>\n        by 곽욱현 @Knowre<br>\n        by 김남훈 @Naver<br>\n        by 송시영 @SmartStudy<br>\n        by 옥수환 @Naver<br>\n        by 이기정 @BankSalad<br>\n        by 정세희 @BankSalad\n    </div>\n</article>","more":"<p>앞선 두 개의 포스팅에서 <strong>KAPT</strong> 와 <strong>KSP</strong> 에 대해서 다루었다.</p>\n<p>이번 포스팅에서는 <strong>KAPT</strong> 와 <strong>KSP</strong> 를 서로 비교해본다.</p>\n<h2 id=\"Better-than-KAPT\"><a href=\"#Better-than-KAPT\" class=\"headerlink\" title=\"Better than KAPT\"></a>Better than KAPT</h2><p>앞선 포스팅에서 언급했듯 KAPT는 Kotlin 코드를 Java Annotation Processor를 수정하지 않기 위해 컴파일시 Java로 된 Stub을 생성하게 된다. </p>\n<p>Stub을 생성하는 것은 kotlinc의 분석 비용의 3분의 1이나 차지하므로, 빌드시 필연적으로 많은 오버헤드가 발생하게 된다. </p>\n<p>KAPT와 달리 KSP는 Java 관점이 아닌 Kotlin의 관점에서 접근하며, <code>top-level function</code>과 같은 Kotlin의 고유 기능에 더 적합하다.</p>\n<p>KAPT와 좀 더 자세하게 비교해보면 아래로 정리할 수 있다.</p>\n<p><strong>1. 빠르다</strong></p>\n<p>기존에는 코틀린 전용 애노테이션 프로세서가 없었기 때문에, <code>javax.lang.model</code> 패키지에서 제공하는 API를 통해 애노테이션 프로세서를 작성했다. </p>\n<p>이 프로세서를 수행하기 위해 KAPT는 코틀린 코드를 <strong>자바 Stub</strong> 으로 컴파일하게 된다. </p>\n<p>이러한 Stub을 생성하려면 KAPT가 코틀린 프로그램의 모든 기호(symbol)들을 확인해야 한다. Stub 코드를 생성하는 비용은 컴파일 전체의 1/3을 차지한다. </p>\n<p>성능 평가를 위해 KSP에서 Glide의 단순화된 버전을 구현하여 <strong>Tachiyomi</strong> 프로젝트용 코드를 생성했는데 </p>\n<p>코틀린 컴파일 시간은 21.55초에서 KAPT가 코드를 생성하는데 8.67초, KSP가 코드를 생성하는데 1.15초가 걸렸다고 한다. </p>\n<blockquote>\n<p><strong>참고</strong> <a href=\"https://github.com/tachiyomiorg/tachiyomi\">Tachiyomi repository</a></p>\n</blockquote>\n<p><strong>2. 쉽다</strong></p>\n<p>KSP는 코틀린 친화적이다. </p>\n<p>KSP는 코틀린만의 고유한 기능들인 확장 함수(extension function), 선언 위치 변환 (Declaration-Site Variance), 지역 함수(local functions) 등을 이해한다. </p>\n<p>또한 타입을 모델링하고 동등성 및 할당호환성(assign-comppatibility)과 같은 기본적인 타입을 검사하는 기능을 제공한다.</p>\n<p>KSP를 이용하여 소스코드를 처리할 때 클래스, 클래스 멤버, 함수 및 관련 매개변수와 같은 내용에 쉽게 접근이 가능하다. </p>\n<p>개념적으로는 코틀린 리플렉션의 KType과 유사하기 때문에 커스텀 SymbolProcessor 작성 시 AbstractProcessor와 비교하여 작성이 편하다는 느낌을 받게 된다.</p>\n<p>자세한 내용은 Part 2를 참고하자.</p>\n<p><strong>3. 호환성 및 유지보수</strong></p>\n<p>KSP는 JVM에 종속되지 않도록 설계되었기 때문에 향후 다른 플랫폼에 보다 쉽게 적용할 수 있다. </p>\n<p>또한 컴파일러 변경 사항을 숨기도록 설계되어 이를 사용하는 프로세서의 유지 관리 노력을 최소화 한다. </p>\n<br>\n<br>\n<br>\n\n<h3 id=\"KAPT-vs-KSP-실제로-빌드해보기-Feat-Room\"><a href=\"#KAPT-vs-KSP-실제로-빌드해보기-Feat-Room\" class=\"headerlink\" title=\"KAPT vs KSP 실제로 빌드해보기 (Feat_ Room)\"></a>KAPT vs KSP 실제로 빌드해보기 (Feat_ Room)</h3><p>Rooom 라이브러리를 이용해 간단하게 테스트를 수행해보았다.</p>\n<p>테스트 조건은 아래와 같다.</p>\n<ol>\n<li>프로젝트로 작성된 간단한 프로젝트 </li>\n<li><code>RoomDatabase</code>를 상속받은 클래스 하나</li>\n<li>3개의 DAO, 3개의 Entity 클래스</li>\n</ol>\n<h4 id=\"KAPT-프로젝트\"><a href=\"#KAPT-프로젝트\" class=\"headerlink\" title=\"KAPT 프로젝트\"></a>KAPT 프로젝트</h4><p>빌드 스크립트에 <code>kotlin-kapt</code>를 추가한다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// build.gradle (app)</span></span><br><span class=\"line\">plugins &#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  id <span class=\"string\">&#x27;kotlin-kapt&#x27;</span></span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>의존성으로는 테스트할 Room 라이브러리를 추가하고, kapt에서 room을 사용하도록 처리한다.</p>\n<p>아래의 의존성으로 인해 Room 라이브러리는 Kotlin 어노테이션을 파싱한 뒤 SQLite를 사용하기 위한 자바 기반의 Stub 파일을 생성하게 된다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  implementation <span class=\"string\">&quot;androidx.room:room-runtime:2.3.0&quot;</span></span><br><span class=\"line\">  kapt <span class=\"string\">&quot;androidx.room:room-compiler:2.3.0&quot;</span></span><br><span class=\"line\">  implementation <span class=\"string\">&quot;androidx.room:room-ktx:2.3.0&quot;</span></span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>이제 <code>RoomDatabase</code>를 상속한 <code>ApplicationDatabase</code> 클래스를 작성한다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Database(</span></span><br><span class=\"line\"><span class=\"meta\">  entities = [AEntity::class, BEntity::class, CEntity::class],</span></span><br><span class=\"line\"><span class=\"meta\">  version = 1,</span></span><br><span class=\"line\"><span class=\"meta\">  exportSchema = false</span></span><br><span class=\"line\"><span class=\"meta\">)</span></span><br><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ApplicationDatabase</span>: <span class=\"type\">RoomDatabase</span></span>() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">companion</span> <span class=\"keyword\">object</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">val</span> DB_NAME = <span class=\"string\">&quot;ApplicationDataBase.db&quot;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">abstract</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">ADao</span><span class=\"params\">()</span></span>: ADao</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">abstract</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">BDao</span><span class=\"params\">()</span></span>: BDao</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">abstract</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">CDao</span><span class=\"params\">()</span></span>: CDao</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Kotlin 코드는 다음과 같은 Java Stub 파일로 생성되게 된다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ...</span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"meta\">@SuppressWarnings(&#123;&quot;unchecked&quot;, &quot;deprecation&quot;&#125;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ApplicationDatabase_Impl</span> <span class=\"keyword\">extends</span> <span class=\"title\">ApplicationDatabase</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> ADao _aDao;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> BDao _bDao;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> CDao _cDao;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">protected</span> SupportSQLiteOpenHelper <span class=\"title\">createOpenHelper</span><span class=\"params\">(DatabaseConfiguration configuration)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> SupportSQLiteOpenHelper.Callback _openCallback = <span class=\"keyword\">new</span> RoomOpenHelper(configuration, <span class=\"keyword\">new</span> RoomOpenHelper.Delegate(<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">      <span class=\"meta\">@Override</span></span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">createAllTables</span><span class=\"params\">(SupportSQLiteDatabase _db)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;                              </span><br><span class=\"line\"><span class=\"comment\">// ...                                                                              </span></span><br></pre></td></tr></table></figure>\n\n<p><strong>빌드 타임 측정</strong></p>\n<img src=\"/Team-Blog/2021/07/21/2021-07-21%20Kotlin%20Symbol%20Processing%20Api%20Part%203/rcWvgv0.png\" class=\"\" title=\"[rcWvgv0]\">\n\n<p>프로젝트 클린 후</p>\n<p>kaptGenerateStubsDebugKotlin으로 빌드시 <strong>16.6s</strong> 가 소요되었다.</p>\n<h4 id=\"KSP-프로젝트\"><a href=\"#KSP-프로젝트\" class=\"headerlink\" title=\"KSP 프로젝트\"></a>KSP 프로젝트</h4><p>위에서 작성한 KAPT 프로젝트를 KSP로 변경해보자.</p>\n<p>프로젝트 단위의 build.gradle 설정에서는 아래와 같이 의존성을 하나 더 추가해준다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// build.gradle (root)</span></span><br><span class=\"line\">buildscript &#123;</span><br><span class=\"line\">  ext.kotlin_version = <span class=\"string\">&quot;1.4.21&quot;</span></span><br><span class=\"line\">  repositories &#123;</span><br><span class=\"line\">    google()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  dependencies &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    classpath(<span class=\"string\">&quot;com.google.devtools.ksp:com.google.devtools.ksp.gradle.plugin:1.5.20-1.0.0-beta04&quot;</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>app의 build.gradle에 <code>com.google.devtools.ksp</code> 플러그인을 추가한다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">plugins &#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  id <span class=\"string\">&#x27;kotlin-kapt&#x27;</span></span><br><span class=\"line\">  id <span class=\"string\">&#x27;com.google.devtools.ksp&#x27;</span></span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>이후 기존 kapt로 추가했던 <code>room-compiler</code> 의존성을 ksp로 교체한다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  implementation <span class=\"string\">&quot;androidx.room:room-runtime:2.3.0&quot;</span></span><br><span class=\"line\">  <span class=\"comment\">// kapt &quot;androidx.room:room-compiler:2.3.0&quot;</span></span><br><span class=\"line\">  ksp <span class=\"string\">&quot;androidx.room:room-compiler:2.3.0&quot;</span></span><br><span class=\"line\">  implementation <span class=\"string\">&quot;androidx.room:room-ktx:2.3.0&quot;</span></span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>빌드 타임 측정</strong></p>\n<img src=\"/Team-Blog/2021/07/21/2021-07-21%20Kotlin%20Symbol%20Processing%20Api%20Part%203/HyjEy1l.png\" class=\"\" title=\"[HyjEy1l]\">\n\n<p>프로젝트 클린 후 빌드하면</p>\n<p>kaptGenerateStubsDebugKotlin이 <strong>12.54s</strong></p>\n<p>kspDebugKotlin이 <strong>5.49s</strong> 만큼 시간이 소요되어 총합 <strong>18.03s</strong> 만큼 시간이 소요되었다.</p>\n<p>KSP를 써서 더 빨라질 것을 기대했는데 왜 더 걸린 것일까?</p>\n<p>Android Developer의 공식 블로그에 그 이유가 공개되어 있다.</p>\n<blockquote>\n<p><strong>참고</strong> <a href=\"https://android-developers.googleblog.com/2021/02/announcing-kotlin-symbol-processing-ksp.html\">Announcing Kotlin Symbol Processing (KSP) Alpha</a></p>\n</blockquote>\n<p>위의 문서를 보면 아래와 같은 문구가 있다.</p>\n<p>That said, using KAPT and KSP in the same module will likely slow down your build initially, so during this alpha period, it is best to use KSP and KAPT in separate modules.</p>\n<p>동일한 모듈 내에서 kapt와 ksp를 동시에 사용하면 초기 빌드 속도가 더 소요된다고 명시되어있고, </p>\n<p>이에 대한 해결책으로(ksp가 alpha인 동안은) kapt와 ksp를 별도의 모듈에서 사용하는 것을 권장하고 있다.</p>\n<p>현재 프로젝트에서 KAPT를 사용하는 의존성을 전부 게거한 뒤, Room에 대한 KAPT, KSP를 비교하면 아래와 같은 결과를 얻을 수 있다.</p>\n<p><strong>Compile Time By KAPT only using Room</strong></p>\n<img src=\"/Team-Blog/2021/07/21/2021-07-21%20Kotlin%20Symbol%20Processing%20Api%20Part%203/NjWXyw6.png\" class=\"\" title=\"[Compile Time By KAPT only using Room]\">\n\n<p>8.40s</p>\n<p><strong>Compile Time By KSP only using Room</strong></p>\n<img src=\"/Team-Blog/2021/07/21/2021-07-21%20Kotlin%20Symbol%20Processing%20Api%20Part%203/0HScWJk.png\" class=\"\" title=\"[Compile Time By KSP only using Room]\">\n\n<p>0.71s</p>\n<p>한정적인 테스트지만 빌드 시간이 현격히 감소한 것을 확인할 수 있다.</p>\n<br>\n<br>\n<br>\n\n<h2 id=\"References\"><a href=\"#References\" class=\"headerlink\" title=\"References\"></a>References</h2><h3 id=\"Members-of-Study\"><a href=\"#Members-of-Study\" class=\"headerlink\" title=\"Members of Study\"></a>Members of Study</h3><ul>\n<li><a href=\"https://www.charlezz.com/?p=1167\">찰스의 안드로이드 - [Android] Annotation Processor 만들기</a></li>\n<li><a href=\"https://namhoon.kim/2021/06/25/android_deep_dive/020_Kotlin%20Symbol%20Processing%20API%20Part%201/\">Namhoon Kims’Coding Log - KSP Api Part 1</a></li>\n<li><a href=\"https://namhoon.kim/2021/06/27/android_deep_dive/021_Kotlin%20Symbol%20Processing%20API%20Part%202/\">Namhoon Kims’Coding Log - KSP Api Part 2</a></li>\n<li><a href=\"https://soda1127.github.io/introduce-kotlin-symbol-processing/\">소다의 개발 블로그 - Introduce Kotlin Symbol Processing</a></li>\n<li><a href=\"https://soda1127.github.io/implement-kotlin-symbol-processing-example/\">소다의 개발 블로그 - Implement Kotlin Symbol Processing</a></li>\n<li><a href=\"https://velog.io/@jshme/KSP-Kotlin-Symbol-Processor-%ED%86%BA%EC%95%84%EB%B3%B4%EA%B8%B0\">jsh-me.log - KSP(Kotlin Symbol Processor) 톺아보기</a></li>\n</ul>\n<h3 id=\"Official\"><a href=\"#Official\" class=\"headerlink\" title=\"Official\"></a>Official</h3><ul>\n<li><a href=\"https://developer.android.com/reference/androidx/annotation/package-summary\">Android Developers#androidx.annotation</a></li>\n<li><a href=\"https://github.com/google/ksp\">Google KSP Repository</a></li>\n<li><a href=\"https://github.com/google/ksp/blob/main/api/src/main/kotlin/com/google/devtools/ksp\">KSP API definition</a></li>\n<li><a href=\"https://github.com/google/ksp/blob/main/api/src/main/kotlin/com/google/devtools/ksp/symbol\">KSP Symbol definition</a></li>\n<li><a href=\"https://kotlinlang.org/docs/kapt.html\">KAPT(Kotlin Annotation Processing Tool)</a></li>\n<li><a href=\"https://android-developers.googleblog.com/2021/02/announcing-kotlin-symbol-processing-ksp.html\">Announcing Kotlin Symbol Processing (KSP) Alpha</a></li>\n<li><a href=\"https://docs.oracle.com/javase/tutorial/java/annotations/index.html\">Oracle JavaDoc#Annotations</a></li>\n<li><a href=\"https://blog.jetbrains.com/kotlin/2015/05/kapt-annotation-processing-for-kotlin\">kapt: Annotation Processing for Kotlin</a></li>\n<li><a href=\"https://kotlinlang.org/docs/kapt.html#using-in-gradle\">Using kapt</a></li>\n</ul>\n<h3 id=\"Etc\"><a href=\"#Etc\" class=\"headerlink\" title=\"Etc\"></a>Etc</h3><ul>\n<li><a href=\"https://github.com/tachiyomiorg/tachiyomi\">Tachiyomi</a></li>\n<li><a href=\"https://jsuch2362.medium.com/my-first-kotlin-symbol-processing-tool-for-android-4eb3a2cfd600\">My first Kotlin Symbol Processing Tool for Android</a></li>\n<li><a href=\"https://proandroiddev.com/ksp-fact-or-kapt-7c7e9218c575\">KSP: Fact or kapt?</a></li>\n<li><a href=\"https://hannesdorfmann.com/annotation-processing/annotationprocessing101/\">Annotation Processing 101</a></li>\n<li><a href=\"https://imstudio.medium.com/kotlin-kotlin-plugin-should-be-enabled-before-kotlin-kapt-d5879f45f09d\">Kotlin : Kotlin plugin should be enabled before ‘kotlin-kapt’</a></li>\n<li><a href=\"https://medium.com/@workingkills/pushing-the-limits-of-kotlin-annotation-processing-8611027b6711\">Pushing the limits of Kotlin annotation processing</a></li>\n</ul>"}],"PostAsset":[{"_id":"source/_posts/2021-04-07 Jetpack Compose Part 3/add_002_002.png","post":"cksagj7kw00043lre9kn363in","slug":"add_002_002.png","modified":1,"renderable":1},{"_id":"source/_posts/2021-04-07 Jetpack Compose Part 1/1_5gfrQWfxyEC7Oq6b2xlJ9w.png","post":"cksagj7km00003lre8y9f5bri","slug":"1_5gfrQWfxyEC7Oq6b2xlJ9w.png","modified":1,"renderable":1},{"_id":"source/_posts/2021-04-07 Jetpack Compose Part 1/VLTxB8C.png","post":"cksagj7km00003lre8y9f5bri","slug":"VLTxB8C.png","modified":1,"renderable":1},{"_id":"source/_posts/2021-04-07 Jetpack Compose Part 1/WprDTs1.png","post":"cksagj7km00003lre8y9f5bri","slug":"WprDTs1.png","modified":1,"renderable":1},{"_id":"source/_posts/2021-04-07 Jetpack Compose Part 1/aO6Jlsg.png","post":"cksagj7km00003lre8y9f5bri","slug":"aO6Jlsg.png","modified":1,"renderable":1},{"_id":"source/_posts/2021-04-07 Jetpack Compose Part 1/compose_animation.gif","post":"cksagj7km00003lre8y9f5bri","slug":"compose_animation.gif","modified":1,"renderable":1},{"_id":"source/_posts/2021-04-07 Jetpack Compose Part 1/qgQ6oY4.png","post":"cksagj7km00003lre8y9f5bri","slug":"qgQ6oY4.png","modified":1,"renderable":1},{"_id":"source/_posts/2021-04-07 Jetpack Compose Part 2/1_5RZOM7sWV0sXctJtTPdshQ.png","post":"cksagj7kt00013lree18reuhl","slug":"1_5RZOM7sWV0sXctJtTPdshQ.png","modified":1,"renderable":1},{"_id":"source/_posts/2021-04-07 Jetpack Compose Part 2/1_9IA2k2s5hAS9pSyzpmQ6Pw.png","post":"cksagj7kt00013lree18reuhl","slug":"1_9IA2k2s5hAS9pSyzpmQ6Pw.png","modified":1,"renderable":1},{"_id":"source/_posts/2021-04-07 Jetpack Compose Part 2/1_T9Pww7JyPMPhCJ_6yU8fyQ.png","post":"cksagj7kt00013lree18reuhl","slug":"1_T9Pww7JyPMPhCJ_6yU8fyQ.png","modified":1,"renderable":1},{"_id":"source/_posts/2021-04-07 Jetpack Compose Part 2/1_UoLVl1dbUjKh9kd4uY0ROA.png","post":"cksagj7kt00013lree18reuhl","slug":"1_UoLVl1dbUjKh9kd4uY0ROA.png","modified":1,"renderable":1},{"_id":"source/_posts/2021-04-07 Jetpack Compose Part 2/1_XVvr-CB2pn88Te7Gg52GPA.png","post":"cksagj7kt00013lree18reuhl","slug":"1_XVvr-CB2pn88Te7Gg52GPA.png","modified":1,"renderable":1},{"_id":"source/_posts/2021-04-07 Jetpack Compose Part 2/1_bSyX8yT7H2HevBNw9fbyYw.png","post":"cksagj7kt00013lree18reuhl","slug":"1_bSyX8yT7H2HevBNw9fbyYw.png","modified":1,"renderable":1},{"_id":"source/_posts/2021-04-07 Jetpack Compose Part 2/1_m7mSalYCza-SoJjmlYeWdA.png","post":"cksagj7kt00013lree18reuhl","slug":"1_m7mSalYCza-SoJjmlYeWdA.png","modified":1,"renderable":1},{"_id":"source/_posts/2021-04-07 Jetpack Compose Part 2/1_tPAf-Akf2IpDRrrZo1f1dg.png","post":"cksagj7kt00013lree18reuhl","slug":"1_tPAf-Akf2IpDRrrZo1f1dg.png","modified":1,"renderable":1},{"_id":"source/_posts/2021-04-07 Jetpack Compose Part 2/1_wFM4jF71V5aJog3lALaRKQ.png","post":"cksagj7kt00013lree18reuhl","slug":"1_wFM4jF71V5aJog3lALaRKQ.png","modified":1,"renderable":1},{"_id":"source/_posts/2021-04-07 Jetpack Compose Part 2/1_ybDWG4W2bPYNq79vr1gE8w.png","post":"cksagj7kt00013lree18reuhl","slug":"1_ybDWG4W2bPYNq79vr1gE8w.png","modified":1,"renderable":1},{"_id":"source/_posts/2021-04-07 Jetpack Compose Part 2/add_002_001.png","post":"cksagj7kt00013lree18reuhl","slug":"add_002_001.png","modified":1,"renderable":1},{"_id":"source/_posts/2021-05-19 Android UI Rendering Optimization Part 1/7AGranC.png","post":"cksagj7kx00053lre02i6f7pq","slug":"7AGranC.png","modified":1,"renderable":1},{"_id":"source/_posts/2021-05-19 Android UI Rendering Optimization Part 1/EzHZMUm.png","post":"cksagj7kx00053lre02i6f7pq","slug":"EzHZMUm.png","modified":1,"renderable":1},{"_id":"source/_posts/2021-05-19 Android UI Rendering Optimization Part 1/UntitledDiagram.png","post":"cksagj7kx00053lre02i6f7pq","slug":"UntitledDiagram.png","modified":1,"renderable":1},{"_id":"source/_posts/2021-05-19 Android UI Rendering Optimization Part 1/image.png","post":"cksagj7kx00053lre02i6f7pq","slug":"image.png","modified":1,"renderable":1},{"_id":"source/_posts/2021-05-19 Android UI Rendering Optimization Part 1/qu5Mr6x.png","post":"cksagj7kx00053lre02i6f7pq","slug":"qu5Mr6x.png","modified":1,"renderable":1},{"_id":"source/_posts/2021-05-19 Android UI Rendering Optimization Part 2/1ZQEOg0.png","post":"cksagj7ky00063lreddjqc1bt","slug":"1ZQEOg0.png","modified":1,"renderable":1},{"_id":"source/_posts/2021-05-19 Android UI Rendering Optimization Part 2/4.png","post":"cksagj7ky00063lreddjqc1bt","slug":"4.png","modified":1,"renderable":1},{"_id":"source/_posts/2021-05-19 Android UI Rendering Optimization Part 2/7990Bf0.png","post":"cksagj7ky00063lreddjqc1bt","slug":"7990Bf0.png","modified":1,"renderable":1},{"_id":"source/_posts/2021-05-19 Android UI Rendering Optimization Part 2/JNfYVx7.png","post":"cksagj7ky00063lreddjqc1bt","slug":"JNfYVx7.png","modified":1,"renderable":1},{"_id":"source/_posts/2021-05-19 Android UI Rendering Optimization Part 2/cK00ybR.png","post":"cksagj7ky00063lreddjqc1bt","slug":"cK00ybR.png","modified":1,"renderable":1},{"_id":"source/_posts/2021-05-19 Android UI Rendering Optimization Part 2/ha7Eriy.png","post":"cksagj7ky00063lreddjqc1bt","slug":"ha7Eriy.png","modified":1,"renderable":1},{"_id":"source/_posts/2021-05-19 Android UI Rendering Optimization Part 2/image-1.png","post":"cksagj7ky00063lreddjqc1bt","slug":"image-1.png","modified":1,"renderable":1},{"_id":"source/_posts/2021-05-19 Android UI Rendering Optimization Part 2/image.png","post":"cksagj7ky00063lreddjqc1bt","slug":"image.png","modified":1,"renderable":1},{"_id":"source/_posts/2021-05-19 Android UI Rendering Optimization Part 2/n6fsbPA.png","post":"cksagj7ky00063lreddjqc1bt","slug":"n6fsbPA.png","modified":1,"renderable":1},{"_id":"source/_posts/2021-05-19 Android UI Rendering Optimization Part 2/ptHtNno.png","post":"cksagj7ky00063lreddjqc1bt","slug":"ptHtNno.png","modified":1,"renderable":1},{"_id":"source/_posts/2021-05-19 Android UI Rendering Optimization Part 3/after_merge.png","post":"cksagj7l400093lreh3dy7weh","slug":"after_merge.png","modified":1,"renderable":1},{"_id":"source/_posts/2021-05-19 Android UI Rendering Optimization Part 3/before_merge.png","post":"cksagj7l400093lreh3dy7weh","slug":"before_merge.png","modified":1,"renderable":1},{"_id":"source/_posts/2021-05-19 Android UI Rendering Optimization Part 3/example1.png","post":"cksagj7l400093lreh3dy7weh","slug":"example1.png","modified":1,"renderable":1},{"_id":"source/_posts/2021-05-19 Android UI Rendering Optimization Part 3/example2.png","post":"cksagj7l400093lreh3dy7weh","slug":"example2.png","modified":1,"renderable":1},{"_id":"source/_posts/2021-05-19 Android UI Rendering Optimization Part 3/gpu_profile.png","post":"cksagj7l400093lreh3dy7weh","slug":"gpu_profile.png","modified":1,"renderable":1},{"_id":"source/_posts/2021-05-19 Android UI Rendering Optimization Part 3/gpu_rendering_profile_1.png","post":"cksagj7l400093lreh3dy7weh","slug":"gpu_rendering_profile_1.png","modified":1,"renderable":1},{"_id":"source/_posts/2021-05-19 Android UI Rendering Optimization Part 3/gpu_rendering_profile_2.png","post":"cksagj7l400093lreh3dy7weh","slug":"gpu_rendering_profile_2.png","modified":1,"renderable":1},{"_id":"source/_posts/2021-05-19 Android UI Rendering Optimization Part 3/graph_color.png","post":"cksagj7l400093lreh3dy7weh","slug":"graph_color.png","modified":1,"renderable":1},{"_id":"source/_posts/2021-05-19 Android UI Rendering Optimization Part 3/image.png","post":"cksagj7l400093lreh3dy7weh","slug":"image.png","modified":1,"renderable":1},{"_id":"source/_posts/2021-05-19 Android UI Rendering Optimization Part 3/overdrawn_1.png","post":"cksagj7l400093lreh3dy7weh","slug":"overdrawn_1.png","modified":1,"renderable":1},{"_id":"source/_posts/2021-05-19 Android UI Rendering Optimization Part 3/overdrawn_2.png","post":"cksagj7l400093lreh3dy7weh","slug":"overdrawn_2.png","modified":1,"renderable":1},{"_id":"source/_posts/2021-05-19 Android UI Rendering Optimization Part 3/overdrawn_3.png","post":"cksagj7l400093lreh3dy7weh","slug":"overdrawn_3.png","modified":1,"renderable":1},{"_id":"source/_posts/2021-05-19 Android UI Rendering Optimization Part 3/overdrawn_4.png","post":"cksagj7l400093lreh3dy7weh","slug":"overdrawn_4.png","modified":1,"renderable":1},{"_id":"source/_posts/2021-05-19 Android UI Rendering Optimization Part 3/zw3H5pZ.png","post":"cksagj7l400093lreh3dy7weh","slug":"zw3H5pZ.png","modified":1,"renderable":1},{"_id":"source/_posts/2021-06-24 Image Loading and Caching Library Part 2/IMG_06A0242D2ABE-1.jpg","post":"cksagj7lt001s3lre6183g4z6","slug":"IMG_06A0242D2ABE-1.jpg","modified":1,"renderable":1},{"_id":"source/_posts/2021-06-24 Image Loading and Caching Library Part 2/Screenshot_1624078627.png","post":"cksagj7lt001s3lre6183g4z6","slug":"Screenshot_1624078627.png","modified":1,"renderable":1},{"_id":"source/_posts/2021-06-24 Image Loading and Caching Library Part 2/image.png","post":"cksagj7lt001s3lre6183g4z6","slug":"image.png","modified":1,"renderable":1},{"_id":"source/_posts/2021-06-24 Image Loading and Caching Library Part 1/IMG_8FF7402ED110-1.jpg","post":"cksagj7ls001r3lrehr0p4cex","slug":"IMG_8FF7402ED110-1.jpg","modified":1,"renderable":1},{"_id":"source/_posts/2021-06-24 Image Loading and Caching Library Part 1/IMG_9F5E046409C4-1.jpg","post":"cksagj7ls001r3lrehr0p4cex","slug":"IMG_9F5E046409C4-1.jpg","modified":1,"renderable":1},{"_id":"source/_posts/2021-06-24 Image Loading and Caching Library Part 1/Screenshot_1623775512.png","post":"cksagj7ls001r3lrehr0p4cex","slug":"Screenshot_1623775512.png","modified":1,"renderable":1},{"_id":"source/_posts/2021-06-24 Image Loading and Caching Library Part 1/coil_caching.gif","post":"cksagj7ls001r3lrehr0p4cex","slug":"coil_caching.gif","modified":1,"renderable":1},{"_id":"source/_posts/2021-06-24 Image Loading and Caching Library Part 1/coil_heap_dump.png","post":"cksagj7ls001r3lrehr0p4cex","slug":"coil_heap_dump.png","modified":1,"renderable":1},{"_id":"source/_posts/2021-06-24 Image Loading and Caching Library Part 1/coil_test.gif","post":"cksagj7ls001r3lrehr0p4cex","slug":"coil_test.gif","modified":1,"renderable":1},{"_id":"source/_posts/2021-06-24 Image Loading and Caching Library Part 1/glide_caching.gif","post":"cksagj7ls001r3lrehr0p4cex","slug":"glide_caching.gif","modified":1,"renderable":1},{"_id":"source/_posts/2021-06-24 Image Loading and Caching Library Part 1/glide_gif.gif","post":"cksagj7ls001r3lrehr0p4cex","slug":"glide_gif.gif","modified":1,"renderable":1},{"_id":"source/_posts/2021-06-24 Image Loading and Caching Library Part 1/glide_heap_dump.png","post":"cksagj7ls001r3lrehr0p4cex","slug":"glide_heap_dump.png","modified":1,"renderable":1},{"_id":"source/_posts/2021-06-24 Image Loading and Caching Library Part 1/glide_test.gif","post":"cksagj7ls001r3lrehr0p4cex","slug":"glide_test.gif","modified":1,"renderable":1},{"_id":"source/_posts/2021-06-24 Image Loading and Caching Library Part 1/heap_dump.png","post":"cksagj7ls001r3lrehr0p4cex","slug":"heap_dump.png","modified":1,"renderable":1},{"_id":"source/_posts/2021-06-24 Image Loading and Caching Library Part 1/picasso_caching.gif","post":"cksagj7ls001r3lrehr0p4cex","slug":"picasso_caching.gif","modified":1,"renderable":1},{"_id":"source/_posts/2021-06-24 Image Loading and Caching Library Part 1/picasso_test.gif","post":"cksagj7ls001r3lrehr0p4cex","slug":"picasso_test.gif","modified":1,"renderable":1},{"_id":"source/_posts/2021-06-24 Image Loading and Caching Library Part 3/0oDUU69.png","post":"cksagj7lv001v3lrebxc2cl09","slug":"0oDUU69.png","modified":1,"renderable":1},{"_id":"source/_posts/2021-06-24 Image Loading and Caching Library Part 3/BntHJ2Y-1.png","post":"cksagj7lv001v3lrebxc2cl09","slug":"BntHJ2Y-1.png","modified":1,"renderable":1},{"_id":"source/_posts/2021-06-24 Image Loading and Caching Library Part 3/BntHJ2Y.png","post":"cksagj7lv001v3lrebxc2cl09","slug":"BntHJ2Y.png","modified":1,"renderable":1},{"_id":"source/_posts/2021-06-24 Image Loading and Caching Library Part 3/QafKUB1.png","post":"cksagj7lv001v3lrebxc2cl09","slug":"QafKUB1.png","modified":1,"renderable":1},{"_id":"source/_posts/2021-06-24 Image Loading and Caching Library Part 3/TIrybR8.png","post":"cksagj7lv001v3lrebxc2cl09","slug":"TIrybR8.png","modified":1,"renderable":1},{"_id":"source/_posts/2021-06-24 Image Loading and Caching Library Part 3/m7itaqy.png","post":"cksagj7lv001v3lrebxc2cl09","slug":"m7itaqy.png","modified":1,"renderable":1},{"_id":"source/_posts/2021-06-24 Image Loading and Caching Library Part 3/rb1bMMt.png","post":"cksagj7lv001v3lrebxc2cl09","slug":"rb1bMMt.png","modified":1,"renderable":1},{"_id":"source/_posts/2021-07-21 Kotlin Symbol Processing Api Part 2/ClassDiagram.svg","post":"cksagj7lx001x3lreg56deplf","slug":"ClassDiagram.svg","modified":1,"renderable":1},{"_id":"source/_posts/2021-07-21 Kotlin Symbol Processing Api Part 3/0HScWJk.png","post":"cksagj7lz00203lre8lqf65qd","slug":"0HScWJk.png","modified":1,"renderable":1},{"_id":"source/_posts/2021-07-21 Kotlin Symbol Processing Api Part 3/HyjEy1l.png","post":"cksagj7lz00203lre8lqf65qd","slug":"HyjEy1l.png","modified":1,"renderable":1},{"_id":"source/_posts/2021-07-21 Kotlin Symbol Processing Api Part 3/NjWXyw6.png","post":"cksagj7lz00203lre8lqf65qd","slug":"NjWXyw6.png","modified":1,"renderable":1},{"_id":"source/_posts/2021-07-21 Kotlin Symbol Processing Api Part 3/rcWvgv0.png","post":"cksagj7lz00203lre8lqf65qd","slug":"rcWvgv0.png","modified":1,"renderable":1},{"_id":"source/_posts/2021-07-21 Kotlin Symbol Processing Api Part 1/processing_rounds.png","post":"cksagj7lw001w3lre4mfub16y","slug":"processing_rounds.png","modified":1,"renderable":1}],"PostCategory":[{"post_id":"cksagj7km00003lre8y9f5bri","category_id":"cksagj7ku00023lredvpg7r2d","_id":"cksagj7l6000b3lre4c3b5qvm"},{"post_id":"cksagj7kt00013lree18reuhl","category_id":"cksagj7ku00023lredvpg7r2d","_id":"cksagj7l7000e3lrecuk91js1"},{"post_id":"cksagj7kw00043lre9kn363in","category_id":"cksagj7ku00023lredvpg7r2d","_id":"cksagj7l9000h3lre8b8f6lx8"},{"post_id":"cksagj7kx00053lre02i6f7pq","category_id":"cksagj7l7000d3lre98av44g2","_id":"cksagj7la000n3lre1ogfbot4"},{"post_id":"cksagj7ky00063lreddjqc1bt","category_id":"cksagj7l7000d3lre98av44g2","_id":"cksagj7lc000p3lre0t5iaz07"},{"post_id":"cksagj7l400093lreh3dy7weh","category_id":"cksagj7l7000d3lre98av44g2","_id":"cksagj7ld000s3lreh5bg82mb"},{"post_id":"cksagj7ls001r3lrehr0p4cex","category_id":"cksagj7lv001t3lre61by7gxv","_id":"cksagj7m000223lrebuf7ds2h"},{"post_id":"cksagj7lt001s3lre6183g4z6","category_id":"cksagj7lv001t3lre61by7gxv","_id":"cksagj7m200263lre0d0dbxtk"},{"post_id":"cksagj7lv001v3lrebxc2cl09","category_id":"cksagj7lv001t3lre61by7gxv","_id":"cksagj7m2002a3lrec509f9cq"},{"post_id":"cksagj7lw001w3lre4mfub16y","category_id":"cksagj7m100253lre15wh1kot","_id":"cksagj7m4002g3lre5o64baks"},{"post_id":"cksagj7lx001x3lreg56deplf","category_id":"cksagj7m100253lre15wh1kot","_id":"cksagj7m6002j3lre0ptp62pg"},{"post_id":"cksagj7lz00203lre8lqf65qd","category_id":"cksagj7m100253lre15wh1kot","_id":"cksagj7m6002n3lre3sg0hx0v"}],"PostTag":[{"post_id":"cksagj7km00003lre8y9f5bri","tag_id":"cksagj7kw00033lreethh5z8y","_id":"cksagj7l9000g3lre477x633j"},{"post_id":"cksagj7km00003lre8y9f5bri","tag_id":"cksagj7kz00083lregnnl66v9","_id":"cksagj7l9000j3lre1borgbrg"},{"post_id":"cksagj7km00003lre8y9f5bri","tag_id":"cksagj7l6000c3lred9z54ods","_id":"cksagj7la000l3lrea25g0rf7"},{"post_id":"cksagj7kt00013lree18reuhl","tag_id":"cksagj7kw00033lreethh5z8y","_id":"cksagj7lc000r3lre49gkg30v"},{"post_id":"cksagj7kt00013lree18reuhl","tag_id":"cksagj7kz00083lregnnl66v9","_id":"cksagj7ld000t3lrebdye68sh"},{"post_id":"cksagj7kt00013lree18reuhl","tag_id":"cksagj7l6000c3lred9z54ods","_id":"cksagj7ld000v3lre3n4i2h9q"},{"post_id":"cksagj7kw00043lre9kn363in","tag_id":"cksagj7kw00033lreethh5z8y","_id":"cksagj7le000y3lre1j1refdv"},{"post_id":"cksagj7kw00043lre9kn363in","tag_id":"cksagj7kz00083lregnnl66v9","_id":"cksagj7le000z3lrebuwgefjs"},{"post_id":"cksagj7kw00043lre9kn363in","tag_id":"cksagj7l6000c3lred9z54ods","_id":"cksagj7lf00113lre7ovcdfth"},{"post_id":"cksagj7kx00053lre02i6f7pq","tag_id":"cksagj7kw00033lreethh5z8y","_id":"cksagj7lg00153lre1r9357aj"},{"post_id":"cksagj7kx00053lre02i6f7pq","tag_id":"cksagj7le000x3lreahsgh0t5","_id":"cksagj7lg00163lred06z2u1v"},{"post_id":"cksagj7kx00053lre02i6f7pq","tag_id":"cksagj7le00103lrehi3w4wbj","_id":"cksagj7lh00183lre73qrghet"},{"post_id":"cksagj7kx00053lre02i6f7pq","tag_id":"cksagj7lf00123lre45v41jyx","_id":"cksagj7lh00193lre2yw2h1d2"},{"post_id":"cksagj7kx00053lre02i6f7pq","tag_id":"cksagj7lf00133lre4nv30wmj","_id":"cksagj7lh001b3lre2lfi4iy1"},{"post_id":"cksagj7ky00063lreddjqc1bt","tag_id":"cksagj7kw00033lreethh5z8y","_id":"cksagj7lj001e3lreat3w3po9"},{"post_id":"cksagj7ky00063lreddjqc1bt","tag_id":"cksagj7le000x3lreahsgh0t5","_id":"cksagj7lj001f3lreaxfb3td6"},{"post_id":"cksagj7ky00063lreddjqc1bt","tag_id":"cksagj7le00103lrehi3w4wbj","_id":"cksagj7lk001h3lregk7ifwhr"},{"post_id":"cksagj7ky00063lreddjqc1bt","tag_id":"cksagj7lf00123lre45v41jyx","_id":"cksagj7lk001i3lrebp6096b1"},{"post_id":"cksagj7ky00063lreddjqc1bt","tag_id":"cksagj7lf00133lre4nv30wmj","_id":"cksagj7ll001k3lre2r3ne6nw"},{"post_id":"cksagj7l400093lreh3dy7weh","tag_id":"cksagj7kw00033lreethh5z8y","_id":"cksagj7ln001m3lre668ag60j"},{"post_id":"cksagj7l400093lreh3dy7weh","tag_id":"cksagj7le000x3lreahsgh0t5","_id":"cksagj7ln001n3lre23mk2axx"},{"post_id":"cksagj7l400093lreh3dy7weh","tag_id":"cksagj7le00103lrehi3w4wbj","_id":"cksagj7ln001o3lre21nmenfd"},{"post_id":"cksagj7l400093lreh3dy7weh","tag_id":"cksagj7lf00123lre45v41jyx","_id":"cksagj7ln001p3lre4bmjhwl8"},{"post_id":"cksagj7l400093lreh3dy7weh","tag_id":"cksagj7lf00133lre4nv30wmj","_id":"cksagj7ln001q3lre8d7f64ij"},{"post_id":"cksagj7ls001r3lrehr0p4cex","tag_id":"cksagj7kw00033lreethh5z8y","_id":"cksagj7m100243lre546l6qtm"},{"post_id":"cksagj7ls001r3lrehr0p4cex","tag_id":"cksagj7lv001u3lregycd00zi","_id":"cksagj7m200273lre0oi60vyn"},{"post_id":"cksagj7ls001r3lrehr0p4cex","tag_id":"cksagj7ly001z3lre4d20a63f","_id":"cksagj7m200293lre7eqzgzwd"},{"post_id":"cksagj7lt001s3lre6183g4z6","tag_id":"cksagj7kw00033lreethh5z8y","_id":"cksagj7m4002d3lre8k6g6pdu"},{"post_id":"cksagj7lt001s3lre6183g4z6","tag_id":"cksagj7lv001u3lregycd00zi","_id":"cksagj7m4002e3lredtrs5dt1"},{"post_id":"cksagj7lt001s3lre6183g4z6","tag_id":"cksagj7ly001z3lre4d20a63f","_id":"cksagj7m5002i3lre30v78c90"},{"post_id":"cksagj7lv001v3lrebxc2cl09","tag_id":"cksagj7kw00033lreethh5z8y","_id":"cksagj7m6002l3lre9395a3pc"},{"post_id":"cksagj7lv001v3lrebxc2cl09","tag_id":"cksagj7lv001u3lregycd00zi","_id":"cksagj7m6002m3lre47uj2wr7"},{"post_id":"cksagj7lv001v3lrebxc2cl09","tag_id":"cksagj7ly001z3lre4d20a63f","_id":"cksagj7m6002p3lre3s4b0zpw"},{"post_id":"cksagj7lw001w3lre4mfub16y","tag_id":"cksagj7m6002k3lredu421j4u","_id":"cksagj7m8002v3lrebxmedwdn"},{"post_id":"cksagj7lw001w3lre4mfub16y","tag_id":"cksagj7m6002o3lre4tch7s0q","_id":"cksagj7m8002w3lre9ggx75or"},{"post_id":"cksagj7lw001w3lre4mfub16y","tag_id":"cksagj7m7002q3lrea5d09i7p","_id":"cksagj7m9002y3lre8rs6deq7"},{"post_id":"cksagj7lw001w3lre4mfub16y","tag_id":"cksagj7m7002r3lre5l4i6jtk","_id":"cksagj7m9002z3lredtzo1kee"},{"post_id":"cksagj7lw001w3lre4mfub16y","tag_id":"cksagj7m7002s3lred1dmfuvf","_id":"cksagj7ma00313lre1fj70h2w"},{"post_id":"cksagj7lw001w3lre4mfub16y","tag_id":"cksagj7m7002t3lre6jkn260o","_id":"cksagj7ma00323lre41dib44z"},{"post_id":"cksagj7lx001x3lreg56deplf","tag_id":"cksagj7m6002k3lredu421j4u","_id":"cksagj7mc00373lrefkvfau9e"},{"post_id":"cksagj7lx001x3lreg56deplf","tag_id":"cksagj7m6002o3lre4tch7s0q","_id":"cksagj7mc00383lrebir9dx0f"},{"post_id":"cksagj7lx001x3lreg56deplf","tag_id":"cksagj7m7002q3lrea5d09i7p","_id":"cksagj7md003a3lre3mat88wl"},{"post_id":"cksagj7lx001x3lreg56deplf","tag_id":"cksagj7m7002r3lre5l4i6jtk","_id":"cksagj7md003b3lrehq515vv0"},{"post_id":"cksagj7lx001x3lreg56deplf","tag_id":"cksagj7m7002s3lred1dmfuvf","_id":"cksagj7me003d3lre60o63xkz"},{"post_id":"cksagj7lx001x3lreg56deplf","tag_id":"cksagj7m7002t3lre6jkn260o","_id":"cksagj7me003e3lre113thnna"},{"post_id":"cksagj7lz00203lre8lqf65qd","tag_id":"cksagj7m6002k3lredu421j4u","_id":"cksagj7mg003i3lrebr1w2vcs"},{"post_id":"cksagj7lz00203lre8lqf65qd","tag_id":"cksagj7m6002o3lre4tch7s0q","_id":"cksagj7mg003j3lre5ec786tr"},{"post_id":"cksagj7lz00203lre8lqf65qd","tag_id":"cksagj7m7002q3lrea5d09i7p","_id":"cksagj7mg003k3lre42tdc0jz"},{"post_id":"cksagj7lz00203lre8lqf65qd","tag_id":"cksagj7m7002r3lre5l4i6jtk","_id":"cksagj7mg003l3lrehk737dub"},{"post_id":"cksagj7lz00203lre8lqf65qd","tag_id":"cksagj7m7002s3lred1dmfuvf","_id":"cksagj7mg003m3lredhbvhl0a"},{"post_id":"cksagj7lz00203lre8lqf65qd","tag_id":"cksagj7m7002t3lre6jkn260o","_id":"cksagj7mg003n3lre39ad4l3b"}],"Tag":[{"name":"Android","_id":"cksagj7kw00033lreethh5z8y"},{"name":"Jetpack","_id":"cksagj7kz00083lregnnl66v9"},{"name":"Compose","_id":"cksagj7l6000c3lred9z54ods"},{"name":"Rendering","_id":"cksagj7le000x3lreahsgh0t5"},{"name":"Principle","_id":"cksagj7le00103lrehi3w4wbj"},{"name":"Optimize","_id":"cksagj7lf00123lre45v41jyx"},{"name":"UI","_id":"cksagj7lf00133lre4nv30wmj"},{"name":"Image","_id":"cksagj7lv001u3lregycd00zi"},{"name":"Library","_id":"cksagj7ly001z3lre4d20a63f"},{"name":"KSP","_id":"cksagj7m6002k3lredu421j4u"},{"name":"Kotlin","_id":"cksagj7m6002o3lre4tch7s0q"},{"name":"Symbol","_id":"cksagj7m7002q3lrea5d09i7p"},{"name":"Processing","_id":"cksagj7m7002r3lre5l4i6jtk"},{"name":"KAPT","_id":"cksagj7m7002s3lred1dmfuvf"},{"name":"Annotation","_id":"cksagj7m7002t3lre6jkn260o"}]}}