{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"themes/icarus/source/img/avatar.png","path":"img/avatar.png","modified":0,"renderable":1},{"_id":"themes/icarus/source/img/favicon.png","path":"img/favicon.png","modified":0,"renderable":1},{"_id":"themes/icarus/source/img/favicon.svg","path":"img/favicon.svg","modified":0,"renderable":1},{"_id":"themes/icarus/source/img/logo.png","path":"img/logo.png","modified":0,"renderable":1},{"_id":"themes/icarus/source/img/logo.svg","path":"img/logo.svg","modified":0,"renderable":1},{"_id":"themes/icarus/source/img/og_image.png","path":"img/og_image.png","modified":0,"renderable":1},{"_id":"themes/icarus/source/img/razor-bottom-black.svg","path":"img/razor-bottom-black.svg","modified":0,"renderable":1},{"_id":"themes/icarus/source/img/razor-top-black.svg","path":"img/razor-top-black.svg","modified":0,"renderable":1},{"_id":"themes/icarus/source/css/cyberpunk.styl","path":"css/cyberpunk.styl","modified":0,"renderable":1},{"_id":"themes/icarus/source/css/default.styl","path":"css/default.styl","modified":0,"renderable":1},{"_id":"themes/icarus/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/icarus/source/js/animation.js","path":"js/animation.js","modified":0,"renderable":1},{"_id":"themes/icarus/source/js/back_to_top.js","path":"js/back_to_top.js","modified":0,"renderable":1},{"_id":"themes/icarus/source/js/main.js","path":"js/main.js","modified":0,"renderable":1},{"_id":"themes/icarus/source/js/column.js","path":"js/column.js","modified":0,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"97ed9e2189ce3a4f0b6d8163d18b95ed512fa29b","modified":1627190505678},{"_id":"source/_posts/.DS_Store","hash":"01eaa8d78adcefe76e73e4551dacae80efbc1a95","modified":1627190497052},{"_id":"source/_posts/2021-04-07 Jetpack Compose Part 1.md","hash":"598b4d83cddf73bb6e0cf420e94242331253a48d","modified":1627190636282},{"_id":"themes/icarus/layout/comment/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1626871710183},{"_id":"themes/icarus/layout/donate/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1626871710187},{"_id":"themes/icarus/layout/misc/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1626871710188},{"_id":"themes/icarus/layout/search/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1626871710189},{"_id":"themes/icarus/layout/share/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1626871710190},{"_id":"themes/icarus/include/schema/comment/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1626871710170},{"_id":"themes/icarus/include/schema/donate/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1626871710173},{"_id":"themes/icarus/include/schema/misc/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1626871710173},{"_id":"themes/icarus/include/schema/search/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1626871710174},{"_id":"themes/icarus/include/schema/share/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1626871710174},{"_id":"themes/icarus/.DS_Store","hash":"c16e31ab96d11a9d5523f6539d4b162123962ddf","modified":1627059163641},{"_id":"themes/icarus/.eslintignore","hash":"5410a1bef9807f666cd92a0d2020f700e67e4096","modified":1626871710164},{"_id":"themes/icarus/.gitignore","hash":"36084c0851a22bfd393933abb8e262562ffc6802","modified":1626873230442},{"_id":"themes/icarus/.eslintrc.json","hash":"43c7740158c8690242720b4ff7fa11426fc20c79","modified":1626871710164},{"_id":"themes/icarus/.npmignore","hash":"42242c8da7a020a3295e7dd3d18bf022cb08b661","modified":1626871710168},{"_id":"themes/icarus/CONTRIBUTING.md","hash":"70254c6778c1e41bb2ff222bbf3a70b2239b9bc1","modified":1626871710168},{"_id":"themes/icarus/LICENSE","hash":"86037e5335a49321fa73b7815cab542057fac944","modified":1626871710169},{"_id":"themes/icarus/package.json","hash":"b87737dd30d2eaa5b240b196c55cc8d52ffba75c","modified":1626871710191},{"_id":"themes/icarus/include/config.js","hash":"1ff0f174e9670074ad2bee890d5b6da486800c9a","modified":1626871710169},{"_id":"themes/icarus/README.md","hash":"247ec8047ee3105d31099dd8e6ca498b6bff1336","modified":1626871710169},{"_id":"themes/icarus/include/dependency.js","hash":"d30dbcefd58619f6705d6369b644bc7ba44d2421","modified":1626871710169},{"_id":"themes/icarus/include/register.js","hash":"a974b56a1fbb254f1ae048cc2221363faaccec25","modified":1626871710170},{"_id":"themes/icarus/languages/de.yml","hash":"01d9c27c3c9224d8c58b1cf7099ef008b9411a45","modified":1626871710178},{"_id":"themes/icarus/languages/en.yml","hash":"1bdb74288808c4d306b46630860e586a1fcd88a7","modified":1626871710178},{"_id":"themes/icarus/languages/es.yml","hash":"48fe3d7d304239b5e5e93f63600093700d6f0fed","modified":1626871710178},{"_id":"themes/icarus/languages/id.yml","hash":"c04fca89e536d539a8bf95980bff7dff79125ba3","modified":1626871710179},{"_id":"themes/icarus/languages/ja.yml","hash":"7568f246a21813527ccea8a1da72a9526aa2d233","modified":1626871710179},{"_id":"themes/icarus/languages/fr.yml","hash":"14765cc6216b4af5a05341315c9f6ee54d636a78","modified":1626871710179},{"_id":"themes/icarus/languages/ko.yml","hash":"f2211a8ca1d73f05a1c931aa11accb4e34c483c4","modified":1626871710179},{"_id":"themes/icarus/languages/pl.yml","hash":"612639b0e0a15185c12eecfe3e8913b629ecdfdf","modified":1626871710180},{"_id":"themes/icarus/languages/tr.yml","hash":"96d94f7a5d56b2682ae2792f0808139d4b950704","modified":1626871710181},{"_id":"themes/icarus/languages/ru.yml","hash":"bf784c6f31e8fb7ed78509468bddecd447c3b73b","modified":1626871710180},{"_id":"themes/icarus/languages/vn.yml","hash":"64307bfa16d851334e2f37a29a84d644624c2060","modified":1626871710181},{"_id":"themes/icarus/languages/pt-BR.yml","hash":"531b22c71fab8aae60ddc7599aaa5f46140cf2c1","modified":1626871710180},{"_id":"themes/icarus/languages/zh-CN.yml","hash":"82ff607b1671b88d259d10b6ce8ca1bb05b2cff4","modified":1626871710181},{"_id":"themes/icarus/languages/tk.yml","hash":"e5b9b369bbcf90c199a65a877eb75fba05cd7f90","modified":1626871710180},{"_id":"themes/icarus/languages/zh-TW.yml","hash":"92f8cf599ad06bb14f79f4806ac4c695f60044d7","modified":1626871710182},{"_id":"themes/icarus/source/.DS_Store","hash":"ae53dfd2a20622619f81b0f3718694cc25286ff8","modified":1627059174203},{"_id":"themes/icarus/layout/archive.jsx","hash":"05677e93d4a43f417dbbf0d63ca37a99e6349e3b","modified":1626871710182},{"_id":"themes/icarus/layout/categories.jsx","hash":"b8ad43e28a4990d222bfbb95b032f88555492347","modified":1626871710183},{"_id":"themes/icarus/layout/category.jsx","hash":"fd15e4eac32de9ac8687aeb3dbe179ab61375700","modified":1626871710183},{"_id":"themes/icarus/layout/layout.jsx","hash":"27dcef37bb2986ba7baf869ef4886ebe9917dabf","modified":1627045299033},{"_id":"themes/icarus/layout/index.jsx","hash":"0a84a2348394fa9fc5080dd396bd28d357594f47","modified":1626871710187},{"_id":"themes/icarus/layout/page.jsx","hash":"d26c2db57e5a88d6483a03aeb51cda9d191d8cea","modified":1626871710188},{"_id":"themes/icarus/layout/tag.jsx","hash":"d2f18cac32ca2725d34ccff3f2051c623be6c892","modified":1626871710190},{"_id":"themes/icarus/layout/post.jsx","hash":"d26c2db57e5a88d6483a03aeb51cda9d191d8cea","modified":1626871710189},{"_id":"themes/icarus/scripts/index.js","hash":"0c666db6fcb4ffc4d300f4e108c00ee42b1cbbe6","modified":1626871710191},{"_id":"themes/icarus/layout/tags.jsx","hash":"2c42cb64778235dd220c563a27a92108ddc50cc4","modified":1626871710190},{"_id":"themes/icarus/include/migration/head.js","hash":"269ba172013cbd2f10b9bc51af0496628081329b","modified":1626871710169},{"_id":"themes/icarus/include/migration/v2_v3.js","hash":"3ccb2d2ce11018bebd7172da66faecc3983bff00","modified":1626871710170},{"_id":"themes/icarus/include/migration/v3_v4.js","hash":"9faf2184d7fe87debfbe007f3fc9079dcbcafcfe","modified":1626871710170},{"_id":"themes/icarus/include/schema/config.json","hash":"ac633f9d349bca4f089d59d2c3738b57376f1b31","modified":1626871710173},{"_id":"themes/icarus/include/style/article.styl","hash":"580b1e9bd356ed6781c32ccc49c6fa3486b94620","modified":1626973290439},{"_id":"themes/icarus/include/style/base.styl","hash":"2bca6ad099949d52236c87db8db1002ffb99774c","modified":1626871710175},{"_id":"themes/icarus/include/style/card.styl","hash":"f78674422eb408cd17c17bbdc3ee1ebe4a453e05","modified":1626871710176},{"_id":"themes/icarus/include/style/donate.styl","hash":"8d0af00628c13134b5f30a558608e7bebf18c2ec","modified":1626871710176},{"_id":"themes/icarus/include/style/button.styl","hash":"0fb35b4786be1b387c751fa2849bc71523fcedd4","modified":1626871710175},{"_id":"themes/icarus/include/style/footer.styl","hash":"a4ad715dee38b249538ac6cce94efc9b355a904b","modified":1626871710176},{"_id":"themes/icarus/include/style/codeblock.styl","hash":"30bee4cf6792e9665eb648cc20b352d9eaff1207","modified":1626871710176},{"_id":"themes/icarus/include/style/helper.styl","hash":"9f3393e6122cc9f351091bfab960674e962da343","modified":1626871710176},{"_id":"themes/icarus/include/style/pagination.styl","hash":"b81bcd7ff915b4e9299533addc01bc4575ec35e3","modified":1626871710177},{"_id":"themes/icarus/include/style/navbar.styl","hash":"ecc73c8ad504c0fa4bb910eb51500c14e0a8d662","modified":1626871710177},{"_id":"themes/icarus/include/style/plugin.styl","hash":"679b61b5fc5b3281735a21c37aeb64229d9c51ea","modified":1626871710177},{"_id":"themes/icarus/include/style/responsive.styl","hash":"207083fe287612cddee6608b541861b14ac8de81","modified":1626972686487},{"_id":"themes/icarus/include/style/search.styl","hash":"416737e1da4e7e907bd03609b0fee9e2aacfe56c","modified":1626871710177},{"_id":"themes/icarus/include/style/timeline.styl","hash":"ea61798a09bffdda07efb93c2ff800b63bddc4c4","modified":1626871710177},{"_id":"themes/icarus/include/style/widget.styl","hash":"c746902251136544eb3fe523235b3183f4189460","modified":1626871710178},{"_id":"themes/icarus/include/util/console.js","hash":"59cf9d277d3ac85a496689bd811b1c316001641d","modified":1626871710178},{"_id":"themes/icarus/source/img/avatar.png","hash":"5f294e72d6b2385e2f7f946ded9f06ca9f3cf6c6","modified":1627059137118},{"_id":"themes/icarus/source/img/favicon.png","hash":"11c336162b4b87962f1e58c06e6d1c1b23eb5d45","modified":1627059457976},{"_id":"themes/icarus/source/img/favicon.svg","hash":"16fd847265845063a16596761cddb32926073dd2","modified":1626871710193},{"_id":"themes/icarus/source/img/logo.svg","hash":"e9b5c1438ddb576693a15d0713b2a1d9ceda4be9","modified":1626871710193},{"_id":"themes/icarus/source/img/logo.png","hash":"be05b47728f1276b913de1191bd7df1929cfbf5d","modified":1626970438413},{"_id":"themes/icarus/source/img/og_image.png","hash":"b03f163096ca9c350ec962feee9836277b5c2509","modified":1626871710194},{"_id":"themes/icarus/source/img/razor-bottom-black.svg","hash":"a3eda07b1c605b456da9cdf335a1075db5e5d72c","modified":1626871710194},{"_id":"themes/icarus/source/img/razor-top-black.svg","hash":"201f1171a43ce667a39091fe47c0f278857f18f0","modified":1626871710194},{"_id":"themes/icarus/source/css/default.styl","hash":"b01da3028e5a1267a40aaae5c86a11187a2259e3","modified":1626871710192},{"_id":"themes/icarus/source/css/style.styl","hash":"5b9815586e993a6ccbe8cdcfc0c65ea38fc315ac","modified":1626871710192},{"_id":"themes/icarus/source/css/cyberpunk.styl","hash":"ae17d3528df0c3f089df14a06b7bd82f1bc5fed9","modified":1626871710192},{"_id":"themes/icarus/source/js/.eslintrc.json","hash":"6bf0641cb69dffac97f69baea192d7fa3ab612cb","modified":1626871710195},{"_id":"themes/icarus/source/js/animation.js","hash":"12cedd5caaf9109eed97e50eeab8f883f6e49be3","modified":1626871710195},{"_id":"themes/icarus/source/js/back_to_top.js","hash":"d91f10c08c726135a13dfa1f422c49d8764ef03f","modified":1626871710195},{"_id":"themes/icarus/source/js/main.js","hash":"13e4b1c4fa287f3db61aae329ad093a81992f23d","modified":1626871710196},{"_id":"themes/icarus/source/js/column.js","hash":"0baee024ab67474c073a4c41b495f3e7f0df4505","modified":1626871710195},{"_id":"themes/icarus/layout/common/article.jsx","hash":"16513ab1745533d0f4cdbdee323339ebab6d02c1","modified":1626871710184},{"_id":"themes/icarus/layout/common/comment.jsx","hash":"427089c33002707b76e2f38709459a6824fd0f9b","modified":1626871710184},{"_id":"themes/icarus/layout/common/footer.jsx","hash":"baa8e40e036a3ec0114d96893b708435104b4ba9","modified":1626871710185},{"_id":"themes/icarus/layout/common/donates.jsx","hash":"889fb0a7ccc502f0a43b4a18eb330e351e50493c","modified":1626871710184},{"_id":"themes/icarus/layout/common/head.jsx","hash":"37f2f2efcb102c706e2460dc9cdeaa302366d318","modified":1626871710185},{"_id":"themes/icarus/layout/common/navbar.jsx","hash":"fcd9fd4624dee49207ef09ea2a1c63f524f3710c","modified":1626871710185},{"_id":"themes/icarus/layout/common/plugins.jsx","hash":"f6826c1a5f5f59f4a0aa00c63bdb0ad4ff4eab69","modified":1626871710186},{"_id":"themes/icarus/layout/common/scripts.jsx","hash":"0fe1fddab431fb9f63906d8c480d5cd6b33abc32","modified":1626871710186},{"_id":"themes/icarus/layout/common/search.jsx","hash":"6f244a37293031670a2964fe424ecd062e591d7b","modified":1626871710186},{"_id":"themes/icarus/layout/common/share.jsx","hash":"c9fb0319ad5e5a10ad3636b26a6c2afed14c590f","modified":1626871710186},{"_id":"themes/icarus/layout/common/widgets.jsx","hash":"689cf4a6b79337b11d1d56afa9dda09223a809a1","modified":1626871710187},{"_id":"themes/icarus/layout/plugin/back_to_top.jsx","hash":"7fc0c5aaabd7d0eaff04cb68ec139442dc3414e8","modified":1626871710189},{"_id":"themes/icarus/layout/plugin/animejs.jsx","hash":"e2aa27c3501a58ef1e91e511557b77395c2c02aa","modified":1626871710188},{"_id":"themes/icarus/layout/widget/profile.jsx","hash":"0d3a7fd922c12cc45d2c8d26a8f4d3a9a6ed0ae0","modified":1626964877654},{"_id":"themes/icarus/include/schema/common/article.json","hash":"8d78149f44629d0848921c6fb9c008b03cef3116","modified":1626871710170},{"_id":"themes/icarus/include/schema/common/comment.json","hash":"7d744391a8abee9a2c450b6fdd36a3866a488025","modified":1626871710170},{"_id":"themes/icarus/include/schema/common/donates.json","hash":"ae86e6f177bedf4afbe638502c12635027539305","modified":1626871710171},{"_id":"themes/icarus/include/schema/common/head.json","hash":"98889f059c635e6bdbd51effd04cf1cf44968a66","modified":1626871710171},{"_id":"themes/icarus/include/schema/common/navbar.json","hash":"6691e587284c4cf450e0288680d5ff0f3565f090","modified":1626871710171},{"_id":"themes/icarus/include/schema/common/footer.json","hash":"09d706cbb94d6da9a0d15c719ce7139325cae1c7","modified":1626871710171},{"_id":"themes/icarus/include/schema/common/providers.json","hash":"97ec953d497fb53594227ae98acaef8a8baa91da","modified":1626871710172},{"_id":"themes/icarus/include/schema/common/plugins.json","hash":"6036a805749816416850d944f7d64aaae62e5e75","modified":1626871710172},{"_id":"themes/icarus/include/schema/common/search.json","hash":"985fbcbf47054af714ead1a124869d54f2a8b607","modified":1626871710172},{"_id":"themes/icarus/include/schema/common/share.json","hash":"cf4f9ff4fb27c3541b35f57db355c228fa6873e4","modified":1626871710172},{"_id":"themes/icarus/include/schema/common/sidebar.json","hash":"eb241beaec4c73e3085dfb3139ce72e827e20549","modified":1626871710172},{"_id":"themes/icarus/include/schema/common/widgets.json","hash":"d000b4d1d09bdd64756265aa4cd2ea980ab7ddc7","modified":1626871710173},{"_id":"themes/icarus/include/schema/plugin/animejs.json","hash":"e62ab6e20bd8862efa1ed32e7c0db0f8acbcfdec","modified":1626871710173},{"_id":"themes/icarus/include/schema/plugin/back_to_top.json","hash":"dc0febab7e7b67075d0ad3f80f5ec8b798b68dea","modified":1626871710174},{"_id":"themes/icarus/include/schema/widget/profile.json","hash":"e801d302e680b4256f89b35d9caff7c9a0b0d178","modified":1626965515768},{"_id":"source/_posts/2021-04-07 Jetpack Compose Part 1/compose_animation.gif","hash":"3045c10cf0a91ce3907c24026a381134b0674f24","modified":1627100104526},{"_id":"public/js/algolia.js","hash":"a8df0c0abeeb4ee1d2d720161f3aea7339380704","modified":1627186669061},{"_id":"public/js/google_cse.js","hash":"1a9881669dfdeb2b3214074eee0d3e01e52db2c4","modified":1627186669061},{"_id":"public/js/insight.js","hash":"86bbdb7305d9bf19ad62d2ca2cf169fc8d9f9d31","modified":1627186669061},{"_id":"public/js/toc.js","hash":"da6fb757a1b083b8ed138bf29aad3a7bf8ec4f11","modified":1627186669061},{"_id":"public/content.json","hash":"d26421bd39282551f472d2e6b3fce39dbe3b7a4a","modified":1627186669061},{"_id":"public/manifest.json","hash":"e304ac116ed2377427b5d86fa1b011b9eaea0f10","modified":1627186669061},{"_id":"public/archives/index.html","hash":"8e10dfae7d8366a3eddcccf2f1afe0309eea9d37","modified":1627186669061},{"_id":"public/archives/2021/index.html","hash":"97d6ed4b2c1d77d997a8333cda38ef9c3cf3223a","modified":1627186669061},{"_id":"public/archives/2021/04/index.html","hash":"49910308343a0c0a94ee5f032f2ab81c3b567f57","modified":1627186669061},{"_id":"public/categories/Jetpack-Compose/index.html","hash":"cec07b1660065b4d3dd877f4db2f966ca4143b21","modified":1627186669061},{"_id":"public/index.html","hash":"d84aae7a1ed2f337b4f50ea6f747cab97351c303","modified":1627186669061},{"_id":"public/tags/Android/index.html","hash":"a329fae3e6e616659e593ee086442f02bc2131a8","modified":1627186669061},{"_id":"public/tags/Jetpack/index.html","hash":"767a1e289718dc3cb0fa61bbc0136893a1e52e10","modified":1627186669061},{"_id":"public/tags/Compose/index.html","hash":"5c160a09037c037c17471e970cf6e79316b32c63","modified":1627186669061},{"_id":"public/tags/index.html","hash":"dbfcc94eee9def930c2f8b56e76a9dd533dc8db7","modified":1627186669061},{"_id":"public/categories/index.html","hash":"dd9a50ec0948b815e421ead8fa7fdd6e2cb8b953","modified":1627186669061},{"_id":"public/2021/04/07/2021-04-07 Jetpack Compose Part 1/index.html","hash":"e5af894f2baa09413209da351c7847df0953dc9b","modified":1627186669061},{"_id":"public/img/favicon.svg","hash":"16fd847265845063a16596761cddb32926073dd2","modified":1627186669061},{"_id":"public/img/avatar.png","hash":"5f294e72d6b2385e2f7f946ded9f06ca9f3cf6c6","modified":1627186669061},{"_id":"public/img/logo.png","hash":"be05b47728f1276b913de1191bd7df1929cfbf5d","modified":1627186669061},{"_id":"public/img/favicon.png","hash":"11c336162b4b87962f1e58c06e6d1c1b23eb5d45","modified":1627186669061},{"_id":"public/img/og_image.png","hash":"b03f163096ca9c350ec962feee9836277b5c2509","modified":1627186669061},{"_id":"public/img/razor-bottom-black.svg","hash":"a3eda07b1c605b456da9cdf335a1075db5e5d72c","modified":1627186669061},{"_id":"public/img/logo.svg","hash":"e9b5c1438ddb576693a15d0713b2a1d9ceda4be9","modified":1627186669061},{"_id":"public/img/razor-top-black.svg","hash":"201f1171a43ce667a39091fe47c0f278857f18f0","modified":1627186669061},{"_id":"public/js/animation.js","hash":"12cedd5caaf9109eed97e50eeab8f883f6e49be3","modified":1627186669061},{"_id":"public/js/back_to_top.js","hash":"d91f10c08c726135a13dfa1f422c49d8764ef03f","modified":1627186669061},{"_id":"public/js/main.js","hash":"13e4b1c4fa287f3db61aae329ad093a81992f23d","modified":1627186669061},{"_id":"public/js/column.js","hash":"0baee024ab67474c073a4c41b495f3e7f0df4505","modified":1627186669061},{"_id":"public/css/default.css","hash":"d1be246b56d96525ef38324dd769a4d70b932124","modified":1627186669061},{"_id":"public/css/cyberpunk.css","hash":"33cb6e6c54af1717a2447f527d0ccf1a06502cb1","modified":1627186669061},{"_id":"public/css/style.css","hash":"d1be246b56d96525ef38324dd769a4d70b932124","modified":1627186669061},{"_id":"public/2021/04/07/2021-04-07 Jetpack Compose Part 1/compose_animation.gif","hash":"3045c10cf0a91ce3907c24026a381134b0674f24","modified":1627186669061},{"_id":"source/_posts/001 Jetpack Compose/2021-04-07 Jetpack Compose Part 1/compose_animation.gif","hash":"3045c10cf0a91ce3907c24026a381134b0674f24","modified":1627100104526},{"_id":"source/_posts/001 Jetpack Compose/images/compose_animation.gif","hash":"3045c10cf0a91ce3907c24026a381134b0674f24","modified":1627100104526},{"_id":"source/images/compose_animation.gif","hash":"3045c10cf0a91ce3907c24026a381134b0674f24","modified":1627100104526}],"Category":[{"name":"Jetpack Compose","_id":"ckrioxi5h0001r2re44eo0yfu"}],"Data":[],"Page":[],"Post":[{"title":"Jetpack Compose Part 1 - Compose 소개 및 코드랩 따라하기","date":"2021-04-06T16:00:00.000Z","_content":"\n<!-- more -->\n\n**Author in [AndroidDeepDive Study](https://github.com/AndroidDeepDive/Study)**\n- 김남훈 @Naver\n- 배희성 @RocketPunch\n- 송시영 @SmartStudy\n- 이기정 @BankSalad\n\n## Jetpack Compose란 무엇인가?\n\n{% asset_img compose_animation.gif [compose_animation] %}\n\n> **출처** [Android Developers#Jetpack Compse](https://developer.android.com/jetpack/compose)\n\nCompose는 Native UI를 코드레벨로 구현할 수 있는 최신 툴킷이다. \n\n기존의 뷰를 업데이트하는 방식과 달리 Compose를 사용하면 필요한 영역의 뷰를 다시 그려주는 방식으로 작업할 수 있다.\n\n아래는 아주 간단한 예제이다.\n\n```kotlin\n@Composable\nfun Greeting(name: String) {\n\tText(\"Hello $name\")\n}\n```\n\n위의 예제처럼 UI를 구성하는 것이 아니라 화면을 구성하는 뷰의 State 설명하는 것이므로 아무것도 반환하지 않는다.\n\n아래는 공식 서비스 소개 영상이다.\n\n<div style=\"width: 560px; height: 315px; float: none; clear: both;\">\n  <embed\n    src=\"https://www.youtube.com/embed/U5BwfqBpiWU\"\n    wmode=\"transparent\"\n    type=\"video/mp4\"\n    width=\"100%\" height=\"100%\"\n    allow=\"autoplay; encrypted-media; picture-in-picture\"\n    allowfullscreen\n  >\n</div>\n\n### Compose의 4가지 특징\n\n구글에서 설명하는 Compose를 이용시 얻을 수 있는 장점은 아래와 같다.\n\n- `Less Code` - 코드 감소\n  - 적은 수의 코드로 더 많은 작업을 하고 전체 버그 클래스를 방지할 수 있으므로 코드가 간단하며 유지 관리하기 쉽습니다.\n- `Intuitive` - 직관적\n  - UI만 설명하면 나머지는 Compose에서 처리합니다. 앱 상태가 변경되면 UI가 자동으로 업데이트됩니다.\n- `Accelerate Development` - 빠른 개발 과정\n  - 기존의 모든 코드와 호환되므로 언제 어디서든 원하는 대로 사용할 수 있습니다. 실시간 미리보기 및 완전한 Android 스튜디오 지원으로 빠르게 반복할 수 있습니다.\n- `Powerful` - 강력한 성능\n  - Android 플랫폼 API에 직접 액세스하고 머티리얼 디자인, 어두운 테마, 애니메이션 등을 기본적으로 지원하는 멋진 앱을 만들 수 있습니다.\n\n늘 그렇듯 구글에서 말하는 설명만 보면 안 쓸 이유가 없어보이고, 대세가 된다면 Android 개발자에게 또 하나의 러닝커브로 작용할 것이다.\n\n## Codelab - Jetpack Compose basics\n\n### 1. 시작하기전에\n\nCompose는 아직 정식으로 릴리즈되지 않은 기능이므로 Android Studio Canary에서 프로젝트를 구성하며 몇 가지 제한사항이 존재한다.\n\n1. Android Studio Canary \n\nCanary는 아래 링크에서 다운 받을 수 있다.\n\n> [Android Studio Preview](https://developer.android.com/studio/preview)\n\n2. 최신 버전의 Kotlin plugin \n\n```groovy\next.kotlin_version = '1.4.31'\n```\n\n3. buildFeatures 및 composeOption 활성화\n\n```groovy\nandroid {\n    ...\n    buildFeatures {\n        compose true\n    }\n    composeOptions {\n        kotlinCompilerExtensionVersion 1.0.0-beta02\n    }\n}\n\ndependencies {\n    ...\n    implementation \"androidx.compose.ui:ui:1.0.0-beta02\"\n    implementation \"androidx.activity:activity-compose:1.3.0-alpha03\"\n    implementation \"androidx.compose.material:material:1.0.0-beta02\"\n    implementation \"androidx.compose.ui:ui-tooling:1.0.0-beta02\"\n    ...\n}\n```\n\n### 2. Empty Compose 프로젝트 생성\n\n[File] - [New] - [New Project…] 를 눌러 새로운 프로젝트를 선택하고(Preview) Empty Compose Activity 를 선택한다.\n\n![](https://cdn-images-1.medium.com/max/3592/1*5gfrQWfxyEC7Oq6b2xlJ9w.png)\n\n선택 이후 Next를 클릭하고, Compose를 구현할 수 있는 최소 API 레벨인 21을 선택해야한다.\n\n프로젝트를 생성하면 아래와 같이 app/build.gradle에 의존성 설정 및 추가가 되어 있는것을 알 수 있다.\n\n```groovy\nandroid {\n    ...\n    kotlinOptions {\n        jvmTarget = '1.8'\n        useIR = true\n    }\n    buildFeatures {\n        compose true\n    }\n    composeOptions {\n        kotlinCompilerExtensionVersion compose_version\n    }\n}\n\ndependencies {\n    ...\n    implementation \"androidx.compose.ui:ui:$compose_version\"\n    implementation \"androidx.activity:activity-compose:1.3.0-alpha03\"\n    implementation \"androidx.compose.material:material:$compose_version\"\n    implementation \"androidx.compose.ui:ui-tooling:$compose_version\"\n    ...\n}\n```\n\n이때 composeOptions 설정에서 kotlinCompilerVersion 에 따라 compose 가 다르게 동작할 수 있음을 유의하자.\n\n프로젝트를 생성하면 아래와 같은 기본 파일들이 생성된다.\n\n**MainActivity.kt**\n```kotlin\nclass MainActivity : AppCompatActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContent {\n            MyFirstComposeApplicationTheme {\n                // A surface container using the 'background' color from the theme\n                Surface(color = MaterialTheme.colors.background) {\n                    Greeting(\"Android\")\n                }\n            }\n        }\n    }\n}\n\n@Composable\nfun Greeting(name: String) {\n    Text(text = \"Hello $name!\")\n}\n\n@Preview(showBackground = true)\n@Composable\nfun DefaultPreview() {\n    MyFirstComposeApplicationTheme {\n        Greeting(\"Android\")\n    }\n}\n```\n\n**ui/theme/Theme.kt**\n```kotlin\nprivate val DarkColorPalette = darkColors(\n    primary = Purple200,\n    primaryVariant = Purple700,\n    secondary = Teal200\n)\n\nprivate val LightColorPalette = lightColors(\n    primary = Purple500,\n    primaryVariant = Purple700,\n    secondary = Teal200*\n\n    /* Other default colors to override\n    background = Color.White,\n    surface = Color.White,\n    onPrimary = Color.White,\n    onSecondary = Color.Black,\n    onBackground = Color.Black,\n    onSurface = Color.Black,\n    */\n)\n\n@Composable\nfun MyFirstComposeApplicationTheme(darkTheme: Boolean = isSystemInDarkTheme(), content: @Composable () -> Unit) {\n    val colors = if (darkTheme) {\n        DarkColorPalette*\n    } else {\n        LightColorPalette*\n    }\n\n    MaterialTheme(\n        colors = colors,\n        typography = Typography,\n        shapes = Shapes,\n        content = content\n    )\n}\n```\n\n기본 생성된 코드를 보았을 때, Compose는 총 3가지의 구성 요소를 가지는 것으로 추측할 수 있다.\n\n1. 위젯을 포함하는 Composable 함수\n2. Preview를 하기 위한 Preview Composable 함수\n3. setContent 람다 표현식으로 실제 화면에 노출하는 코드\n\n일반적으로 우리가 아는 Activity의 라이프사이클 콜백 `onCreate()`에서   `setContentView(Int)` 함수를 호출하던것이 `setContent()` 함수로 바뀐것이 가장 큰 특징으로 보여진다.\n\n### 3. Composable Function\n\nComposable Function은 어노테이션을 이용한 기술이다. 함수위에 `@Composable` 어노테이션을 붙이게 되면 함수 안 다른 함수를 호출할 수 있게된다. 아래 코드를 보자.\n\n```kotlin\n@Composable\nfun Greeting(names: List<String>) {\n    for (name in names) {\n        Text(\"Hello $name\")\n    }\n}\n```\n\n단순하게 내부에는 Text라는 함수가 존재하는데, 이를 통해 UI계층 별 요구하는 컴포넌트를 생성해준다. 기본적으로 보이는 text 파라미터는 내부 속성에서 받는 일부 중 하나이다.\n\n### 4. TextView 만들기\n\n위 코드를 실행시켜보면 당연하게도 Hello로 시작하는 TextView가 화면에 그려질것을 암시한다.\n\n```kotlin\nsetContent {\n  BasicsCodelabTheme {\n    // A surface container using the 'background' color from the theme\n    Surface(color = MaterialTheme.colors.background) {\n      Greeting(\"Android\")\n    }\n  }\n}\n```\n\n![output](https://imgur.com/aO6Jlsg.jpg)\n\n### 5. `@Preview`\n\n말 그대로 어노테이션을 이용하여 IDE에서 Preview를하기 위한 용도이다. 아래 코드와 같이 @Preview 어노테이션을 추가하면 다음 결과를 볼 수 있다.\n\n```kotlin\n@Preview(\"Greeting Preview\")\n@Composable\nfun GreetingPreview() {\n    BasicsCodelabTheme {\n        Surface(color = MaterialTheme.colors.background) {\n            Greeting(\"Android\")\n        }\n    }\n}\n```\n\n![Greeting Preview](https://imgur.com/WprDTs1.jpg)\n\n### 6. setContent / Theme / Surface\n\n```kotlin\nsetContent {\n  BasicsCodelabTheme {\n    // A surface container using the 'background' color from the theme\n    Surface(color = MaterialTheme.colors.background) {\n      Greeting(\"Android\")\n    }\n  }\n}\n```\n\n기존에 onCreate시점에 화면을 그려주기 위한 필수적인 요소를 정리해보자면\n\n- **setContent** : Activity에서 setContentView함수를 사용하는 것과 동일한 동작을 하는 확장함수이다. 다만, setContent의 경우 (@Composable) -> Unit 타입의 컴포즈 UI를 구현해주어야한다.\n\n- **XXXTheme** : Theme정보를 의미한다. 해당 프로젝트에서는 Theme.kt에 여러 테마에 필요한 정보를 정리하고, 컴포즈 UI 구현을 위한 코드를 작성해두었다.\n\n```kotlin\nprivate val DarkColorPalette = darkColors(\n    primary = purple200,\n    primaryVariant = purple700,\n    secondary = teal200\n)\n\nprivate val LightColorPalette = lightColors(\n    primary = purple500,\n    primaryVariant = purple700,\n    secondary = teal200\n\n    /* Other default colors to override\n    background = Color.White,\n    surface = Color.White,\n    onPrimary = Color.White,\n    onSecondary = Color.Black,\n    onBackground = Color.Black,\n    onSurface = Color.Black,\n    */\n)\n\n@Composable\nfun BasicsCodelabTheme(\n    darkTheme: Boolean = isSystemInDarkTheme(),\n    content: @Composable () -> Unit\n) {\n    val colors = if (darkTheme) {\n        DarkColorPalette\n    } else {\n        LightColorPalette\n    }\n\n    MaterialTheme(\n        colors = colors,\n        typography = typography,\n        shapes = shapes,\n        content = content\n    )\n}\n```\n\n- **Surface** : Greeting을 감싸는 뷰에 해당한다. 여기서는 크기를 정하지 않고, background 색상을 정의하고 있다. 역시 람다 표현식이다. 색상에 대한 Paramter로 `color` 라는 값을 사용하여 부여가 가능하다. 내부코드를 보면\n\n```kotlin\n@Composable\nfun Surface(\n    modifier: Modifier = Modifier,\n    shape: Shape = RectangleShape,\n    color: Color = MaterialTheme.colors.surface,\n    contentColor: Color = contentColorFor(color),\n    border: BorderStroke? = null,\n    elevation: Dp = 0.dp,\n    content: @Composable () -> Unit\n) {\n    val elevationPx = with(LocalDensity.current) { elevation.toPx() }\n    val elevationOverlay = LocalElevationOverlay.current\n    val absoluteElevation = LocalAbsoluteElevation.current + elevation\n    val backgroundColor = if (color == MaterialTheme.colors.surface && elevationOverlay != null) {\n        elevationOverlay.apply(color, absoluteElevation)\n    } else {\n        color\n    }\n    CompositionLocalProvider(\n        LocalContentColor provides contentColor,\n        LocalAbsoluteElevation provides absoluteElevation\n    ) {\n        Box(\n            modifier.graphicsLayer(shadowElevation = elevationPx, shape = shape)\n                .then(if (border != null) Modifier.border(border, shape) else Modifier)\n                .background(\n                    color = backgroundColor,\n                    shape = shape\n                )\n                .clip(shape),\n            propagateMinConstraints = true\n        ) {\n            content()\n        }\n    }\n}\n```\n\n### 7. Declarative UI - 선언형 UI\n\n노란색 배경을 입혀 기존 TextView에 추가해보았다. 또한, Greeting에는 Modifier라는 것을 이용하여 Padding을 추가했다. 아래와 같은 결과가 나오게 되었다.\n\n```kotlin\nBasicsCodelabTheme {\n  // A surface container using the 'background' color from the theme\n  Surface(color = Color.Yellow) {\n    Greeting(\"Android\")\n  }\n}\n```\n\n```kotlin\n@Composable\nfun Greeting(name: String) {\n    var isSelected by remember { mutableStateOf(false) }\n    val backgroundColor by animateColorAsState(if (isSelected) Color.Red else Color.Transparent)\n\n    Text(\n        text = \"Hello $name!\",\n        modifier = Modifier\n            .padding(24.dp)\n            .background(color = backgroundColor)\n            .clickable(onClick = { isSelected = !isSelected })\n    )\n}\n```\n\n![결과](https://imgur.com/qgQ6oY4.jpg)\n\n선언형 UI의 장점은 말 그대로 내가 UI를 정의한대로 시각적으로 표현이 가능하다는 장점이 있다. 기존에는 속성을 매번 On/Off와 같은 옵션을 통해 변경하는 것이 다반사였지만, 이제는 매번 속성에 변경이 생길때마다 새로 그려주게 되는것이다.\n\n\n### 8. 재사용\n\nCompose의 장점 중 하나는 재사용성이 뛰어난것인데, XML에서 우리가 include 태그를 통해 여러곳에서 갖다쓸 수 있던것처럼, 함수를 통해 여러곳에서 정의하여 사용이 가능하다.\n\n참고해야할 점은 Compose 컴포넌트 확장 시 `@Composable` 어노테이션을 붙여야 한다.\n\n### 9. Container 작성\n\nMyApp이라는 이름으로 컴포즈 컴포넌트를 구횬하여 여러곳에서 공통으로 사용할 수 있는 Composable을 구현하였다. 내부적으로 Container내 내가 원하는 컴포넌트를 넣어주려면 아래와 같이 인자로 `@Composable () -> Unit` 타입을 넘겨받아 처리해주면 된다.\n\n```kotlin\n@Composable\nfun MyApp(content: @Composable () -> Unit) {\n    BasicsCodelabTheme {\n        Surface(color = Color.Yellow) {\n            content()\n        }\n    }\n}\n```\n\n위 함수를 통해 이제는 어디서든 반복해서 사용할 수 있는 Container를 구현하게 되어 아래와 같이 코드를 활용할 수 있게되었다.\n\n```kotlin\nclass MainActivity : AppCompatActivity() {\n  override fun onCreate(savedInstanceState: Bundle?) {\n    super.onCreate(savedInstanceState)\n    setContent {\n      MyApp {\n        Greeting(\"Android\")\n      }\n    }\n    ...\n  }\n```\n\n### 10. 레이아웃을 활용한 Compose function의 다중 호출\n\n지금까지는 하나의 컴포넌트만을 갖고 사용했지만, 여러개의 컴포넌트를 넣는것도 가능하다.\n\n```kotlin\n@Composable\nfun MyScreenContent() {\n    Column {\n        Greeting(\"Android\")\n        Divider(color = Color.Black)\n        Greeting(\"there\")\n    }\n}\n```\n\n `Column`과 위에서부터 사용하던 `Greeting` 함수를 사용하고, 라인을 그어주기 위한 `Divider`를 추가한 결과물은 다음과 같다.\n\n![multiple component](https://imgur.com/VLTxB8C.jpg)\n\n위 컴포넌트 중 못보던 컴포저블이 있는데, 아래와 같이 설명이 가능하다.\n\n- Column : 항목을 순서대로 배치하기 위해 사용한다.\n- Divider : 선 긋기 가능한 Compose 함수이다.\n\n이를 리스트 형태로도 구현이 가능하다.\n\n```kotlin\n@Composable\nfun MyColumnScreen(names: List<String> = listOf(\"Line One\", \"Line Two\")) {\n    Column {\n        names.forEach {\n            Greeting(name = it)\n            Divider(color = Color.Black)\n        }\n    }\n}\n```\n\n### 11. State in Compose - Compose에서의 상태값 관리\n\n\n컴포넌트에 버튼을 클릭했을 때 클릭한 카운트를 집계하는 간단한 컴포넌트를 만들어보았다.\n\n```kotlin\n@Composable\nfun MyColumnScreen(names: List<String> = listOf(\"Line One\", \"Line Two\")) {\n    val counterState = remember { mutableStateOf(0) } // \n\n    Column {\n        names.forEach {\n            Greeting(name = it)\n            Divider(color = Color.Black)\n        }\n        Counter(\n            count = counterState.value,\n            updateCount = { newCount ->\n                counterState.value = newCount\n            }\n        )\n    }\n}\n```\n\nremember라는 함수를 사용하여 기존에 존재하는 컴포넌트의 상태값을 기억하게 하는 함수가 있다. \n\n`remember` 함수의 내부를 살펴보자.\n\n```kotlin\n/**\n * Remember the value produced by [calculation]. [calculation] will only be evaluated during the composition.\n * Recomposition will always return the value produced by composition.\n */\n@OptIn(ComposeCompilerApi::class)\n@Composable\ninline fun <T> remember(calculation: @DisallowComposableCalls () -> T): T =\n    currentComposer.cache(false, calculation)\n```\n\n매 호출마다 Recomposition(재조합)하게되는 경우 컴포넌트에 값을 다시 제공하는 것을 알 수 있다. @Composable 어노테이션에 들어간 함수는 매번 해당 상태를 구독하고, 상태가 변경될때마다 알림을 받아 기존 화면을 갱신해준다.\n\n그리고, 아래 Counter를 보면 Button을 이용하여 이벤트를 받아 처리하도록 했다.\n\n```kotlin\n@Composable\nfun Counter(count: Int, updateCount: (Int) -> Unit) {\n    Button(\n        onClick = { updateCount(count + 1) },\n        colors = ButtonDefaults.buttonColors(\n            backgroundColor = if (count > 5) Color.Green else Color.White\n        )\n    ) {\n        Text(\"I've been clicked $count times\")\n    }\n}\n```\n\n`updateCount(Int)` 함수릉 통해 매번 값을 업데이트 해주는데, 이를 통해 counterState에 값을 넣어주면서 해당 컴포넌트가 매번 변경이 되는것이다.\n\n따라서 결과를 보면, 다음과 같다. Count가 5가 넘어가면 초록색으로 바뀐다.\n\n![count](https://imgur.com/Ju6BSg2.gif)\n\n그 외에도 여러형태의 모양을 구성할수 있도록 옵션이 제공되어 있다. 자세한 정보는 나중에 [Codelabs](https://developer.android.com/codelabs/jetpack-compose-basics)에 더 나와 있으니 보도록하고, 이번에 setContent에 대한 동작원리를 함께 고민해보자.\n\n### 12. Activity에서의 View 생성 방식과의 비교\n\nCompose를 안드로이드 앱에서 사용하려면 Activity, Fragment와 같은곳에서 contentView로 뿌려줘야한다. 기존에 우리가 사용하던 함수를 보자.\n\n```java\n/**\n* Set the activity content from a layout resource.  The resource will be\n* inflated, adding all top-level views to the activity.\n*\n* @param layoutResID Resource ID to be inflated.\n*\n* @see #setContentView(android.view.View)\n* @see #setContentView(android.view.View, android.view.ViewGroup.LayoutParams)\n*/\npublic void setContentView(@LayoutRes int layoutResID) {\n  getWindow().setContentView(layoutResID);\n  initWindowDecorActionBar();\n}\n```\n\nUI 컴포넌트에서 화면을 붙일 수 있는 Window라는 녀석에서 Layout Resource Id를 통해 기존에 등록되어있던 Layout XML 파일을 로드하여 인플레이터에서 파싱하고, 이를통해 레이아웃 계층에 있는 뷰객체를 생성하여 순차적으로 ViewGroup, View를 만들어 넣어주게 된다.\n\n`PhoneWindow`를 보면 자세하게 알 수 있는데, Window를 구현한 setContentView에서 처음에 생성되는 최상위 레이아웃 그 위에 따로 없다면 `installDecor()` 함수를 통해 mContentParent(레이아웃 리소스가 붙게될 ViewGroup)를 생성하고, 하위에 넣어주게 된다.\n\n그러면 기존 방식은 이정도로 설명을하고, 이번엔 Compose에서 `setContent()` 라는 함수를 어떻게 사용하는지 보자.\n\n```kotlin\n/**\n * Composes the given composable into the given activity. The [content] will become the root view\n * of the given activity.\n *\n * This is roughly equivalent to calling [ComponentActivity.setContentView] with a [ComposeView]\n * i.e.:\n *\n * ```\n * setContentView(\n *   ComposeView(this).apply {\n *     setContent {\n *       MyComposableContent()\n *     }\n *   }\n * )\n * ```\n *\n * @param parent The parent composition reference to coordinate scheduling of composition updates\n * @param content A `@Composable` function declaring the UI contents\n */\npublic fun ComponentActivity.setContent(\n    parent: CompositionContext? = null,\n    content: @Composable () -> Unit\n) {\n    val existingComposeView = window.decorView\n        .findViewById<ViewGroup>(android.R.id.content)\n        .getChildAt(0) as? ComposeView\n\n    if (existingComposeView != null) with(existingComposeView) {\n        setParentCompositionContext(parent)\n        setContent(content)\n    } else ComposeView(this).apply {\n        // Set content and parent **before** setContentView\n        // to have ComposeView create the composition on attach\n        setParentCompositionContext(parent)\n        setContent(content)\n        // Set the view tree owners before setting the content view so that the inflation process\n        // and attach listeners will see them already present\n        setOwners()\n        setContentView(this, DefaultActivityContentLayoutParams)\n    }\n}\n```\n\n이녀석도 마찬가지로 `window.decorView.findViewById<ViewGroup>(android.R.id.content)`  함수를 호출하여 decorView를 가져온다. 만약 compose를 통해 만들어진 최상위 레이아웃이 존재하면, 기존에 inflator에서 ViewGroup, View를 생성해서 넣어주던것 처럼 `setContent()` => window가 Activity/Fragment에 붙으면 `createComposition()`를 호출하여 검증 후 `ensureCompsositionCreated()` 함수를 호출한다. 현재는 내부적으로 `ViewGroup.setContent()` 를 사용하고 있는데, 곧 교체 될 예정이라고 한다. 이코드도 보면 기존에 있는 ViewGroup에 확장함수로 구현한 녀석인데, 쉽게 말해 ViewGroup에 하위 View, ViewGroup에 Composable로 구현된 함수로 컴포넌트를 넣어줄 때 AndroidComposeView라는 객체를 꺼내오거나 없다면 새로 생성하여 넣어준다.\n\n```kotlin\n/**\n * Composes the given composable into the given view.\n *\n * The new composition can be logically \"linked\" to an existing one, by providing a\n * [parent]. This will ensure that invalidations and CompositionLocals will flow through\n * the two compositions as if they were not separate.\n *\n * Note that this [ViewGroup] should have an unique id for the saved instance state mechanism to\n * be able to save and restore the values used within the composition. See [View.setId].\n *\n * @param parent The [Recomposer] or parent composition reference.\n * @param content Composable that will be the content of the view.\n */\ninternal fun ViewGroup.setContent(\n    parent: CompositionContext,\n    content: @Composable () -> Unit\n): Composition {\n    GlobalSnapshotManager.ensureStarted()\n    val composeView =\n        if (childCount > 0) {\n            getChildAt(0) as? AndroidComposeView\n        } else {\n            removeAllViews(); null\n        } ?: AndroidComposeView(context).also { addView(it.view, DefaultLayoutParams) }\n    return doSetContent(composeView, parent, content)\n}\n```\n\n\n\n다시 돌아와서, ComposeView의 `setContent()` 이라는 녀석을 보자.\n\n```kotlin\n/**\n * A [android.view.View] that can host Jetpack Compose UI content.\n * Use [setContent] to supply the content composable function for the view.\n *\n * This [android.view.View] requires that the window it is attached to contains a\n * [ViewTreeLifecycleOwner]. This [androidx.lifecycle.LifecycleOwner] is used to\n * [dispose][androidx.compose.runtime.Composition.dispose] of the underlying composition\n * when the host [Lifecycle] is destroyed, permitting the view to be attached and\n * detached repeatedly while preserving the composition. Call [disposeComposition]\n * to dispose of the underlying composition earlier, or if the view is never initially\n * attached to a window. (The requirement to dispose of the composition explicitly\n * in the event that the view is never (re)attached is temporary.)\n */\nclass ComposeView @JvmOverloads constructor(\n    context: Context,\n    attrs: AttributeSet? = null,\n    defStyleAttr: Int = 0\n) : AbstractComposeView(context, attrs, defStyleAttr) {\n\n    private val content = mutableStateOf<(@Composable () -> Unit)?>(null)\n\n    @Suppress(\"RedundantVisibilityModifier\")\n    protected override var shouldCreateCompositionOnAttachedToWindow: Boolean = false\n        private set\n\n    @Composable\n    override fun Content() {\n        content.value?.invoke()\n    }\n\n    /**\n     * Set the Jetpack Compose UI content for this view.\n     * Initial composition will occur when the view becomes attached to a window or when\n     * [createComposition] is called, whichever comes first.\n     */\n    fun setContent(content: @Composable () -> Unit) {\n        shouldCreateCompositionOnAttachedToWindow = true\n        this.content.value = content\n        if (isAttachedToWindow) {\n            createComposition()\n        }\n    }\n}\n```\n\n결론적으로 `AbstractComposeView` 라는 녀석은 ViewGroup을 상속받은 녀석이며, 모든 composable의 상태가 변화 되었을 때 이를 감지하는 중요한 녀석이다.\n\n`setContent()`라는 함수는 위에서 설명했으니 넘어가고, 이번에는 `Content`라는 녀석을 보자. 이녀석은 추상 메소드로, `createComposition()` 이라는 함수가 호출 되었을 때, 가장 먼저 불리는 함수이다. 아까 언급되었던 `ensureCompsositionCreated()` 함수에서 tree계층의 ComposeView가 다 붙었다면, 이후에 즉시 Content함수가 호출이된다.\n\n```kotlin\n@Suppress(\"DEPRECATION\") // Still using ViewGroup.setContent for now\n    private fun ensureCompositionCreated() {\n        if (composition == null) {\n            try {\n                creatingComposition = true\n                composition = setContent(\n                    parentContext ?: findViewTreeCompositionContext() ?: windowRecomposer\n                ) {\n                    Content() // 이곳에서 뷰가 다 window에 붙게되면 콜백을 호출한다.\n                }\n            } finally {\n                creatingComposition = false\n            }\n        }\n    }\n```\n\n그러면 아래 `ComposeView`의 오버라이딩 된 Content가 호출되면서, 기존에 생성된 View에 UI속성과 같은 Content가 붙게된다.\n\n```kotlin\n/**\n* The Jetpack Compose UI content for this view.\n* Subclasses must implement this method to provide content. Initial composition will\n* occur when the view becomes attached to a window or when [createComposition] is called,\n* whichever comes first.\n*/\n@Composable\nabstract fun Content()\n```\n\nContent는 설명에서 보는것과 같이 `createComposition()` 함수 호출 후 View가 Window에 붙은 이후 즉시 호출된다.\n\n최종적으로 `ComponentActivity.setContent(CompositionContext?, @Composable () -> Unit)` 함수에서 구현된 ComposeView 인스턴스를 ContentLayout을 widht/height를 wrapContent크기로 정하여 ContentView를 Set해주게 된다.\n\n```kotlin\n/**\n * Composes the given composable into the given activity. The [content] will become the root view\n * of the given activity.\n *\n * This is roughly equivalent to calling [ComponentActivity.setContentView] with a [ComposeView]\n * i.e.:\n *\n * ```\n * setContentView(\n *   ComposeView(this).apply {\n *     setContent {\n *       MyComposableContent()\n *     }\n *   }\n * )\n * ```\n *\n * @param parent The parent composition reference to coordinate scheduling of composition updates\n * @param content A `@Composable` function declaring the UI contents\n */\npublic fun ComponentActivity.setContent(\n    parent: CompositionContext? = null,\n    content: @Composable () -> Unit\n) {\n  \t...\n\t\telse ComposeView(this).apply {\n        // Set content and parent **before** setContentView\n        // to have ComposeView create the composition on attach\n        setParentCompositionContext(parent)\n        setContent(content)\n        // Set the view tree owners before setting the content view so that the inflation process\n        // and attach listeners will see them already present\n        setOwners()\n        setContentView(this, DefaultActivityContentLayoutParams)\n    }\n}\n```\n\n### 13. ComposeView\n\nandroid.view.View 는 Jetpack Compose UI 콘텐츠를 사용할 수 있도록 해줍니다. setContent 를 사용하면 composable function content 를 뷰에 제공할 수 있다.\n\nCompose 의 계층 구조는 아래와 같으며. ComposeView 를 통해 androidx.compose.materia 에 정의된 다양한 컴포넌트를 조합하여 Composable function 콘텐츠를 구성할 수 있다.\n\n```\nkotlin.Any\n ↳ android.view.View\n   ↳ android.view.ViewGroup\n     ↳ androidx.compose.ui.platform.AbstractComposeView\n       ↳ androidx.compose.ui.platform.ComposeView\n```\n\n### 14. Compose Compiler / Compose Runtime\n\nCompose Compiler 는 `@Composable` 이 설정된 경우 Composable function 으로 코드 변환과 코틀린 컴파일러 플러그인과 함께 최적화를 활성화한다.\n\nCompose Runtime은 Compose의 프로그래밍 모델과 상태 관리, 그리고 Compose 컴파일러를 지정하기 위한 코어 런타임에 대한 기본 설정을 수행한다.\n\n\n```koltin\n@Composable\nfun Greeting(name: String) {\n    var greet by remember { mutableStateOf(\"Hello $name\") }\n    Text(text = greet, color = Color.Red)\n}\n```\n\n위의 코드는 Compose Compiler에 의해 `@Composeable`은 아래와 같이 변경된다.\n\n```kotlin\nfun Greeting(\n  $composer: Composer,\n  $static: Int,\n  name: String\n) {\n  $composer.start(123)\n  var greet by remember { mutableStateOf(\"Hello $name\") }\n  Text(text = greet, color = Color.Red)\n  $composer.end()\n}\n```\n\nCompose 는 `composer.start` 에서 고유의 키를 가지고 있고, 이는 Compose 의 state 가 변경될 때 해당 키를 가진 Compose 만 변경되도록 동작한다.\n\nstatic 은 상태(state)의 변경여부를 알 수 있는데 상태의 변화가 없는 경우, `composer.start` 와 `composer.end` 사이의 UI 의 변경을 하지 않는다.\n\n이때 데이터의 상태가 변경되어 UI 를 다시 구성하는 경우는 Recomposition 이라고 한다.","source":"_posts/2021-04-07 Jetpack Compose Part 1.md","raw":"---\ntitle: Jetpack Compose Part 1 - Compose 소개 및 코드랩 따라하기\ndate: 2021-04-07 01:00\ncategories:\n- Jetpack Compose\ntags:\n- Android\n- Jetpack\n- Compose\n---\n\n<!-- more -->\n\n**Author in [AndroidDeepDive Study](https://github.com/AndroidDeepDive/Study)**\n- 김남훈 @Naver\n- 배희성 @RocketPunch\n- 송시영 @SmartStudy\n- 이기정 @BankSalad\n\n## Jetpack Compose란 무엇인가?\n\n{% asset_img compose_animation.gif [compose_animation] %}\n\n> **출처** [Android Developers#Jetpack Compse](https://developer.android.com/jetpack/compose)\n\nCompose는 Native UI를 코드레벨로 구현할 수 있는 최신 툴킷이다. \n\n기존의 뷰를 업데이트하는 방식과 달리 Compose를 사용하면 필요한 영역의 뷰를 다시 그려주는 방식으로 작업할 수 있다.\n\n아래는 아주 간단한 예제이다.\n\n```kotlin\n@Composable\nfun Greeting(name: String) {\n\tText(\"Hello $name\")\n}\n```\n\n위의 예제처럼 UI를 구성하는 것이 아니라 화면을 구성하는 뷰의 State 설명하는 것이므로 아무것도 반환하지 않는다.\n\n아래는 공식 서비스 소개 영상이다.\n\n<div style=\"width: 560px; height: 315px; float: none; clear: both;\">\n  <embed\n    src=\"https://www.youtube.com/embed/U5BwfqBpiWU\"\n    wmode=\"transparent\"\n    type=\"video/mp4\"\n    width=\"100%\" height=\"100%\"\n    allow=\"autoplay; encrypted-media; picture-in-picture\"\n    allowfullscreen\n  >\n</div>\n\n### Compose의 4가지 특징\n\n구글에서 설명하는 Compose를 이용시 얻을 수 있는 장점은 아래와 같다.\n\n- `Less Code` - 코드 감소\n  - 적은 수의 코드로 더 많은 작업을 하고 전체 버그 클래스를 방지할 수 있으므로 코드가 간단하며 유지 관리하기 쉽습니다.\n- `Intuitive` - 직관적\n  - UI만 설명하면 나머지는 Compose에서 처리합니다. 앱 상태가 변경되면 UI가 자동으로 업데이트됩니다.\n- `Accelerate Development` - 빠른 개발 과정\n  - 기존의 모든 코드와 호환되므로 언제 어디서든 원하는 대로 사용할 수 있습니다. 실시간 미리보기 및 완전한 Android 스튜디오 지원으로 빠르게 반복할 수 있습니다.\n- `Powerful` - 강력한 성능\n  - Android 플랫폼 API에 직접 액세스하고 머티리얼 디자인, 어두운 테마, 애니메이션 등을 기본적으로 지원하는 멋진 앱을 만들 수 있습니다.\n\n늘 그렇듯 구글에서 말하는 설명만 보면 안 쓸 이유가 없어보이고, 대세가 된다면 Android 개발자에게 또 하나의 러닝커브로 작용할 것이다.\n\n## Codelab - Jetpack Compose basics\n\n### 1. 시작하기전에\n\nCompose는 아직 정식으로 릴리즈되지 않은 기능이므로 Android Studio Canary에서 프로젝트를 구성하며 몇 가지 제한사항이 존재한다.\n\n1. Android Studio Canary \n\nCanary는 아래 링크에서 다운 받을 수 있다.\n\n> [Android Studio Preview](https://developer.android.com/studio/preview)\n\n2. 최신 버전의 Kotlin plugin \n\n```groovy\next.kotlin_version = '1.4.31'\n```\n\n3. buildFeatures 및 composeOption 활성화\n\n```groovy\nandroid {\n    ...\n    buildFeatures {\n        compose true\n    }\n    composeOptions {\n        kotlinCompilerExtensionVersion 1.0.0-beta02\n    }\n}\n\ndependencies {\n    ...\n    implementation \"androidx.compose.ui:ui:1.0.0-beta02\"\n    implementation \"androidx.activity:activity-compose:1.3.0-alpha03\"\n    implementation \"androidx.compose.material:material:1.0.0-beta02\"\n    implementation \"androidx.compose.ui:ui-tooling:1.0.0-beta02\"\n    ...\n}\n```\n\n### 2. Empty Compose 프로젝트 생성\n\n[File] - [New] - [New Project…] 를 눌러 새로운 프로젝트를 선택하고(Preview) Empty Compose Activity 를 선택한다.\n\n![](https://cdn-images-1.medium.com/max/3592/1*5gfrQWfxyEC7Oq6b2xlJ9w.png)\n\n선택 이후 Next를 클릭하고, Compose를 구현할 수 있는 최소 API 레벨인 21을 선택해야한다.\n\n프로젝트를 생성하면 아래와 같이 app/build.gradle에 의존성 설정 및 추가가 되어 있는것을 알 수 있다.\n\n```groovy\nandroid {\n    ...\n    kotlinOptions {\n        jvmTarget = '1.8'\n        useIR = true\n    }\n    buildFeatures {\n        compose true\n    }\n    composeOptions {\n        kotlinCompilerExtensionVersion compose_version\n    }\n}\n\ndependencies {\n    ...\n    implementation \"androidx.compose.ui:ui:$compose_version\"\n    implementation \"androidx.activity:activity-compose:1.3.0-alpha03\"\n    implementation \"androidx.compose.material:material:$compose_version\"\n    implementation \"androidx.compose.ui:ui-tooling:$compose_version\"\n    ...\n}\n```\n\n이때 composeOptions 설정에서 kotlinCompilerVersion 에 따라 compose 가 다르게 동작할 수 있음을 유의하자.\n\n프로젝트를 생성하면 아래와 같은 기본 파일들이 생성된다.\n\n**MainActivity.kt**\n```kotlin\nclass MainActivity : AppCompatActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContent {\n            MyFirstComposeApplicationTheme {\n                // A surface container using the 'background' color from the theme\n                Surface(color = MaterialTheme.colors.background) {\n                    Greeting(\"Android\")\n                }\n            }\n        }\n    }\n}\n\n@Composable\nfun Greeting(name: String) {\n    Text(text = \"Hello $name!\")\n}\n\n@Preview(showBackground = true)\n@Composable\nfun DefaultPreview() {\n    MyFirstComposeApplicationTheme {\n        Greeting(\"Android\")\n    }\n}\n```\n\n**ui/theme/Theme.kt**\n```kotlin\nprivate val DarkColorPalette = darkColors(\n    primary = Purple200,\n    primaryVariant = Purple700,\n    secondary = Teal200\n)\n\nprivate val LightColorPalette = lightColors(\n    primary = Purple500,\n    primaryVariant = Purple700,\n    secondary = Teal200*\n\n    /* Other default colors to override\n    background = Color.White,\n    surface = Color.White,\n    onPrimary = Color.White,\n    onSecondary = Color.Black,\n    onBackground = Color.Black,\n    onSurface = Color.Black,\n    */\n)\n\n@Composable\nfun MyFirstComposeApplicationTheme(darkTheme: Boolean = isSystemInDarkTheme(), content: @Composable () -> Unit) {\n    val colors = if (darkTheme) {\n        DarkColorPalette*\n    } else {\n        LightColorPalette*\n    }\n\n    MaterialTheme(\n        colors = colors,\n        typography = Typography,\n        shapes = Shapes,\n        content = content\n    )\n}\n```\n\n기본 생성된 코드를 보았을 때, Compose는 총 3가지의 구성 요소를 가지는 것으로 추측할 수 있다.\n\n1. 위젯을 포함하는 Composable 함수\n2. Preview를 하기 위한 Preview Composable 함수\n3. setContent 람다 표현식으로 실제 화면에 노출하는 코드\n\n일반적으로 우리가 아는 Activity의 라이프사이클 콜백 `onCreate()`에서   `setContentView(Int)` 함수를 호출하던것이 `setContent()` 함수로 바뀐것이 가장 큰 특징으로 보여진다.\n\n### 3. Composable Function\n\nComposable Function은 어노테이션을 이용한 기술이다. 함수위에 `@Composable` 어노테이션을 붙이게 되면 함수 안 다른 함수를 호출할 수 있게된다. 아래 코드를 보자.\n\n```kotlin\n@Composable\nfun Greeting(names: List<String>) {\n    for (name in names) {\n        Text(\"Hello $name\")\n    }\n}\n```\n\n단순하게 내부에는 Text라는 함수가 존재하는데, 이를 통해 UI계층 별 요구하는 컴포넌트를 생성해준다. 기본적으로 보이는 text 파라미터는 내부 속성에서 받는 일부 중 하나이다.\n\n### 4. TextView 만들기\n\n위 코드를 실행시켜보면 당연하게도 Hello로 시작하는 TextView가 화면에 그려질것을 암시한다.\n\n```kotlin\nsetContent {\n  BasicsCodelabTheme {\n    // A surface container using the 'background' color from the theme\n    Surface(color = MaterialTheme.colors.background) {\n      Greeting(\"Android\")\n    }\n  }\n}\n```\n\n![output](https://imgur.com/aO6Jlsg.jpg)\n\n### 5. `@Preview`\n\n말 그대로 어노테이션을 이용하여 IDE에서 Preview를하기 위한 용도이다. 아래 코드와 같이 @Preview 어노테이션을 추가하면 다음 결과를 볼 수 있다.\n\n```kotlin\n@Preview(\"Greeting Preview\")\n@Composable\nfun GreetingPreview() {\n    BasicsCodelabTheme {\n        Surface(color = MaterialTheme.colors.background) {\n            Greeting(\"Android\")\n        }\n    }\n}\n```\n\n![Greeting Preview](https://imgur.com/WprDTs1.jpg)\n\n### 6. setContent / Theme / Surface\n\n```kotlin\nsetContent {\n  BasicsCodelabTheme {\n    // A surface container using the 'background' color from the theme\n    Surface(color = MaterialTheme.colors.background) {\n      Greeting(\"Android\")\n    }\n  }\n}\n```\n\n기존에 onCreate시점에 화면을 그려주기 위한 필수적인 요소를 정리해보자면\n\n- **setContent** : Activity에서 setContentView함수를 사용하는 것과 동일한 동작을 하는 확장함수이다. 다만, setContent의 경우 (@Composable) -> Unit 타입의 컴포즈 UI를 구현해주어야한다.\n\n- **XXXTheme** : Theme정보를 의미한다. 해당 프로젝트에서는 Theme.kt에 여러 테마에 필요한 정보를 정리하고, 컴포즈 UI 구현을 위한 코드를 작성해두었다.\n\n```kotlin\nprivate val DarkColorPalette = darkColors(\n    primary = purple200,\n    primaryVariant = purple700,\n    secondary = teal200\n)\n\nprivate val LightColorPalette = lightColors(\n    primary = purple500,\n    primaryVariant = purple700,\n    secondary = teal200\n\n    /* Other default colors to override\n    background = Color.White,\n    surface = Color.White,\n    onPrimary = Color.White,\n    onSecondary = Color.Black,\n    onBackground = Color.Black,\n    onSurface = Color.Black,\n    */\n)\n\n@Composable\nfun BasicsCodelabTheme(\n    darkTheme: Boolean = isSystemInDarkTheme(),\n    content: @Composable () -> Unit\n) {\n    val colors = if (darkTheme) {\n        DarkColorPalette\n    } else {\n        LightColorPalette\n    }\n\n    MaterialTheme(\n        colors = colors,\n        typography = typography,\n        shapes = shapes,\n        content = content\n    )\n}\n```\n\n- **Surface** : Greeting을 감싸는 뷰에 해당한다. 여기서는 크기를 정하지 않고, background 색상을 정의하고 있다. 역시 람다 표현식이다. 색상에 대한 Paramter로 `color` 라는 값을 사용하여 부여가 가능하다. 내부코드를 보면\n\n```kotlin\n@Composable\nfun Surface(\n    modifier: Modifier = Modifier,\n    shape: Shape = RectangleShape,\n    color: Color = MaterialTheme.colors.surface,\n    contentColor: Color = contentColorFor(color),\n    border: BorderStroke? = null,\n    elevation: Dp = 0.dp,\n    content: @Composable () -> Unit\n) {\n    val elevationPx = with(LocalDensity.current) { elevation.toPx() }\n    val elevationOverlay = LocalElevationOverlay.current\n    val absoluteElevation = LocalAbsoluteElevation.current + elevation\n    val backgroundColor = if (color == MaterialTheme.colors.surface && elevationOverlay != null) {\n        elevationOverlay.apply(color, absoluteElevation)\n    } else {\n        color\n    }\n    CompositionLocalProvider(\n        LocalContentColor provides contentColor,\n        LocalAbsoluteElevation provides absoluteElevation\n    ) {\n        Box(\n            modifier.graphicsLayer(shadowElevation = elevationPx, shape = shape)\n                .then(if (border != null) Modifier.border(border, shape) else Modifier)\n                .background(\n                    color = backgroundColor,\n                    shape = shape\n                )\n                .clip(shape),\n            propagateMinConstraints = true\n        ) {\n            content()\n        }\n    }\n}\n```\n\n### 7. Declarative UI - 선언형 UI\n\n노란색 배경을 입혀 기존 TextView에 추가해보았다. 또한, Greeting에는 Modifier라는 것을 이용하여 Padding을 추가했다. 아래와 같은 결과가 나오게 되었다.\n\n```kotlin\nBasicsCodelabTheme {\n  // A surface container using the 'background' color from the theme\n  Surface(color = Color.Yellow) {\n    Greeting(\"Android\")\n  }\n}\n```\n\n```kotlin\n@Composable\nfun Greeting(name: String) {\n    var isSelected by remember { mutableStateOf(false) }\n    val backgroundColor by animateColorAsState(if (isSelected) Color.Red else Color.Transparent)\n\n    Text(\n        text = \"Hello $name!\",\n        modifier = Modifier\n            .padding(24.dp)\n            .background(color = backgroundColor)\n            .clickable(onClick = { isSelected = !isSelected })\n    )\n}\n```\n\n![결과](https://imgur.com/qgQ6oY4.jpg)\n\n선언형 UI의 장점은 말 그대로 내가 UI를 정의한대로 시각적으로 표현이 가능하다는 장점이 있다. 기존에는 속성을 매번 On/Off와 같은 옵션을 통해 변경하는 것이 다반사였지만, 이제는 매번 속성에 변경이 생길때마다 새로 그려주게 되는것이다.\n\n\n### 8. 재사용\n\nCompose의 장점 중 하나는 재사용성이 뛰어난것인데, XML에서 우리가 include 태그를 통해 여러곳에서 갖다쓸 수 있던것처럼, 함수를 통해 여러곳에서 정의하여 사용이 가능하다.\n\n참고해야할 점은 Compose 컴포넌트 확장 시 `@Composable` 어노테이션을 붙여야 한다.\n\n### 9. Container 작성\n\nMyApp이라는 이름으로 컴포즈 컴포넌트를 구횬하여 여러곳에서 공통으로 사용할 수 있는 Composable을 구현하였다. 내부적으로 Container내 내가 원하는 컴포넌트를 넣어주려면 아래와 같이 인자로 `@Composable () -> Unit` 타입을 넘겨받아 처리해주면 된다.\n\n```kotlin\n@Composable\nfun MyApp(content: @Composable () -> Unit) {\n    BasicsCodelabTheme {\n        Surface(color = Color.Yellow) {\n            content()\n        }\n    }\n}\n```\n\n위 함수를 통해 이제는 어디서든 반복해서 사용할 수 있는 Container를 구현하게 되어 아래와 같이 코드를 활용할 수 있게되었다.\n\n```kotlin\nclass MainActivity : AppCompatActivity() {\n  override fun onCreate(savedInstanceState: Bundle?) {\n    super.onCreate(savedInstanceState)\n    setContent {\n      MyApp {\n        Greeting(\"Android\")\n      }\n    }\n    ...\n  }\n```\n\n### 10. 레이아웃을 활용한 Compose function의 다중 호출\n\n지금까지는 하나의 컴포넌트만을 갖고 사용했지만, 여러개의 컴포넌트를 넣는것도 가능하다.\n\n```kotlin\n@Composable\nfun MyScreenContent() {\n    Column {\n        Greeting(\"Android\")\n        Divider(color = Color.Black)\n        Greeting(\"there\")\n    }\n}\n```\n\n `Column`과 위에서부터 사용하던 `Greeting` 함수를 사용하고, 라인을 그어주기 위한 `Divider`를 추가한 결과물은 다음과 같다.\n\n![multiple component](https://imgur.com/VLTxB8C.jpg)\n\n위 컴포넌트 중 못보던 컴포저블이 있는데, 아래와 같이 설명이 가능하다.\n\n- Column : 항목을 순서대로 배치하기 위해 사용한다.\n- Divider : 선 긋기 가능한 Compose 함수이다.\n\n이를 리스트 형태로도 구현이 가능하다.\n\n```kotlin\n@Composable\nfun MyColumnScreen(names: List<String> = listOf(\"Line One\", \"Line Two\")) {\n    Column {\n        names.forEach {\n            Greeting(name = it)\n            Divider(color = Color.Black)\n        }\n    }\n}\n```\n\n### 11. State in Compose - Compose에서의 상태값 관리\n\n\n컴포넌트에 버튼을 클릭했을 때 클릭한 카운트를 집계하는 간단한 컴포넌트를 만들어보았다.\n\n```kotlin\n@Composable\nfun MyColumnScreen(names: List<String> = listOf(\"Line One\", \"Line Two\")) {\n    val counterState = remember { mutableStateOf(0) } // \n\n    Column {\n        names.forEach {\n            Greeting(name = it)\n            Divider(color = Color.Black)\n        }\n        Counter(\n            count = counterState.value,\n            updateCount = { newCount ->\n                counterState.value = newCount\n            }\n        )\n    }\n}\n```\n\nremember라는 함수를 사용하여 기존에 존재하는 컴포넌트의 상태값을 기억하게 하는 함수가 있다. \n\n`remember` 함수의 내부를 살펴보자.\n\n```kotlin\n/**\n * Remember the value produced by [calculation]. [calculation] will only be evaluated during the composition.\n * Recomposition will always return the value produced by composition.\n */\n@OptIn(ComposeCompilerApi::class)\n@Composable\ninline fun <T> remember(calculation: @DisallowComposableCalls () -> T): T =\n    currentComposer.cache(false, calculation)\n```\n\n매 호출마다 Recomposition(재조합)하게되는 경우 컴포넌트에 값을 다시 제공하는 것을 알 수 있다. @Composable 어노테이션에 들어간 함수는 매번 해당 상태를 구독하고, 상태가 변경될때마다 알림을 받아 기존 화면을 갱신해준다.\n\n그리고, 아래 Counter를 보면 Button을 이용하여 이벤트를 받아 처리하도록 했다.\n\n```kotlin\n@Composable\nfun Counter(count: Int, updateCount: (Int) -> Unit) {\n    Button(\n        onClick = { updateCount(count + 1) },\n        colors = ButtonDefaults.buttonColors(\n            backgroundColor = if (count > 5) Color.Green else Color.White\n        )\n    ) {\n        Text(\"I've been clicked $count times\")\n    }\n}\n```\n\n`updateCount(Int)` 함수릉 통해 매번 값을 업데이트 해주는데, 이를 통해 counterState에 값을 넣어주면서 해당 컴포넌트가 매번 변경이 되는것이다.\n\n따라서 결과를 보면, 다음과 같다. Count가 5가 넘어가면 초록색으로 바뀐다.\n\n![count](https://imgur.com/Ju6BSg2.gif)\n\n그 외에도 여러형태의 모양을 구성할수 있도록 옵션이 제공되어 있다. 자세한 정보는 나중에 [Codelabs](https://developer.android.com/codelabs/jetpack-compose-basics)에 더 나와 있으니 보도록하고, 이번에 setContent에 대한 동작원리를 함께 고민해보자.\n\n### 12. Activity에서의 View 생성 방식과의 비교\n\nCompose를 안드로이드 앱에서 사용하려면 Activity, Fragment와 같은곳에서 contentView로 뿌려줘야한다. 기존에 우리가 사용하던 함수를 보자.\n\n```java\n/**\n* Set the activity content from a layout resource.  The resource will be\n* inflated, adding all top-level views to the activity.\n*\n* @param layoutResID Resource ID to be inflated.\n*\n* @see #setContentView(android.view.View)\n* @see #setContentView(android.view.View, android.view.ViewGroup.LayoutParams)\n*/\npublic void setContentView(@LayoutRes int layoutResID) {\n  getWindow().setContentView(layoutResID);\n  initWindowDecorActionBar();\n}\n```\n\nUI 컴포넌트에서 화면을 붙일 수 있는 Window라는 녀석에서 Layout Resource Id를 통해 기존에 등록되어있던 Layout XML 파일을 로드하여 인플레이터에서 파싱하고, 이를통해 레이아웃 계층에 있는 뷰객체를 생성하여 순차적으로 ViewGroup, View를 만들어 넣어주게 된다.\n\n`PhoneWindow`를 보면 자세하게 알 수 있는데, Window를 구현한 setContentView에서 처음에 생성되는 최상위 레이아웃 그 위에 따로 없다면 `installDecor()` 함수를 통해 mContentParent(레이아웃 리소스가 붙게될 ViewGroup)를 생성하고, 하위에 넣어주게 된다.\n\n그러면 기존 방식은 이정도로 설명을하고, 이번엔 Compose에서 `setContent()` 라는 함수를 어떻게 사용하는지 보자.\n\n```kotlin\n/**\n * Composes the given composable into the given activity. The [content] will become the root view\n * of the given activity.\n *\n * This is roughly equivalent to calling [ComponentActivity.setContentView] with a [ComposeView]\n * i.e.:\n *\n * ```\n * setContentView(\n *   ComposeView(this).apply {\n *     setContent {\n *       MyComposableContent()\n *     }\n *   }\n * )\n * ```\n *\n * @param parent The parent composition reference to coordinate scheduling of composition updates\n * @param content A `@Composable` function declaring the UI contents\n */\npublic fun ComponentActivity.setContent(\n    parent: CompositionContext? = null,\n    content: @Composable () -> Unit\n) {\n    val existingComposeView = window.decorView\n        .findViewById<ViewGroup>(android.R.id.content)\n        .getChildAt(0) as? ComposeView\n\n    if (existingComposeView != null) with(existingComposeView) {\n        setParentCompositionContext(parent)\n        setContent(content)\n    } else ComposeView(this).apply {\n        // Set content and parent **before** setContentView\n        // to have ComposeView create the composition on attach\n        setParentCompositionContext(parent)\n        setContent(content)\n        // Set the view tree owners before setting the content view so that the inflation process\n        // and attach listeners will see them already present\n        setOwners()\n        setContentView(this, DefaultActivityContentLayoutParams)\n    }\n}\n```\n\n이녀석도 마찬가지로 `window.decorView.findViewById<ViewGroup>(android.R.id.content)`  함수를 호출하여 decorView를 가져온다. 만약 compose를 통해 만들어진 최상위 레이아웃이 존재하면, 기존에 inflator에서 ViewGroup, View를 생성해서 넣어주던것 처럼 `setContent()` => window가 Activity/Fragment에 붙으면 `createComposition()`를 호출하여 검증 후 `ensureCompsositionCreated()` 함수를 호출한다. 현재는 내부적으로 `ViewGroup.setContent()` 를 사용하고 있는데, 곧 교체 될 예정이라고 한다. 이코드도 보면 기존에 있는 ViewGroup에 확장함수로 구현한 녀석인데, 쉽게 말해 ViewGroup에 하위 View, ViewGroup에 Composable로 구현된 함수로 컴포넌트를 넣어줄 때 AndroidComposeView라는 객체를 꺼내오거나 없다면 새로 생성하여 넣어준다.\n\n```kotlin\n/**\n * Composes the given composable into the given view.\n *\n * The new composition can be logically \"linked\" to an existing one, by providing a\n * [parent]. This will ensure that invalidations and CompositionLocals will flow through\n * the two compositions as if they were not separate.\n *\n * Note that this [ViewGroup] should have an unique id for the saved instance state mechanism to\n * be able to save and restore the values used within the composition. See [View.setId].\n *\n * @param parent The [Recomposer] or parent composition reference.\n * @param content Composable that will be the content of the view.\n */\ninternal fun ViewGroup.setContent(\n    parent: CompositionContext,\n    content: @Composable () -> Unit\n): Composition {\n    GlobalSnapshotManager.ensureStarted()\n    val composeView =\n        if (childCount > 0) {\n            getChildAt(0) as? AndroidComposeView\n        } else {\n            removeAllViews(); null\n        } ?: AndroidComposeView(context).also { addView(it.view, DefaultLayoutParams) }\n    return doSetContent(composeView, parent, content)\n}\n```\n\n\n\n다시 돌아와서, ComposeView의 `setContent()` 이라는 녀석을 보자.\n\n```kotlin\n/**\n * A [android.view.View] that can host Jetpack Compose UI content.\n * Use [setContent] to supply the content composable function for the view.\n *\n * This [android.view.View] requires that the window it is attached to contains a\n * [ViewTreeLifecycleOwner]. This [androidx.lifecycle.LifecycleOwner] is used to\n * [dispose][androidx.compose.runtime.Composition.dispose] of the underlying composition\n * when the host [Lifecycle] is destroyed, permitting the view to be attached and\n * detached repeatedly while preserving the composition. Call [disposeComposition]\n * to dispose of the underlying composition earlier, or if the view is never initially\n * attached to a window. (The requirement to dispose of the composition explicitly\n * in the event that the view is never (re)attached is temporary.)\n */\nclass ComposeView @JvmOverloads constructor(\n    context: Context,\n    attrs: AttributeSet? = null,\n    defStyleAttr: Int = 0\n) : AbstractComposeView(context, attrs, defStyleAttr) {\n\n    private val content = mutableStateOf<(@Composable () -> Unit)?>(null)\n\n    @Suppress(\"RedundantVisibilityModifier\")\n    protected override var shouldCreateCompositionOnAttachedToWindow: Boolean = false\n        private set\n\n    @Composable\n    override fun Content() {\n        content.value?.invoke()\n    }\n\n    /**\n     * Set the Jetpack Compose UI content for this view.\n     * Initial composition will occur when the view becomes attached to a window or when\n     * [createComposition] is called, whichever comes first.\n     */\n    fun setContent(content: @Composable () -> Unit) {\n        shouldCreateCompositionOnAttachedToWindow = true\n        this.content.value = content\n        if (isAttachedToWindow) {\n            createComposition()\n        }\n    }\n}\n```\n\n결론적으로 `AbstractComposeView` 라는 녀석은 ViewGroup을 상속받은 녀석이며, 모든 composable의 상태가 변화 되었을 때 이를 감지하는 중요한 녀석이다.\n\n`setContent()`라는 함수는 위에서 설명했으니 넘어가고, 이번에는 `Content`라는 녀석을 보자. 이녀석은 추상 메소드로, `createComposition()` 이라는 함수가 호출 되었을 때, 가장 먼저 불리는 함수이다. 아까 언급되었던 `ensureCompsositionCreated()` 함수에서 tree계층의 ComposeView가 다 붙었다면, 이후에 즉시 Content함수가 호출이된다.\n\n```kotlin\n@Suppress(\"DEPRECATION\") // Still using ViewGroup.setContent for now\n    private fun ensureCompositionCreated() {\n        if (composition == null) {\n            try {\n                creatingComposition = true\n                composition = setContent(\n                    parentContext ?: findViewTreeCompositionContext() ?: windowRecomposer\n                ) {\n                    Content() // 이곳에서 뷰가 다 window에 붙게되면 콜백을 호출한다.\n                }\n            } finally {\n                creatingComposition = false\n            }\n        }\n    }\n```\n\n그러면 아래 `ComposeView`의 오버라이딩 된 Content가 호출되면서, 기존에 생성된 View에 UI속성과 같은 Content가 붙게된다.\n\n```kotlin\n/**\n* The Jetpack Compose UI content for this view.\n* Subclasses must implement this method to provide content. Initial composition will\n* occur when the view becomes attached to a window or when [createComposition] is called,\n* whichever comes first.\n*/\n@Composable\nabstract fun Content()\n```\n\nContent는 설명에서 보는것과 같이 `createComposition()` 함수 호출 후 View가 Window에 붙은 이후 즉시 호출된다.\n\n최종적으로 `ComponentActivity.setContent(CompositionContext?, @Composable () -> Unit)` 함수에서 구현된 ComposeView 인스턴스를 ContentLayout을 widht/height를 wrapContent크기로 정하여 ContentView를 Set해주게 된다.\n\n```kotlin\n/**\n * Composes the given composable into the given activity. The [content] will become the root view\n * of the given activity.\n *\n * This is roughly equivalent to calling [ComponentActivity.setContentView] with a [ComposeView]\n * i.e.:\n *\n * ```\n * setContentView(\n *   ComposeView(this).apply {\n *     setContent {\n *       MyComposableContent()\n *     }\n *   }\n * )\n * ```\n *\n * @param parent The parent composition reference to coordinate scheduling of composition updates\n * @param content A `@Composable` function declaring the UI contents\n */\npublic fun ComponentActivity.setContent(\n    parent: CompositionContext? = null,\n    content: @Composable () -> Unit\n) {\n  \t...\n\t\telse ComposeView(this).apply {\n        // Set content and parent **before** setContentView\n        // to have ComposeView create the composition on attach\n        setParentCompositionContext(parent)\n        setContent(content)\n        // Set the view tree owners before setting the content view so that the inflation process\n        // and attach listeners will see them already present\n        setOwners()\n        setContentView(this, DefaultActivityContentLayoutParams)\n    }\n}\n```\n\n### 13. ComposeView\n\nandroid.view.View 는 Jetpack Compose UI 콘텐츠를 사용할 수 있도록 해줍니다. setContent 를 사용하면 composable function content 를 뷰에 제공할 수 있다.\n\nCompose 의 계층 구조는 아래와 같으며. ComposeView 를 통해 androidx.compose.materia 에 정의된 다양한 컴포넌트를 조합하여 Composable function 콘텐츠를 구성할 수 있다.\n\n```\nkotlin.Any\n ↳ android.view.View\n   ↳ android.view.ViewGroup\n     ↳ androidx.compose.ui.platform.AbstractComposeView\n       ↳ androidx.compose.ui.platform.ComposeView\n```\n\n### 14. Compose Compiler / Compose Runtime\n\nCompose Compiler 는 `@Composable` 이 설정된 경우 Composable function 으로 코드 변환과 코틀린 컴파일러 플러그인과 함께 최적화를 활성화한다.\n\nCompose Runtime은 Compose의 프로그래밍 모델과 상태 관리, 그리고 Compose 컴파일러를 지정하기 위한 코어 런타임에 대한 기본 설정을 수행한다.\n\n\n```koltin\n@Composable\nfun Greeting(name: String) {\n    var greet by remember { mutableStateOf(\"Hello $name\") }\n    Text(text = greet, color = Color.Red)\n}\n```\n\n위의 코드는 Compose Compiler에 의해 `@Composeable`은 아래와 같이 변경된다.\n\n```kotlin\nfun Greeting(\n  $composer: Composer,\n  $static: Int,\n  name: String\n) {\n  $composer.start(123)\n  var greet by remember { mutableStateOf(\"Hello $name\") }\n  Text(text = greet, color = Color.Red)\n  $composer.end()\n}\n```\n\nCompose 는 `composer.start` 에서 고유의 키를 가지고 있고, 이는 Compose 의 state 가 변경될 때 해당 키를 가진 Compose 만 변경되도록 동작한다.\n\nstatic 은 상태(state)의 변경여부를 알 수 있는데 상태의 변화가 없는 경우, `composer.start` 와 `composer.end` 사이의 UI 의 변경을 하지 않는다.\n\n이때 데이터의 상태가 변경되어 UI 를 다시 구성하는 경우는 Recomposition 이라고 한다.","slug":"2021-04-07 Jetpack Compose Part 1","published":1,"updated":"2021-07-25T05:23:56.282Z","_id":"ckrir2hpe0005peregel33vbc","comments":1,"layout":"post","photos":[],"link":"","content":"<span id=\"more\"></span>\n\n<p><strong>Author in <a href=\"https://github.com/AndroidDeepDive/Study\">AndroidDeepDive Study</a></strong></p>\n<ul>\n<li>김남훈 @Naver</li>\n<li>배희성 @RocketPunch</li>\n<li>송시영 @SmartStudy</li>\n<li>이기정 @BankSalad</li>\n</ul>\n<h2 id=\"Jetpack-Compose란-무엇인가\"><a href=\"#Jetpack-Compose란-무엇인가\" class=\"headerlink\" title=\"Jetpack Compose란 무엇인가?\"></a>Jetpack Compose란 무엇인가?</h2><img src=\"/Team-Blog/2021/04/07/2021-04-07%20Jetpack%20Compose%20Part%201/compose_animation.gif\" class=\"\" title=\"[compose_animation]\">\n\n<blockquote>\n<p><strong>출처</strong> <a href=\"https://developer.android.com/jetpack/compose\">Android Developers#Jetpack Compse</a></p>\n</blockquote>\n<p>Compose는 Native UI를 코드레벨로 구현할 수 있는 최신 툴킷이다. </p>\n<p>기존의 뷰를 업데이트하는 방식과 달리 Compose를 사용하면 필요한 영역의 뷰를 다시 그려주는 방식으로 작업할 수 있다.</p>\n<p>아래는 아주 간단한 예제이다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Composable</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">Greeting</span><span class=\"params\">(name: <span class=\"type\">String</span>)</span></span> &#123;</span><br><span class=\"line\">\tText(<span class=\"string\">&quot;Hello <span class=\"variable\">$name</span>&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>위의 예제처럼 UI를 구성하는 것이 아니라 화면을 구성하는 뷰의 State 설명하는 것이므로 아무것도 반환하지 않는다.</p>\n<p>아래는 공식 서비스 소개 영상이다.</p>\n<div style=\"width: 560px; height: 315px; float: none; clear: both;\">\n  <embed\n    src=\"https://www.youtube.com/embed/U5BwfqBpiWU\"\n    wmode=\"transparent\"\n    type=\"video/mp4\"\n    width=\"100%\" height=\"100%\"\n    allow=\"autoplay; encrypted-media; picture-in-picture\"\n    allowfullscreen\n  >\n</div>\n\n<h3 id=\"Compose의-4가지-특징\"><a href=\"#Compose의-4가지-특징\" class=\"headerlink\" title=\"Compose의 4가지 특징\"></a>Compose의 4가지 특징</h3><p>구글에서 설명하는 Compose를 이용시 얻을 수 있는 장점은 아래와 같다.</p>\n<ul>\n<li><code>Less Code</code> - 코드 감소<ul>\n<li>적은 수의 코드로 더 많은 작업을 하고 전체 버그 클래스를 방지할 수 있으므로 코드가 간단하며 유지 관리하기 쉽습니다.</li>\n</ul>\n</li>\n<li><code>Intuitive</code> - 직관적<ul>\n<li>UI만 설명하면 나머지는 Compose에서 처리합니다. 앱 상태가 변경되면 UI가 자동으로 업데이트됩니다.</li>\n</ul>\n</li>\n<li><code>Accelerate Development</code> - 빠른 개발 과정<ul>\n<li>기존의 모든 코드와 호환되므로 언제 어디서든 원하는 대로 사용할 수 있습니다. 실시간 미리보기 및 완전한 Android 스튜디오 지원으로 빠르게 반복할 수 있습니다.</li>\n</ul>\n</li>\n<li><code>Powerful</code> - 강력한 성능<ul>\n<li>Android 플랫폼 API에 직접 액세스하고 머티리얼 디자인, 어두운 테마, 애니메이션 등을 기본적으로 지원하는 멋진 앱을 만들 수 있습니다.</li>\n</ul>\n</li>\n</ul>\n<p>늘 그렇듯 구글에서 말하는 설명만 보면 안 쓸 이유가 없어보이고, 대세가 된다면 Android 개발자에게 또 하나의 러닝커브로 작용할 것이다.</p>\n<h2 id=\"Codelab-Jetpack-Compose-basics\"><a href=\"#Codelab-Jetpack-Compose-basics\" class=\"headerlink\" title=\"Codelab - Jetpack Compose basics\"></a>Codelab - Jetpack Compose basics</h2><h3 id=\"1-시작하기전에\"><a href=\"#1-시작하기전에\" class=\"headerlink\" title=\"1. 시작하기전에\"></a>1. 시작하기전에</h3><p>Compose는 아직 정식으로 릴리즈되지 않은 기능이므로 Android Studio Canary에서 프로젝트를 구성하며 몇 가지 제한사항이 존재한다.</p>\n<ol>\n<li>Android Studio Canary </li>\n</ol>\n<p>Canary는 아래 링크에서 다운 받을 수 있다.</p>\n<blockquote>\n<p><a href=\"https://developer.android.com/studio/preview\">Android Studio Preview</a></p>\n</blockquote>\n<ol start=\"2\">\n<li>최신 버전의 Kotlin plugin </li>\n</ol>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ext.kotlin_version = <span class=\"string\">&#x27;1.4.31&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>buildFeatures 및 composeOption 활성화</li>\n</ol>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">android &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    buildFeatures &#123;</span><br><span class=\"line\">        compose <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    composeOptions &#123;</span><br><span class=\"line\">        kotlinCompilerExtensionVersion <span class=\"number\">1.0</span><span class=\"number\">.0</span>-beta02</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    implementation <span class=\"string\">&quot;androidx.compose.ui:ui:1.0.0-beta02&quot;</span></span><br><span class=\"line\">    implementation <span class=\"string\">&quot;androidx.activity:activity-compose:1.3.0-alpha03&quot;</span></span><br><span class=\"line\">    implementation <span class=\"string\">&quot;androidx.compose.material:material:1.0.0-beta02&quot;</span></span><br><span class=\"line\">    implementation <span class=\"string\">&quot;androidx.compose.ui:ui-tooling:1.0.0-beta02&quot;</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-Empty-Compose-프로젝트-생성\"><a href=\"#2-Empty-Compose-프로젝트-생성\" class=\"headerlink\" title=\"2. Empty Compose 프로젝트 생성\"></a>2. Empty Compose 프로젝트 생성</h3><p>[File] - [New] - [New Project…] 를 눌러 새로운 프로젝트를 선택하고(Preview) Empty Compose Activity 를 선택한다.</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/3592/1*5gfrQWfxyEC7Oq6b2xlJ9w.png\"></p>\n<p>선택 이후 Next를 클릭하고, Compose를 구현할 수 있는 최소 API 레벨인 21을 선택해야한다.</p>\n<p>프로젝트를 생성하면 아래와 같이 app/build.gradle에 의존성 설정 및 추가가 되어 있는것을 알 수 있다.</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">android &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    kotlinOptions &#123;</span><br><span class=\"line\">        jvmTarget = <span class=\"string\">&#x27;1.8&#x27;</span></span><br><span class=\"line\">        useIR = <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    buildFeatures &#123;</span><br><span class=\"line\">        compose <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    composeOptions &#123;</span><br><span class=\"line\">        kotlinCompilerExtensionVersion compose_version</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    implementation <span class=\"string\">&quot;androidx.compose.ui:ui:$compose_version&quot;</span></span><br><span class=\"line\">    implementation <span class=\"string\">&quot;androidx.activity:activity-compose:1.3.0-alpha03&quot;</span></span><br><span class=\"line\">    implementation <span class=\"string\">&quot;androidx.compose.material:material:$compose_version&quot;</span></span><br><span class=\"line\">    implementation <span class=\"string\">&quot;androidx.compose.ui:ui-tooling:$compose_version&quot;</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>이때 composeOptions 설정에서 kotlinCompilerVersion 에 따라 compose 가 다르게 동작할 수 있음을 유의하자.</p>\n<p>프로젝트를 생성하면 아래와 같은 기본 파일들이 생성된다.</p>\n<p><strong>MainActivity.kt</strong></p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MainActivity</span> : <span class=\"type\">AppCompatActivity</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onCreate</span><span class=\"params\">(savedInstanceState: <span class=\"type\">Bundle</span>?)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onCreate(savedInstanceState)</span><br><span class=\"line\">        setContent &#123;</span><br><span class=\"line\">            MyFirstComposeApplicationTheme &#123;</span><br><span class=\"line\">                <span class=\"comment\">// A surface container using the &#x27;background&#x27; color from the theme</span></span><br><span class=\"line\">                Surface(color = MaterialTheme.colors.background) &#123;</span><br><span class=\"line\">                    Greeting(<span class=\"string\">&quot;Android&quot;</span>)</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Composable</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">Greeting</span><span class=\"params\">(name: <span class=\"type\">String</span>)</span></span> &#123;</span><br><span class=\"line\">    Text(text = <span class=\"string\">&quot;Hello <span class=\"variable\">$name</span>!&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Preview(showBackground = true)</span></span><br><span class=\"line\"><span class=\"meta\">@Composable</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">DefaultPreview</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    MyFirstComposeApplicationTheme &#123;</span><br><span class=\"line\">        Greeting(<span class=\"string\">&quot;Android&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>ui/theme/Theme.kt</strong></p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">val</span> DarkColorPalette = darkColors(</span><br><span class=\"line\">    primary = Purple200,</span><br><span class=\"line\">    primaryVariant = Purple700,</span><br><span class=\"line\">    secondary = Teal200</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">val</span> LightColorPalette = lightColors(</span><br><span class=\"line\">    primary = Purple500,</span><br><span class=\"line\">    primaryVariant = Purple700,</span><br><span class=\"line\">    secondary = Teal200*</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Other default colors to override</span></span><br><span class=\"line\"><span class=\"comment\">    background = Color.White,</span></span><br><span class=\"line\"><span class=\"comment\">    surface = Color.White,</span></span><br><span class=\"line\"><span class=\"comment\">    onPrimary = Color.White,</span></span><br><span class=\"line\"><span class=\"comment\">    onSecondary = Color.Black,</span></span><br><span class=\"line\"><span class=\"comment\">    onBackground = Color.Black,</span></span><br><span class=\"line\"><span class=\"comment\">    onSurface = Color.Black,</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Composable</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">MyFirstComposeApplicationTheme</span><span class=\"params\">(darkTheme: <span class=\"type\">Boolean</span> = isSystemInDarkTheme()</span></span>, content: <span class=\"meta\">@Composable</span> () -&gt; <span class=\"built_in\">Unit</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> colors = <span class=\"keyword\">if</span> (darkTheme) &#123;</span><br><span class=\"line\">        DarkColorPalette*</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        LightColorPalette*</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    MaterialTheme(</span><br><span class=\"line\">        colors = colors,</span><br><span class=\"line\">        typography = Typography,</span><br><span class=\"line\">        shapes = Shapes,</span><br><span class=\"line\">        content = content</span><br><span class=\"line\">    )</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>기본 생성된 코드를 보았을 때, Compose는 총 3가지의 구성 요소를 가지는 것으로 추측할 수 있다.</p>\n<ol>\n<li>위젯을 포함하는 Composable 함수</li>\n<li>Preview를 하기 위한 Preview Composable 함수</li>\n<li>setContent 람다 표현식으로 실제 화면에 노출하는 코드</li>\n</ol>\n<p>일반적으로 우리가 아는 Activity의 라이프사이클 콜백 <code>onCreate()</code>에서   <code>setContentView(Int)</code> 함수를 호출하던것이 <code>setContent()</code> 함수로 바뀐것이 가장 큰 특징으로 보여진다.</p>\n<h3 id=\"3-Composable-Function\"><a href=\"#3-Composable-Function\" class=\"headerlink\" title=\"3. Composable Function\"></a>3. Composable Function</h3><p>Composable Function은 어노테이션을 이용한 기술이다. 함수위에 <code>@Composable</code> 어노테이션을 붙이게 되면 함수 안 다른 함수를 호출할 수 있게된다. 아래 코드를 보자.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Composable</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">Greeting</span><span class=\"params\">(names: <span class=\"type\">List</span>&lt;<span class=\"type\">String</span>&gt;)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (name <span class=\"keyword\">in</span> names) &#123;</span><br><span class=\"line\">        Text(<span class=\"string\">&quot;Hello <span class=\"variable\">$name</span>&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>단순하게 내부에는 Text라는 함수가 존재하는데, 이를 통해 UI계층 별 요구하는 컴포넌트를 생성해준다. 기본적으로 보이는 text 파라미터는 내부 속성에서 받는 일부 중 하나이다.</p>\n<h3 id=\"4-TextView-만들기\"><a href=\"#4-TextView-만들기\" class=\"headerlink\" title=\"4. TextView 만들기\"></a>4. TextView 만들기</h3><p>위 코드를 실행시켜보면 당연하게도 Hello로 시작하는 TextView가 화면에 그려질것을 암시한다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setContent &#123;</span><br><span class=\"line\">  BasicsCodelabTheme &#123;</span><br><span class=\"line\">    <span class=\"comment\">// A surface container using the &#x27;background&#x27; color from the theme</span></span><br><span class=\"line\">    Surface(color = MaterialTheme.colors.background) &#123;</span><br><span class=\"line\">      Greeting(<span class=\"string\">&quot;Android&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://imgur.com/aO6Jlsg.jpg\" alt=\"output\"></p>\n<h3 id=\"5-Preview\"><a href=\"#5-Preview\" class=\"headerlink\" title=\"5. @Preview\"></a>5. <code>@Preview</code></h3><p>말 그대로 어노테이션을 이용하여 IDE에서 Preview를하기 위한 용도이다. 아래 코드와 같이 @Preview 어노테이션을 추가하면 다음 결과를 볼 수 있다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Preview(<span class=\"meta-string\">&quot;Greeting Preview&quot;</span>)</span></span><br><span class=\"line\"><span class=\"meta\">@Composable</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">GreetingPreview</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    BasicsCodelabTheme &#123;</span><br><span class=\"line\">        Surface(color = MaterialTheme.colors.background) &#123;</span><br><span class=\"line\">            Greeting(<span class=\"string\">&quot;Android&quot;</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://imgur.com/WprDTs1.jpg\" alt=\"Greeting Preview\"></p>\n<h3 id=\"6-setContent-Theme-Surface\"><a href=\"#6-setContent-Theme-Surface\" class=\"headerlink\" title=\"6. setContent / Theme / Surface\"></a>6. setContent / Theme / Surface</h3><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setContent &#123;</span><br><span class=\"line\">  BasicsCodelabTheme &#123;</span><br><span class=\"line\">    <span class=\"comment\">// A surface container using the &#x27;background&#x27; color from the theme</span></span><br><span class=\"line\">    Surface(color = MaterialTheme.colors.background) &#123;</span><br><span class=\"line\">      Greeting(<span class=\"string\">&quot;Android&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>기존에 onCreate시점에 화면을 그려주기 위한 필수적인 요소를 정리해보자면</p>\n<ul>\n<li><p><strong>setContent</strong> : Activity에서 setContentView함수를 사용하는 것과 동일한 동작을 하는 확장함수이다. 다만, setContent의 경우 (@Composable) -&gt; Unit 타입의 컴포즈 UI를 구현해주어야한다.</p>\n</li>\n<li><p><strong>XXXTheme</strong> : Theme정보를 의미한다. 해당 프로젝트에서는 Theme.kt에 여러 테마에 필요한 정보를 정리하고, 컴포즈 UI 구현을 위한 코드를 작성해두었다.</p>\n</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">val</span> DarkColorPalette = darkColors(</span><br><span class=\"line\">    primary = purple200,</span><br><span class=\"line\">    primaryVariant = purple700,</span><br><span class=\"line\">    secondary = teal200</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">val</span> LightColorPalette = lightColors(</span><br><span class=\"line\">    primary = purple500,</span><br><span class=\"line\">    primaryVariant = purple700,</span><br><span class=\"line\">    secondary = teal200</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Other default colors to override</span></span><br><span class=\"line\"><span class=\"comment\">    background = Color.White,</span></span><br><span class=\"line\"><span class=\"comment\">    surface = Color.White,</span></span><br><span class=\"line\"><span class=\"comment\">    onPrimary = Color.White,</span></span><br><span class=\"line\"><span class=\"comment\">    onSecondary = Color.Black,</span></span><br><span class=\"line\"><span class=\"comment\">    onBackground = Color.Black,</span></span><br><span class=\"line\"><span class=\"comment\">    onSurface = Color.Black,</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Composable</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">BasicsCodelabTheme</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    darkTheme: <span class=\"type\">Boolean</span> = isSystemInDarkTheme()</span></span>,</span><br><span class=\"line\">    content: <span class=\"meta\">@Composable</span> () -&gt; <span class=\"built_in\">Unit</span></span><br><span class=\"line\">) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> colors = <span class=\"keyword\">if</span> (darkTheme) &#123;</span><br><span class=\"line\">        DarkColorPalette</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        LightColorPalette</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    MaterialTheme(</span><br><span class=\"line\">        colors = colors,</span><br><span class=\"line\">        typography = typography,</span><br><span class=\"line\">        shapes = shapes,</span><br><span class=\"line\">        content = content</span><br><span class=\"line\">    )</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>Surface</strong> : Greeting을 감싸는 뷰에 해당한다. 여기서는 크기를 정하지 않고, background 색상을 정의하고 있다. 역시 람다 표현식이다. 색상에 대한 Paramter로 <code>color</code> 라는 값을 사용하여 부여가 가능하다. 내부코드를 보면</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Composable</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">Surface</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    modifier: <span class=\"type\">Modifier</span> = Modifier,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    shape: <span class=\"type\">Shape</span> = RectangleShape,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    color: <span class=\"type\">Color</span> = MaterialTheme.colors.surface,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    contentColor: <span class=\"type\">Color</span> = contentColorFor(color)</span></span>,</span><br><span class=\"line\">    border: BorderStroke? = <span class=\"literal\">null</span>,</span><br><span class=\"line\">    elevation: Dp = <span class=\"number\">0.</span>dp,</span><br><span class=\"line\">    content: <span class=\"meta\">@Composable</span> () -&gt; <span class=\"built_in\">Unit</span></span><br><span class=\"line\">) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> elevationPx = with(LocalDensity.current) &#123; elevation.toPx() &#125;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> elevationOverlay = LocalElevationOverlay.current</span><br><span class=\"line\">    <span class=\"keyword\">val</span> absoluteElevation = LocalAbsoluteElevation.current + elevation</span><br><span class=\"line\">    <span class=\"keyword\">val</span> backgroundColor = <span class=\"keyword\">if</span> (color == MaterialTheme.colors.surface &amp;&amp; elevationOverlay != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        elevationOverlay.apply(color, absoluteElevation)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        color</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    CompositionLocalProvider(</span><br><span class=\"line\">        LocalContentColor provides contentColor,</span><br><span class=\"line\">        LocalAbsoluteElevation provides absoluteElevation</span><br><span class=\"line\">    ) &#123;</span><br><span class=\"line\">        Box(</span><br><span class=\"line\">            modifier.graphicsLayer(shadowElevation = elevationPx, shape = shape)</span><br><span class=\"line\">                .then(<span class=\"keyword\">if</span> (border != <span class=\"literal\">null</span>) Modifier.border(border, shape) <span class=\"keyword\">else</span> Modifier)</span><br><span class=\"line\">                .background(</span><br><span class=\"line\">                    color = backgroundColor,</span><br><span class=\"line\">                    shape = shape</span><br><span class=\"line\">                )</span><br><span class=\"line\">                .clip(shape),</span><br><span class=\"line\">            propagateMinConstraints = <span class=\"literal\">true</span></span><br><span class=\"line\">        ) &#123;</span><br><span class=\"line\">            content()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"7-Declarative-UI-선언형-UI\"><a href=\"#7-Declarative-UI-선언형-UI\" class=\"headerlink\" title=\"7. Declarative UI - 선언형 UI\"></a>7. Declarative UI - 선언형 UI</h3><p>노란색 배경을 입혀 기존 TextView에 추가해보았다. 또한, Greeting에는 Modifier라는 것을 이용하여 Padding을 추가했다. 아래와 같은 결과가 나오게 되었다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BasicsCodelabTheme &#123;</span><br><span class=\"line\">  <span class=\"comment\">// A surface container using the &#x27;background&#x27; color from the theme</span></span><br><span class=\"line\">  Surface(color = Color.Yellow) &#123;</span><br><span class=\"line\">    Greeting(<span class=\"string\">&quot;Android&quot;</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Composable</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">Greeting</span><span class=\"params\">(name: <span class=\"type\">String</span>)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> isSelected <span class=\"keyword\">by</span> remember &#123; mutableStateOf(<span class=\"literal\">false</span>) &#125;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> backgroundColor <span class=\"keyword\">by</span> animateColorAsState(<span class=\"keyword\">if</span> (isSelected) Color.Red <span class=\"keyword\">else</span> Color.Transparent)</span><br><span class=\"line\"></span><br><span class=\"line\">    Text(</span><br><span class=\"line\">        text = <span class=\"string\">&quot;Hello <span class=\"variable\">$name</span>!&quot;</span>,</span><br><span class=\"line\">        modifier = Modifier</span><br><span class=\"line\">            .padding(<span class=\"number\">24.</span>dp)</span><br><span class=\"line\">            .background(color = backgroundColor)</span><br><span class=\"line\">            .clickable(onClick = &#123; isSelected = !isSelected &#125;)</span><br><span class=\"line\">    )</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://imgur.com/qgQ6oY4.jpg\" alt=\"결과\"></p>\n<p>선언형 UI의 장점은 말 그대로 내가 UI를 정의한대로 시각적으로 표현이 가능하다는 장점이 있다. 기존에는 속성을 매번 On/Off와 같은 옵션을 통해 변경하는 것이 다반사였지만, 이제는 매번 속성에 변경이 생길때마다 새로 그려주게 되는것이다.</p>\n<h3 id=\"8-재사용\"><a href=\"#8-재사용\" class=\"headerlink\" title=\"8. 재사용\"></a>8. 재사용</h3><p>Compose의 장점 중 하나는 재사용성이 뛰어난것인데, XML에서 우리가 include 태그를 통해 여러곳에서 갖다쓸 수 있던것처럼, 함수를 통해 여러곳에서 정의하여 사용이 가능하다.</p>\n<p>참고해야할 점은 Compose 컴포넌트 확장 시 <code>@Composable</code> 어노테이션을 붙여야 한다.</p>\n<h3 id=\"9-Container-작성\"><a href=\"#9-Container-작성\" class=\"headerlink\" title=\"9. Container 작성\"></a>9. Container 작성</h3><p>MyApp이라는 이름으로 컴포즈 컴포넌트를 구횬하여 여러곳에서 공통으로 사용할 수 있는 Composable을 구현하였다. 내부적으로 Container내 내가 원하는 컴포넌트를 넣어주려면 아래와 같이 인자로 <code>@Composable () -&gt; Unit</code> 타입을 넘겨받아 처리해주면 된다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Composable</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">MyApp</span><span class=\"params\">(content: @<span class=\"type\">Composable</span> () -&gt; <span class=\"type\">Unit</span>)</span></span> &#123;</span><br><span class=\"line\">    BasicsCodelabTheme &#123;</span><br><span class=\"line\">        Surface(color = Color.Yellow) &#123;</span><br><span class=\"line\">            content()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>위 함수를 통해 이제는 어디서든 반복해서 사용할 수 있는 Container를 구현하게 되어 아래와 같이 코드를 활용할 수 있게되었다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MainActivity</span> : <span class=\"type\">AppCompatActivity</span></span>() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onCreate</span><span class=\"params\">(savedInstanceState: <span class=\"type\">Bundle</span>?)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.onCreate(savedInstanceState)</span><br><span class=\"line\">    setContent &#123;</span><br><span class=\"line\">      MyApp &#123;</span><br><span class=\"line\">        Greeting(<span class=\"string\">&quot;Android&quot;</span>)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"10-레이아웃을-활용한-Compose-function의-다중-호출\"><a href=\"#10-레이아웃을-활용한-Compose-function의-다중-호출\" class=\"headerlink\" title=\"10. 레이아웃을 활용한 Compose function의 다중 호출\"></a>10. 레이아웃을 활용한 Compose function의 다중 호출</h3><p>지금까지는 하나의 컴포넌트만을 갖고 사용했지만, 여러개의 컴포넌트를 넣는것도 가능하다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Composable</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">MyScreenContent</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    Column &#123;</span><br><span class=\"line\">        Greeting(<span class=\"string\">&quot;Android&quot;</span>)</span><br><span class=\"line\">        Divider(color = Color.Black)</span><br><span class=\"line\">        Greeting(<span class=\"string\">&quot;there&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p> <code>Column</code>과 위에서부터 사용하던 <code>Greeting</code> 함수를 사용하고, 라인을 그어주기 위한 <code>Divider</code>를 추가한 결과물은 다음과 같다.</p>\n<p><img src=\"https://imgur.com/VLTxB8C.jpg\" alt=\"multiple component\"></p>\n<p>위 컴포넌트 중 못보던 컴포저블이 있는데, 아래와 같이 설명이 가능하다.</p>\n<ul>\n<li>Column : 항목을 순서대로 배치하기 위해 사용한다.</li>\n<li>Divider : 선 긋기 가능한 Compose 함수이다.</li>\n</ul>\n<p>이를 리스트 형태로도 구현이 가능하다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Composable</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">MyColumnScreen</span><span class=\"params\">(names: <span class=\"type\">List</span>&lt;<span class=\"type\">String</span>&gt; = listOf(<span class=\"string\">&quot;Line One&quot;</span>, <span class=\"string\">&quot;Line Two&quot;</span>)</span></span>) &#123;</span><br><span class=\"line\">    Column &#123;</span><br><span class=\"line\">        names.forEach &#123;</span><br><span class=\"line\">            Greeting(name = it)</span><br><span class=\"line\">            Divider(color = Color.Black)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"11-State-in-Compose-Compose에서의-상태값-관리\"><a href=\"#11-State-in-Compose-Compose에서의-상태값-관리\" class=\"headerlink\" title=\"11. State in Compose - Compose에서의 상태값 관리\"></a>11. State in Compose - Compose에서의 상태값 관리</h3><p>컴포넌트에 버튼을 클릭했을 때 클릭한 카운트를 집계하는 간단한 컴포넌트를 만들어보았다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Composable</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">MyColumnScreen</span><span class=\"params\">(names: <span class=\"type\">List</span>&lt;<span class=\"type\">String</span>&gt; = listOf(<span class=\"string\">&quot;Line One&quot;</span>, <span class=\"string\">&quot;Line Two&quot;</span>)</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> counterState = remember &#123; mutableStateOf(<span class=\"number\">0</span>) &#125; <span class=\"comment\">// </span></span><br><span class=\"line\"></span><br><span class=\"line\">    Column &#123;</span><br><span class=\"line\">        names.forEach &#123;</span><br><span class=\"line\">            Greeting(name = it)</span><br><span class=\"line\">            Divider(color = Color.Black)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Counter(</span><br><span class=\"line\">            count = counterState.value,</span><br><span class=\"line\">            updateCount = &#123; newCount -&gt;</span><br><span class=\"line\">                counterState.value = newCount</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>remember라는 함수를 사용하여 기존에 존재하는 컴포넌트의 상태값을 기억하게 하는 함수가 있다. </p>\n<p><code>remember</code> 함수의 내부를 살펴보자.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Remember the value produced by [calculation]. [calculation] will only be evaluated during the composition.</span></span><br><span class=\"line\"><span class=\"comment\"> * Recomposition will always return the value produced by composition.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@OptIn(ComposeCompilerApi::class)</span></span><br><span class=\"line\"><span class=\"meta\">@Composable</span></span><br><span class=\"line\"><span class=\"keyword\">inline</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"type\">&lt;T&gt;</span> <span class=\"title\">remember</span><span class=\"params\">(calculation: @<span class=\"type\">DisallowComposableCalls</span> () -&gt; <span class=\"type\">T</span>)</span></span>: T =</span><br><span class=\"line\">    currentComposer.cache(<span class=\"literal\">false</span>, calculation)</span><br></pre></td></tr></table></figure>\n\n<p>매 호출마다 Recomposition(재조합)하게되는 경우 컴포넌트에 값을 다시 제공하는 것을 알 수 있다. @Composable 어노테이션에 들어간 함수는 매번 해당 상태를 구독하고, 상태가 변경될때마다 알림을 받아 기존 화면을 갱신해준다.</p>\n<p>그리고, 아래 Counter를 보면 Button을 이용하여 이벤트를 받아 처리하도록 했다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Composable</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">Counter</span><span class=\"params\">(count: <span class=\"type\">Int</span>, updateCount: (<span class=\"type\">Int</span>) -&gt; <span class=\"type\">Unit</span>)</span></span> &#123;</span><br><span class=\"line\">    Button(</span><br><span class=\"line\">        onClick = &#123; updateCount(count + <span class=\"number\">1</span>) &#125;,</span><br><span class=\"line\">        colors = ButtonDefaults.buttonColors(</span><br><span class=\"line\">            backgroundColor = <span class=\"keyword\">if</span> (count &gt; <span class=\"number\">5</span>) Color.Green <span class=\"keyword\">else</span> Color.White</span><br><span class=\"line\">        )</span><br><span class=\"line\">    ) &#123;</span><br><span class=\"line\">        Text(<span class=\"string\">&quot;I&#x27;ve been clicked <span class=\"variable\">$count</span> times&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>updateCount(Int)</code> 함수릉 통해 매번 값을 업데이트 해주는데, 이를 통해 counterState에 값을 넣어주면서 해당 컴포넌트가 매번 변경이 되는것이다.</p>\n<p>따라서 결과를 보면, 다음과 같다. Count가 5가 넘어가면 초록색으로 바뀐다.</p>\n<p><img src=\"https://imgur.com/Ju6BSg2.gif\" alt=\"count\"></p>\n<p>그 외에도 여러형태의 모양을 구성할수 있도록 옵션이 제공되어 있다. 자세한 정보는 나중에 <a href=\"https://developer.android.com/codelabs/jetpack-compose-basics\">Codelabs</a>에 더 나와 있으니 보도록하고, 이번에 setContent에 대한 동작원리를 함께 고민해보자.</p>\n<h3 id=\"12-Activity에서의-View-생성-방식과의-비교\"><a href=\"#12-Activity에서의-View-생성-방식과의-비교\" class=\"headerlink\" title=\"12. Activity에서의 View 생성 방식과의 비교\"></a>12. Activity에서의 View 생성 방식과의 비교</h3><p>Compose를 안드로이드 앱에서 사용하려면 Activity, Fragment와 같은곳에서 contentView로 뿌려줘야한다. 기존에 우리가 사용하던 함수를 보자.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* Set the activity content from a layout resource.  The resource will be</span></span><br><span class=\"line\"><span class=\"comment\">* inflated, adding all top-level views to the activity.</span></span><br><span class=\"line\"><span class=\"comment\">*</span></span><br><span class=\"line\"><span class=\"comment\">* <span class=\"doctag\">@param</span> layoutResID Resource ID to be inflated.</span></span><br><span class=\"line\"><span class=\"comment\">*</span></span><br><span class=\"line\"><span class=\"comment\">* <span class=\"doctag\">@see</span> #setContentView(android.view.View)</span></span><br><span class=\"line\"><span class=\"comment\">* <span class=\"doctag\">@see</span> #setContentView(android.view.View, android.view.ViewGroup.LayoutParams)</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setContentView</span><span class=\"params\">(<span class=\"meta\">@LayoutRes</span> <span class=\"keyword\">int</span> layoutResID)</span> </span>&#123;</span><br><span class=\"line\">  getWindow().setContentView(layoutResID);</span><br><span class=\"line\">  initWindowDecorActionBar();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>UI 컴포넌트에서 화면을 붙일 수 있는 Window라는 녀석에서 Layout Resource Id를 통해 기존에 등록되어있던 Layout XML 파일을 로드하여 인플레이터에서 파싱하고, 이를통해 레이아웃 계층에 있는 뷰객체를 생성하여 순차적으로 ViewGroup, View를 만들어 넣어주게 된다.</p>\n<p><code>PhoneWindow</code>를 보면 자세하게 알 수 있는데, Window를 구현한 setContentView에서 처음에 생성되는 최상위 레이아웃 그 위에 따로 없다면 <code>installDecor()</code> 함수를 통해 mContentParent(레이아웃 리소스가 붙게될 ViewGroup)를 생성하고, 하위에 넣어주게 된다.</p>\n<p>그러면 기존 방식은 이정도로 설명을하고, 이번엔 Compose에서 <code>setContent()</code> 라는 함수를 어떻게 사용하는지 보자.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Composes the given composable into the given activity. The [content] will become the root view</span></span><br><span class=\"line\"><span class=\"comment\"> * of the given activity.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * This is roughly equivalent to calling [ComponentActivity.setContentView] with a [ComposeView]</span></span><br><span class=\"line\"><span class=\"comment\"> * i.e.:</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * ```</span></span><br><span class=\"line\"><span class=\"comment\"> * setContentView(</span></span><br><span class=\"line\"><span class=\"comment\"> *   ComposeView(this).apply &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     setContent &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *       MyComposableContent()</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *   &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * )</span></span><br><span class=\"line\"><span class=\"comment\"> * ```</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> parent The parent composition reference to coordinate scheduling of composition updates</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> content A `<span class=\"doctag\">@Composable</span>` function declaring the UI contents</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">fun</span> ComponentActivity.<span class=\"title\">setContent</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    parent: <span class=\"type\">CompositionContext</span>? = <span class=\"literal\">null</span>,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    content: @<span class=\"type\">Composable</span> () -&gt; <span class=\"type\">Unit</span></span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> existingComposeView = window.decorView</span><br><span class=\"line\">        .findViewById&lt;ViewGroup&gt;(android.R.id.content)</span><br><span class=\"line\">        .getChildAt(<span class=\"number\">0</span>) <span class=\"keyword\">as</span>? ComposeView</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (existingComposeView != <span class=\"literal\">null</span>) with(existingComposeView) &#123;</span><br><span class=\"line\">        setParentCompositionContext(parent)</span><br><span class=\"line\">        setContent(content)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> ComposeView(<span class=\"keyword\">this</span>).apply &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Set content and parent **before** setContentView</span></span><br><span class=\"line\">        <span class=\"comment\">// to have ComposeView create the composition on attach</span></span><br><span class=\"line\">        setParentCompositionContext(parent)</span><br><span class=\"line\">        setContent(content)</span><br><span class=\"line\">        <span class=\"comment\">// Set the view tree owners before setting the content view so that the inflation process</span></span><br><span class=\"line\">        <span class=\"comment\">// and attach listeners will see them already present</span></span><br><span class=\"line\">        setOwners()</span><br><span class=\"line\">        setContentView(<span class=\"keyword\">this</span>, DefaultActivityContentLayoutParams)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>이녀석도 마찬가지로 <code>window.decorView.findViewById&lt;ViewGroup&gt;(android.R.id.content)</code>  함수를 호출하여 decorView를 가져온다. 만약 compose를 통해 만들어진 최상위 레이아웃이 존재하면, 기존에 inflator에서 ViewGroup, View를 생성해서 넣어주던것 처럼 <code>setContent()</code> =&gt; window가 Activity/Fragment에 붙으면 <code>createComposition()</code>를 호출하여 검증 후 <code>ensureCompsositionCreated()</code> 함수를 호출한다. 현재는 내부적으로 <code>ViewGroup.setContent()</code> 를 사용하고 있는데, 곧 교체 될 예정이라고 한다. 이코드도 보면 기존에 있는 ViewGroup에 확장함수로 구현한 녀석인데, 쉽게 말해 ViewGroup에 하위 View, ViewGroup에 Composable로 구현된 함수로 컴포넌트를 넣어줄 때 AndroidComposeView라는 객체를 꺼내오거나 없다면 새로 생성하여 넣어준다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Composes the given composable into the given view.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * The new composition can be logically &quot;linked&quot; to an existing one, by providing a</span></span><br><span class=\"line\"><span class=\"comment\"> * [parent]. This will ensure that invalidations and CompositionLocals will flow through</span></span><br><span class=\"line\"><span class=\"comment\"> * the two compositions as if they were not separate.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Note that this [ViewGroup] should have an unique id for the saved instance state mechanism to</span></span><br><span class=\"line\"><span class=\"comment\"> * be able to save and restore the values used within the composition. See [View.setId].</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> parent The [Recomposer] or parent composition reference.</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> content Composable that will be the content of the view.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">internal</span> <span class=\"function\"><span class=\"keyword\">fun</span> ViewGroup.<span class=\"title\">setContent</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    parent: <span class=\"type\">CompositionContext</span>,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    content: @<span class=\"type\">Composable</span> () -&gt; <span class=\"type\">Unit</span></span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">)</span></span>: Composition &#123;</span><br><span class=\"line\">    GlobalSnapshotManager.ensureStarted()</span><br><span class=\"line\">    <span class=\"keyword\">val</span> composeView =</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (childCount &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            getChildAt(<span class=\"number\">0</span>) <span class=\"keyword\">as</span>? AndroidComposeView</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            removeAllViews(); <span class=\"literal\">null</span></span><br><span class=\"line\">        &#125; ?: AndroidComposeView(context).also &#123; addView(it.view, DefaultLayoutParams) &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> doSetContent(composeView, parent, content)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>다시 돌아와서, ComposeView의 <code>setContent()</code> 이라는 녀석을 보자.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * A [android.view.View] that can host Jetpack Compose UI content.</span></span><br><span class=\"line\"><span class=\"comment\"> * Use [setContent] to supply the content composable function for the view.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * This [android.view.View] requires that the window it is attached to contains a</span></span><br><span class=\"line\"><span class=\"comment\"> * [ViewTreeLifecycleOwner]. This [androidx.lifecycle.LifecycleOwner] is used to</span></span><br><span class=\"line\"><span class=\"comment\"> * [dispose][androidx.compose.runtime.Composition.dispose] of the underlying composition</span></span><br><span class=\"line\"><span class=\"comment\"> * when the host [Lifecycle] is destroyed, permitting the view to be attached and</span></span><br><span class=\"line\"><span class=\"comment\"> * detached repeatedly while preserving the composition. Call [disposeComposition]</span></span><br><span class=\"line\"><span class=\"comment\"> * to dispose of the underlying composition earlier, or if the view is never initially</span></span><br><span class=\"line\"><span class=\"comment\"> * attached to a window. (The requirement to dispose of the composition explicitly</span></span><br><span class=\"line\"><span class=\"comment\"> * in the event that the view is never (re)attached is temporary.)</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ComposeView</span> <span class=\"meta\">@JvmOverloads</span> <span class=\"keyword\">constructor</span></span>(</span><br><span class=\"line\">    context: Context,</span><br><span class=\"line\">    attrs: AttributeSet? = <span class=\"literal\">null</span>,</span><br><span class=\"line\">    defStyleAttr: <span class=\"built_in\">Int</span> = <span class=\"number\">0</span></span><br><span class=\"line\">) : AbstractComposeView(context, attrs, defStyleAttr) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">val</span> content = mutableStateOf&lt;(<span class=\"meta\">@Composable</span> () -&gt; <span class=\"built_in\">Unit</span>)?&gt;(<span class=\"literal\">null</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Suppress(<span class=\"meta-string\">&quot;RedundantVisibilityModifier&quot;</span>)</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">override</span> <span class=\"keyword\">var</span> shouldCreateCompositionOnAttachedToWindow: <span class=\"built_in\">Boolean</span> = <span class=\"literal\">false</span></span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">set</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Composable</span></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">Content</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        content.value?.invoke()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Set the Jetpack Compose UI content for this view.</span></span><br><span class=\"line\"><span class=\"comment\">     * Initial composition will occur when the view becomes attached to a window or when</span></span><br><span class=\"line\"><span class=\"comment\">     * [createComposition] is called, whichever comes first.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">setContent</span><span class=\"params\">(content: @<span class=\"type\">Composable</span> () -&gt; <span class=\"type\">Unit</span>)</span></span> &#123;</span><br><span class=\"line\">        shouldCreateCompositionOnAttachedToWindow = <span class=\"literal\">true</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.content.value = content</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isAttachedToWindow) &#123;</span><br><span class=\"line\">            createComposition()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>결론적으로 <code>AbstractComposeView</code> 라는 녀석은 ViewGroup을 상속받은 녀석이며, 모든 composable의 상태가 변화 되었을 때 이를 감지하는 중요한 녀석이다.</p>\n<p><code>setContent()</code>라는 함수는 위에서 설명했으니 넘어가고, 이번에는 <code>Content</code>라는 녀석을 보자. 이녀석은 추상 메소드로, <code>createComposition()</code> 이라는 함수가 호출 되었을 때, 가장 먼저 불리는 함수이다. 아까 언급되었던 <code>ensureCompsositionCreated()</code> 함수에서 tree계층의 ComposeView가 다 붙었다면, 이후에 즉시 Content함수가 호출이된다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Suppress(<span class=\"meta-string\">&quot;DEPRECATION&quot;</span>)</span> <span class=\"comment\">// Still using ViewGroup.setContent for now</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">ensureCompositionCreated</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (composition == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                creatingComposition = <span class=\"literal\">true</span></span><br><span class=\"line\">                composition = setContent(</span><br><span class=\"line\">                    parentContext ?: findViewTreeCompositionContext() ?: windowRecomposer</span><br><span class=\"line\">                ) &#123;</span><br><span class=\"line\">                    Content() <span class=\"comment\">// 이곳에서 뷰가 다 window에 붙게되면 콜백을 호출한다.</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                creatingComposition = <span class=\"literal\">false</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>그러면 아래 <code>ComposeView</code>의 오버라이딩 된 Content가 호출되면서, 기존에 생성된 View에 UI속성과 같은 Content가 붙게된다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* The Jetpack Compose UI content for this view.</span></span><br><span class=\"line\"><span class=\"comment\">* Subclasses must implement this method to provide content. Initial composition will</span></span><br><span class=\"line\"><span class=\"comment\">* occur when the view becomes attached to a window or when [createComposition] is called,</span></span><br><span class=\"line\"><span class=\"comment\">* whichever comes first.</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"meta\">@Composable</span></span><br><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">Content</span><span class=\"params\">()</span></span></span><br></pre></td></tr></table></figure>\n\n<p>Content는 설명에서 보는것과 같이 <code>createComposition()</code> 함수 호출 후 View가 Window에 붙은 이후 즉시 호출된다.</p>\n<p>최종적으로 <code>ComponentActivity.setContent(CompositionContext?, @Composable () -&gt; Unit)</code> 함수에서 구현된 ComposeView 인스턴스를 ContentLayout을 widht/height를 wrapContent크기로 정하여 ContentView를 Set해주게 된다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Composes the given composable into the given activity. The [content] will become the root view</span></span><br><span class=\"line\"><span class=\"comment\"> * of the given activity.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * This is roughly equivalent to calling [ComponentActivity.setContentView] with a [ComposeView]</span></span><br><span class=\"line\"><span class=\"comment\"> * i.e.:</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * ```</span></span><br><span class=\"line\"><span class=\"comment\"> * setContentView(</span></span><br><span class=\"line\"><span class=\"comment\"> *   ComposeView(this).apply &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     setContent &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *       MyComposableContent()</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *   &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * )</span></span><br><span class=\"line\"><span class=\"comment\"> * ```</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> parent The parent composition reference to coordinate scheduling of composition updates</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> content A `<span class=\"doctag\">@Composable</span>` function declaring the UI contents</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">fun</span> ComponentActivity.<span class=\"title\">setContent</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    parent: <span class=\"type\">CompositionContext</span>? = <span class=\"literal\">null</span>,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    content: @<span class=\"type\">Composable</span> () -&gt; <span class=\"type\">Unit</span></span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">)</span></span> &#123;</span><br><span class=\"line\">  \t...</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> ComposeView(<span class=\"keyword\">this</span>).apply &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Set content and parent **before** setContentView</span></span><br><span class=\"line\">        <span class=\"comment\">// to have ComposeView create the composition on attach</span></span><br><span class=\"line\">        setParentCompositionContext(parent)</span><br><span class=\"line\">        setContent(content)</span><br><span class=\"line\">        <span class=\"comment\">// Set the view tree owners before setting the content view so that the inflation process</span></span><br><span class=\"line\">        <span class=\"comment\">// and attach listeners will see them already present</span></span><br><span class=\"line\">        setOwners()</span><br><span class=\"line\">        setContentView(<span class=\"keyword\">this</span>, DefaultActivityContentLayoutParams)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"13-ComposeView\"><a href=\"#13-ComposeView\" class=\"headerlink\" title=\"13. ComposeView\"></a>13. ComposeView</h3><p>android.view.View 는 Jetpack Compose UI 콘텐츠를 사용할 수 있도록 해줍니다. setContent 를 사용하면 composable function content 를 뷰에 제공할 수 있다.</p>\n<p>Compose 의 계층 구조는 아래와 같으며. ComposeView 를 통해 androidx.compose.materia 에 정의된 다양한 컴포넌트를 조합하여 Composable function 콘텐츠를 구성할 수 있다.</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kotlin.Any</span><br><span class=\"line\"> ↳ android.view.View</span><br><span class=\"line\">   ↳ android.view.ViewGroup</span><br><span class=\"line\">     ↳ androidx.compose.ui.platform.AbstractComposeView</span><br><span class=\"line\">       ↳ androidx.compose.ui.platform.ComposeView</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"14-Compose-Compiler-Compose-Runtime\"><a href=\"#14-Compose-Compiler-Compose-Runtime\" class=\"headerlink\" title=\"14. Compose Compiler / Compose Runtime\"></a>14. Compose Compiler / Compose Runtime</h3><p>Compose Compiler 는 <code>@Composable</code> 이 설정된 경우 Composable function 으로 코드 변환과 코틀린 컴파일러 플러그인과 함께 최적화를 활성화한다.</p>\n<p>Compose Runtime은 Compose의 프로그래밍 모델과 상태 관리, 그리고 Compose 컴파일러를 지정하기 위한 코어 런타임에 대한 기본 설정을 수행한다.</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Composable</span><br><span class=\"line\">fun Greeting(name: String) &#123;</span><br><span class=\"line\">    var greet by remember &#123; mutableStateOf(&quot;Hello $name&quot;) &#125;</span><br><span class=\"line\">    Text(text = greet, color = Color.Red)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>위의 코드는 Compose Compiler에 의해 <code>@Composeable</code>은 아래와 같이 변경된다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">Greeting</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">  $composer: <span class=\"type\">Composer</span>,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">  $static: <span class=\"type\">Int</span>,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">  name: <span class=\"type\">String</span></span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">)</span></span> &#123;</span><br><span class=\"line\">  $composer.start(<span class=\"number\">123</span>)</span><br><span class=\"line\">  <span class=\"keyword\">var</span> greet <span class=\"keyword\">by</span> remember &#123; mutableStateOf(<span class=\"string\">&quot;Hello <span class=\"variable\">$name</span>&quot;</span>) &#125;</span><br><span class=\"line\">  Text(text = greet, color = Color.Red)</span><br><span class=\"line\">  $composer.end()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Compose 는 <code>composer.start</code> 에서 고유의 키를 가지고 있고, 이는 Compose 의 state 가 변경될 때 해당 키를 가진 Compose 만 변경되도록 동작한다.</p>\n<p>static 은 상태(state)의 변경여부를 알 수 있는데 상태의 변화가 없는 경우, <code>composer.start</code> 와 <code>composer.end</code> 사이의 UI 의 변경을 하지 않는다.</p>\n<p>이때 데이터의 상태가 변경되어 UI 를 다시 구성하는 경우는 Recomposition 이라고 한다.</p>\n","site":{"data":{}},"excerpt":"","more":"<p><strong>Author in <a href=\"https://github.com/AndroidDeepDive/Study\">AndroidDeepDive Study</a></strong></p>\n<ul>\n<li>김남훈 @Naver</li>\n<li>배희성 @RocketPunch</li>\n<li>송시영 @SmartStudy</li>\n<li>이기정 @BankSalad</li>\n</ul>\n<h2 id=\"Jetpack-Compose란-무엇인가\"><a href=\"#Jetpack-Compose란-무엇인가\" class=\"headerlink\" title=\"Jetpack Compose란 무엇인가?\"></a>Jetpack Compose란 무엇인가?</h2><img src=\"/Team-Blog/2021/04/07/2021-04-07%20Jetpack%20Compose%20Part%201/compose_animation.gif\" class=\"\" title=\"[compose_animation]\">\n\n<blockquote>\n<p><strong>출처</strong> <a href=\"https://developer.android.com/jetpack/compose\">Android Developers#Jetpack Compse</a></p>\n</blockquote>\n<p>Compose는 Native UI를 코드레벨로 구현할 수 있는 최신 툴킷이다. </p>\n<p>기존의 뷰를 업데이트하는 방식과 달리 Compose를 사용하면 필요한 영역의 뷰를 다시 그려주는 방식으로 작업할 수 있다.</p>\n<p>아래는 아주 간단한 예제이다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Composable</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">Greeting</span><span class=\"params\">(name: <span class=\"type\">String</span>)</span></span> &#123;</span><br><span class=\"line\">\tText(<span class=\"string\">&quot;Hello <span class=\"variable\">$name</span>&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>위의 예제처럼 UI를 구성하는 것이 아니라 화면을 구성하는 뷰의 State 설명하는 것이므로 아무것도 반환하지 않는다.</p>\n<p>아래는 공식 서비스 소개 영상이다.</p>\n<div style=\"width: 560px; height: 315px; float: none; clear: both;\">\n  <embed\n    src=\"https://www.youtube.com/embed/U5BwfqBpiWU\"\n    wmode=\"transparent\"\n    type=\"video/mp4\"\n    width=\"100%\" height=\"100%\"\n    allow=\"autoplay; encrypted-media; picture-in-picture\"\n    allowfullscreen\n  >\n</div>\n\n<h3 id=\"Compose의-4가지-특징\"><a href=\"#Compose의-4가지-특징\" class=\"headerlink\" title=\"Compose의 4가지 특징\"></a>Compose의 4가지 특징</h3><p>구글에서 설명하는 Compose를 이용시 얻을 수 있는 장점은 아래와 같다.</p>\n<ul>\n<li><code>Less Code</code> - 코드 감소<ul>\n<li>적은 수의 코드로 더 많은 작업을 하고 전체 버그 클래스를 방지할 수 있으므로 코드가 간단하며 유지 관리하기 쉽습니다.</li>\n</ul>\n</li>\n<li><code>Intuitive</code> - 직관적<ul>\n<li>UI만 설명하면 나머지는 Compose에서 처리합니다. 앱 상태가 변경되면 UI가 자동으로 업데이트됩니다.</li>\n</ul>\n</li>\n<li><code>Accelerate Development</code> - 빠른 개발 과정<ul>\n<li>기존의 모든 코드와 호환되므로 언제 어디서든 원하는 대로 사용할 수 있습니다. 실시간 미리보기 및 완전한 Android 스튜디오 지원으로 빠르게 반복할 수 있습니다.</li>\n</ul>\n</li>\n<li><code>Powerful</code> - 강력한 성능<ul>\n<li>Android 플랫폼 API에 직접 액세스하고 머티리얼 디자인, 어두운 테마, 애니메이션 등을 기본적으로 지원하는 멋진 앱을 만들 수 있습니다.</li>\n</ul>\n</li>\n</ul>\n<p>늘 그렇듯 구글에서 말하는 설명만 보면 안 쓸 이유가 없어보이고, 대세가 된다면 Android 개발자에게 또 하나의 러닝커브로 작용할 것이다.</p>\n<h2 id=\"Codelab-Jetpack-Compose-basics\"><a href=\"#Codelab-Jetpack-Compose-basics\" class=\"headerlink\" title=\"Codelab - Jetpack Compose basics\"></a>Codelab - Jetpack Compose basics</h2><h3 id=\"1-시작하기전에\"><a href=\"#1-시작하기전에\" class=\"headerlink\" title=\"1. 시작하기전에\"></a>1. 시작하기전에</h3><p>Compose는 아직 정식으로 릴리즈되지 않은 기능이므로 Android Studio Canary에서 프로젝트를 구성하며 몇 가지 제한사항이 존재한다.</p>\n<ol>\n<li>Android Studio Canary </li>\n</ol>\n<p>Canary는 아래 링크에서 다운 받을 수 있다.</p>\n<blockquote>\n<p><a href=\"https://developer.android.com/studio/preview\">Android Studio Preview</a></p>\n</blockquote>\n<ol start=\"2\">\n<li>최신 버전의 Kotlin plugin </li>\n</ol>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ext.kotlin_version = <span class=\"string\">&#x27;1.4.31&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>buildFeatures 및 composeOption 활성화</li>\n</ol>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">android &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    buildFeatures &#123;</span><br><span class=\"line\">        compose <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    composeOptions &#123;</span><br><span class=\"line\">        kotlinCompilerExtensionVersion <span class=\"number\">1.0</span><span class=\"number\">.0</span>-beta02</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    implementation <span class=\"string\">&quot;androidx.compose.ui:ui:1.0.0-beta02&quot;</span></span><br><span class=\"line\">    implementation <span class=\"string\">&quot;androidx.activity:activity-compose:1.3.0-alpha03&quot;</span></span><br><span class=\"line\">    implementation <span class=\"string\">&quot;androidx.compose.material:material:1.0.0-beta02&quot;</span></span><br><span class=\"line\">    implementation <span class=\"string\">&quot;androidx.compose.ui:ui-tooling:1.0.0-beta02&quot;</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-Empty-Compose-프로젝트-생성\"><a href=\"#2-Empty-Compose-프로젝트-생성\" class=\"headerlink\" title=\"2. Empty Compose 프로젝트 생성\"></a>2. Empty Compose 프로젝트 생성</h3><p>[File] - [New] - [New Project…] 를 눌러 새로운 프로젝트를 선택하고(Preview) Empty Compose Activity 를 선택한다.</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/3592/1*5gfrQWfxyEC7Oq6b2xlJ9w.png\"></p>\n<p>선택 이후 Next를 클릭하고, Compose를 구현할 수 있는 최소 API 레벨인 21을 선택해야한다.</p>\n<p>프로젝트를 생성하면 아래와 같이 app/build.gradle에 의존성 설정 및 추가가 되어 있는것을 알 수 있다.</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">android &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    kotlinOptions &#123;</span><br><span class=\"line\">        jvmTarget = <span class=\"string\">&#x27;1.8&#x27;</span></span><br><span class=\"line\">        useIR = <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    buildFeatures &#123;</span><br><span class=\"line\">        compose <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    composeOptions &#123;</span><br><span class=\"line\">        kotlinCompilerExtensionVersion compose_version</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    implementation <span class=\"string\">&quot;androidx.compose.ui:ui:$compose_version&quot;</span></span><br><span class=\"line\">    implementation <span class=\"string\">&quot;androidx.activity:activity-compose:1.3.0-alpha03&quot;</span></span><br><span class=\"line\">    implementation <span class=\"string\">&quot;androidx.compose.material:material:$compose_version&quot;</span></span><br><span class=\"line\">    implementation <span class=\"string\">&quot;androidx.compose.ui:ui-tooling:$compose_version&quot;</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>이때 composeOptions 설정에서 kotlinCompilerVersion 에 따라 compose 가 다르게 동작할 수 있음을 유의하자.</p>\n<p>프로젝트를 생성하면 아래와 같은 기본 파일들이 생성된다.</p>\n<p><strong>MainActivity.kt</strong></p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MainActivity</span> : <span class=\"type\">AppCompatActivity</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onCreate</span><span class=\"params\">(savedInstanceState: <span class=\"type\">Bundle</span>?)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onCreate(savedInstanceState)</span><br><span class=\"line\">        setContent &#123;</span><br><span class=\"line\">            MyFirstComposeApplicationTheme &#123;</span><br><span class=\"line\">                <span class=\"comment\">// A surface container using the &#x27;background&#x27; color from the theme</span></span><br><span class=\"line\">                Surface(color = MaterialTheme.colors.background) &#123;</span><br><span class=\"line\">                    Greeting(<span class=\"string\">&quot;Android&quot;</span>)</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Composable</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">Greeting</span><span class=\"params\">(name: <span class=\"type\">String</span>)</span></span> &#123;</span><br><span class=\"line\">    Text(text = <span class=\"string\">&quot;Hello <span class=\"variable\">$name</span>!&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Preview(showBackground = true)</span></span><br><span class=\"line\"><span class=\"meta\">@Composable</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">DefaultPreview</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    MyFirstComposeApplicationTheme &#123;</span><br><span class=\"line\">        Greeting(<span class=\"string\">&quot;Android&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>ui/theme/Theme.kt</strong></p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">val</span> DarkColorPalette = darkColors(</span><br><span class=\"line\">    primary = Purple200,</span><br><span class=\"line\">    primaryVariant = Purple700,</span><br><span class=\"line\">    secondary = Teal200</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">val</span> LightColorPalette = lightColors(</span><br><span class=\"line\">    primary = Purple500,</span><br><span class=\"line\">    primaryVariant = Purple700,</span><br><span class=\"line\">    secondary = Teal200*</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Other default colors to override</span></span><br><span class=\"line\"><span class=\"comment\">    background = Color.White,</span></span><br><span class=\"line\"><span class=\"comment\">    surface = Color.White,</span></span><br><span class=\"line\"><span class=\"comment\">    onPrimary = Color.White,</span></span><br><span class=\"line\"><span class=\"comment\">    onSecondary = Color.Black,</span></span><br><span class=\"line\"><span class=\"comment\">    onBackground = Color.Black,</span></span><br><span class=\"line\"><span class=\"comment\">    onSurface = Color.Black,</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Composable</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">MyFirstComposeApplicationTheme</span><span class=\"params\">(darkTheme: <span class=\"type\">Boolean</span> = isSystemInDarkTheme()</span></span>, content: <span class=\"meta\">@Composable</span> () -&gt; <span class=\"built_in\">Unit</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> colors = <span class=\"keyword\">if</span> (darkTheme) &#123;</span><br><span class=\"line\">        DarkColorPalette*</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        LightColorPalette*</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    MaterialTheme(</span><br><span class=\"line\">        colors = colors,</span><br><span class=\"line\">        typography = Typography,</span><br><span class=\"line\">        shapes = Shapes,</span><br><span class=\"line\">        content = content</span><br><span class=\"line\">    )</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>기본 생성된 코드를 보았을 때, Compose는 총 3가지의 구성 요소를 가지는 것으로 추측할 수 있다.</p>\n<ol>\n<li>위젯을 포함하는 Composable 함수</li>\n<li>Preview를 하기 위한 Preview Composable 함수</li>\n<li>setContent 람다 표현식으로 실제 화면에 노출하는 코드</li>\n</ol>\n<p>일반적으로 우리가 아는 Activity의 라이프사이클 콜백 <code>onCreate()</code>에서   <code>setContentView(Int)</code> 함수를 호출하던것이 <code>setContent()</code> 함수로 바뀐것이 가장 큰 특징으로 보여진다.</p>\n<h3 id=\"3-Composable-Function\"><a href=\"#3-Composable-Function\" class=\"headerlink\" title=\"3. Composable Function\"></a>3. Composable Function</h3><p>Composable Function은 어노테이션을 이용한 기술이다. 함수위에 <code>@Composable</code> 어노테이션을 붙이게 되면 함수 안 다른 함수를 호출할 수 있게된다. 아래 코드를 보자.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Composable</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">Greeting</span><span class=\"params\">(names: <span class=\"type\">List</span>&lt;<span class=\"type\">String</span>&gt;)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (name <span class=\"keyword\">in</span> names) &#123;</span><br><span class=\"line\">        Text(<span class=\"string\">&quot;Hello <span class=\"variable\">$name</span>&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>단순하게 내부에는 Text라는 함수가 존재하는데, 이를 통해 UI계층 별 요구하는 컴포넌트를 생성해준다. 기본적으로 보이는 text 파라미터는 내부 속성에서 받는 일부 중 하나이다.</p>\n<h3 id=\"4-TextView-만들기\"><a href=\"#4-TextView-만들기\" class=\"headerlink\" title=\"4. TextView 만들기\"></a>4. TextView 만들기</h3><p>위 코드를 실행시켜보면 당연하게도 Hello로 시작하는 TextView가 화면에 그려질것을 암시한다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setContent &#123;</span><br><span class=\"line\">  BasicsCodelabTheme &#123;</span><br><span class=\"line\">    <span class=\"comment\">// A surface container using the &#x27;background&#x27; color from the theme</span></span><br><span class=\"line\">    Surface(color = MaterialTheme.colors.background) &#123;</span><br><span class=\"line\">      Greeting(<span class=\"string\">&quot;Android&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://imgur.com/aO6Jlsg.jpg\" alt=\"output\"></p>\n<h3 id=\"5-Preview\"><a href=\"#5-Preview\" class=\"headerlink\" title=\"5. @Preview\"></a>5. <code>@Preview</code></h3><p>말 그대로 어노테이션을 이용하여 IDE에서 Preview를하기 위한 용도이다. 아래 코드와 같이 @Preview 어노테이션을 추가하면 다음 결과를 볼 수 있다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Preview(<span class=\"meta-string\">&quot;Greeting Preview&quot;</span>)</span></span><br><span class=\"line\"><span class=\"meta\">@Composable</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">GreetingPreview</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    BasicsCodelabTheme &#123;</span><br><span class=\"line\">        Surface(color = MaterialTheme.colors.background) &#123;</span><br><span class=\"line\">            Greeting(<span class=\"string\">&quot;Android&quot;</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://imgur.com/WprDTs1.jpg\" alt=\"Greeting Preview\"></p>\n<h3 id=\"6-setContent-Theme-Surface\"><a href=\"#6-setContent-Theme-Surface\" class=\"headerlink\" title=\"6. setContent / Theme / Surface\"></a>6. setContent / Theme / Surface</h3><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setContent &#123;</span><br><span class=\"line\">  BasicsCodelabTheme &#123;</span><br><span class=\"line\">    <span class=\"comment\">// A surface container using the &#x27;background&#x27; color from the theme</span></span><br><span class=\"line\">    Surface(color = MaterialTheme.colors.background) &#123;</span><br><span class=\"line\">      Greeting(<span class=\"string\">&quot;Android&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>기존에 onCreate시점에 화면을 그려주기 위한 필수적인 요소를 정리해보자면</p>\n<ul>\n<li><p><strong>setContent</strong> : Activity에서 setContentView함수를 사용하는 것과 동일한 동작을 하는 확장함수이다. 다만, setContent의 경우 (@Composable) -&gt; Unit 타입의 컴포즈 UI를 구현해주어야한다.</p>\n</li>\n<li><p><strong>XXXTheme</strong> : Theme정보를 의미한다. 해당 프로젝트에서는 Theme.kt에 여러 테마에 필요한 정보를 정리하고, 컴포즈 UI 구현을 위한 코드를 작성해두었다.</p>\n</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">val</span> DarkColorPalette = darkColors(</span><br><span class=\"line\">    primary = purple200,</span><br><span class=\"line\">    primaryVariant = purple700,</span><br><span class=\"line\">    secondary = teal200</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">val</span> LightColorPalette = lightColors(</span><br><span class=\"line\">    primary = purple500,</span><br><span class=\"line\">    primaryVariant = purple700,</span><br><span class=\"line\">    secondary = teal200</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Other default colors to override</span></span><br><span class=\"line\"><span class=\"comment\">    background = Color.White,</span></span><br><span class=\"line\"><span class=\"comment\">    surface = Color.White,</span></span><br><span class=\"line\"><span class=\"comment\">    onPrimary = Color.White,</span></span><br><span class=\"line\"><span class=\"comment\">    onSecondary = Color.Black,</span></span><br><span class=\"line\"><span class=\"comment\">    onBackground = Color.Black,</span></span><br><span class=\"line\"><span class=\"comment\">    onSurface = Color.Black,</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Composable</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">BasicsCodelabTheme</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    darkTheme: <span class=\"type\">Boolean</span> = isSystemInDarkTheme()</span></span>,</span><br><span class=\"line\">    content: <span class=\"meta\">@Composable</span> () -&gt; <span class=\"built_in\">Unit</span></span><br><span class=\"line\">) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> colors = <span class=\"keyword\">if</span> (darkTheme) &#123;</span><br><span class=\"line\">        DarkColorPalette</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        LightColorPalette</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    MaterialTheme(</span><br><span class=\"line\">        colors = colors,</span><br><span class=\"line\">        typography = typography,</span><br><span class=\"line\">        shapes = shapes,</span><br><span class=\"line\">        content = content</span><br><span class=\"line\">    )</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>Surface</strong> : Greeting을 감싸는 뷰에 해당한다. 여기서는 크기를 정하지 않고, background 색상을 정의하고 있다. 역시 람다 표현식이다. 색상에 대한 Paramter로 <code>color</code> 라는 값을 사용하여 부여가 가능하다. 내부코드를 보면</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Composable</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">Surface</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    modifier: <span class=\"type\">Modifier</span> = Modifier,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    shape: <span class=\"type\">Shape</span> = RectangleShape,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    color: <span class=\"type\">Color</span> = MaterialTheme.colors.surface,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    contentColor: <span class=\"type\">Color</span> = contentColorFor(color)</span></span>,</span><br><span class=\"line\">    border: BorderStroke? = <span class=\"literal\">null</span>,</span><br><span class=\"line\">    elevation: Dp = <span class=\"number\">0.</span>dp,</span><br><span class=\"line\">    content: <span class=\"meta\">@Composable</span> () -&gt; <span class=\"built_in\">Unit</span></span><br><span class=\"line\">) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> elevationPx = with(LocalDensity.current) &#123; elevation.toPx() &#125;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> elevationOverlay = LocalElevationOverlay.current</span><br><span class=\"line\">    <span class=\"keyword\">val</span> absoluteElevation = LocalAbsoluteElevation.current + elevation</span><br><span class=\"line\">    <span class=\"keyword\">val</span> backgroundColor = <span class=\"keyword\">if</span> (color == MaterialTheme.colors.surface &amp;&amp; elevationOverlay != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        elevationOverlay.apply(color, absoluteElevation)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        color</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    CompositionLocalProvider(</span><br><span class=\"line\">        LocalContentColor provides contentColor,</span><br><span class=\"line\">        LocalAbsoluteElevation provides absoluteElevation</span><br><span class=\"line\">    ) &#123;</span><br><span class=\"line\">        Box(</span><br><span class=\"line\">            modifier.graphicsLayer(shadowElevation = elevationPx, shape = shape)</span><br><span class=\"line\">                .then(<span class=\"keyword\">if</span> (border != <span class=\"literal\">null</span>) Modifier.border(border, shape) <span class=\"keyword\">else</span> Modifier)</span><br><span class=\"line\">                .background(</span><br><span class=\"line\">                    color = backgroundColor,</span><br><span class=\"line\">                    shape = shape</span><br><span class=\"line\">                )</span><br><span class=\"line\">                .clip(shape),</span><br><span class=\"line\">            propagateMinConstraints = <span class=\"literal\">true</span></span><br><span class=\"line\">        ) &#123;</span><br><span class=\"line\">            content()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"7-Declarative-UI-선언형-UI\"><a href=\"#7-Declarative-UI-선언형-UI\" class=\"headerlink\" title=\"7. Declarative UI - 선언형 UI\"></a>7. Declarative UI - 선언형 UI</h3><p>노란색 배경을 입혀 기존 TextView에 추가해보았다. 또한, Greeting에는 Modifier라는 것을 이용하여 Padding을 추가했다. 아래와 같은 결과가 나오게 되었다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BasicsCodelabTheme &#123;</span><br><span class=\"line\">  <span class=\"comment\">// A surface container using the &#x27;background&#x27; color from the theme</span></span><br><span class=\"line\">  Surface(color = Color.Yellow) &#123;</span><br><span class=\"line\">    Greeting(<span class=\"string\">&quot;Android&quot;</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Composable</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">Greeting</span><span class=\"params\">(name: <span class=\"type\">String</span>)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> isSelected <span class=\"keyword\">by</span> remember &#123; mutableStateOf(<span class=\"literal\">false</span>) &#125;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> backgroundColor <span class=\"keyword\">by</span> animateColorAsState(<span class=\"keyword\">if</span> (isSelected) Color.Red <span class=\"keyword\">else</span> Color.Transparent)</span><br><span class=\"line\"></span><br><span class=\"line\">    Text(</span><br><span class=\"line\">        text = <span class=\"string\">&quot;Hello <span class=\"variable\">$name</span>!&quot;</span>,</span><br><span class=\"line\">        modifier = Modifier</span><br><span class=\"line\">            .padding(<span class=\"number\">24.</span>dp)</span><br><span class=\"line\">            .background(color = backgroundColor)</span><br><span class=\"line\">            .clickable(onClick = &#123; isSelected = !isSelected &#125;)</span><br><span class=\"line\">    )</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://imgur.com/qgQ6oY4.jpg\" alt=\"결과\"></p>\n<p>선언형 UI의 장점은 말 그대로 내가 UI를 정의한대로 시각적으로 표현이 가능하다는 장점이 있다. 기존에는 속성을 매번 On/Off와 같은 옵션을 통해 변경하는 것이 다반사였지만, 이제는 매번 속성에 변경이 생길때마다 새로 그려주게 되는것이다.</p>\n<h3 id=\"8-재사용\"><a href=\"#8-재사용\" class=\"headerlink\" title=\"8. 재사용\"></a>8. 재사용</h3><p>Compose의 장점 중 하나는 재사용성이 뛰어난것인데, XML에서 우리가 include 태그를 통해 여러곳에서 갖다쓸 수 있던것처럼, 함수를 통해 여러곳에서 정의하여 사용이 가능하다.</p>\n<p>참고해야할 점은 Compose 컴포넌트 확장 시 <code>@Composable</code> 어노테이션을 붙여야 한다.</p>\n<h3 id=\"9-Container-작성\"><a href=\"#9-Container-작성\" class=\"headerlink\" title=\"9. Container 작성\"></a>9. Container 작성</h3><p>MyApp이라는 이름으로 컴포즈 컴포넌트를 구횬하여 여러곳에서 공통으로 사용할 수 있는 Composable을 구현하였다. 내부적으로 Container내 내가 원하는 컴포넌트를 넣어주려면 아래와 같이 인자로 <code>@Composable () -&gt; Unit</code> 타입을 넘겨받아 처리해주면 된다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Composable</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">MyApp</span><span class=\"params\">(content: @<span class=\"type\">Composable</span> () -&gt; <span class=\"type\">Unit</span>)</span></span> &#123;</span><br><span class=\"line\">    BasicsCodelabTheme &#123;</span><br><span class=\"line\">        Surface(color = Color.Yellow) &#123;</span><br><span class=\"line\">            content()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>위 함수를 통해 이제는 어디서든 반복해서 사용할 수 있는 Container를 구현하게 되어 아래와 같이 코드를 활용할 수 있게되었다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MainActivity</span> : <span class=\"type\">AppCompatActivity</span></span>() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onCreate</span><span class=\"params\">(savedInstanceState: <span class=\"type\">Bundle</span>?)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.onCreate(savedInstanceState)</span><br><span class=\"line\">    setContent &#123;</span><br><span class=\"line\">      MyApp &#123;</span><br><span class=\"line\">        Greeting(<span class=\"string\">&quot;Android&quot;</span>)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"10-레이아웃을-활용한-Compose-function의-다중-호출\"><a href=\"#10-레이아웃을-활용한-Compose-function의-다중-호출\" class=\"headerlink\" title=\"10. 레이아웃을 활용한 Compose function의 다중 호출\"></a>10. 레이아웃을 활용한 Compose function의 다중 호출</h3><p>지금까지는 하나의 컴포넌트만을 갖고 사용했지만, 여러개의 컴포넌트를 넣는것도 가능하다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Composable</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">MyScreenContent</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    Column &#123;</span><br><span class=\"line\">        Greeting(<span class=\"string\">&quot;Android&quot;</span>)</span><br><span class=\"line\">        Divider(color = Color.Black)</span><br><span class=\"line\">        Greeting(<span class=\"string\">&quot;there&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p> <code>Column</code>과 위에서부터 사용하던 <code>Greeting</code> 함수를 사용하고, 라인을 그어주기 위한 <code>Divider</code>를 추가한 결과물은 다음과 같다.</p>\n<p><img src=\"https://imgur.com/VLTxB8C.jpg\" alt=\"multiple component\"></p>\n<p>위 컴포넌트 중 못보던 컴포저블이 있는데, 아래와 같이 설명이 가능하다.</p>\n<ul>\n<li>Column : 항목을 순서대로 배치하기 위해 사용한다.</li>\n<li>Divider : 선 긋기 가능한 Compose 함수이다.</li>\n</ul>\n<p>이를 리스트 형태로도 구현이 가능하다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Composable</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">MyColumnScreen</span><span class=\"params\">(names: <span class=\"type\">List</span>&lt;<span class=\"type\">String</span>&gt; = listOf(<span class=\"string\">&quot;Line One&quot;</span>, <span class=\"string\">&quot;Line Two&quot;</span>)</span></span>) &#123;</span><br><span class=\"line\">    Column &#123;</span><br><span class=\"line\">        names.forEach &#123;</span><br><span class=\"line\">            Greeting(name = it)</span><br><span class=\"line\">            Divider(color = Color.Black)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"11-State-in-Compose-Compose에서의-상태값-관리\"><a href=\"#11-State-in-Compose-Compose에서의-상태값-관리\" class=\"headerlink\" title=\"11. State in Compose - Compose에서의 상태값 관리\"></a>11. State in Compose - Compose에서의 상태값 관리</h3><p>컴포넌트에 버튼을 클릭했을 때 클릭한 카운트를 집계하는 간단한 컴포넌트를 만들어보았다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Composable</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">MyColumnScreen</span><span class=\"params\">(names: <span class=\"type\">List</span>&lt;<span class=\"type\">String</span>&gt; = listOf(<span class=\"string\">&quot;Line One&quot;</span>, <span class=\"string\">&quot;Line Two&quot;</span>)</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> counterState = remember &#123; mutableStateOf(<span class=\"number\">0</span>) &#125; <span class=\"comment\">// </span></span><br><span class=\"line\"></span><br><span class=\"line\">    Column &#123;</span><br><span class=\"line\">        names.forEach &#123;</span><br><span class=\"line\">            Greeting(name = it)</span><br><span class=\"line\">            Divider(color = Color.Black)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Counter(</span><br><span class=\"line\">            count = counterState.value,</span><br><span class=\"line\">            updateCount = &#123; newCount -&gt;</span><br><span class=\"line\">                counterState.value = newCount</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>remember라는 함수를 사용하여 기존에 존재하는 컴포넌트의 상태값을 기억하게 하는 함수가 있다. </p>\n<p><code>remember</code> 함수의 내부를 살펴보자.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Remember the value produced by [calculation]. [calculation] will only be evaluated during the composition.</span></span><br><span class=\"line\"><span class=\"comment\"> * Recomposition will always return the value produced by composition.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@OptIn(ComposeCompilerApi::class)</span></span><br><span class=\"line\"><span class=\"meta\">@Composable</span></span><br><span class=\"line\"><span class=\"keyword\">inline</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"type\">&lt;T&gt;</span> <span class=\"title\">remember</span><span class=\"params\">(calculation: @<span class=\"type\">DisallowComposableCalls</span> () -&gt; <span class=\"type\">T</span>)</span></span>: T =</span><br><span class=\"line\">    currentComposer.cache(<span class=\"literal\">false</span>, calculation)</span><br></pre></td></tr></table></figure>\n\n<p>매 호출마다 Recomposition(재조합)하게되는 경우 컴포넌트에 값을 다시 제공하는 것을 알 수 있다. @Composable 어노테이션에 들어간 함수는 매번 해당 상태를 구독하고, 상태가 변경될때마다 알림을 받아 기존 화면을 갱신해준다.</p>\n<p>그리고, 아래 Counter를 보면 Button을 이용하여 이벤트를 받아 처리하도록 했다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Composable</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">Counter</span><span class=\"params\">(count: <span class=\"type\">Int</span>, updateCount: (<span class=\"type\">Int</span>) -&gt; <span class=\"type\">Unit</span>)</span></span> &#123;</span><br><span class=\"line\">    Button(</span><br><span class=\"line\">        onClick = &#123; updateCount(count + <span class=\"number\">1</span>) &#125;,</span><br><span class=\"line\">        colors = ButtonDefaults.buttonColors(</span><br><span class=\"line\">            backgroundColor = <span class=\"keyword\">if</span> (count &gt; <span class=\"number\">5</span>) Color.Green <span class=\"keyword\">else</span> Color.White</span><br><span class=\"line\">        )</span><br><span class=\"line\">    ) &#123;</span><br><span class=\"line\">        Text(<span class=\"string\">&quot;I&#x27;ve been clicked <span class=\"variable\">$count</span> times&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>updateCount(Int)</code> 함수릉 통해 매번 값을 업데이트 해주는데, 이를 통해 counterState에 값을 넣어주면서 해당 컴포넌트가 매번 변경이 되는것이다.</p>\n<p>따라서 결과를 보면, 다음과 같다. Count가 5가 넘어가면 초록색으로 바뀐다.</p>\n<p><img src=\"https://imgur.com/Ju6BSg2.gif\" alt=\"count\"></p>\n<p>그 외에도 여러형태의 모양을 구성할수 있도록 옵션이 제공되어 있다. 자세한 정보는 나중에 <a href=\"https://developer.android.com/codelabs/jetpack-compose-basics\">Codelabs</a>에 더 나와 있으니 보도록하고, 이번에 setContent에 대한 동작원리를 함께 고민해보자.</p>\n<h3 id=\"12-Activity에서의-View-생성-방식과의-비교\"><a href=\"#12-Activity에서의-View-생성-방식과의-비교\" class=\"headerlink\" title=\"12. Activity에서의 View 생성 방식과의 비교\"></a>12. Activity에서의 View 생성 방식과의 비교</h3><p>Compose를 안드로이드 앱에서 사용하려면 Activity, Fragment와 같은곳에서 contentView로 뿌려줘야한다. 기존에 우리가 사용하던 함수를 보자.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* Set the activity content from a layout resource.  The resource will be</span></span><br><span class=\"line\"><span class=\"comment\">* inflated, adding all top-level views to the activity.</span></span><br><span class=\"line\"><span class=\"comment\">*</span></span><br><span class=\"line\"><span class=\"comment\">* <span class=\"doctag\">@param</span> layoutResID Resource ID to be inflated.</span></span><br><span class=\"line\"><span class=\"comment\">*</span></span><br><span class=\"line\"><span class=\"comment\">* <span class=\"doctag\">@see</span> #setContentView(android.view.View)</span></span><br><span class=\"line\"><span class=\"comment\">* <span class=\"doctag\">@see</span> #setContentView(android.view.View, android.view.ViewGroup.LayoutParams)</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setContentView</span><span class=\"params\">(<span class=\"meta\">@LayoutRes</span> <span class=\"keyword\">int</span> layoutResID)</span> </span>&#123;</span><br><span class=\"line\">  getWindow().setContentView(layoutResID);</span><br><span class=\"line\">  initWindowDecorActionBar();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>UI 컴포넌트에서 화면을 붙일 수 있는 Window라는 녀석에서 Layout Resource Id를 통해 기존에 등록되어있던 Layout XML 파일을 로드하여 인플레이터에서 파싱하고, 이를통해 레이아웃 계층에 있는 뷰객체를 생성하여 순차적으로 ViewGroup, View를 만들어 넣어주게 된다.</p>\n<p><code>PhoneWindow</code>를 보면 자세하게 알 수 있는데, Window를 구현한 setContentView에서 처음에 생성되는 최상위 레이아웃 그 위에 따로 없다면 <code>installDecor()</code> 함수를 통해 mContentParent(레이아웃 리소스가 붙게될 ViewGroup)를 생성하고, 하위에 넣어주게 된다.</p>\n<p>그러면 기존 방식은 이정도로 설명을하고, 이번엔 Compose에서 <code>setContent()</code> 라는 함수를 어떻게 사용하는지 보자.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Composes the given composable into the given activity. The [content] will become the root view</span></span><br><span class=\"line\"><span class=\"comment\"> * of the given activity.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * This is roughly equivalent to calling [ComponentActivity.setContentView] with a [ComposeView]</span></span><br><span class=\"line\"><span class=\"comment\"> * i.e.:</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * ```</span></span><br><span class=\"line\"><span class=\"comment\"> * setContentView(</span></span><br><span class=\"line\"><span class=\"comment\"> *   ComposeView(this).apply &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     setContent &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *       MyComposableContent()</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *   &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * )</span></span><br><span class=\"line\"><span class=\"comment\"> * ```</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> parent The parent composition reference to coordinate scheduling of composition updates</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> content A `<span class=\"doctag\">@Composable</span>` function declaring the UI contents</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">fun</span> ComponentActivity.<span class=\"title\">setContent</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    parent: <span class=\"type\">CompositionContext</span>? = <span class=\"literal\">null</span>,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    content: @<span class=\"type\">Composable</span> () -&gt; <span class=\"type\">Unit</span></span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> existingComposeView = window.decorView</span><br><span class=\"line\">        .findViewById&lt;ViewGroup&gt;(android.R.id.content)</span><br><span class=\"line\">        .getChildAt(<span class=\"number\">0</span>) <span class=\"keyword\">as</span>? ComposeView</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (existingComposeView != <span class=\"literal\">null</span>) with(existingComposeView) &#123;</span><br><span class=\"line\">        setParentCompositionContext(parent)</span><br><span class=\"line\">        setContent(content)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> ComposeView(<span class=\"keyword\">this</span>).apply &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Set content and parent **before** setContentView</span></span><br><span class=\"line\">        <span class=\"comment\">// to have ComposeView create the composition on attach</span></span><br><span class=\"line\">        setParentCompositionContext(parent)</span><br><span class=\"line\">        setContent(content)</span><br><span class=\"line\">        <span class=\"comment\">// Set the view tree owners before setting the content view so that the inflation process</span></span><br><span class=\"line\">        <span class=\"comment\">// and attach listeners will see them already present</span></span><br><span class=\"line\">        setOwners()</span><br><span class=\"line\">        setContentView(<span class=\"keyword\">this</span>, DefaultActivityContentLayoutParams)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>이녀석도 마찬가지로 <code>window.decorView.findViewById&lt;ViewGroup&gt;(android.R.id.content)</code>  함수를 호출하여 decorView를 가져온다. 만약 compose를 통해 만들어진 최상위 레이아웃이 존재하면, 기존에 inflator에서 ViewGroup, View를 생성해서 넣어주던것 처럼 <code>setContent()</code> =&gt; window가 Activity/Fragment에 붙으면 <code>createComposition()</code>를 호출하여 검증 후 <code>ensureCompsositionCreated()</code> 함수를 호출한다. 현재는 내부적으로 <code>ViewGroup.setContent()</code> 를 사용하고 있는데, 곧 교체 될 예정이라고 한다. 이코드도 보면 기존에 있는 ViewGroup에 확장함수로 구현한 녀석인데, 쉽게 말해 ViewGroup에 하위 View, ViewGroup에 Composable로 구현된 함수로 컴포넌트를 넣어줄 때 AndroidComposeView라는 객체를 꺼내오거나 없다면 새로 생성하여 넣어준다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Composes the given composable into the given view.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * The new composition can be logically &quot;linked&quot; to an existing one, by providing a</span></span><br><span class=\"line\"><span class=\"comment\"> * [parent]. This will ensure that invalidations and CompositionLocals will flow through</span></span><br><span class=\"line\"><span class=\"comment\"> * the two compositions as if they were not separate.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Note that this [ViewGroup] should have an unique id for the saved instance state mechanism to</span></span><br><span class=\"line\"><span class=\"comment\"> * be able to save and restore the values used within the composition. See [View.setId].</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> parent The [Recomposer] or parent composition reference.</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> content Composable that will be the content of the view.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">internal</span> <span class=\"function\"><span class=\"keyword\">fun</span> ViewGroup.<span class=\"title\">setContent</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    parent: <span class=\"type\">CompositionContext</span>,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    content: @<span class=\"type\">Composable</span> () -&gt; <span class=\"type\">Unit</span></span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">)</span></span>: Composition &#123;</span><br><span class=\"line\">    GlobalSnapshotManager.ensureStarted()</span><br><span class=\"line\">    <span class=\"keyword\">val</span> composeView =</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (childCount &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            getChildAt(<span class=\"number\">0</span>) <span class=\"keyword\">as</span>? AndroidComposeView</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            removeAllViews(); <span class=\"literal\">null</span></span><br><span class=\"line\">        &#125; ?: AndroidComposeView(context).also &#123; addView(it.view, DefaultLayoutParams) &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> doSetContent(composeView, parent, content)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>다시 돌아와서, ComposeView의 <code>setContent()</code> 이라는 녀석을 보자.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * A [android.view.View] that can host Jetpack Compose UI content.</span></span><br><span class=\"line\"><span class=\"comment\"> * Use [setContent] to supply the content composable function for the view.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * This [android.view.View] requires that the window it is attached to contains a</span></span><br><span class=\"line\"><span class=\"comment\"> * [ViewTreeLifecycleOwner]. This [androidx.lifecycle.LifecycleOwner] is used to</span></span><br><span class=\"line\"><span class=\"comment\"> * [dispose][androidx.compose.runtime.Composition.dispose] of the underlying composition</span></span><br><span class=\"line\"><span class=\"comment\"> * when the host [Lifecycle] is destroyed, permitting the view to be attached and</span></span><br><span class=\"line\"><span class=\"comment\"> * detached repeatedly while preserving the composition. Call [disposeComposition]</span></span><br><span class=\"line\"><span class=\"comment\"> * to dispose of the underlying composition earlier, or if the view is never initially</span></span><br><span class=\"line\"><span class=\"comment\"> * attached to a window. (The requirement to dispose of the composition explicitly</span></span><br><span class=\"line\"><span class=\"comment\"> * in the event that the view is never (re)attached is temporary.)</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ComposeView</span> <span class=\"meta\">@JvmOverloads</span> <span class=\"keyword\">constructor</span></span>(</span><br><span class=\"line\">    context: Context,</span><br><span class=\"line\">    attrs: AttributeSet? = <span class=\"literal\">null</span>,</span><br><span class=\"line\">    defStyleAttr: <span class=\"built_in\">Int</span> = <span class=\"number\">0</span></span><br><span class=\"line\">) : AbstractComposeView(context, attrs, defStyleAttr) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">val</span> content = mutableStateOf&lt;(<span class=\"meta\">@Composable</span> () -&gt; <span class=\"built_in\">Unit</span>)?&gt;(<span class=\"literal\">null</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Suppress(<span class=\"meta-string\">&quot;RedundantVisibilityModifier&quot;</span>)</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">override</span> <span class=\"keyword\">var</span> shouldCreateCompositionOnAttachedToWindow: <span class=\"built_in\">Boolean</span> = <span class=\"literal\">false</span></span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">set</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Composable</span></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">Content</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        content.value?.invoke()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Set the Jetpack Compose UI content for this view.</span></span><br><span class=\"line\"><span class=\"comment\">     * Initial composition will occur when the view becomes attached to a window or when</span></span><br><span class=\"line\"><span class=\"comment\">     * [createComposition] is called, whichever comes first.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">setContent</span><span class=\"params\">(content: @<span class=\"type\">Composable</span> () -&gt; <span class=\"type\">Unit</span>)</span></span> &#123;</span><br><span class=\"line\">        shouldCreateCompositionOnAttachedToWindow = <span class=\"literal\">true</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.content.value = content</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isAttachedToWindow) &#123;</span><br><span class=\"line\">            createComposition()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>결론적으로 <code>AbstractComposeView</code> 라는 녀석은 ViewGroup을 상속받은 녀석이며, 모든 composable의 상태가 변화 되었을 때 이를 감지하는 중요한 녀석이다.</p>\n<p><code>setContent()</code>라는 함수는 위에서 설명했으니 넘어가고, 이번에는 <code>Content</code>라는 녀석을 보자. 이녀석은 추상 메소드로, <code>createComposition()</code> 이라는 함수가 호출 되었을 때, 가장 먼저 불리는 함수이다. 아까 언급되었던 <code>ensureCompsositionCreated()</code> 함수에서 tree계층의 ComposeView가 다 붙었다면, 이후에 즉시 Content함수가 호출이된다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Suppress(<span class=\"meta-string\">&quot;DEPRECATION&quot;</span>)</span> <span class=\"comment\">// Still using ViewGroup.setContent for now</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">ensureCompositionCreated</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (composition == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                creatingComposition = <span class=\"literal\">true</span></span><br><span class=\"line\">                composition = setContent(</span><br><span class=\"line\">                    parentContext ?: findViewTreeCompositionContext() ?: windowRecomposer</span><br><span class=\"line\">                ) &#123;</span><br><span class=\"line\">                    Content() <span class=\"comment\">// 이곳에서 뷰가 다 window에 붙게되면 콜백을 호출한다.</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                creatingComposition = <span class=\"literal\">false</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>그러면 아래 <code>ComposeView</code>의 오버라이딩 된 Content가 호출되면서, 기존에 생성된 View에 UI속성과 같은 Content가 붙게된다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* The Jetpack Compose UI content for this view.</span></span><br><span class=\"line\"><span class=\"comment\">* Subclasses must implement this method to provide content. Initial composition will</span></span><br><span class=\"line\"><span class=\"comment\">* occur when the view becomes attached to a window or when [createComposition] is called,</span></span><br><span class=\"line\"><span class=\"comment\">* whichever comes first.</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"meta\">@Composable</span></span><br><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">Content</span><span class=\"params\">()</span></span></span><br></pre></td></tr></table></figure>\n\n<p>Content는 설명에서 보는것과 같이 <code>createComposition()</code> 함수 호출 후 View가 Window에 붙은 이후 즉시 호출된다.</p>\n<p>최종적으로 <code>ComponentActivity.setContent(CompositionContext?, @Composable () -&gt; Unit)</code> 함수에서 구현된 ComposeView 인스턴스를 ContentLayout을 widht/height를 wrapContent크기로 정하여 ContentView를 Set해주게 된다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Composes the given composable into the given activity. The [content] will become the root view</span></span><br><span class=\"line\"><span class=\"comment\"> * of the given activity.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * This is roughly equivalent to calling [ComponentActivity.setContentView] with a [ComposeView]</span></span><br><span class=\"line\"><span class=\"comment\"> * i.e.:</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * ```</span></span><br><span class=\"line\"><span class=\"comment\"> * setContentView(</span></span><br><span class=\"line\"><span class=\"comment\"> *   ComposeView(this).apply &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     setContent &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *       MyComposableContent()</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *   &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * )</span></span><br><span class=\"line\"><span class=\"comment\"> * ```</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> parent The parent composition reference to coordinate scheduling of composition updates</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> content A `<span class=\"doctag\">@Composable</span>` function declaring the UI contents</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">fun</span> ComponentActivity.<span class=\"title\">setContent</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    parent: <span class=\"type\">CompositionContext</span>? = <span class=\"literal\">null</span>,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    content: @<span class=\"type\">Composable</span> () -&gt; <span class=\"type\">Unit</span></span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">)</span></span> &#123;</span><br><span class=\"line\">  \t...</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> ComposeView(<span class=\"keyword\">this</span>).apply &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Set content and parent **before** setContentView</span></span><br><span class=\"line\">        <span class=\"comment\">// to have ComposeView create the composition on attach</span></span><br><span class=\"line\">        setParentCompositionContext(parent)</span><br><span class=\"line\">        setContent(content)</span><br><span class=\"line\">        <span class=\"comment\">// Set the view tree owners before setting the content view so that the inflation process</span></span><br><span class=\"line\">        <span class=\"comment\">// and attach listeners will see them already present</span></span><br><span class=\"line\">        setOwners()</span><br><span class=\"line\">        setContentView(<span class=\"keyword\">this</span>, DefaultActivityContentLayoutParams)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"13-ComposeView\"><a href=\"#13-ComposeView\" class=\"headerlink\" title=\"13. ComposeView\"></a>13. ComposeView</h3><p>android.view.View 는 Jetpack Compose UI 콘텐츠를 사용할 수 있도록 해줍니다. setContent 를 사용하면 composable function content 를 뷰에 제공할 수 있다.</p>\n<p>Compose 의 계층 구조는 아래와 같으며. ComposeView 를 통해 androidx.compose.materia 에 정의된 다양한 컴포넌트를 조합하여 Composable function 콘텐츠를 구성할 수 있다.</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kotlin.Any</span><br><span class=\"line\"> ↳ android.view.View</span><br><span class=\"line\">   ↳ android.view.ViewGroup</span><br><span class=\"line\">     ↳ androidx.compose.ui.platform.AbstractComposeView</span><br><span class=\"line\">       ↳ androidx.compose.ui.platform.ComposeView</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"14-Compose-Compiler-Compose-Runtime\"><a href=\"#14-Compose-Compiler-Compose-Runtime\" class=\"headerlink\" title=\"14. Compose Compiler / Compose Runtime\"></a>14. Compose Compiler / Compose Runtime</h3><p>Compose Compiler 는 <code>@Composable</code> 이 설정된 경우 Composable function 으로 코드 변환과 코틀린 컴파일러 플러그인과 함께 최적화를 활성화한다.</p>\n<p>Compose Runtime은 Compose의 프로그래밍 모델과 상태 관리, 그리고 Compose 컴파일러를 지정하기 위한 코어 런타임에 대한 기본 설정을 수행한다.</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Composable</span><br><span class=\"line\">fun Greeting(name: String) &#123;</span><br><span class=\"line\">    var greet by remember &#123; mutableStateOf(&quot;Hello $name&quot;) &#125;</span><br><span class=\"line\">    Text(text = greet, color = Color.Red)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>위의 코드는 Compose Compiler에 의해 <code>@Composeable</code>은 아래와 같이 변경된다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">Greeting</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">  $composer: <span class=\"type\">Composer</span>,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">  $static: <span class=\"type\">Int</span>,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">  name: <span class=\"type\">String</span></span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">)</span></span> &#123;</span><br><span class=\"line\">  $composer.start(<span class=\"number\">123</span>)</span><br><span class=\"line\">  <span class=\"keyword\">var</span> greet <span class=\"keyword\">by</span> remember &#123; mutableStateOf(<span class=\"string\">&quot;Hello <span class=\"variable\">$name</span>&quot;</span>) &#125;</span><br><span class=\"line\">  Text(text = greet, color = Color.Red)</span><br><span class=\"line\">  $composer.end()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Compose 는 <code>composer.start</code> 에서 고유의 키를 가지고 있고, 이는 Compose 의 state 가 변경될 때 해당 키를 가진 Compose 만 변경되도록 동작한다.</p>\n<p>static 은 상태(state)의 변경여부를 알 수 있는데 상태의 변화가 없는 경우, <code>composer.start</code> 와 <code>composer.end</code> 사이의 UI 의 변경을 하지 않는다.</p>\n<p>이때 데이터의 상태가 변경되어 UI 를 다시 구성하는 경우는 Recomposition 이라고 한다.</p>"}],"PostAsset":[{"_id":"source/_posts/2021-04-07 Jetpack Compose Part 1/compose_animation.gif","slug":"compose_animation.gif","post":"ckrir2hpe0005peregel33vbc","modified":0,"renderable":0}],"PostCategory":[{"post_id":"ckrir2hpe0005peregel33vbc","category_id":"ckrioxi5h0001r2re44eo0yfu","_id":"ckrir2hph0008peredr4i2yh3"}],"PostTag":[{"post_id":"ckrir2hpe0005peregel33vbc","tag_id":"ckrioxi5j0002r2re27e5ayme","_id":"ckrir2hph0006pere1gmh8srv"},{"post_id":"ckrir2hpe0005peregel33vbc","tag_id":"ckrioxi5k0003r2re420j0wmb","_id":"ckrir2hph0007peredhtyd4sw"},{"post_id":"ckrir2hpe0005peregel33vbc","tag_id":"ckrioxi5k0005r2re2cx39u2k","_id":"ckrir2hph0009pere9sb01oj9"}],"Tag":[{"name":"Android","_id":"ckrioxi5j0002r2re27e5ayme"},{"name":"Jetpack","_id":"ckrioxi5k0003r2re420j0wmb"},{"name":"Compose","_id":"ckrioxi5k0005r2re2cx39u2k"}]}}