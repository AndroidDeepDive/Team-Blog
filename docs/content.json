{"pages":[],"posts":[{"title":"Jetpack Compose Part 1 - Compose 소개 및 코드랩 따라하기","text":"Writers by 김남훈 @Naver by 배희성 @RocketPunch by 송시영 @SmartStudy by 이기정 @BankSalad Jetpack Compose란 무엇인가? 출처 Android Developers#Jetpack Compse Compose는 Native UI를 코드레벨로 구현할 수 있는 최신 툴킷이다. 기존의 뷰를 업데이트하는 방식과 달리 Compose를 사용하면 필요한 영역의 뷰를 다시 그려주는 방식으로 작업할 수 있다. 아래는 아주 간단한 예제이다. 1234@Composablefun Greeting(name: String) { Text(&quot;Hello $name&quot;)} 위의 예제처럼 UI를 구성하는 것이 아니라 화면을 구성하는 뷰의 State 설명하는 것이므로 아무것도 반환하지 않는다. 아래는 공식 서비스 소개 영상이다. Compose의 4가지 특징구글에서 설명하는 Compose를 이용시 얻을 수 있는 장점은 아래와 같다. Less Code - 코드 감소 적은 수의 코드로 더 많은 작업을 하고 전체 버그 클래스를 방지할 수 있으므로 코드가 간단하며 유지 관리하기 쉽습니다. Intuitive - 직관적 UI만 설명하면 나머지는 Compose에서 처리합니다. 앱 상태가 변경되면 UI가 자동으로 업데이트됩니다. Accelerate Development - 빠른 개발 과정 기존의 모든 코드와 호환되므로 언제 어디서든 원하는 대로 사용할 수 있습니다. 실시간 미리보기 및 완전한 Android 스튜디오 지원으로 빠르게 반복할 수 있습니다. Powerful - 강력한 성능 Android 플랫폼 API에 직접 액세스하고 머티리얼 디자인, 어두운 테마, 애니메이션 등을 기본적으로 지원하는 멋진 앱을 만들 수 있습니다. 늘 그렇듯 구글에서 말하는 설명만 보면 안 쓸 이유가 없어보이고, 대세가 된다면 Android 개발자에게 또 하나의 러닝커브로 작용할 것이다. Codelab - Jetpack Compose basics1. 시작하기전에Compose는 아직 정식으로 릴리즈되지 않은 기능이므로 Android Studio Canary에서 프로젝트를 구성하며 몇 가지 제한사항이 존재한다. Android Studio Canary Canary는 아래 링크에서 다운 받을 수 있다. Android Studio Preview 최신 버전의 Kotlin plugin 1ext.kotlin_version = '1.4.31' buildFeatures 및 composeOption 활성화 123456789101112131415161718android { ... buildFeatures { compose true } composeOptions { kotlinCompilerExtensionVersion 1.0.0-beta02 }}dependencies { ... implementation &quot;androidx.compose.ui:ui:1.0.0-beta02&quot; implementation &quot;androidx.activity:activity-compose:1.3.0-alpha03&quot; implementation &quot;androidx.compose.material:material:1.0.0-beta02&quot; implementation &quot;androidx.compose.ui:ui-tooling:1.0.0-beta02&quot; ...} 2. Empty Compose 프로젝트 생성[File] - [New] - [New Project…] 를 눌러 새로운 프로젝트를 선택하고(Preview) Empty Compose Activity 를 선택한다. 선택 이후 Next를 클릭하고, Compose를 구현할 수 있는 최소 API 레벨인 21을 선택해야한다. 프로젝트를 생성하면 아래와 같이 app/build.gradle에 의존성 설정 및 추가가 되어 있는것을 알 수 있다. 12345678910111213141516171819202122android { ... kotlinOptions { jvmTarget = '1.8' useIR = true } buildFeatures { compose true } composeOptions { kotlinCompilerExtensionVersion compose_version }}dependencies { ... implementation &quot;androidx.compose.ui:ui:$compose_version&quot; implementation &quot;androidx.activity:activity-compose:1.3.0-alpha03&quot; implementation &quot;androidx.compose.material:material:$compose_version&quot; implementation &quot;androidx.compose.ui:ui-tooling:$compose_version&quot; ...} 이때 composeOptions 설정에서 kotlinCompilerVersion 에 따라 compose 가 다르게 동작할 수 있음을 유의하자. 프로젝트를 생성하면 아래와 같은 기본 파일들이 생성된다. MainActivity.kt 1234567891011121314151617181920212223242526class MainActivity : AppCompatActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { MyFirstComposeApplicationTheme { // A surface container using the 'background' color from the theme Surface(color = MaterialTheme.colors.background) { Greeting(&quot;Android&quot;) } } } }}@Composablefun Greeting(name: String) { Text(text = &quot;Hello $name!&quot;)}@Preview(showBackground = true)@Composablefun DefaultPreview() { MyFirstComposeApplicationTheme { Greeting(&quot;Android&quot;) }} ui/theme/Theme.kt 123456789101112131415161718192021222324252627282930313233343536private val DarkColorPalette = darkColors( primary = Purple200, primaryVariant = Purple700, secondary = Teal200)private val LightColorPalette = lightColors( primary = Purple500, primaryVariant = Purple700, secondary = Teal200* /* Other default colors to override background = Color.White, surface = Color.White, onPrimary = Color.White, onSecondary = Color.Black, onBackground = Color.Black, onSurface = Color.Black, */)@Composablefun MyFirstComposeApplicationTheme(darkTheme: Boolean = isSystemInDarkTheme(), content: @Composable () -&gt; Unit) { val colors = if (darkTheme) { DarkColorPalette* } else { LightColorPalette* } MaterialTheme( colors = colors, typography = Typography, shapes = Shapes, content = content )} 기본 생성된 코드를 보았을 때, Compose는 총 3가지의 구성 요소를 가지는 것으로 추측할 수 있다. 위젯을 포함하는 Composable 함수 Preview를 하기 위한 Preview Composable 함수 setContent 람다 표현식으로 실제 화면에 노출하는 코드 일반적으로 우리가 아는 Activity의 라이프사이클 콜백 onCreate()에서 setContentView(Int) 함수를 호출하던것이 setContent() 함수로 바뀐것이 가장 큰 특징으로 보여진다. 3. Composable FunctionComposable Function은 어노테이션을 이용한 기술이다. 함수위에 @Composable 어노테이션을 붙이게 되면 함수 안 다른 함수를 호출할 수 있게된다. 아래 코드를 보자. 123456@Composablefun Greeting(names: List&lt;String&gt;) { for (name in names) { Text(&quot;Hello $name&quot;) }} 단순하게 내부에는 Text라는 함수가 존재하는데, 이를 통해 UI계층 별 요구하는 컴포넌트를 생성해준다. 기본적으로 보이는 text 파라미터는 내부 속성에서 받는 일부 중 하나이다. 4. TextView 만들기위 코드를 실행시켜보면 당연하게도 Hello로 시작하는 TextView가 화면에 그려질것을 암시한다. 12345678setContent { BasicsCodelabTheme { // A surface container using the 'background' color from the theme Surface(color = MaterialTheme.colors.background) { Greeting(&quot;Android&quot;) } }} 5. @Preview말 그대로 어노테이션을 이용하여 IDE에서 Preview를하기 위한 용도이다. 아래 코드와 같이 @Preview 어노테이션을 추가하면 다음 결과를 볼 수 있다. 123456789@Preview(&quot;Greeting Preview&quot;)@Composablefun GreetingPreview() { BasicsCodelabTheme { Surface(color = MaterialTheme.colors.background) { Greeting(&quot;Android&quot;) } }} 6. setContent / Theme / Surface12345678setContent { BasicsCodelabTheme { // A surface container using the 'background' color from the theme Surface(color = MaterialTheme.colors.background) { Greeting(&quot;Android&quot;) } }} 기존에 onCreate시점에 화면을 그려주기 위한 필수적인 요소를 정리해보자면 setContent : Activity에서 setContentView함수를 사용하는 것과 동일한 동작을 하는 확장함수이다. 다만, setContent의 경우 (@Composable) -&gt; Unit 타입의 컴포즈 UI를 구현해주어야한다. XXXTheme : Theme정보를 의미한다. 해당 프로젝트에서는 Theme.kt에 여러 테마에 필요한 정보를 정리하고, 컴포즈 UI 구현을 위한 코드를 작성해두었다. 123456789101112131415161718192021222324252627282930313233343536373839private val DarkColorPalette = darkColors( primary = purple200, primaryVariant = purple700, secondary = teal200)private val LightColorPalette = lightColors( primary = purple500, primaryVariant = purple700, secondary = teal200 /* Other default colors to override background = Color.White, surface = Color.White, onPrimary = Color.White, onSecondary = Color.Black, onBackground = Color.Black, onSurface = Color.Black, */)@Composablefun BasicsCodelabTheme( darkTheme: Boolean = isSystemInDarkTheme(), content: @Composable () -&gt; Unit) { val colors = if (darkTheme) { DarkColorPalette } else { LightColorPalette } MaterialTheme( colors = colors, typography = typography, shapes = shapes, content = content )} Surface : Greeting을 감싸는 뷰에 해당한다. 여기서는 크기를 정하지 않고, background 색상을 정의하고 있다. 역시 람다 표현식이다. 색상에 대한 Paramter로 color 라는 값을 사용하여 부여가 가능하다. 내부코드를 보면 123456789101112131415161718192021222324252627282930313233343536@Composablefun Surface( modifier: Modifier = Modifier, shape: Shape = RectangleShape, color: Color = MaterialTheme.colors.surface, contentColor: Color = contentColorFor(color), border: BorderStroke? = null, elevation: Dp = 0.dp, content: @Composable () -&gt; Unit) { val elevationPx = with(LocalDensity.current) { elevation.toPx() } val elevationOverlay = LocalElevationOverlay.current val absoluteElevation = LocalAbsoluteElevation.current + elevation val backgroundColor = if (color == MaterialTheme.colors.surface &amp;&amp; elevationOverlay != null) { elevationOverlay.apply(color, absoluteElevation) } else { color } CompositionLocalProvider( LocalContentColor provides contentColor, LocalAbsoluteElevation provides absoluteElevation ) { Box( modifier.graphicsLayer(shadowElevation = elevationPx, shape = shape) .then(if (border != null) Modifier.border(border, shape) else Modifier) .background( color = backgroundColor, shape = shape ) .clip(shape), propagateMinConstraints = true ) { content() } }} 7. Declarative UI - 선언형 UI노란색 배경을 입혀 기존 TextView에 추가해보았다. 또한, Greeting에는 Modifier라는 것을 이용하여 Padding을 추가했다. 아래와 같은 결과가 나오게 되었다. 123456BasicsCodelabTheme { // A surface container using the 'background' color from the theme Surface(color = Color.Yellow) { Greeting(&quot;Android&quot;) }} 12345678910111213@Composablefun Greeting(name: String) { var isSelected by remember { mutableStateOf(false) } val backgroundColor by animateColorAsState(if (isSelected) Color.Red else Color.Transparent) Text( text = &quot;Hello $name!&quot;, modifier = Modifier .padding(24.dp) .background(color = backgroundColor) .clickable(onClick = { isSelected = !isSelected }) )} 선언형 UI의 장점은 말 그대로 내가 UI를 정의한대로 시각적으로 표현이 가능하다는 장점이 있다. 기존에는 속성을 매번 On/Off와 같은 옵션을 통해 변경하는 것이 다반사였지만, 이제는 매번 속성에 변경이 생길때마다 새로 그려주게 되는것이다. 8. 재사용Compose의 장점 중 하나는 재사용성이 뛰어난것인데, XML에서 우리가 include 태그를 통해 여러곳에서 갖다쓸 수 있던것처럼, 함수를 통해 여러곳에서 정의하여 사용이 가능하다. 참고해야할 점은 Compose 컴포넌트 확장 시 @Composable 어노테이션을 붙여야 한다. 9. Container 작성MyApp이라는 이름으로 컴포즈 컴포넌트를 구횬하여 여러곳에서 공통으로 사용할 수 있는 Composable을 구현하였다. 내부적으로 Container내 내가 원하는 컴포넌트를 넣어주려면 아래와 같이 인자로 @Composable () -&gt; Unit 타입을 넘겨받아 처리해주면 된다. 12345678@Composablefun MyApp(content: @Composable () -&gt; Unit) { BasicsCodelabTheme { Surface(color = Color.Yellow) { content() } }} 위 함수를 통해 이제는 어디서든 반복해서 사용할 수 있는 Container를 구현하게 되어 아래와 같이 코드를 활용할 수 있게되었다. 12345678910class MainActivity : AppCompatActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { MyApp { Greeting(&quot;Android&quot;) } } ... } 10. 레이아웃을 활용한 Compose function의 다중 호출지금까지는 하나의 컴포넌트만을 갖고 사용했지만, 여러개의 컴포넌트를 넣는것도 가능하다. 12345678@Composablefun MyScreenContent() { Column { Greeting(&quot;Android&quot;) Divider(color = Color.Black) Greeting(&quot;there&quot;) }} Column과 위에서부터 사용하던 Greeting 함수를 사용하고, 라인을 그어주기 위한 Divider를 추가한 결과물은 다음과 같다. 위 컴포넌트 중 못보던 컴포저블이 있는데, 아래와 같이 설명이 가능하다. Column : 항목을 순서대로 배치하기 위해 사용한다. Divider : 선 긋기 가능한 Compose 함수이다. 이를 리스트 형태로도 구현이 가능하다. 123456789@Composablefun MyColumnScreen(names: List&lt;String&gt; = listOf(&quot;Line One&quot;, &quot;Line Two&quot;)) { Column { names.forEach { Greeting(name = it) Divider(color = Color.Black) } }} 11. State in Compose - Compose에서의 상태값 관리컴포넌트에 버튼을 클릭했을 때 클릭한 카운트를 집계하는 간단한 컴포넌트를 만들어보았다. 1234567891011121314151617@Composablefun MyColumnScreen(names: List&lt;String&gt; = listOf(&quot;Line One&quot;, &quot;Line Two&quot;)) { val counterState = remember { mutableStateOf(0) } // Column { names.forEach { Greeting(name = it) Divider(color = Color.Black) } Counter( count = counterState.value, updateCount = { newCount -&gt; counterState.value = newCount } ) }} remember라는 함수를 사용하여 기존에 존재하는 컴포넌트의 상태값을 기억하게 하는 함수가 있다. remember 함수의 내부를 살펴보자. 12345678/** * Remember the value produced by [calculation]. [calculation] will only be evaluated during the composition. * Recomposition will always return the value produced by composition. */@OptIn(ComposeCompilerApi::class)@Composableinline fun &lt;T&gt; remember(calculation: @DisallowComposableCalls () -&gt; T): T = currentComposer.cache(false, calculation) 매 호출마다 Recomposition(재조합)하게되는 경우 컴포넌트에 값을 다시 제공하는 것을 알 수 있다. @Composable 어노테이션에 들어간 함수는 매번 해당 상태를 구독하고, 상태가 변경될때마다 알림을 받아 기존 화면을 갱신해준다. 그리고, 아래 Counter를 보면 Button을 이용하여 이벤트를 받아 처리하도록 했다. 1234567891011@Composablefun Counter(count: Int, updateCount: (Int) -&gt; Unit) { Button( onClick = { updateCount(count + 1) }, colors = ButtonDefaults.buttonColors( backgroundColor = if (count &gt; 5) Color.Green else Color.White ) ) { Text(&quot;I've been clicked $count times&quot;) }} updateCount(Int) 함수릉 통해 매번 값을 업데이트 해주는데, 이를 통해 counterState에 값을 넣어주면서 해당 컴포넌트가 매번 변경이 되는것이다. 따라서 결과를 보면, 다음과 같다. Count가 5가 넘어가면 초록색으로 바뀐다. 그 외에도 여러형태의 모양을 구성할수 있도록 옵션이 제공되어 있다. 자세한 정보는 나중에 Codelabs에 더 나와 있으니 보도록하고, 이번에 setContent에 대한 동작원리를 함께 고민해보자. 12. Activity에서의 View 생성 방식과의 비교Compose를 안드로이드 앱에서 사용하려면 Activity, Fragment와 같은곳에서 contentView로 뿌려줘야한다. 기존에 우리가 사용하던 함수를 보자. 12345678910111213/*** Set the activity content from a layout resource. The resource will be* inflated, adding all top-level views to the activity.** @param layoutResID Resource ID to be inflated.** @see #setContentView(android.view.View)* @see #setContentView(android.view.View, android.view.ViewGroup.LayoutParams)*/public void setContentView(@LayoutRes int layoutResID) { getWindow().setContentView(layoutResID); initWindowDecorActionBar();} UI 컴포넌트에서 화면을 붙일 수 있는 Window라는 녀석에서 Layout Resource Id를 통해 기존에 등록되어있던 Layout XML 파일을 로드하여 인플레이터에서 파싱하고, 이를통해 레이아웃 계층에 있는 뷰객체를 생성하여 순차적으로 ViewGroup, View를 만들어 넣어주게 된다. PhoneWindow를 보면 자세하게 알 수 있는데, Window를 구현한 setContentView에서 처음에 생성되는 최상위 레이아웃 그 위에 따로 없다면 installDecor() 함수를 통해 mContentParent(레이아웃 리소스가 붙게될 ViewGroup)를 생성하고, 하위에 넣어주게 된다. 그러면 기존 방식은 이정도로 설명을하고, 이번엔 Compose에서 setContent() 라는 함수를 어떻게 사용하는지 보자. 123456789101112131415161718192021222324252627282930313233343536373839404142/** * Composes the given composable into the given activity. The [content] will become the root view * of the given activity. * * This is roughly equivalent to calling [ComponentActivity.setContentView] with a [ComposeView] * i.e.: * * ``` * setContentView( * ComposeView(this).apply { * setContent { * MyComposableContent() * } * } * ) * ``` * * @param parent The parent composition reference to coordinate scheduling of composition updates * @param content A `@Composable` function declaring the UI contents */public fun ComponentActivity.setContent( parent: CompositionContext? = null, content: @Composable () -&gt; Unit) { val existingComposeView = window.decorView .findViewById&lt;ViewGroup&gt;(android.R.id.content) .getChildAt(0) as? ComposeView if (existingComposeView != null) with(existingComposeView) { setParentCompositionContext(parent) setContent(content) } else ComposeView(this).apply { // Set content and parent **before** setContentView // to have ComposeView create the composition on attach setParentCompositionContext(parent) setContent(content) // Set the view tree owners before setting the content view so that the inflation process // and attach listeners will see them already present setOwners() setContentView(this, DefaultActivityContentLayoutParams) }} 이녀석도 마찬가지로 window.decorView.findViewById&lt;ViewGroup&gt;(android.R.id.content) 함수를 호출하여 decorView를 가져온다. 만약 compose를 통해 만들어진 최상위 레이아웃이 존재하면, 기존에 inflator에서 ViewGroup, View를 생성해서 넣어주던것 처럼 setContent() =&gt; window가 Activity/Fragment에 붙으면 createComposition()를 호출하여 검증 후 ensureCompsositionCreated() 함수를 호출한다. 현재는 내부적으로 ViewGroup.setContent() 를 사용하고 있는데, 곧 교체 될 예정이라고 한다. 이코드도 보면 기존에 있는 ViewGroup에 확장함수로 구현한 녀석인데, 쉽게 말해 ViewGroup에 하위 View, ViewGroup에 Composable로 구현된 함수로 컴포넌트를 넣어줄 때 AndroidComposeView라는 객체를 꺼내오거나 없다면 새로 생성하여 넣어준다. 1234567891011121314151617181920212223242526/** * Composes the given composable into the given view. * * The new composition can be logically &quot;linked&quot; to an existing one, by providing a * [parent]. This will ensure that invalidations and CompositionLocals will flow through * the two compositions as if they were not separate. * * Note that this [ViewGroup] should have an unique id for the saved instance state mechanism to * be able to save and restore the values used within the composition. See [View.setId]. * * @param parent The [Recomposer] or parent composition reference. * @param content Composable that will be the content of the view. */internal fun ViewGroup.setContent( parent: CompositionContext, content: @Composable () -&gt; Unit): Composition { GlobalSnapshotManager.ensureStarted() val composeView = if (childCount &gt; 0) { getChildAt(0) as? AndroidComposeView } else { removeAllViews(); null } ?: AndroidComposeView(context).also { addView(it.view, DefaultLayoutParams) } return doSetContent(composeView, parent, content)} 다시 돌아와서, ComposeView의 setContent() 이라는 녀석을 보자. 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * A [android.view.View] that can host Jetpack Compose UI content. * Use [setContent] to supply the content composable function for the view. * * This [android.view.View] requires that the window it is attached to contains a * [ViewTreeLifecycleOwner]. This [androidx.lifecycle.LifecycleOwner] is used to * [dispose][androidx.compose.runtime.Composition.dispose] of the underlying composition * when the host [Lifecycle] is destroyed, permitting the view to be attached and * detached repeatedly while preserving the composition. Call [disposeComposition] * to dispose of the underlying composition earlier, or if the view is never initially * attached to a window. (The requirement to dispose of the composition explicitly * in the event that the view is never (re)attached is temporary.) */class ComposeView @JvmOverloads constructor( context: Context, attrs: AttributeSet? = null, defStyleAttr: Int = 0) : AbstractComposeView(context, attrs, defStyleAttr) { private val content = mutableStateOf&lt;(@Composable () -&gt; Unit)?&gt;(null) @Suppress(&quot;RedundantVisibilityModifier&quot;) protected override var shouldCreateCompositionOnAttachedToWindow: Boolean = false private set @Composable override fun Content() { content.value?.invoke() } /** * Set the Jetpack Compose UI content for this view. * Initial composition will occur when the view becomes attached to a window or when * [createComposition] is called, whichever comes first. */ fun setContent(content: @Composable () -&gt; Unit) { shouldCreateCompositionOnAttachedToWindow = true this.content.value = content if (isAttachedToWindow) { createComposition() } }} 결론적으로 AbstractComposeView 라는 녀석은 ViewGroup을 상속받은 녀석이며, 모든 composable의 상태가 변화 되었을 때 이를 감지하는 중요한 녀석이다. setContent()라는 함수는 위에서 설명했으니 넘어가고, 이번에는 Content라는 녀석을 보자. 이녀석은 추상 메소드로, createComposition() 이라는 함수가 호출 되었을 때, 가장 먼저 불리는 함수이다. 아까 언급되었던 ensureCompsositionCreated() 함수에서 tree계층의 ComposeView가 다 붙었다면, 이후에 즉시 Content함수가 호출이된다. 123456789101112131415@Suppress(&quot;DEPRECATION&quot;) // Still using ViewGroup.setContent for now private fun ensureCompositionCreated() { if (composition == null) { try { creatingComposition = true composition = setContent( parentContext ?: findViewTreeCompositionContext() ?: windowRecomposer ) { Content() // 이곳에서 뷰가 다 window에 붙게되면 콜백을 호출한다. } } finally { creatingComposition = false } } } 그러면 아래 ComposeView의 오버라이딩 된 Content가 호출되면서, 기존에 생성된 View에 UI속성과 같은 Content가 붙게된다. 12345678/*** The Jetpack Compose UI content for this view.* Subclasses must implement this method to provide content. Initial composition will* occur when the view becomes attached to a window or when [createComposition] is called,* whichever comes first.*/@Composableabstract fun Content() Content는 설명에서 보는것과 같이 createComposition() 함수 호출 후 View가 Window에 붙은 이후 즉시 호출된다. 최종적으로 ComponentActivity.setContent(CompositionContext?, @Composable () -&gt; Unit) 함수에서 구현된 ComposeView 인스턴스를 ContentLayout을 widht/height를 wrapContent크기로 정하여 ContentView를 Set해주게 된다. 123456789101112131415161718192021222324252627282930313233343536/** * Composes the given composable into the given activity. The [content] will become the root view * of the given activity. * * This is roughly equivalent to calling [ComponentActivity.setContentView] with a [ComposeView] * i.e.: * * ``` * setContentView( * ComposeView(this).apply { * setContent { * MyComposableContent() * } * } * ) * ``` * * @param parent The parent composition reference to coordinate scheduling of composition updates * @param content A `@Composable` function declaring the UI contents */public fun ComponentActivity.setContent( parent: CompositionContext? = null, content: @Composable () -&gt; Unit) { ... else ComposeView(this).apply { // Set content and parent **before** setContentView // to have ComposeView create the composition on attach setParentCompositionContext(parent) setContent(content) // Set the view tree owners before setting the content view so that the inflation process // and attach listeners will see them already present setOwners() setContentView(this, DefaultActivityContentLayoutParams) }} 13. ComposeViewandroid.view.View 는 Jetpack Compose UI 콘텐츠를 사용할 수 있도록 해줍니다. setContent 를 사용하면 composable function content 를 뷰에 제공할 수 있다. Compose 의 계층 구조는 아래와 같으며. ComposeView 를 통해 androidx.compose.materia 에 정의된 다양한 컴포넌트를 조합하여 Composable function 콘텐츠를 구성할 수 있다. 12345kotlin.Any ↳ android.view.View ↳ android.view.ViewGroup ↳ androidx.compose.ui.platform.AbstractComposeView ↳ androidx.compose.ui.platform.ComposeView 14. Compose Compiler / Compose RuntimeCompose Compiler 는 @Composable 이 설정된 경우 Composable function 으로 코드 변환과 코틀린 컴파일러 플러그인과 함께 최적화를 활성화한다. Compose Runtime은 Compose의 프로그래밍 모델과 상태 관리, 그리고 Compose 컴파일러를 지정하기 위한 코어 런타임에 대한 기본 설정을 수행한다. 12345@Composablefun Greeting(name: String) { var greet by remember { mutableStateOf(&quot;Hello $name&quot;) } Text(text = greet, color = Color.Red)} 위의 코드는 Compose Compiler에 의해 @Composeable은 아래와 같이 변경된다. 12345678910fun Greeting( $composer: Composer, $static: Int, name: String) { $composer.start(123) var greet by remember { mutableStateOf(&quot;Hello $name&quot;) } Text(text = greet, color = Color.Red) $composer.end()} Compose 는 composer.start 에서 고유의 키를 가지고 있고, 이는 Compose 의 state 가 변경될 때 해당 키를 가진 Compose 만 변경되도록 동작한다. static 은 상태(state)의 변경여부를 알 수 있는데 상태의 변화가 없는 경우, composer.start 와 composer.end 사이의 UI 의 변경을 하지 않는다. 이때 데이터의 상태가 변경되어 UI 를 다시 구성하는 경우는 Recomposition 이라고 한다.","link":"/Team-Blog/2021/04/07/2021-04-07%20Jetpack%20Compose%20Part%201/"},{"title":"Jetpack Compose Part 2 - Preview &#x2F; Layout &#x2F; Decompile","text":"Writers by 김남훈 @Naver by 배희성 @RocketPunch by 송시영 @SmartStudy by 이기정 @BankSalad Android Studio의 Jetpack ComposeAndroid Studio Preview를 사용해 Compose를 사용하다보면 Preview라 코드레벨에서 활성화되는 것을 알 수 있다. 좀 더 자세히 살펴보자. Preview의 기능들Preview 와 Compose 를 사용해서 아래와 같이 구성할 수 있다. Split(design/code) 을 선택에 따라 코드 및 디자인의 패널을 변경할 수도 있다. 미리보기에서 인터렉티브 모드를 설정할 수 있다. 인터렉티브 모드를 설정하면 실제 디바이스처럼 클릭이나 드래그 등의 상호 작용을 확인해 볼 수 있다. 다만, 네트워크나 파일에 접근 또는 일부 Context API 는 인터렉티브 모드를 지원하지 않고 있다. 간헐적으로 interactive 모드가 작동하지 않는 경우가 있다. 미리보기에서 직접 디바이스 혹은 에뮬레이터로 배포하여 결과를 확인할 수도 있다. @Preview Annotation 분석위에서 언급했다시피 @Preview를 사용하면 디바이스나 에뮬레이터를 실행하지 않고 실시간으로 Compose UI 를 볼 수 있다. @Preview를는 아래와 같이 구성되어 있으며 설정에 따라서 미리보기를 다양하게 구성할 수 있다. 12345678910111213141516annotation class Preview( val name: String = &quot;&quot;, val group: String = &quot;&quot;, @IntRange(from = 1) val apiLevel: Int = -1, // TODO(mount): Make this Dp when they are inline classes val widthDp: Int = -1, // TODO(mount): Make this Dp when they are inline classes val heightDp: Int = -1, val locale: String = &quot;&quot;, @FloatRange(from = 0.01) val fontScale: Float = 1f, val showSystemUi: Boolean = false, val showBackground: Boolean = false, val backgroundColor: Long = 0, @UiMode val uiMode: Int = 0, @Device val device: String = Devices.DEFAULT) name : Preview 의 이름을 지정하며, 기본 값은 function 이름으로 설정된다. group : Preview 의 그룹을 지정한다, 기본 값은 function 이름으로 설정된다. apiLevel : api level 설정에 따라 Composable 을 렌더링해준다. widthDp : Preview 의 너비를 설정한다. (기본 단위는 dp) heightDp : Preview 의 높이를 설정한다. (기본 단위는 dp) locale : 사용자 locales 에 따라 보여지는 UI 를 테스트 하기 위해 사용한다. fontScale : 기본 density 애 배율을 적용해서 폰트 사이즈를 변경할 수 있다. showSystemUi : true 로 설정하면 status bar 와 action bar 를 노출한다. showBackground : true 로 설정하면 기본 배경색상을 적용해준다. backgroundColor : 미리보기의 배경색을 설정할 수 있으며, showBackground 설정에 따라 노출 유무를 결정한다. uiMode : uiMode 를 설정한다. device : 기존 정의된 디바이스를 프리뷰에 적용한다. Devices object 에 정의된 값을 선택해서 사용할 수 있습니다. (Devices.NEXUS_9) Compose의 레이아웃 구성 Column : 아이템을 세로로 배치한다. 1234567@Composablefun ComposeColumn() { Column { Text(text = &quot;My First Compose&quot;) Text(text = &quot;My First Compose&quot;) }} Row : 아이템을 가로로 배치한다. 1234567@Composablefun ComposeRow() { Row { Text(text = &quot;My First Compose&quot;) Text(text = &quot;My First Compose&quot;) }} Box : 구성 요소를 다른 구성 요소 위에 배치한다. 1234567@Composablefun ComposeBox() { Box { Text(text = &quot;My First Compose 1&quot;) Text(text = &quot;My First Compose 2&quot;) }} Modifier : 구성 요소의 크기, 마진등을 변경하거나 클릭이나 스크롤 등의 이벤트를 제어할 수 있도록 한다. 12345678@Composablefun ComposeModifier() { Box(modifier = Modifier .padding(5.dp) ) { Text(text = &quot;Compose Modifier&quot;) }} LazyColumn / LazyRow : Recyclerview 유사하게 화면에 보여지는 구성 요소만을 렌더링한다. 큰 데이터셋을 다루기에 용이하다. 12345678910@Composablefun ComposeLazyColumn() { val itemsList = (0..100).toList() LazyColumn { items(items = itemsList, itemContent = { item -&gt; Text(text = &quot;Item : $item&quot;, style = TextStyle(fontSize = 80.sp)) }) }} ConstraintLayout : 기존 ContraintLayout 과 같이 여러 제약 참조를 설정해서 사용할 수 있다.createRefs / createRefFor 를 통해 참조를 생성하며, constrainAs 를 통해 제약 조건을 설정한다. 123456789101112131415161718192021222324252627282930@Composablefun ComposeConstraintLayout() { ConstraintLayout(modifier = Modifier.size(100.dp, 200.dp)) { val (text1, image, text3) = createRefs() Text(&quot;Text Item 1&quot;, Modifier.constrainAs(text1) { top.linkTo(parent.top) start.linkTo(parent.start) end.linkTo(parent.end) }) Image( painterResource(R.drawable.ic_launcher_foreground), contentDescription = &quot;&quot;, contentScale = ContentScale.Crop, modifier = Modifier.fillMaxSize().constrainAs(image) { top.linkTo(text1.bottom) bottom.linkTo(text3.top) start.linkTo(parent.start) end.linkTo(parent.end) } ) Text(&quot;Text Item 3&quot;, Modifier.constrainAs(text3) { bottom.linkTo(parent.bottom) start.linkTo(parent.start) end.linkTo(parent.end) }) }} Jetpack Compose 의 ConstraintLayout 을 사용하기 위해서는 아래 의존성을 추가해야 한다. 1implementation &quot;androidx.constraintlayout:constraintlayout-compose:1.0.0-alpha05&quot; Jetpack Compose의 동작 원리 파악을 위한 빌드 과정 추적1. 프로젝트 생성Compose가 내부적으로 어떻게 동작하는 지 알아보기 위해 먼저 프로젝트를 빌드해보자. 빌드 후 Kotlin &gt; Byte Code &gt; Decompiled Java 순서로 변환하여 살펴볼 것이다. Android Studio Preview에서 Empty Compose Activity로 프로젝트를 생성하면 아래와 같은 샘플 코드를 얻을 수 있다. 프로젝트 생성 후 임의로 Hello World로 파라미터값을 변경하였다. 1234567891011121314151617181920212223242526class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { HelloWorldTheme { // A surface container using the 'background' color from the theme Surface(color = MaterialTheme.colors.background) { Greeting(&quot;World&quot;) } } } }}@Composablefun Greeting(name: String) { Text(text = &quot;Hello $name!&quot;)}@Preview(showBackground = true)@Composablefun DefaultPreview() { HelloWorldTheme { Greeting(&quot;World&quot;) }} 부가적으로 src 폴더 내부에 ui.theme 패키지가 생성되고 Color.kt, Shape.kt, Theme.kt, Type.kt 파일도 생성된다. 이 파일들은 필요한 경우 들여다 보도록 하자. 생성 후 Preview에 아래와 같이 렌더링 된다. 2. MainActivity 디컴파일12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152@Metadata( mv = {1, 4, 2}, bv = {1, 0, 3}, k = 2, d1 = {&quot;...&quot;}, d2 = {&quot;DefaultPreview&quot;, &quot;&quot;, &quot;Greeting&quot;, &quot;name&quot;, &quot;&quot;, &quot;app_debug&quot;})public final class MainActivityKt { @Composable public static final void Greeting(@NotNull String name) { Intrinsics.checkNotNullParameter(name, &quot;name&quot;); TextKt.Text-Vh6c2nE$default(&quot;Hello &quot; + name + '!', (Modifier)null, 0L, 0L, (FontStyle)null, (FontWeight)null, (FontFamily)null, 0L, (TextDecoration)null, (TextAlign)null, 0L, (TextOverflow)null, false, 0, (Function1)null, (TextStyle)null, 65534, (Object)null ); } @Composable public static final void DefaultPreview() { ThemeKt.HelloWorldTheme$default(false, (Function0)null.INSTANCE, 1, (Object)null); }}// MainActivity.java@Metadata( mv = {1, 4, 2}, bv = {1, 0, 3}, k = 1, d1 = {&quot;...&quot;}, d2 = {&quot;...&quot;})public final class MainActivity extends ComponentActivity { protected void onCreate(@Nullable Bundle savedInstanceState) { super.onCreate(savedInstanceState); ComponentActivityKt.setContent$default(this, (CompositionContext)null, (Function0)null.INSTANCE, 1, (Object)null); }} ComponentActivityKt.setContent()의 구현체는 아래와 같다. 12345678910111213141516171819public fun ComponentActivity.setContent( parent: CompositionContext? = null, content: @Composable () -&gt; Unit) { val existingComposeView = window.decorView .findViewById&lt;ViewGroup&gt;(android.R.id.content) .getChildAt(0) as? ComposeView if (existingComposeView != null) with(existingComposeView) { setParentCompositionContext(parent) setContent(content) } else ComposeView(this).apply { // Set content and parent **before** setContentView // to have ComposeView create the composition on attach setParentCompositionContext(parent) setContent(content) setContentView(this, DefaultActivityContentLayoutParams) }} CompositionContext 파라미터는 null을 그대로 넘겨주었고, (Function0)null.INSTANCE, 1, (Object)null의 값으로 무언가를 넘겨주는데, 이 값이 @Composable Annotation의 구현체이다. 위의 코드 흔적을 술어로 표현해보면 @Composable 구현체를 넘겨주면 이를 기반으로 ComposeView 객체를 생성하여 Activity의 setContentView()에 적용한다. 가 되겠다. 3. @Composable 구현체 확인Composable Annotaion 클래스의 구현체는 아래와 같다. 1234567891011121314151617181920212223242526@MustBeDocumented@Retention(AnnotationRetention.BINARY)@Target( // function declarations // @Composable fun Foo() { ... } // lambda expressions // val foo = @Composable { ... } AnnotationTarget.FUNCTION, // type declarations // var foo: @Composable () -&gt; Unit = { ... } // parameter types // foo: @Composable () -&gt; Unit AnnotationTarget.TYPE, // composable types inside of type signatures // foo: (@Composable () -&gt; Unit) -&gt; Unit AnnotationTarget.TYPE_PARAMETER, // composable property getters and setters // val foo: Int @Composable get() { ... } // var bar: Int // @Composable get() { ... } AnnotationTarget.PROPERTY_GETTER)annotation class Composable AnnotationTarget을 통해 메서드나 Lambda 객체를 넘겨서 뷰를 조립하는 방식인데, View와 ViewGroup처럼 내부적으로 트리 구조로 실행지점에 대한 정보를 저장하고 있다. 파면 팔수록 Flutter의 Widget, React Native의 Component와 유사한 느낌을 준다.","link":"/Team-Blog/2021/04/07/2021-04-07%20Jetpack%20Compose%20Part%202/"},{"title":"Jetpack Compose Part 3 - Retrospect","text":"Writers by 김남훈 @Naver by 배희성 @RocketPunch by 송시영 @SmartStudy by 이기정 @BankSalad Jetpack Compose의 Coupling과 Cohesion비단 Android 애플리케이션뿐만 아니라, 소프트웨어를 잘 개발하기 위해 지켜야할 원칙 중 하나는 관심사의 분리(Separation of concerns) 라는 개념이다. 흔히 복잡성을 극복하기 위해 여러가지 디자인 패턴을 적용하여 View와 Controller를 분리하기 위해 애쓰는 사람들이 많은 것도 결국 프로덕트의 복잡성을 (완전히 없앨 수는 있을까?) 최소화하기 위해서이다. Compose 또한 이 복잡성의 극복을 위해 나온 도구라고 봐도 무방할 것이다. 따라서 Compose를 적용하면서 계속 머릿속에 캐시해두어야할 개념은 Coupling 과 Cohesion 이다. 흔히들 커플링이 심하다라고 표현하긴 하는데, 굳이 한글로 번역하자면 각각, 어떠한 컴포넌트들간의 결속 과 분리된 각 모듈 내부의 응집 을 뜻한다고 볼 수 있다. 출처 How Cohesion and Coupling Correlate 위의 세 그림을 아래 개념을 뜻한다. A : Low cohesion, tight coupling B : High cohesion, tight coupling C : High cohesion, loose coupling 결국 Compose를 잘 쓴다는 것은 UI/UX 입장에서 뷰를 잘 분리하여 재사용을 통해 우리가 개발하려는 프로덕트가 C의 구조가 되게끔 작성하는 것이다. Compose 사용시 주의사항 최대한 재사용성이 높게 설계되어야 한다. 뷰 모델과 비지니스 모델 분리가 필요하다. 지속적으로 재사용하는데 ViewModel과 같은 비지니스 모델이 수행되면 무거워지기 때문 매개변수나 람다를 이용하자. 호출 순서가 보장되지 않으므로, 각 함수는 독립적으로 설계해야 한다. Compose의 Stateremember 예약어를 통해 메모리에 단일 객체를 저장 가능하다. 상위 컴포넌트가 재구성되기 전까지 상태를 가지고 있다. Stateless Satateless Composable은 말그대로 상태값을 가지고 있지 않다. 외부에서 매개변수나 람다를 통해 상태를 받아 사용한다. Stateful 상태 값을 가지고 있는 Composable State&lt;T&gt; 객체를 통해 관찰가능한 값을 가지고 있으므로 사용이 권장된다. Runtime시 통합된다. 이전 상태를 복원하기 위해서는 rememberSaveable 키워드를 사용한다. Bundle에 데이터가 자동으로 저장된다. Compose Samples코드랩 뿐만 아니라 다양한 Compose 샘플들을 구글이 모아두었다. 아래 링크를 참조하자. Github#Android Compose Samples 현재 작업하고 있는 뷰와 제일 유사한 것들을 통해 Compose를 이해하는 것도 하나의 방법이 될 수 있다. 마무리하며 뷰를 제작함에 있어서 선언형 프로그래밍은 좋은 효율을 낼 수 있을 것 같다 Flutter나 SwiftUI를 사용해보면 뷰 제작 속도가 얼마나 다른지 알 수 있다. (개개인의 차이가 있을 수 있음) 요즘 제일 많이 사용하는 MVVM 아키텍처도 적용 가능하지만 이게 적합한지는 잘 모르겠다. MVI 같은 아키텍처가 오히려 더 잘 맞을 수 있다고 생각한다. 안드로이드에서 전혀 생각지도 못한 선언형 프로그래밍 방식을 도입할 수 있던 것이 신선하다고 생각한다. 선언형 프로그래밍도 결국 유행하지않을까? 기존에 React나 Flutter를 통해 선언형 프로그래밍을 쉽게 접했던 개발자들은 더 쉽게 안드로이드 개발을 도전해보지 않을까 싶다. 오히려 반대로 기존에 XML로 레이아웃 코드를 짜던 개발자들은 생소한 방식이라 적응하는데 시간이 꽤나 걸릴 것이다. 다만, 아직도 alpha버전이라 바뀔 수 있는 것이 너무나도 많은 상황이다. 앞으로 좋은 예시들이 나오고, 좀 더 기존 안드로이드 개발자들이 익숙해 할만한 컴포넌트로 제공이 되면, 좀 더 많은 개발자들이 선언형 프로그래밍으로 넘어갈 수 있지 않을까 싶다. 당장 기존에 있던 코드와 공존하면서 쓰기에는 여간 불편할것 같다. Flutter의 경우 선언형 프로그래밍 방식으로 렌더링을 지원하기 때문에 처음부터 개발을 선언형으로 하게되니, 굳이 이럴바에는 Flutter로 서비스를 따로 구현하는 게 낫지 않을까라는 생각이 들었다. ReferencesMembers of Study https://namhoon.kim/2021/03/14/android_deep_dive/001/ https://namhoon.kim/2021/03/21/android_deep_dive/002/ https://sysys.medium.com/jetpack-compose-%EC%B2%B4%ED%97%98%EA%B8%B0-8f90aff89f47 https://soda1127.github.io/introduce-jetpack-compose/ Official Android Developers#Jetpack Compose Android Developers#Compose 이해 Android Developers#Compose Cource Android#Compose Samples Etc Understanding Jetpack Compose - part 1 of 2 Understanding Jetpack Compose - part 2 of 2 foso.github.io","link":"/Team-Blog/2021/04/07/2021-04-07%20Jetpack%20Compose%20Part%203/"},{"title":"Introduce Android UI Rendering Principle and View Optimization Part 1","text":"Writers by 김남훈 @Naver by 배희성 @RocketPunch by 송시영 @SmartStudy by 이기정 @BankSalad by 정세희 @BankSalad by 최소영 @BankSalad 우리는 안드로이드 개발자로 있으면서 기본적인 것들을 놓치곤한다. 안드로이드에서 가장 중요한것은 사용자에게 보여지는 UI와 UX이다. 이를 위해서 안드로이드 개발자가 해야할 일은 UI를 이쁘게 요구사항에 맞게 그리고, 지연없는 UI로딩을 통해 UI를 그리는 것이다. 글을 작성하다 보니 문득 든 생각이 있었다. 과연 우리가 안드로이드에서 UI를 그릴 때 정확하게 방법을 알고 View를 그리는 코드를 작성하고 있었을까? 나 스스로도 그렇지 않다라는 생각이 들었고, 궁금증이 생겨 ADD 멤버분들과 함께 글을 정리해보았다. Android View안드로이드 개발자라면 한번쯤은 들어봤을 법한, 컴포넌트들이 있다. 바로 아래의 녀석들이다. 안드로이드의 다양한 컴포넌트들은 다음과 같이 View라는 녀석을 상속받아서 만들어졌다. View &amp; ViewGroup간단히 개념만 잡고 넘어가보도록 해보자. 안드로이드에서 화면을 나누는 두가지 부류는 View와 ViewGroup 두가지로 나눌 수 있다. View는 Activity, 즉 한 화면에서 화면을 구성하는 최소 단위의 개념이다. 또다른 말로는 위젯이라고 하는데, 이 View를 상속받아 구현되는 수많은 요소들이 존재한다. 대표적으로 ImageView, TextView, Button과 같은 녀석이 있다. 위젯이나 노티피케이션 위젯과 같이 사용성이 특수한 경우 RemoteView를 이용하여 구현을 해야하는 경우도 있는데, 여기서는 이에 대한 설명은 생략하겠다. ViewGroup은 View를 상속받아 구현된 클래스이다. 다른말로는 레이아웃이라고 하며, View를 N개 담을 수 있는 녀석이다. 대표적으로 LinearLayout, FrameLayout, RelativeLayout, ConsraintLayout이 있다. 이러한 방식으로 View, ViewGroup은 Java, 또는 Kotlin코드로 구성될 수 있지만, 더 쉬운 방법으로 Mark-Up 랭귀지를 이용하여 구성도 가능하다. 안드로이드 프로그래밍에서는 XML이라는 마크업 랭귀지를 이용하는데, 결국 이도 XML Parser를 통해 파싱되어 Java코드로 변환되어진다. 안드로이드 개발자들은 어플리케이션의 좋은 성능을 낼 수 있는 방법과, 올바른 방법으로 개발을 하기 위해서라도 View가 그려지는 과정과 생명주기에 대해 잘 알고 있어야 한다. 이를 위해서 먼저 View가 어떤 생명주기를 갖는지 보도록하자. View Life-Cycle상용화 하는 어플리케이션을 만들수록, 우리가 만들어나가는 View는 고도화 될 필요가 있다. 특히 View, ViewGroup을 기반으로 한 컴포넌트를 구성하게 될 때, 우리는 커스텀 뷰라는 것을만들게 된다. 커스텀 뷰를 만들게 될 때, 만들면 만들수록 점점 뷰를 그려지는 방식은 복잡해지고, 성능적인 부분을 충족하기 위해 최적화할 수 있는 방법을 고민해야한다. 이를 위해서는 View의 생명주기에 대해서도 잘 알고 있어야 한다. 안드로이드 컴포넌트, Fragment와 마찬가지로 View도 생명주기를 갖고있다. View의 생명주기는 아래와 같이 도식화 하여 표현 가능하다, 생명주기에 대해 몇 가지 특징적으로 나눌 수 있는 부분이 있다. ConstructorsProgrammatically하게 View를 생성하는 방법이다. View를 생성하는 방법은 여러가지가 존재하지만, 가장 직관적인 방법 중 하나이다. 생성자의 종류는 여러가지가 존재한다. View(Context context) View(Context context, @Nullable AttributeSet attrs) View(Context context, @Nullable AttributeSet attrs, int defStyleAttr) View(Context context, @Nullable AttributeSet attrs, int defStyleAttr, int defStyleRes) Attachment / Detachment Attachment는 Window에서 붙었음을 의미한다. Detachment는 Window에서 떼어졌음을 의미한다. 위 동작이 수행되었음을 받을 수 있는 Callback Function으로 두가지 함수를 각각 제공한다. onAttachedToWindow()View가 Window에 붙었을 때 호출된다. 이때부터는 View가 Active하다고 판단되며, 이때부터는 리소스 할당, 파라미터에 대한 계산, 리스너를 부착할 수 있는 준비가 된다. onDetachedFromWindow()View가 Window에 떼어졌을 때 호출된다. Window상에서 더 이상 존재하지 않으므로, Inactive하며, 기존에 View에 할당된 리소스를 해제해주어야한다. 해당 콜백함수가 불리는 케이스로는 두가지가 있다. ViewGroup에서 View가 제거될 때 Activity가 finish() 함수를 호출하여 Activity가 Destroyed될 때 onMeasure()View의 크기를 계산한다. ViewGroup은 하위 노드인 View에 대한 크기를 측정하고, 관계성을 파악 후 자신의 크기를 계산한다. 따라서, 하위 노드가 ViewGroup에 올바르게 붙었는지 확인해야한다. 12345678910111213/** * * 기본적으로 View의 크기를 측정할 때는 Background의 Dimension Size를 보고 결정한다. * * 현재 계산된 크기를 비교하여 Background크기보다 작은경우, Background크기를 반환하여 크기를 반환한다. * @param widthMeasureSpec 부모뷰에 의해 적용된 수평 공간 * @param heightMeasureSpec 부모뷰에 의해 적용된 수직 공간 * */protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) { setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec), getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));} MeasureSpecViewGroup의 하위 컴포넌트인 View에서는 크기에 대한 제약을 정하기 위해 스펙을 정하게 되는데, 이를 MeasureSpec을 통해 해결한다. MeasureSpec은 Width, Height에 대한 스펙이며, 크기와 모드로 나뉜다. 그리고 세가지의 값으로 나뉜다. MeasureSpec.EXACTLY : 부모뷰가 자식뷰의 정확한 크기를 결정한다. 자식뷰의 사이즈와 관계없이 주어진 경계내에서 사이즈가 결정된다. MeasureSpec.AT_MOST : 자식뷰는 지정된 크기까지 원하는 만큼 커질 수 있다. MeasureSpec.UNSPECIFIED : 부모뷰가 자식뷰에 제한을 두지 않기 때문에, 자식뷰는 원하는 크기가 될 수 있다. 아래와 같은 코드로 체크할 수 있다. 1234567@Overridepublic void onMeasure(int widthMeasureSpec, int heightMeasureSpec) { int mode = MeasureSpec.getMode(heightMeasureSpec) if (mode != MeasureSpec.EXACTLY) { // Logic }} onLayout()계산이 된 이후에는 onLayout 함수를 통해 계산된 View를 Window에 배치한다. View와 같은 경우 아래 코드를 기반으로 상속받아 처리한다. 1protected void onLayout(boolean changed, int left, int top, int right, int bottom) onDraw()onLayout에서 View에 대한 크기 계산 및 배치가 완료되었으므로, 이를 기반으로 onDraw에서는 Canvas라는 인스턴스를 넘겨주며, 해당 Canvas 인스턴스는 DisplayList에 그릴 데이터를 담아서 넘겨준다. onDraw는 한프레임을 그리는 함수기 때문에 반복적으로 호출이된다. 특이하게 여러번 호출되고 CPU연산이 되는 곳이기 떄문에, 객체를 만들어서 사용하는 것은 금기시한다. View가 draw를 하는 기준은 두가지로 나눌 수 있다. View의 모양이 변형이 생겼을 때 - invalidate() View의 경계에 변화가 생겼을 때 - requestLayout() Invalidate()invalidate 함수는 직접적으로도 호출이 가능하지만, 상위에서 View에서 여러 View내에 상태가 변형이 되었을 때 호출을한다. 직접 코드를 까보는 것이 아무래도 좋으니, 본인이 확인한 invalidate를 호출하는 시점을 리스트업 해본다. drawableStateChanged - Background, 포커스 되었을 때 나타다는 하이라이트, Foreground Drawable에 대해 변경점을 체크하며, 상태가 존재하면 변경된 것으로 판단 setDefaultFocusHighlight - 포커스 되었을 때 하이라이트를 기본적으로 세팅해줌. 무조건 새로 그림 setForeground setScrollIndicators - indicator의 색상과 마스크를 설정한다. 기존 마스크와 머지하고, 플래그를 체크하여 업데이트 된 경우 새로 그린다. setAutoFilled requestAccessibilityFocus - 포커스를 쓸 수 있는 권한을 요청할 때 View에대한 포커스에 대해서 달라진 점이 생기면 플래그로 비교하여 처리 setForceDarkAllowed - 어둡게 처리시 필요한 함수 onDrawScrollBars - 스크롤바에 움직임이 생길 시 setLayerPaint - 색상에 대한 변형이 있을 때 처리한다. (alpha, Xfermode, colorFilter) requestLayout()뷰의 경계가 변경되면 무조건 호출돼야하는 함수이다. 이를 통해 재 계산을 거쳐 onMeasure =&gt; onLayout을 거친다. View State Save/RestoreView는 Activity의 상태에 따라 상태를 저장/복원해야 할 필요가있다. 이를 위한 두가지의 함수를 제공한다. onSaveInstanceState() -&gt; Parcelable상태를 저장하기 위한 함수에서는 상태를 저장할 때 각 View에 대한 고유 ID를 필요로한다. 저장을 할때는 Bundle 인스턴스를 생성하여 저장하면 된다. Bundle은 Parcelable을 구현한 클래스로, 적절하게 저장하여 처리할 수 있다. 아래 코드를 참고하자. 12345678910@Overridepublic Parcelable onSaveInstanceState() { Bundle bundle = new Bundle(); // The vars you want to save - in this instance a string and a boolean String someString = &quot;something&quot;; boolean someBoolean = true; State state = new State(super.onSaveInstanceState(), someString, someBoolean); bundle.putParcelable(State.STATE, state); return bundle;} State라는 녀석이 보이는데, 해당 State는 직접 구현해주어야 하는 클래스가 될 수 있다. View에대한 상태를 저장할 수 있는 어떤것이든 상관없다. onRestoreInstanceState(Parcelable state)해당함수를 오버라이딩하면 다시 Paracleable로 된 인스턴스를 받아서 처리가 가능하다. Parcelable을 그대로 쓸수는 없으니, 구현체에 해당하는 인스턴스로 캐스팅하여 처리하면 된다. 아래는 예시이다. 1234567891011121314@Overridepublic void onRestoreInstanceState(Parcelable state) { if (state instanceof Bundle) { Bundle bundle = (Bundle) state; State customViewState = (State) bundle.getParcelable(State.STATE); // The vars you saved - do whatever you want with them String someString = customViewState.getText(); boolean someBoolean = customViewState.isSomethingShowing()); super.onRestoreInstanceState(customViewState.getSuperState()); return; } // Stops a bug with the wrong state being passed to the super super.onRestoreInstanceState(BaseSavedState.EMPTY_STATE); } View가 그려지는 순서View가 렌더링 될 때, 상위수준의 ViewGroup 에서부터 하위 자식인 View 로 내려가면서 Measure -&gt; Layout -&gt; Draw 를 거치게 된다. Measure Pass측정 패스는 measure(int, int) 로 구현되며 뷰 트리의 탑-다운으로 순회한다. 각 뷰는 트리를 재귀하는 동안 측정한 수치를 트리 아래로 보낸다. 측정이 모두 끝나면 모든 뷰는 측정한 값을 가지게 된다. 두번째 단계 또한 탑-다운으로 layout(int, int, int) 에서 일어난다. 각각의 부모는 측정단계에서 계산된 사이즈를 사용해서 자신의 모든 자식을 배치한다. View 의 크기는 2가지로 정의될 수 있다. measured width &amp; measured height : 뷰가 부모뷰 크기의 범위 내에서 가지고 싶어하는 너비와 높이이다. drawing width &amp; drawing height : 뷰의 실제 너비와 높이로 뷰를 그리기 위해서 사용한다. View의 Padding, Margin 등을 고려하면 원하는 크기에서 Padding 및 Margin 값을 빼야 하기 때문에 Measured Width, Measured Height 는 Drawing Width, Drawing Height 와 다를 수 있다. Layout Pass레이아웃을 시작하려면, requestLayout() 를 호출한다. 일반적으로 현재 범위내에 더이상 맞지 않을때 자체적으로 뷰에 의해 호출된다. 이 과정에서도 top-down 형식의 탐색이 일어나게 되는데, 이 때는 각각의 ViewGroup이 Measure 단계에서 측정된 크기를 이용해서 하위속성들의 위치를 결정한다. Draw PassGPU에게 명령을 내려주는 단계이다. 그려야 할 객체들의 리스트를 GPU에게 보내기 위해 View Tree에서 각 객체의 대한 Canvas 객체가 생성된다. 이 때, 이전 1,2단계를 거쳐 결정된 객체들의 크기와 위치에 대한 정보가 들어가게 된다. 만약 View가 변할 때, 시스템에게 알려주기 위한 2가지 방법이 존재하는데, Invaliadate()가 호출 될 때에는 draw부터 다시 작업이 시행되고, requestLayout()이 호출될 때에는 measure -&gt; layout -&gt; draw 단계를 다시 거치게 된다. 코드로 보면서 어떤식으로 View가 그려지는지 한번 보도록하자. 실험을 통한 View Rendering Process 관찰123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;androidx.constraintlayout.widget.ConstraintLayout android:id=&quot;@+id/root1&quot; xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;.MainActivity&quot;&gt; &lt;androidx.constraintlayout.widget.ConstraintLayout android:id=&quot;@+id/constraintContainer2&quot; android:layout_width=&quot;400dp&quot; android:layout_height=&quot;400dp&quot; android:background=&quot;@color/teal_200&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintEnd_toEndOf=&quot;parent&quot; app:layout_constraintBottom_toBottomOf=&quot;parent&quot;&gt; &lt;TextView android:id=&quot;@+id/constraintTextView3&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;First TextView&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; /&gt; &lt;LinearLayout android:id=&quot;@+id/linearContainer4&quot; android:layout_width=&quot;200dp&quot; android:layout_height=&quot;200dp&quot; android:orientation=&quot;vertical&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; app:layout_constraintEnd_toEndOf=&quot;parent&quot;&gt; &lt;ImageView android:id=&quot;@+id/linearImageView5&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:background=&quot;@drawable/ic_launcher_foreground&quot;/&gt; &lt;TextView android:id=&quot;@+id/linearTextView5&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;Second TextView&quot;/&gt; &lt;RelativeLayout android:id=&quot;@+id/relativeContainer5&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:background=&quot;@color/purple_500&quot;&gt; &lt;TextView android:id=&quot;@+id/relativeTextView6&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;Thired TextView&quot;/&gt; &lt;/RelativeLayout&gt; &lt;/LinearLayout&gt; &lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; &lt;FrameLayout android:id=&quot;@+id/frameContainer2&quot; android:layout_width=&quot;100dp&quot; android:layout_height=&quot;100dp&quot; android:background=&quot;@color/teal_200_30&quot; app:layout_constraintEnd_toEndOf=&quot;parent&quot; app:layout_constraintBottom_toBottomOf=&quot;parent&quot; /&gt;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; root Container 를 부모 레이아웃으로 삼아 다양한 depth 의 View 가 쌓여져 있고, 이는 아래처럼 그래프로 나타낼 수 있다. 각각의 View, ViewGroup에 onLayout 시점을 포착할 수 있는 코드를 구현해, 어느 순서로 View 가 그려지는지 확인해보자. doOnLayout, doOnDraw, doOnXXX 등을 통해 원하는 라이프사이클 시점을 포착할 수 있다. OnLayout 호출로 순서 보기1234567891011121314151617181920212223242526272829303132333435linearContainer4.doOnLayout { println(&quot;linearContainer4 doOnLayout&quot;)}constraintContainer2.doOnLayout { println(&quot;ConstraintContainer2 doOnLayout&quot;)}constraintTextView3.doOnLayout { println(&quot;constraintTextView3 doOnLayout&quot;)}root1.doOnLayout { println(&quot;root1 doOnLayout&quot;)}relativeContainer5.doOnLayout { println(&quot;relativeContainer5 doOnLayout&quot;)}relativeTextView6.doOnLayout { println(&quot;relativeTextView6 doOnLayout&quot;)}linearImageView5.doOnLayout { println(&quot;linearImageView5 doOnLayout&quot;)}linearTextView5.doOnLayout { println(&quot;linearTextView5 doOnLayout&quot;)}frameContainer2.doOnLayout { println(&quot;frameContainer2 doOnLayout&quot;)} onLayout 시점에는 트리구조로 이루어진 View &amp; ViewGroup 이 후위순회를 하며 측정이 된다는 것을 알 수 있다. 실험을 통해 알게 된 결론Layout 내에 존재하는 Chile View가 lifecycle 를 거치면서 크기가 측정되는 순서와, 그려지는 순서는 다르다. Child View 들의 크기가 정해지고 Parent View 가 그 측정값을 알아야지 자신의 크기를 정할 수 있는 것이고, (Layout 단계) 도화지가 준비되어야 그림을 그릴 수 있듯이, Parent View 가 먼저 그려져야 Child View 가 그려질 수 있기 때문이다. (Draw 단계) Extra Infolayout_weight 의 배신Linear Layout 의 layout_weight 속성을 사용하는 경우 자식 뷰는 두번의 Measure pass가 필요하기 때문에 많은 비용이 소모된다. layout_weight는 단순히 비율을 나누어 공간을 차지하는 것이 아닌, 부모의 View가 그려지고 나서 남은 공간이 얼마만큼인지, 다른 View들이 그려지고 나서 다시한번 남은공간도 계산하고 나서 자기 자신을 그리기 때문에 지속적인 계산이 일어나게 된다. 복잡한 View의 계산을 피하기 위해 Releative Layout &amp; Constraint Layout을 권하는 것이다. Overdraw 를 피하는 방법OverDraw를 피하는 방법 중, 사용자에게 보여지지 않는 Layout의 Background 색을 제거하면 성능 향상에 도움이 된다는 글이 많이 존재한다. 하지만 어째서 배경 색을 지우는 것만으로도 성능이 크게 향상될 수 있다는 것일까? Layout에 Background를 제거한 후 디버깅을 해보면 View Lifecycle의 onDraw를 거치지 않음을 알 수 있다. UI 렌더링 시 가장 비용이 많이 드는 부분이 onDraw(GPU에 업로드 하는 과정) 인데, 이 부분이 skip 되니 성능이 향상되는건 당연한 부분일 것이다. 여기까지 View의 생명주기, View가 그려지는 과정에 대해 알아보았다. 다음 글에서는 View 상위에서 그려지는 요소인 Window, Surface, Canvas에 대해 소개하고, 소프트웨어 레벨에서 어떻게 하드웨어 레벨까지 동기화 되는지 분석하고, 현재 사용하는 하드웨어 모델 기반 렌더링에 대해 소개하도록 하겠다.","link":"/Team-Blog/2021/05/19/2021-05-19%20Android%20UI%20Rendering%20Optimization%20Part%201/"},{"title":"Introduce Android UI Rendering Principle and View Optimization Part 2","text":"Writers by 김남훈 @Naver by 배희성 @RocketPunch by 송시영 @SmartStudy by 이기정 @BankSalad by 정세희 @BankSalad by 최소영 @BankSalad 저번 포스트에서는 View와 ViewGroup 개념, UI가 그려지는 과정, UI가 그려질 때 View의 생명주기에 대해 보았다. 이번시간에는 UI Rendering 시 화면에 보여질 때 어떤 과정을 거치는지 알아보자. UI Rendering아래 내용은 Google Android Source Document의 그래픽 아키텍쳐 내용을 참고하여 작성되었다. 위와 같은 최적화가 내부적으로 일어나기 위해서는 화면을 그리는 필수요소로, Window, Surface, Canvas, View 레이어로 나눠서 처리하게 된다. Window무언가를 그릴 수 있는 창(Window)이다. 이 영역에서는 그릴 수 있는 Surface를 들고 있고, 애플리케이션은 WindowManager와 상호작용을 통해 Window를 만들고, Window위에 올려진 Surface를 통해 UI를 그린다. 하나의 화면에서는 여러개의 Window를 가지며, WindowManager를 통해 관리받게 된다. 대표적으로 PhoneWindowManager, DialogWindowManager와 같은 요소가 있다. Surface and SurfacHolder기본적으로 안드로이드에서 모든 화면에 그려지는 요소들은, Surface를 통해 처리된다. 안드로이드에서는 Surface와 SurfaceHolder를 통해 그려지는 영역을 제어한다. SurfaceSurface는 화면에 표시하는 이미지를 앱이 렌더링 할 수 있도록 해준다. 해당 클래스는 Android 1.0 초창기부터 API에 내장되어 있었으며, 안드로이드 온라인 도움말 사이트에는 Surface 클래스에 대해서 Screen Compositor가 관리하는 하나의 Raw 버퍼를 가리키는 핸들이라고 설명한다. 잘 이해가 안갈테니, 이미지를 함께 보면서 이해 해보도록 하자. 하나의 애플리케이션은 기본적으로 하나의 Surface를 가진다. BufferQueue는 그래픽 데이터의 버퍼를 생성하는 요소(생산자)를 표시 데이터 또는 추가 처리를 허용하는 요소(소비자)에 연결한다. Suface는 자주 사용되는 BufferQueue를 생성하고(Producer), 버퍼에 데이터를 담아 SurfaceFlinger(Consumer)로 전달하여 출력한다. 이를 통해 화면에 drawing을 하여 Application과 상호작용하게 된다. 각 Surface는 이중 버퍼 렌더링을 위한 1개 이상 (보통 2개)의 버퍼를 가진다. 이중 버퍼 렌더링(Double Buffer Rendering)스크린에 출력될 화면 데이터는 프레임 버퍼에 저장되는데, 하나의 버퍼만 가지는 경우 이미지가 반복해서 그려지게 되거나, 이미지가 다 그려지지 않아도 화면 주사율 때문에 렌더링을 해야할 때, 다 그려지지 않은 프레임 버퍼가 렌더링이 되어서 이미지가 깜빡이는 Flicker 현상이 나타날 수 있다. 이를 해결하기 위해 프레임 버퍼에 바로 렌더링 하지 않고, 다른 버퍼를 만들어서 그 버퍼에 렌더링을 완료 하고, 다음 프레임 버퍼에 옮기는 방식을 사용하여 Flicker 현상을 해결한다. SurfaceFlingerSurfaceFlinger는 버퍼를 받아들이고 버퍼를 구성하며 버퍼를 디스플레이로 보내는 역할을 한다. SurfaceFlinger는 BufferQueue 및 SurfaceControl을 통해 버퍼를 처리할 수 있다. 안드로이드 10부터는 ASurfaceControl라는 것을 통해 버퍼를 받아들인다. 자세한 내용은 Google Android Source Document의 SurfaceFlinger 및 WindowManager를 참고하자. SurfaceHolderSurfaceHolder 인터페이스는 앱이 Surface을 수정하고 제어할 수 있게 해준다. 일부 서비스에서는 제어가 필요한 케이스가 있는데, 대표적으로 SurfaceView, GLSurfaceView를 사용한 기능이다. 영상처리나 카메라 미리보기 화면을 렌더링할 때 특히 많이 사용한다. 일반 VIew와 달리 onDraw를 호출하는 것이 아닌, Thread를 이용하여 화면에 강제로 그려 처리한다. Canvas Rendering안드로이드에서 모든 그려지는 UI 요소는 대부분은 OpenGL ES 또는 Vulkan을 사용하여 View를 렌더링한다. 하지만, 예외 요소도 있기 마련이다. 예를들면 2D게임을 구현한다던지, 스트리밍 컨텐츠를 보여주는 플레이어라던지, 카메라 등에서는 캔버스 API를 통해 뷰를 그리는 작업이 이뤄진다. 이를 Canvas Rendering이라 한다. Canvas가 가지는 특징을 정리하면 아래와 같다. onDraw() 재정의 Canvas(그리는 내용) =&gt; Paint(그리기 방법) 직접 구현도 가능하고, Drawable를 상속한 BitmapDrawable를 이용하여 그릴 수 있다. 프로젝트에 저장된 이미지 리소스(비트맵 파일)를 확장한다. Drawable 속성을 정의하는 XML 리소스(우리가 아는 벡터 파일 변환도 여기 해당!) 도형 Drawable(라운딩 처리 된 사각형, 동그라미 등등등..) NinePatch 드로어블 최종적으로는 SKIA를 통해 캔버스 c++ native API를 호출하여 그린다. 예전에는 모든 렌더링은 소프트웨어 레벨에서 처리되었다. 지금은 하드웨어 레벨에서 처리되어 최적화되어 구현이 가능하지만, 이러한 방식으로 수동적으로 처리가 가능하다. 안드로이드의 경우 일반적으로 그리기를 프레임워크에 맡겨서 Rendering Process를 거치지만(우리가 알고 있는 onDraw() 함수를 통해 그리는 것을 말함), 위에서 언급한 Canvas Rendering의 경우 쓰레드를 이용해 화면에 강제로 그려 원하는 시점에 화면에 그릴 수 있다. 캔버스 구현은 Skia 그래픽 라이브러리에서 제공한다. 직사각형을 그리고 싶은 경우 적절히 버퍼에 바이트를 설정하는 캔버스 API를 호출한다. Canvas 인스턴스를 생성할 때는 이에 바탕이 되는 Bitmap 인스턴스를 생성하여 처리한다. Surface까지 도달하기 위해 어떤 흐름을 타는지 알아보자. 예를 들어, 우리가 View에서 직접 Rect를 생성하여 사각형을 그리고 싶다면, Skia 라이브러리를 호출하여 처리할 수 있다. Skia는 바이트들을 적절하게 버퍼의 형태로 구성한다. 그리고 버퍼가 두 클라이언트에 의해 한번에 업데이트 되는 것을 방지하기 위해, 버퍼에 액세스 하기 위해서는 락을 사용해야 한다. **lockCanvas()**는 버퍼에 락을 걸고 드로잉을 처리하기 위한 Canvas를 리턴한다. 그리고 **unlockCanvasAnsPost()**는 버퍼에 락을 해제하고, 그것을 compositor로 전달한다. 그 과정에서 일어나는 매커니즘은 매우 복잡하지만, 결론은 Surface로 전달 된다. 과거에는 View를 캔버스로 처리했지만, 현재는 범용 3D 엔진을 탑재한 기기들이 늘어나면서, 안드로이드에서 모든 그려지는 UI 요소는 대부분은 OpenGL ES 또는 Vulkan을 사용하여 View를 렌더링하도록 구성된다. 하지만 이전에 사용하던 API와의 호환성이 중요하기 때문에, 하드웨어 가속 Canvas API가 만들어지게 되었다. 지금까지는 그래픽 데이터를 처리하는 과정 및 요소에 대한 내용을 보았다면, 이번에는 해당 데이터를 화면에 직접 보여지는 과정에서 어떤 요소들이 필요하고 어떻게 동작하는지 보도록 하겠다. Surface Flinger and Harware Composer해당글은 Android Drawing Process 1(App surface, SF Layer)를 참고하여 작성하였다. 앞에서 언급했던 SyrfaceFlinger에서는 **HWComposer(Hardware Composer)**를 통해 그래픽 데이터를 디바이스 디스플레이에 전송한다. 이를 도식화 하면, 아래와 같이 표현 가능하다. Layer Management여기서 Layer Management는 우리가 앞서 언급한 각 어플리케이션이 갖는 Surface에서 SufraceFlinger에 의해 Layer 형태로 관리된다. 도식화 하면 아래와 같다. Screen Refreshing디바이스 디스플레이는 특정 주기로 리프레시되며, 일반적으로는 폰이나 테블릿에서는 초당 60프레임의 속도로 리프레시된다. 요즘 나오는 디바이스의 경우 90hz, 120hz 등 고주사율 디스플레이를 탑재하면서, 게임이 아닌 일반적인 애플리케이션은 높은 fps를 지원하게 되었다. 일반적인 디스플레이 주사율을 기준으로 했을 때, 60 FPS(1초에 60프레임)을 지원하며, 이를 바꿔부르면, 16ms안에 화면을 갱신하면 사용자에게 있어 자연스러운 화면전환을 제공할 수 있기 때문에, 16ms 안에 draw가 완료되어야 한다. 안드로이드 4.0 - ICS(아이스크림 샌드위치) 버전까지는 Screen Refershing과정에서 Framebuffer 출력이 SurfaceFligner의 Thread 동작 주기로 임으로 출력이 출력이 되어 프레임이 일정하지 않았다. 만약 16ms 이상 걸리게 된다면 어떻게 될까? View 렌더링 과정이 지체되어 사용자 경험에 좋지 않을 것이고, 애니메이션이 매끄럽게 보이지 않으며, 앱이 정상적으로 작동되지 않는 것처럼 보이게 될 것이다. 흔히 “렉 걸린다” 라는 표현을 주로 하는데, 이를 Frame Drop 이라고 부른다. Frame Drop 이 발생하는 원인은 오랜 시간동안 뷰의 계층구조를 새로 그리거나, 유저가 볼 수 없는 화면에 공을 들여 색칠하는 경우 CPU &amp; GPU 에 과부하를 일으키게 된다. 만약 디스플레이 컨텐츠가 UI 리프레시 도중에 업데이트가 된다면, 티어링(tearing) / 프레임 드롭(Frame Drop) 현상이 나타날 것이다. Project Butter 이러한 문제를 해결하기 위해 Android 4.1JB(젤리빈) 버전부터는 Project Butter를 발표하여 60hz디스플레이에 온전하게 60 FPS를 애플리케이션에서 지원하도록 하였다. 그래서 각 리프레시 주기 동안에 컨텐츠 업데이트를 마무리 하는 것이 중요하다. Proejct Butter에서는 매끄러운 화면 출력을 위해 VSync 기술과 Choreographer를 도입하였다. Vsync ProcessingVSync는 Vertical Synchronization(수직 동기화)의 약자이다. VSync는 화면의 출력되는 정보가 변경이 되었을 때 이를 동기화하고, 지속적으로 갱신해주는 기능이다. 쉽게 설명하면, GPU의 Rendering Rate, 즉 fps와 Device Presenting Rate, 즉 hz사이의 간극이 있을 때 이를 조정한다. 예를들면, GPU가 그리는 프레임은 100fps(초 당 100개의 프레임을 그림), Device Screen의 주사율은 60hz(초 당 60개의 화면을 그림)라면, GPU에서 그리는 것을 그대로 Device Screen에 뿌리게 되면 계속 지연(Delay)이 생길 수 있다. 이 때, VSync가 GPU 프레임과 Device 화면간의 시간차(Time Gap)를 계산하여 필요한 프레임만 만 그려주어 최적화를 해준다. VSync에 대한 Detail한 원리에 대해서 잘 소개된 영상은 Android Performance Patterns: Understanding VSYNC 영상을 참고하라. ChoreographerSurfaceFlinger에서 송신되는 Vsync Event를 요청/수신하여 아래 작업을 처리한다. Input Event Handling Self-Invalidation Animation ViewRootImplViewRootImpl은 DecorView와 Choreographer를 연결해주는 일종의 핸들러 역할을 하는 객체로써, DecorView와 Choreographer 사이에서 둘의 요청을 처리하고 중계한다. Rendering Flow최종적으로 Vsync Process에서는 아래 과정으로 처리된다. 실제 그리기는 현재 foreground에 표시되고 있는 어플리케이션에서 그릴 것이 생김으로써 시작한다. 특정 변화가 생겨 Invalidate를 호출하게 되면 ViewRootImpl에 scheduleTraversal() 함수를 호출한다. scheduleTraversal() 메서드 내부에서는 Choreographer 객체에게 다음 Vsync를 예약해달라는 요청을 보내게 된다. 이 작업이 위 그림에서 Invalidate와 Vsync scheduling에 해당한다. Choreographer에 VSync 스케쥴링을 요청하여 Frame Render를 Screen Rate에 맞춘다. Vsync 예약 요청을 받은 Choreographer는 SurfaceFlinger로 하여금 다음 Vsync 도착 시 알려달라고 요청한다. 다음 Vsync signal이 도착하여 Choreographer에서 받게된다. Choreographer는 ViewRootImpl의 performTraversal() 메서드를 호출한다. performTraversal 메서드 내부에서는 다시 그려야 될 부분을 measure()하고, 레이아웃을 재구성한다. 마지막으로 performDraw() 메서드를 호출하여 그리기를 수행한다. Software Rendering Model V.S. Hardare Rendering Model안드로이드의 렌더링 모델은 안드로이드3.0((API 레벨 11, 허니컴))버전을 기준으로 나뉜다. 이전까지는 소프트웨어 모델을 기반으로 렌더링이 되었다. Software Rendering ModelSoftware Rendering Model은 Android 3.0 전 버전까지 사용되던 방식이다. CPU 연산기반으로 동작하였으며, 아래 두단계로 그려진다. 계층 구조 무효화 계층 구조 그리기 Hardare Rendering Model (By using GPU)Android 3.0부터 Android 2D 렌더링 파이프라인 하드웨어에서는 가속화를 지원하므로, View의 캔버스에서 실행되는 모든 그리기 작업에서 GPU를 사용한다. 하드웨어 가속을 사용하려면 필요한 리소스가 늘어나므로 앱에서 더 많은 RAM을 사용한다. Android 시스템에서는 여전히 invalidate() 및 draw()를 사용하여 화면을 업데이트하고 보기를 렌더링하지만, 실제 그리기는 다르게 처리한다. Android 시스템에서는 즉시 그리기 명령을 실행하지 않고, 보기 계층 구조의 그리기 코드 출력을 포함하는 표시 목록에 기록한다. 또한 Android 시스템에서 invalidate() 호출을 통해 더티로 표시된 보기의 표시 목록을 기록하고 업데이트만 하면 되도록 최적화한다. 무효화되지 않은 보기는 단순히 이전에 기록된 표시 목록을 다시 실행하여 다시 그릴 수 있습니다. 새 그리기 모델에는 다음 세 단계가 포함된다. 계층 구조 무효화 표시 목록 기록 및 업데이트 표시 목록 그리기 Internal UI Rendering Optimization우리가 사용하는 상위 수준의 객체들(Button, TextView, etc.)은 아래의 과정을 거쳐 화면의 픽셀로 나타낼 수 있다. CPU Level에서 상위 수준의 객체들을 가져오고, 이 객체를 그리기 위한 집합인 displaylist 로 바꾸어준다. GPU는 높은 수준의 객체들을 가져와 텍스처 또는 화면에서 픽셀로 바꾸어주는 Rasterization기능을 수행한다. CPU에서 만들어진 명령어들은 OpenGL-ES api를 이용해 GPU에 업로드 되며, 픽셀화에 이용된다. 한번 업로드되면 displaylist 객체는 캐싱되는데, 이는 우리가 다시 displaylist를 통해 그리고 싶다면 다시 새로 생성할 필요없이 기존에 존재하는 것을 다시 그리기 때문에 비용이 훨씬 더 저렴하다. UI 렌더링이 진행될 때, CPU에서 displaylist 를 생성하고 GPU에 업로드 하는 과정은 매우 고비용(High Cost)적이기 때문에, 효율적인 개선안을 찾아야한다. Extra InfoDisplaylist란 ? 안드로이드 3.0 이전에는 View의 변경사항이 일어나면, ViewRoot까지 전파하도록 설계되었다. View에서 ViewGroup, ViewRoot를 거쳐 다시 View 까지 내려와야하는 과정이 많은 코드를 접근하기 때문에 비효율적이었다. 이러한 대안에 Displaylist가 나오게 되었는데, 이는 UI 요소를 그리기 위한 정보를 리스트로 모아둔 것이다. UI요소의 변경이 일어났을 때, 다시 View Tree 를 탈 필요가 없이 리스트를 확인하고 사용하면 된다는 이점이 있다. 이번시간에는 Window, Surface, Canvas에 대해 소개하고, 소프트웨어 레벨에서 어떻게 하드웨어 레벨까지 동기화 되는지 정리해보았다. 또한 View가 렌더링 될 때 두가지 방식으로 어떻게 동작하는지 개념 설명 및 원리 설명을 했다. 다음 포스트에서는 하드웨어 가속을 사용하는 GPU 렌더링 체계의 경우 어떤 문제가 있고, 어떻게 프로파일링 하고, 어떻게 모니터링하는지 알아보도록 하겠다. 그리고 어떻게 최적화 할 수 있을지 방법을 소개하도록 하겠다.","link":"/Team-Blog/2021/05/19/2021-05-19%20Android%20UI%20Rendering%20Optimization%20Part%202/"},{"title":"Introduce Android UI Rendering Principle and View Optimization Part 3","text":"Writers by 김남훈 @Naver by 배희성 @RocketPunch by 송시영 @SmartStudy by 이기정 @BankSalad by 정세희 @BankSalad by 최소영 @BankSalad 저번 포스트에서는 UI Rendering 시 화면에 보여질 때 어떤 과정을 거치는지 알 수 있었고, 현재 보편적으로 사용되는 하드웨어 모델 기반 렌더링 방식에서 발생하는 문제는 무엇이고, 해당 문제를 해결하기 위해 어떤 방법이 있는지, 실제로 어느정도의 성과를 낼 수 있는지 정리해보았다. 버벅거림(Jank)앱이 느린 렌더링으로 어려움을 겪는 경우, 시스템은 프레임을 건너 뛰게되고 사용자는 앱에서 끊김을 감지하게 된다. 버벅거림에는 여러문제가 있지만, 대표적으로 UI렌더링 시에는 OverDraw, Slow Rendering과 같은 문제가 존재한다. Slow Rendering 방지하기해당 내용은 Google Android Source Document의 느린 렌더링글 을 참고하였다. 렌더링 시 버벅거림을 감지할 수 있는 방법은 세가지이다. Visual inspection Systrace Custom performance monitoring 시각적 검사(Visual Inspection)우리는 안드로이드에서 제공하는 몇가지 옵션을 통해 시각화 하여 문제를 해결할 수 있다. 해결책은 아래와 같다. Profile GPU Rendering 을 활성화60fps(GPU 연산으로 초 당 60프레임으로 화면을 뿌리는 것)일 때 렌더링에 얼마나 성능을 잡아먹는지 확인하기 위해 개발자 옵션을 통해 다음 도구를 사용설정 할 수 있다. 프로파일링은 Android 4.1(API 16 ) 이상에서 사용 가능하며 미리 해당 기능을 활성화하는 작업이 필요하다. 다음과 같은 순서로 진행하면 활성화 할 수 있다. 여는방법 기기에서 설정으로 이동하여 개발자 옵션을 탭한다. 모니터링 섹션에서 프로필 GPU 렌더링을 선택한다. ‘프로필 GPU 렌더링’ 대화상자에서 화면에 막대로 표시를 선택하여 기기의 화면에 그래프를 오버레이한다. 프로파일링하려는 앱을 연다. 설정을 활성화 하고 확인해보면, 아래와 같이 히스토그램으로 표시되는 것을 볼 수 있다. 표시되는 각 애플리케이션에 관해 그래프가 표시된다. 가로축의 각 세로 막대는 프레임을 나타내며 각 세로 막대의 높이는 프레임을 렌더링하는 데 걸린 시간(밀리초)을 나타낸다. 녹색 가로선은 16밀리초를 나타냅니다. 60fps를 달성하려면 각 프레임의 세로 막대가 이 선 아래에 머물러야 합니다. 막대가 이 선을 넘어서면 애니메이션이 일시중지될 수 있다. 16밀리초 임계값을 초과하는 프레임은 막대를 더 넓고 덜 투명하게 만들어 강조표시한다. 각 막대에는 렌더링 파이프라인의 단계로 매핑되는 색상으로 표시된 구성요소가 있습니다. 구성요소의 수는 기기의 API 수준에 따라 다르다. 각 막대에는 렌더링 파이프 라인의 단계에 매핑되는 색상 구성 요소가 있으므로 어느 부분이 가장 오래 걸리는지 확인할 수 있다. 예를 들어 프레임이 입력을 처리하는 데 많은 시간을 소비하는 경우 사용자 입력을 처리하는 앱 코드를 살펴 봐야한다. 막대 색상 별 의미 세로 막대 차트는 위와 같이 8개의 단계로 표시된다. 프로세스/스왑버퍼(Swap): 안드로이드는 디스플레이 목록을 GPU 에 제출하는것을 끝내면, 시스템은 그래픽 드라이버에 현재 프레임이 완료되었음을 알리며 드라이버를 업데이트된 이미지를 화면에 표시한다. CPU 와 GPU 는 병렬로 처리되는데 CPU 가 GPU 처리보다 빠른 경우, 프로세스간 통신 큐가 가득찰 수 있다. CPU 는 큐에 공간이 생길때까지 기다린다. 큐가 가득한 상태는 스왑버퍼 상태에서 자주 발생하는데 이 단계에서 프레임 전체의 명령어가 제출되기 때문이다. 명령어 실행 단계와 비슷하게 GPU 에서 일어나는 일의 복잡성을 줄여 문제를 해결할 수 있다. 명령어 실행(Issue): 디스플레이 목록을 화면에 그리기 위한 모든 명령어를 실행하기 위해 걸리는 시간을 측정한다. 주어진 프레임에서 렌더링하는 디스플레이 목록과 수량을 직접적으로 측정한다. 내재적으로 많은 그리기 동작이 있는 경우, 오랜 시간이 걸릴수 있다. 동기화/업로드(Upload): 현재 프레임에서 비트맵 객체가 CPU 메모리에서 GPU 메모리로 전송되는데 걸리는 시간을 측정한다. 오랜 시간이 걸리는 경우는 작은 리소스가 많이 로드되어 있거나 적지만 큰 리소스가 로드되어 있는 경우이다. 비트맵 해상도가 실제 디스플레이 해상도보다 큰 사이즈로 로드되어 있지 않도록 하거나 동기화 전에 비동기로 미리 업로드해서 실행 시간을 줄일 수 있다. 그리기(Draw): 백그라운드 혹은 텍스트 그리기와 같은 뷰를 그리기 명령어로 번역하는 단계로 시스템은 명령어를 디스플레이 목록에 캡처한다. 무효화된 뷰에서 onDraw 호출을 실행해 걸리는 모든 시간을 측정하며, 오랜 시간이 걸린다는 것은 무효화된 뷰가 많다는 것을 의미한다. 뷰가 무효화되는 경우 뷰의 디스프레이 목록을 재생성한다. 혹은 커스텀한 뷰가 onDraw 할때 복잡한 로직을 가질 때도 실행시간이 오랜 걸린다. 측정 및 배치(Measure): 안드로이드에서 뷰를 스크린에 그리기 위해 측정하고 배치하는데 걸리는 시간을 측정한다. 일반적으로 오랜 시간이 걸리는 경우는 배치할 뷰가 너무 많거나 혹은 계층구조의 잘못된 장소에서 중복 계산이 이뤄지며, Traceview와 Systrace 를 사용해서 호출 스택을 확인하여 문제를 파악할 수 있다. 애니메이션(Anim): 현재 프레임에서 실행되는 애니메이션에 대해 걸리는 시간을 측정한다. 일반적으로 오랜 시간이 걸리는 경우는 애니메이션의 속성 변경으로 인해 발생한다. 입력 처리(Input): 앱이 입력 이벤트를 처리하는 시간으로 입력 이벤트 콜백의 결과로 호출된 코드를 실행하는데 걸리는 시간을 나타낸다. 일반적으로 오랜 시간이 걸리는 경우는 메인쓰레드에서 발생하며, 작업을 최적화하거나 다른 쓰레드를 이용해서 작업을 실행하도록 한다. 기타(Misc): 렌더링 시스템이 작업을 수행하는 시간외에 렌더링과 관련 없는 추가적인 작업이 있다. 일반적으로 렌더링의 연속된 두 프레임 사이에서 UI 스레드에서 발생할 수 있는 일을 나타낸다. 오랜 시간이 걸리는 경우, 다른스레드에서 실행해야할 콜백, 인텐트 또는 기타 다른 작업이 있을 수 있다. Method tracing 또는 Systrace 를 사용하면 메인스레드에서 실행중인 작업을 확인해 문제를 해결할 수 있다. 아래에는 이미지 뷰에 클릭 이벤트를 설정하고 이미지 리소스를 변경하는 로직이다. 좌측에는 단순하게 이미지 리소스를 변경하는 로직만 추가하였고, 우측에는 리소스를 변경하는 과정에서 스레드를 일시 중단하는 코드를 추가하였다. 그 결과 입력처리 시간에 차이가 발생한다는 것을 확인할 수 있다. 아래에는 이미지 뷰에 각각 다른 크기의 이미지 리소스를 배치하였다. 좌측에는 8.1MB 크기의 이미지 리소스를 배치하고 우측에는 16KB 크기의 이미지 리소스를 배치하였다. 그 결과 이미지를 업로드 시간에 차이가 발생한 다는 것을 확인할 수 있다. Etc예외적인 케이스에 대한 해법으로는 아래 세가지가 있다. Release 버전의 앱을 실행하자. ART(Android Runtime)는 디버깅 기능을 지원하기 위해 몇 가지 중요한 최적화를 비활성화하기 때문이다. 때때로 버벅거림은 앱이 cold start 에서 시작될 때만 재현 될 수 있다. 버벅거림을 극대화 시키기 위해 더 느린 장치에서 앱을 실행해 봐라. Systrace기기가 수행하는 전체 작업을 보여주는 도구이지만 앱에서 버벅거림을 식별하는 데 유용할 수 있다. Systrace는 최소한의 시스템 오버헤드를 가지므로 계측 중에 현실적인 버벅거림을 경험할 수 있다. 버벅거림을 유발할 수 있는 요소들버벅거림을 유발하는 요소는 대표적으로 Scrollable lists, Layout performance, Rendering performance가 있다. Scrollable listsListView 및 특히 RecyclerView는 버벅거림에 가장 취약한 복잡한 스크롤 목록에 일반적으로 사용된다. 둘 다 Systrace 마커가 포함되어 있으므로 Systrace를 사용하여 앱에서 버벅거림을 유발하는지 여부를 파악할 수 있다. RecyclerView의 systrace 섹션을 표시하려면 명령에 -a &lt;your-package-name&gt;을 전달해야한다. 사용 가능한 경우 systrace 출력에 생성 된 경고의 지침을 따르자. Systrace 내에서 RecyclerView systrace 섹션을 클릭하여 RecyclerView가 수행하는 작업에 대한 설명을 볼 수 있다. 작은 업데이트를 위해 notifyDataSetChanged(), setAdapter(Adapter), or swapAdapter(Adapter, boolean)를 호출하지 마라. 전체 목록 아이템이 변경되었다고 알리기 때문이다. 대신 SortedList 또는 DiffUtil을 사용하여 콘텐츠가 변경되거나 추가 될 때 최소한의 업데이트를 하도록하자. Nested recyclerview 내부 RecyclerView의 LinearLayoutManager에 setInitialPrefetchItemCount(int) 를 설정할 수도 있다. 예를 들어 항상 3.5 개의 항목이 한 행에 표시되는 경우, innerLinearLayoutManager.setInitialItemPrefetchCount(4); 를 호출한다. RecyclerView 의 view type 이 적을수록 새 item type 이 화면에 표시 될 때 수행해야하는 inflation 이 줄어 든다. 만약 아이콘, 색상, 작은 문구 변경 차이라면, 별도의 view type 으로 나누지 않고 bind 할 때 변경하는 것이 낫다. (동시에 앱의 메모리 사용량 감소) Bind (즉, onBindViewHolder (VH, int) 는 매우 간단해야하며 가장 복잡한 항목을 제외한 모든 항목에 대해 1 밀리 초 미만이 소요되야 한다. 단순히 adapter 의 내부 item 에서 POJO item 을 가져와서, ViewHolder의 view 에서 setter 를 호출해야 한다. Layout performanceSystrace에서 Choreographer # doFrame의 레이아웃 세그먼트가 너무 많은 작업을 수행하거나 너무 자주 작업을 수행하는 것으로 표시되면 레이아웃 성능 문제가 있음을 의미한다. 세그먼트가 몇 밀리 초보다 길면 RelativeLayouts 또는 weighted-LinearLayouts에 대해 최악의 경우 중첩 성능에 도달 할 수 있다. 이러한 각 레이아웃은 자식의 여러 측정 / 레이아웃 패스를 트리거 할 수 있으므로 중첩하면 중첩 깊이에서 O (n ^ 2) 동작이 발생할 수 있다. 계층 구조의 최하위 리프 노드를 제외한 모든 노드에서 RelativeLayout 또는 LinearLayout의 가중치 기능을 피해라. Rendering performanceAndroid UI는 UI 스레드의 Record View # draw와 RenderThread의 DrawFrame의 두 단계로 작동한다. 첫 번째는 모든 invalidated View 에서 draw (Canvas)를 실행한다. 두 번째는 기본 RenderThread에서 실행되지만 View#draw() 단계에서 생성 된 작업을 기반으로 작동한다. View#draw() 가 너무 오래 걸린다면, 이 경우는 보통 UI 스레드에서 bitmap 이 그려지는 경우다. Bitmap 에 그리기는 CPU 렌더링을 사용하므로 일반적으로 가능하면 이를 피해야 한다. Custom Performance Monitoring(맞춤 성능 모니터링 사용)로컬 기기에서 버벅거림을 재현할 수 없는 경우 앱에 맞춤 성능 모니터링을 빌드하여 현장에서 기기의 버벅거림 원인을 식별할 수 있다. 이를 위해 FrameMetricsAggregator를 사용하여 앱의 특정 부분에서 프레임 렌더링 시간을 수집하고 Firebase Performance Monitoring을 사용하여 데이터를 기록하고 분석할 수 있다. 자세한 내용은 아래내용을 참조하자. Android Vitals Firebase Performance Monitoring 사용 Overdraw An app may draw the same pixel more than once within a single frame, an event called overdraw. Overdraw is usually unnecessary, and best eliminated. It manifests itself as a performance problem by wasting GPU time to render pixels that don’t contribute to what the user sees on the screen. 오버드로는 시스템이 단일 렌더링 프레임에서 화면에 여러 번 픽셀을 그리는 것을 말한다. 참고 : Overdraw는 더 이상 Google I/O 성능 세션 및 성능 패턴 동영상에서 논의되었을 때 만큼 심각한 문제가 아니다. 이는 저가형 장치가 GPU 성능에서 지속적으로 성장하는 반면 디스플레이는 상대적으로 낮은 해상도에서 정체 되었기 때문. 알려진 저 성능 GPU 장치를 최적화하지 않는 한, 원활한 앱 성능을 보장하는 것 대신 UI 스레드 작업을 최적화하는 데 집중하는 것이 좋다. 참고영상을 확인하자. 다른 개발자 옵션으로 UI 에 컬러를 지정함으로써 오버드로를 식별할 수 있다. 같은 프레임내에서 같은 픽셀을 한번 이상 그릴 때 오버드로가 발생한다. 앱에서 필요 이상으로 많은 렌더링이 발생하는 곳을 시각화로 보여주며, 사용자에게 보여지지 않는 픽셀을 렌더링하기 위해 추가 GPU 작업으로 성능 문제가 발생한 수 있음을 알 수 있다. 다음과 같이 설정하면 오버드로 시각화를 확인 할 수 있다. Overdraw 디버깅여는방법 기기에서 설정으로 이동하여 개발자 옵션을 탭한다. 하드웨어 가속 렌더링 섹션으로 스크롤하여 GPU 오버드로 디버그를 선택한다. GPU 오버드로 디버그 대화상자에서 오버드로 영역 표시를 선택한다. 분석 True color: No overdraw Blue: Overdrawn 1 time Green: Overdrawn 2 times Pink: Overdrawn 3 times Red: Overdrawn 4 or more times 디버깅 결과는 아래와 같이 비교 가능하다. 뷰의 배치에 따라 각각 오버드로가 발생한 픽셀을 확인할 수 있다. Overdraw 줄이기Overdraw를 줄일 수 있는 방법은 대표적으로 세가지가 있다. layouts 에서 불필요한 backgrounds 는 제거하자 View 계층을 평면화하자 투명도를 줄이자 알파 렌더링으로 알려진 화면에서 투명 픽셀을 렌더링하는 것은 오버드로의 주요 원인이다. 시스템이 그 위에 불투명 한 픽셀을 그려서 기존의 그려진 픽셀을 완전히 숨기는 표준 오버드로와 달리, 투명한 객체는 올바른 blending equation 이 발생하도록 기존 픽셀을 먼저 그려야한다. 참고 blending equation : 2개의 픽셀 컬러 값을 결합시키는 것. 관련 블로그 UI 렌더링 성능 개선지금까지는 원인 및 분석 방법에 대해서 살펴보았다. 이번에는 본격적으로 코드레벨에서 분석 및 개선방안을 통해 어떻게 개선할 수 있는지 보자. 레이아웃 재사용 include, merge를 통해 뷰를 재사용한다. include로만 뷰를 재사용하면 다음과 같이 뷰가 중첩될 수 있다. merge를 같이 사용하여 중첩을 줄여준다 오버드로잉 방지(뷰 백그라운드)일반적으로 우리는 앱의 배경 색상을 적용하기 위해 android:background=&quot;@color/white&quot; 해당 뷰의 배경색상을 적용한다. 1234567891011121314151617181920&lt;!-- /res/layout/activity_main.xml --&gt;&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;.MainActivity&quot; android:background=&quot;@color/white&quot;&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;Hello World!&quot; app:layout_constraintBottom_toBottomOf=&quot;parent&quot; app:layout_constraintLeft_toLeftOf=&quot;parent&quot; app:layout_constraintRight_toRightOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; 이러한 방법은 View에 그려짐에 있어 중복으로 그릴 수 있는 여지가 있다. 왜 Overdraw가 생기는지 확인을 위해 앱 테마 값을 확인해보았다. 1234567891011121314151617&lt;!-- /res/values/themes.xml --&gt;&lt;resources xmlns:tools=&quot;http://schemas.android.com/tools&quot;&gt; &lt;!-- Base application theme. --&gt; &lt;style name=&quot;Theme.UITest&quot; parent=&quot;Theme.MaterialComponents.DayNight.DarkActionBar&quot;&gt; &lt;!-- Primary brand color. --&gt; &lt;item name=&quot;colorPrimary&quot;&gt;@color/purple_500&lt;/item&gt; &lt;item name=&quot;colorPrimaryVariant&quot;&gt;@color/purple_700&lt;/item&gt; &lt;item name=&quot;colorOnPrimary&quot;&gt;@color/white&lt;/item&gt; &lt;!-- Secondary brand color. --&gt; &lt;item name=&quot;colorSecondary&quot;&gt;@color/teal_200&lt;/item&gt; &lt;item name=&quot;colorSecondaryVariant&quot;&gt;@color/teal_700&lt;/item&gt; &lt;item name=&quot;colorOnSecondary&quot;&gt;@color/black&lt;/item&gt; &lt;!-- Status bar color. --&gt; &lt;item name=&quot;android:statusBarColor&quot; tools:targetApi=&quot;l&quot;&gt;?attr/colorPrimaryVariant&lt;/item&gt; &lt;!-- Customize your theme here. --&gt; &lt;/style&gt;&lt;/resources&gt; 특별히 지정해준 사항이 없어 해당 테마의 Parent를 따라가 보았다. 12345Base.V14.Theme.MaterialComponents.Lightㄴ Base.Theme.MaterialComponents.Light ㄴ Base.Theme.MaterialComponents.Light.DarkActionBar ㄴ Theme.MaterialComponents.Light.DarkActionBar ㄴ Theme.MaterialComponents.DayNight.DarkActionBar 해당 소스에서 아래와 같이 배경 색상을 지정하는 걸 확인하였고 1&lt;item name=&quot;android:colorBackground&quot;&gt;@color/design_default_color_background&lt;/item&gt; 해당 값을 확인해보니 아래와 같이 흰색으로 설정하고 있었다. 1&lt;color name=&quot;design_default_color_background&quot;&gt;#FFFFFF&lt;/color&gt; 한마디로 배경 색상을 흰색으로 칠해주고 그 위에 다시 흰색으로 칠해주고 있었다. 해당 Overdraw를 없애고 내가 원하는 색상으로 설정하기 위해 테마 파일을 아래와 같이 &lt;item name=&quot;android:windowBackground&quot;&gt;@color/beige&lt;/item&gt; 를 통해 오버드로잉 문제를 해결할 수 있다. 123456789101112131415161718&lt;!-- /res/values/themes.xml --&gt;&lt;resources xmlns:tools=&quot;http://schemas.android.com/tools&quot;&gt; &lt;!-- Base application theme. --&gt; &lt;style name=&quot;Theme.UITest&quot; parent=&quot;Theme.MaterialComponents.DayNight.NoActionBar&quot;&gt; &lt;!-- Primary brand color. --&gt; &lt;item name=&quot;colorPrimary&quot;&gt;@color/purple_500&lt;/item&gt; &lt;item name=&quot;colorPrimaryVariant&quot;&gt;@color/purple_700&lt;/item&gt; &lt;item name=&quot;colorOnPrimary&quot;&gt;@color/white&lt;/item&gt; &lt;!-- Secondary brand color. --&gt; &lt;item name=&quot;colorSecondary&quot;&gt;@color/teal_200&lt;/item&gt; &lt;item name=&quot;colorSecondaryVariant&quot;&gt;@color/teal_700&lt;/item&gt; &lt;item name=&quot;colorOnSecondary&quot;&gt;@color/black&lt;/item&gt; &lt;!-- Status bar color. --&gt; &lt;item name=&quot;android:statusBarColor&quot; tools:targetApi=&quot;l&quot;&gt;?attr/colorPrimaryVariant&lt;/item&gt; &lt;!-- Customize your theme here. --&gt; &lt;item name=&quot;android:windowBackground&quot;&gt;@color/beige&lt;/item&gt; &lt;/style&gt;&lt;/resources&gt; /res/layout/activity_main.xml 파일에 android:background=&quot;@color/beige&quot; 코드를 입력 후 Overdraw를 확인한 결과는 다음과 같다. 결론적으로 배경 색상 지정을 테마를 통해 지정하면 Overdraw를 줄일 수 있다. Lazy Load by ViewStub해당 내용은 찰스의 안드로이드 - ViewStub 활용으로 성능 높이기글 을 참고하였다. ViewStub은 사이즈가 없는 보이지 않는 뷰로 런타임에서 늦은 전개(lazy-inflate)를 원할 때 사용할 수 있다. ViewStub을 보이게 만들거나 inflate() 메서드를 호출하면 레이아웃이 전개되면서 ViewStub을 대체하기 때문에 ViewStub은 사라진다. 전개된 뷰는 ViewStub의 부모 뷰에 추가 된다. 레이아웃에서 ViewStub을 사용하는 예제를 확인하자. 12345&lt;ViewStub android:id=&quot;@+id/stub&quot; android:inflatedId=&quot;@+id/subTree&quot; android:layout=&quot;@layout/mySubTree&quot; android:layout_width=&quot;120dp&quot; android:layout_height=&quot;40dp&quot; /&gt; findViewById() 호출을 통해 ViewStub에 접근할 수 있다. 1val viewStub = findViewById(R.id.stub) 생성되는 바인딩 클래스에서 ViewStub은 ViewStubProxy로 표현되며, ViewStub에 대해 접근할 수 있게 해준다. 123val binding: ActivityMainBinding = ...val viewStubProxy = binding.stubval viewStub = viewStubProxy.viewStub() ViewStub에 지정된 레이아웃을 전개 시키기 위해서 서는 setVisibility() 또는 inflate()를 호출 할 수 있다. 123val viewStub: ViewStub = ...viewStub.inflate()//또는 viewStub.visibility = View.VISIBLE ViewStub은 복잡하게 구성된 레이아웃을 빠르게 전개시켜야하는 상황에서, 레이아웃의 전개 시기를 선택적으로 늦출 수 있다. 예를 들어 리스트 형태의 UI를 구성하고 하나의 뷰홀더가 전개 되는데 상당한 비용이 발생한다고 가정하자. 이 때 사용자가 빠르게 화면을 스크롤 할 경우 프레임 드랍이 발생 할 수 있다. 이럴 때 선택적으로 불필요한 레이아웃의 전개를 제어하고 전개 시기를 늦춤으로써 성능을 개선시킬 수 있다. 우리는 1, 2, 3편에서 안드로이드의 기본적인 UI구성요소, 내부적인 렌더링 매커니즘, 렌더링 되면서 성능상 이슈가 있는 부분을 알아보았고 마지막으로 성능에 대한 개선방안에 대해 알 수 있었다. 안드로이드를 공부하는 여러분들께 조금이나마 도움이 되길 바란다. ReferenceMembers of Studyhttps://soda1127.github.io/introduce-jetpack-compose/ https://velog.io/@jshme/How-To-Render-UI-In-Android https://velog.io/@jshme/How-To-Render-UI-In-Android-22 OfficialDocsAndroid vitals Android 드로잉 보기 방법 느린렌터링 Firebase Performance Monitoring 사용 GPU 렌더링 속도 및 오버드로 검사 맞춤 그리기 뷰 최적화 VideosAndroid Performance Patterns: Understanding VSYNC Android Performance Patterns: Rendering Performance 101 Android Performance Patterns: Tool - Profile GPU Rendering Android Performance Patterns: Understanding Overdraw Android Performance Patterns: Invalidations, Layouts, and Performance Android Performance Patterns: Hidden Cost of Transparency Etc찰스의 안드로이드 - ViewStub 활용으로 성능 높이기 Android Drawing Process 1(App surface, SF Layer)","link":"/Team-Blog/2021/05/19/2021-05-19%20Android%20UI%20Rendering%20Optimization%20Part%203/"},{"title":"Image Loading and Caching Library Part 1 — Why use?","text":"Writers by 곽욱현 @Knowre by 김남훈 @Naver by 배희성 @RocketPunch by 송시영 @SmartStudy by 옥수환 @Naver by 이기정 @BankSalad by 정세희 @BankSalad Android에서는 Image를 나타내기 위해 ImageView라는 위젯을 사용한다. ImageView가 무엇인지 간단하게 알아보자. android.widget.ImageView123kotlin.Any ㄴ android.view.View ㄴ android.widget.ImageView ImageView는 View를 상속받아 구현된 Image를 보여주기 위한 위젯이다. android.graphics.Bitmap나 android.graphics.drawable.Drawable 리소스를 표현해줄 수 있으며, tint 처리나 스케일링에 대한 처리에 일반적으로 사용된다. 아래 xml 코드가 ImageView의 일반적인 쓰임새를 나타낸다. 12345678910&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;ImageView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:src=&quot;@drawable/my_image&quot; android:contentDescription=&quot;@string/my_image_description&quot;/&gt;&lt;/LinearLayout&gt; 참고 Android Developers#Drawble Resources 참고 Android Developers#Handling bitmaps Bitmap12kotlin.Any ㄴ android.graphics.Bitmap 흔히 .bmp 확장자로 알려진 이미지 파일 포맷이다. 사이즈가 정해진 이미지를 픽셀들의 조합으로 표현하는 방식이다. 이 사이즈만큼의 픽셀 정보를 다 저장해야하기 때문에 상대적으로 용량이 크고 처리 속도가 느리므로, Android 개발시 메모리 관리에 신경써주어야 하는 부분이 많다. 흔히 볼 수 있는 확장자인 .jpg, .jpeg, .png, .gif 파일들이 비트맵 방식으로 이루어진 이미지 파일이다. Android에서 이미지를 렌더링하려면?Android Platform에서 이미지를 렌더링하려면 어떤 걸 고려해야할까? 먼저 예제를 작성해보자. Android Studio에서 Empty Activity 으로 프로젝트를 생성한 후, Layout을 아래와 같이 수정하였다. 1234567891011121314151617181920&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;.MainActivity&quot;&gt; &lt;ImageView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:src=&quot;@drawable/ic_launcher_foreground&quot; android:background=&quot;@drawable/ic_launcher_background&quot; app:layout_constraintBottom_toBottomOf=&quot;parent&quot; app:layout_constraintLeft_toLeftOf=&quot;parent&quot; app:layout_constraintRight_toRightOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot;/&gt;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; 빌드 후 에뮬레이터로 실행하면 아래와 같이 렌더링 된다. 코드레벨에서 분석하기 위해 xml을 수정하고 ImageView의 소스를 코드로 주입해보자. 코드는 간단하게 아래와 같다. 12345678910class MainActivity : AppCompatActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) var imageView: ImageView = findViewById(R.id.imageView) imageView.background = getDrawable(R.drawable.ic_launcher_background) imageView.setImageResource(R.drawable.ic_launcher_foreground) }} 여기서 imageView 변수의 background 속성은 View에 해당하는 것이므로 제외하고, ImageView 위젯의 메서드인 setImageResource에 대해서 탐구해보자. 12345678910111213141516171819// ImageView#setImageResource@android.view.RemotableViewMethod(asyncImpl=&quot;setImageResourceAsync&quot;)public void setImageResource(@DrawableRes int resId) { // The resource configuration may have changed, so we should always // try to load the resource even if the resId hasn't changed. final int oldWidth = mDrawableWidth; final int oldHeight = mDrawableHeight; updateDrawable(null); mResource = resId; mUri = null; resolveUri(); if (oldWidth != mDrawableWidth || oldHeight != mDrawableHeight) { requestLayout(); } invalidate();} ImageView에는 위 메서드와 유사한 메서드들이 더 존재하고 있다. 12345678910111213// ImageView#setImageBitmap@android.view.RemotableViewMethodpublic void setImageBitmap(Bitmap bm) { // Hacky fix to force setImageDrawable to do a full setImageDrawable // instead of doing an object reference comparison mDrawable = null; if (mRecycleableBitmapDrawable == null) { mRecycleableBitmapDrawable = new BitmapDrawable(mContext.getResources(), bm); } else { mRecycleableBitmapDrawable.setBitmap(bm); } setImageDrawable(mRecycleableBitmapDrawable);} 1234567891011121314151617// ImageView#setImageDrawablepublic void setImageDrawable(@Nullable Drawable drawable) { if (mDrawable != drawable) { mResource = 0; mUri = null; final int oldWidth = mDrawableWidth; final int oldHeight = mDrawableHeight; updateDrawable(drawable); if (oldWidth != mDrawableWidth || oldHeight != mDrawableHeight) { requestLayout(); } invalidate(); }} 12345678910111213141516171819// ImageView#setImageURI@android.view.RemotableViewMethod(asyncImpl=&quot;setImageURIAsync&quot;)public void setImageURI(@Nullable Uri uri) { if (mResource != 0 || (mUri != uri &amp;&amp; (uri == null || mUri == null || !uri.equals(mUri)))) { updateDrawable(null); mResource = 0; mUri = uri; final int oldWidth = mDrawableWidth; final int oldHeight = mDrawableHeight; resolveUri(); if (oldWidth != mDrawableWidth || oldHeight != mDrawableHeight) { requestLayout(); } invalidate(); }} 어떤 방식을 선택하더라도 ImageView에 비트맵을 밀어넣으려하면 비슷비슷한 로직들을 수행하고 있다. 이미지의 가로 및 세로 길이를 획득한다. requestLayout() 메서드를 호출한다. invalidate() 메서드를 호출한다. requestLayout()와 invalidate() 모두 View에 속해있는 메서드이다. 결국 주어진 이미지 리소스를 뷰의 사이즈를 측정한 뒤 onDraw하는 역할을 공통적으로 수행하는 것이다. 이렇게만 보면 간단하지만, Android에서 Bitmap 또는 Drawable과 같은 리소스를 사용할 때엔 아래와 같은 사항을 고려해야 한다. Bitmap 은 쉽게 앱의 메모리한도를 고갈시킬 수 있다. 예를 들어 픽셀 폰은 카메라 사진이 4048x3036 픽셀(12 메가픽셀)까지 찍을수 있다. Bitmap 구성이 ARGB_8888 인 경우, 기본적으로 안드로이드 2.3 (API level 9) 이상에서는 하나의 사진을 메모리에 로딩하기 위해 48MB 의 메모리를 차지하게 된다. 이렇게 큰 메모리를 요구하면 앱에서 사용할 수 있는 모든 메모리를 즉시 사용하게 될 수 있다. UI 스레드에서 비트맵을 로딩하는 것은 앱의 성능을 저하되어 늦은 응답성 또는 ANR 메시지와 같은 원인이 된다. 따라서 Bitmap 을 작업할 때에는 스레드를 적절하게 관리하는 것이 중요하다. 앱에서 여러 Bitmap 을 메모리에 로딩할 때에는, 메모리 관리와 디스크 캐싱이 필요하다. 그렇지 않으면, 앱의 응답성과 유동성이 나빠질 수 있다. 앱에서 Bitmap 을 가져와서 디코딩하고 표시하기 위해서는 이미지 라이브러를 사용하는 것이 좋다. 이미지 라이브러리는 Bitmap 과 관련된 다양하고 복잡한 과정을 대신 관리해주며, 손쉽게 사용할 수 있도록 되어있다. 고려사항을 주제별로 쪼개어서 조금 더 명세해보자. ImageView를 사용할때 고려해야할 점Out of memoryAndroid에서 가장 중요한 것 중 하나는 메모리를 관리하는 것이다. 카메라 하드웨어의 발달로 사진 한 장의 사이즈가 어마어마하게 커졌는데, 이걸 사용자에게 보여준다고 생각한다면 OOM 이슈는 개발자로서 꼭 피해야할 요소일 것이다. 아무리 큰 사이즈의 이미지여도 사용자에게 보여지는 사이즈엔 한계가 있고, 특히 썸네일의 경우 더더욱 고화질일 필요가 없으므로 다운샘플링을 통해 적당한 사이즈의 이미지로 가공하는 테크닉이 필요하다. Slow LoadingBitmap 이미지가 지나치게 크면 이미지를 보여주는 데 많은 시간이 걸리게 되고, 이는 사용자로 하여금 로딩 속도가 느려진 듯한 불쾌한 경험을 선사하게 된다. 비단 사이즈 뿐만 아니라, 이미지를 다운로드 받는 시간과 불필요한 디코딩 등 여러가지 원인이 존재할 수 있다. Bitmap Caching (Memory / Disk cache)반복적으로 노출되는 이미지에 쓰이는 작업을 줄이는 방법은 해당 이미지의 비트맵을 캐싱해두는 것이다. 예를 들어 외부 url을 통해 다운로드 받은 이미지를 캐싱해둔다면, 동일한 url에서 이미지를 다시 그려줄 때에 해당 캐시에서 바로 가져와 사용할 수 있을 것이다. Android에서 캐싱을 처리하기 위해선 먼저 Memory를 먼저 확인한 뒤, 그 다음에 Disk를 검증하도록 처리할 수 있다. LRU CacheAndroid에서는 LruCache라는 객체를 제공해주고 있다. 이 객체를 이용해 비트맵 캐시를 생성해서 작업할 수 있다. 가장 최근에 불러온 이미지를 가장 앞으로 불러오는 식으로 캐시 적중률을 올리는 알고리즘인 LRU Algorithm으로 동작하며, 4Mib(메비바이트) 단위로 캐시 사이즈가 제한되어 있다. 참고 Android Developers#LruCache 참고 androidx.collection.LruCache 참고 Cache replacement policies#recently used Unresponsive UI / Gabarge collectorBitmap의 사이즈가 지나치게 크다면 해당 Bitmap을 처리하기 위해 많은 작업이 필요하게 된다. ui thread에서의 과도한 작업은 결국 끊어지는 듯한 ui를 사용자에게 보여주게 될 것이며, 만약 16ms 이상 걸리는 작업이라면 Android OS가 해당 작업의 프레임을 건너뛰는 이슈를 겪게 될 것이다. Image Library 소개Android에서 ImageView를 통해 Bitmap을 단순히 보여주기 위해서도 고려해야할 점, 처리해야할 문제들이 매우 많다. 이 많은 문제들을 한 번에 다 처리할 수 있는 방법은 바로 검증된 이미지 라이브러리를 사용하는 것이다. 간단하게 Android에서 자주 쓰이는 이미지 라이브러리들의 리스트를 살펴보자. 1. Picasso 개발 주체 : Square Open Source 웹 사이트 : https://square.github.io/picasso/ 주요 기능 이미지 재활용 다운로드 취소 처리 최소한으로 사용하는 메모리 이미지 변환 메모리 및 디스크 캐싱 자동화 2. Glide 개발 주체 : Bump Technologies 웹 사이트 : https://bumptech.github.io/glide/ 주요 기능 미디어 디코딩 LruResourceCache 및 MemorySizeCalculator를 사용한 메모리 캐싱 Lru 기반의 디스크 캐싱 (기본값 250mb) 리소스 풀링을 위한 간단한 인터페이스 제공 RGB_565의 기본 포맷 사용 gif, jpeg, war, png, webp 포맷 지원 Coil (Coroutine Image Loader) 개발 주체 : Instacart 웹 사이트 : https://github.com/coil-kt/coil 주요 기능 MemoryCache.Key를 사용한 메모리 캐싱 OkHttpClient 기반의 디스크 캐싱 (CoilUtils.createDefaultCache에서 옵션 설정) 다운 샘플링 이미지 재사용 일시정지 및 취소의 자동화를 비롯한 최적화 작업 Corotines, Okio 등의 최신 라이브러리 사용 bmp, jpeg, png, webp 포맷 지원 Android 8.0 이상에서 heif 포맷 지원 coil-gif 의존성 추가시 Android 9.0 이상에서 animated webp 포맷 지원 Android 11.0 이상에서 animated heif 지원 () coil-svg 의존성 추가시 svg 포맷 지원 coil-video 의존성 추가시 Android가 지원하는 모든 비디오 코덱으로부터 정적 frame 획득 가능 Fresco 개발 주체 : Facebook 웹 사이트 : https://frescolib.org 주요 기능 압축된 이미지를 통한 메모리 사용 최소화 이미지 파이프라인을 통한 최적화 Drawees를 사용한 이미지 렌더링 URI 지정을 통한 점진적 jpeg 이미지 개선 Android 4.0 이하에서 OOM을 최소화 다운로드중일 경우 PlaceHolder 제공 AMUL (Android-Universal-Image-Loader) 개발 주체 : Sergey Tarasevich(User) 웹 사이트 : https://github.com/nostra13/Android-Universal-Image-Loader/wiki 주요 기능 동기/비동기 기반의 멀티스레드 이미지 로딩 Thread / Downloader / Decoder에 대한 광범위한 커스터마이징 메모리 및 디스크 캐싱 자동화 다운로드 진행률 제공 대표적인 라이브러리들의 간단한 성능 비교PicassoPicasso 는 번거로움 없이 종종 단 한줄의 코드만으로도 이미지를 로딩할 수 있게 해준다. 어댑터에서 이미지뷰를 재사용하고 다운로드와 취소할 수 있다. 적은 메모리 사용으로 복잡한 이미지 변환을 할 수 있다. 자동 메모리와 디스크 캐싱을 지원한다. 또한 Picasso는 최소한의 메모리로 이미지의 다양한 Transformation을 지원하며, 자동으로 메모리 &amp; 디스크 캐싱, 어댑터에서 ImageView를 재활용 및 다운로드 취소가 가능하다는 점을 강조하고 있다. MinSdkVersion CompileSdkVersion AAR Size 비고 14 29 105kb GIF를 지원하지 않음 1234567891011Picasso.get().load(url) .transform(RoundedCornersTransformation(128, 3)) .into(imageView5, object : Callback { override fun onSuccess() { toast(&quot;Complete&quot;) } override fun onError(e: Exception?) { TODO(&quot;Not yet implemented&quot;) } }) 최초 로딩 속도 : 6.4s 기본 캐싱 적용 : 1.6s Picasso는 원본 이미지 크기를 그대로 비트맵에 그린 후에 이미지뷰에 적용한다. 아래와같이 1000 * 800 의 이미지가 존재할 때, Bitmap 에 1000 * 800 * 4bytes = 3MB 가 ImageView 위에 올라갈 것이다. 그렇기 때문에 고화질의 이미지를 로드한다면 OOM을 발생시킬 수 있다. 이 문제를 방지하기 위해 fit() 함수를 이용한다면 고화질 이미지를 로드하기 전 이미지뷰의 크기를 먼저 측정하기 때문에 메모리 사용량을 최소화할 수 있을 것이다. 1234Picasso.get() .fit() .transform({...}) .load(url) Heap Dump 10,136,858 byte (= 10MB) GlideGoogle에서 만든 이미지 로더 라이브러리인 Glide는 빠른 이미지 로딩, 버벅 거림과 끊김 현상이 발생하지 않는다는 점을 강조하고 있다. 미디어 디코딩, 메모리 및 디스크 캐싱 그리고 리소스 풀링을 간단하고 사용하기 쉽게 인터페이스로 래핑하였으며 페치, 디코딩, 그리고 비디오스틸, 이미지, 움직이는 GIF 를 표시할 수 있다. 커스텀된 HttpUrlConnection 을 기본 스택으로 사용하지만 거의 모든 네트워크 스택에 연결할 수 있는 유연한 API 를 포함하고 있어, Volly 또는 OkHttp 라이브러리를 대신 사용할 수 있다. MinSdkVersion CompileSdkVersion AAR Size 비고 14 26 625kb Glide는 아래처럼 싱글톤으로 만들어 간단하게 사용할 수 있다. 123456789101112131415Glide.with(this) .load(url) .apply(RequestOptions.bitmapTransform(RoundedCornersTransformation(128, 3))) .listener(object : RequestListener&lt;Drawable&gt; { override fun onLoadFailed(e: GlideException?, model: Any?, target: Target&lt;Drawable&gt;?, isFirstResource: Boolean): Boolean { TODO(&quot;Not yet implemented&quot;) } override fun onResourceReady(resource: Drawable?, model: Any?, target: Target&lt;Drawable&gt;?, dataSource: DataSource?, isFirstResource: Boolean): Boolean { toast(&quot;Complete&quot;) return false } }) .into(imageView) 최초 로딩 속도 : 6.2s 기본 캐싱 적용 : 0.72s Picasso와는 달리 Glide는 이미지뷰의 크기를 측정한 다음 원본이미지를 가져와 이미지 뷰 크기에 맞게 리사이징 후 비트맵에 그려주는 것을 기본 옵션으로 하기 때문에 메모리 효율성이 Picasso보다 좋다. Glide가 언급한 이미지 라이브러리 중에서 완벽하게 Gif를 지원하는 것이 특징이다. Picasso는 미지원, Coil은 1.2.2 기준 확장 라이브러리로 Gif를 지원하지만 실제 사용해보니 라이브러리 자체가 불안정했으며, Fresco는 Gif에 Transformation와 같은 다양한 옵션을 적용할 수는 없었다.) Heap Dump 11,004,024 byte (= 11MB) CoilInstacart에서 만든 Coil 은 Coroutine Image Loading의 줄임말로 위에 설명했던 이미지로더 라이브러리와 달리 코틀린 &amp; 코루틴으로 구성되어있다. 제일 장점으로는 라이브러리가 거의 100% 코틀린으로 이루어졌다는 점과 AndroidX, OkHttp 등 현업에서 많이 쓰이고있는 라이브러리들을 지원하고 있다는 점이다. Coil 라이브러리 내부를 살펴보면, Glide와 굉장히 비슷하다는 것을 알 수 있는데 Glide를 많이 벤치마킹했다고 한다 👀. 또한 ImageView의 확장함수로 지원하고, 코틀린의 매력인 함수형 언어 덕으로 다른 라이브러리보다 더욱 간결한 코드를 구성할 수 있다. MinSdkVersion CompileSdkVersion AAR Size 비고 14 30 16kb 1234567imageView.load(url) { listener( onError = { _,_ -&gt; /** Show toast. */ }, onSuccess = { _,_ -&gt; toast(&quot;Complete&quot;) } ) transformations(RoundedCornersTransformation(128f))} 최초 로딩 속도 : 5.24s 기본 캐싱 적용 : 1.3s Heap Dump 6,995,072 byte (= 7MB) 좀 더 자세한 퍼포먼스 테스트는 Part 3에서 다루도록 하자.","link":"/Team-Blog/2021/06/24/2021-06-24%20Image%20Loading%20and%20Caching%20Library%20Part%201/"},{"title":"Image Loading and Caching Library Part 2 — Principle &#x2F; Memory &amp; Footprint &#x2F; Compose","text":"Writers by 곽욱현 @Knowre by 김남훈 @Naver by 배희성 @RocketPunch by 송시영 @SmartStudy by 옥수환 @Naver by 이기정 @BankSalad by 정세희 @BankSalad Image Library의 동작 방식Android 에서 가장 많이 쓰이는 Glide를 기준으로 이미지 라이브러리의 동작 방식을 살펴보자. 먼저 Part 1에서 다루었던 기본 예제를 수정하도록 하자. Glide 의존성 설정123456dependencies { ... implementation 'com.github.bumptech.glide:glide:4.12.0' annotationProcessor 'com.github.bumptech.glide:compiler:4.12.0' ...} 인터넷 사용 권한 부여123456789&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; package=&quot;android.deepdive.raw&quot;&gt; &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&gt; &lt;!-- ... --&gt;&lt;/manifest&gt; 레이아웃 파일에서 이미지 소스 제거12345678&lt;ImageView android:id=&quot;@+id/imageView&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; app:layout_constraintBottom_toBottomOf=&quot;parent&quot; app:layout_constraintLeft_toLeftOf=&quot;parent&quot; app:layout_constraintRight_toRightOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot;/&gt; 코드에 Glide 예제 적용12345678910111213class MainActivity : AppCompatActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) var imageView: ImageView = findViewById(R.id.imageView) Glide .with(this) .load(&quot;https://goo.gl/gEgYUd&quot;) .into(imageView) }} 위와 같이 작업을 하고 나면 아래와 같은 화면을 렌더링할 수 있다. 기능 톺아보기이미지 렌더링 방식1234Glide .with(this) .load(&quot;https://goo.gl/gEgYUd&quot;) .into(imageView) 개발자 입장에서는 매우 간단하게 이미지를 렌더링할 수 있게 해준다. Glide 문서에서 최소로 요구되고 있는 with()와 load(), into()의 내부 구조를 한 번 살펴보자. 1. with 메서드1234@NonNullpublic static RequestManager with(@NonNull FragmentActivity activity) { return getRetriever(activity).get(activity);} 1234567891011@NonNullprivate static RequestManagerRetriever getRetriever(@Nullable Context context) { // Context could be null for other reasons (ie the user passes in null), but in practice it will // only occur due to errors with the Fragment lifecycle. Preconditions.checkNotNull( context, &quot;You cannot start a load on a not yet attached View or a Fragment where getActivity() &quot; + &quot;returns null (which usually occurs when getActivity() is called before the Fragment &quot; + &quot;is attached or after the Fragment is destroyed).&quot;); return Glide.get(context).getRequestManagerRetriever();} with()메서드를 호출하면 getRetriever() 메서드를 통해 RequestManagerRetriever 객체를 획득한다. 이후 get() 메서드를 이용해 RequestManager 객체를 생성하는 코드도 연달아 호출하게 된다. 12345678910111213141516171819@NonNullpublic RequestManager get(@NonNull Context context) { if (context == null) { throw new IllegalArgumentException(&quot;You cannot start a load on a null Context&quot;); } else if (Util.isOnMainThread() &amp;&amp; !(context instanceof Application)) { if (context instanceof FragmentActivity) { return get((FragmentActivity) context); } else if (context instanceof Activity) { return get((Activity) context); } else if (context instanceof ContextWrapper // Only unwrap a ContextWrapper if the baseContext has a non-null application context. // Context#createPackageContext may return a Context without an Application instance, // in which case a ContextWrapper may be used to attach one. &amp;&amp; ((ContextWrapper) context).getBaseContext().getApplicationContext() != null) { return get(((ContextWrapper) context).getBaseContext()); } } return getApplicationManager(context);} Context의 instance type에 대한 처리후 제일 마지막에 getApplicationManager()를 호출한다. 123456789101112131415161718192021222324@NonNullprivate RequestManager getApplicationManager(@NonNull Context context) { // Either an application context or we're on a background thread. if (applicationManager == null) { synchronized (this) { if (applicationManager == null) { // Normally pause/resume is taken care of by the fragment we add to the fragment or // activity. However, in this case since the manager attached to the application will not // receive lifecycle events, we must force the manager to start resumed using // ApplicationLifecycle. // T ODO(b/27524013): Factor out this Glide.get() call. Glide glide = Glide.get(context.getApplicationContext()); applicationManager = factory.build( glide, new ApplicationLifecycle(), new EmptyRequestManagerTreeNode(), context.getApplicationContext()); } } } return applicationManager;} with() 메서드는 Global Scope에서 애플리케이션의 생명주기와 연동하여 Glide의 싱글턴 객체를 획득하는 것이 목적이라고 볼 수 있다. 2. load 메서드두 번째로 load() 메서드를 살펴보자. 123456@NonNull@CheckResult@Overridepublic RequestBuilder&lt;Drawable&gt; load(@Nullable String string) { return asDrawable().load(string);} 단순힌 asDrawable()을 호출해 RequestBuilder 객체를 만들고, load()를 호출한다고만 명세되어있다. asDrawable() 구현체를 살펴보자. 12345@NonNull@CheckResultpublic RequestBuilder&lt;Drawable&gt; asDrawable() { return as(Drawable.class);} android.graphics.drawable.Drawable 타입을 as()에 파라미터로 넘겨주고 있다. as() 구현체를 살펴보자. 12345@NonNull@CheckResultpublic &lt;ResourceType&gt; RequestBuilder&lt;ResourceType&gt; as(@NonNull Class&lt;ResourceType&gt; resourceClass) { return new RequestBuilder&lt;&gt;(glide, this, resourceClass, context);} 파라미터로 주어진 객체 타입(여기서는 android.graphics.drawable.Drawable)으로 디코딩하여 반환한다. 여기서 쓰이는 디코더는 com.bumptech.glide.load.ResourceDecoders이다. Drawable.class로 고정되어있지 않은 이유는 리소스 클래스의 서브클래스들도 호환하기 위해서이다. Glide.load()에서 호출하는 asDrawable()이 디코딩할 리소스 클래스를 생성하였다면 바로 뒤에 붙은 RequestBuilder.load() 메서드에서 데이터를 불러올 것임을 추측할 수 있다. RequestBuilder.load() 메서드의 호출 구조를 살펴보자. 123456@NonNull@Override@CheckResultpublic RequestBuilder&lt;TranscodeType&gt; load(@Nullable String string) { return loadGeneric(string);} load()의 파라미터로 주어진 string값을 key로 사용해 데이터를 캐시하는 영역이다. 동일 이미지의 반복적인 렌더링 작업에 대해 처리한 부분임을 알 수 있다. 이후 loadGeneric()을 호출한다. 123456789@NonNullprivate RequestBuilder&lt;TranscodeType&gt; loadGeneric(@Nullable Object model) { if (isAutoCloneEnabled()) { return clone().loadGeneric(model); } this.model = model; isModelSet = true; return selfOrThrowIfLocked();} 파라미터의 타입이 String에서 Object로 변경되었다. 이 model은 com.bumptech.glide.load.model.UriLoader 객체에서 핸들링하게 된다. 12345678@NonNull@SuppressWarnings(&quot;unchecked&quot;)protected final T selfOrThrowIfLocked() { if (isLocked) { throw new IllegalStateException(&quot;You cannot modify locked T, consider clone()&quot;); } return self();} 1234@SuppressWarnings(&quot;unchecked&quot;)private T self() { return (T) this;} 이후 RequestBuilder.load()는 최종적으로 RequestBuilder 객체를 반환해주게 된다. 3. into 메서드현재까지 with()에서 RequestManager객체를 생성한 뒤, 이 객체의 load() 메서드를 호출하여 RequestBuilder 객체를 획득하는 과정까지 진행되었다. 이제 RequestBuilder에서 into() 메서드를 호출해 ImageView에 리소스를 할당하는 마지막 작업이다. 리소스를 할당할 ImageView를 파라미터로 요구한다. 123456789101112131415161718192021222324252627282930313233343536373839@NonNullpublic ViewTarget&lt;ImageView, TranscodeType&gt; into(@NonNull ImageView view) { Util.assertMainThread(); Preconditions.checkNotNull(view); BaseRequestOptions&lt;?&gt; requestOptions = this; if (!requestOptions.isTransformationSet() &amp;&amp; requestOptions.isTransformationAllowed() &amp;&amp; view.getScaleType() != null) { // Clone in this method so that if we use this RequestBuilder to load into a View and then // into a different target, we don't retain the transformation applied based on the previous // View's scale type. switch (view.getScaleType()) { case CENTER_CROP: requestOptions = requestOptions.clone().optionalCenterCrop(); break; case CENTER_INSIDE: requestOptions = requestOptions.clone().optionalCenterInside(); break; case FIT_CENTER: case FIT_START: case FIT_END: requestOptions = requestOptions.clone().optionalFitCenter(); break; case FIT_XY: requestOptions = requestOptions.clone().optionalCenterInside(); break; case CENTER: case MATRIX: default: // Do nothing. } } return into( glideContext.buildImageViewTarget(view, transcodeClass), /*targetListener=*/ null, requestOptions, Executors.mainThreadExecutor());} Util.assertMainThread()에서 메인 쓰레드 여부를 검증한 뒤, Preconditions.checkNotNull(view)에서 파라미터로 주어진 ImageView에 대한 null check를 수행한다. 이후 ImageView의 scaleType에 대한 처리 후, into(target, targetListener, options, callbackExecutor)를 호출한다. 이때 target 자리에 GlideContext.buildImageViewTarget()이라는 메서드를 주입하는데, 파라미터로 주어진 ImageView를 이용해 BitmapImageViewTarget이나 DrawableImageViewTarget으로 변환하는 작업을 수행한다. GlideContext.buildImageViewTarget()의 두 번째 파라미터인 transcodeClass의 값은 Glide.load()를 호출하였을 때 수행하는 as() 메소드의 파라미터인 Drawable.class로 이미 주입되어있다. 123456789101112131415161718192021222324252627282930313233private &lt;Y extends Target&lt;TranscodeType&gt;&gt; Y into( @NonNull Y target, @Nullable RequestListener&lt;TranscodeType&gt; targetListener, BaseRequestOptions&lt;?&gt; options, Executor callbackExecutor) { Preconditions.checkNotNull(target); if (!isModelSet) { throw new IllegalArgumentException(&quot;You must call #load() before calling #into()&quot;); } Request request = buildRequest(target, targetListener, options, callbackExecutor); Request previous = target.getRequest(); if (request.isEquivalentTo(previous) &amp;&amp; !isSkipMemoryCacheWithCompletePreviousRequest(options, previous)) { // If the request is completed, beginning again will ensure the result is re-delivered, // triggering RequestListeners and Targets. If the request is failed, beginning again will // restart the request, giving it another chance to complete. If the request is already // running, we can let it continue running without interruption. if (!Preconditions.checkNotNull(previous).isRunning()) { // Use the previous request rather than the new one to allow for optimizations like skipping // setting placeholders, tracking and un-tracking Targets, and obtaining View dimensions // that are done in the individual Request. previous.begin(); } return target; } requestManager.clear(target); target.setRequest(request); requestManager.track(target, request); return target;} target으로 주어진 ImageView에 리소스를 세팅하는 곳인데, 특기할만한 부분은 requestManager.clear(target)이다. 해당 메서드를 호출하면 현재 target으로 설정된 뷰에 대한 모든 로딩을 취소하고 모든 리소스를 해제한다. Memory &amp; FootprintBitmap를 다루다보면 필연적으로 OOM 관련하여 메모리 이슈를 피할 수 없다. Image Library를 사용하지 않은 상태에서 많은 이미지를 사용하거나 고해상도 이미지를 이미지뷰에 로드해야하는 경우 메모리 부족으로 OOM이 발생하게 된다. 요즘 나오는 스마트폰은 굉장히 많은 메모리를 가지고 태어나는데 왜 이정도도 못 버티지(?) 라는 생각을 한다면, 안드로이드는 앱 내에서 사용할 수 있는 힙 메모리가 정해져있기 때문이다. Android의 메모리 모델은 운영체제 버전에 따라 두가지로 나뉘게 된다. Dalvik heap 영역 : java 객체를 저장하는 메모리 External 영역 : native heap의 일종으로 네이티브의 비트맵 객체를 저장하는 메모리Dalvik heap 영역와 External 영역의 Dalvik heap footprint + External Limit을 합쳐 프로세스당 메모리 한계를 초과하면 OOM이 발생하게 된다. Footprintjava의 footprint는 한 번 증가하면 크기가 다시 감소되지 않기 때문에, footprint가 과도하게 커지지 않게끔 잘 관리해야한다. Dalvik VM은 처음에 동작에 필요한 만큼만 프로세스에 Heap을 할당하게 되고, 프로세스에 할당된 메모리보다 많은 메모리를 필요하게될 때마다 Dalvit Footfrint도 증가하게된다. 하지만 증가된 Footfrint는 결코 감소하지 않기 때문에 java 객체가 사용가능한 메모리 공간의 여유가 있어도, External heap의 크기가 증가되면 OOM이 발생할 수 있다. 하지만 이런 문제도 Honeycomb 이후부터는 Dalvik heap 과 External 영역이 합쳐졌기 때문에, 고려할 필요가 없어졌다. External 영역을 사용하는 Honeycomb 미만 버전에서는 이미지를 많이 사용하고있는 화면에서 화면을 전환하는 행동이 발생했을 때도 OOM이 발생하면서 앱이 중지될 것이다. 화면을 전환하면 이전 액티비티 인스턴스에 있던 이미지뷰나 할당되었던 비트맵이 함께 소멸되어 메모리가 회수되고 새로운 액티비티 인스턴스를 생성할텐데, 이 과정에서 이전 액티비티 인스턴스의 비트맵 객체가 회수되지 않아 메모리 누수가 발생했기 때문이다. 비트맵 객체에 대한 참조가 없는데도 왜 회수가 될 수 없을까? Honeycomb 미만 버전에서는 Java 비트맵 객체는 실제 비트맵 데이터를 가지고 있는 곳을 가리키는 포인터일 뿐이고 실제 데이터는 External 영역인 Native Heap 영역에 저장되기 때문이다. Java 비트맵 객체는 참조가 없을 때 GC에 의해 회수되지만 Native Heap 영역은 GC 수행영역 밖이기 때문에 메모리 소멸 시점이 다르다. 이러한 문제점 때문에, Honeycomb 이후 버전에서는 External 영역이 없어지면서 Dalvik heap 영역에 비트맵 메모리를 올릴 수 있게 되었고 GC도 접근할 수 있게 되었다. 다시 돌아와, 만약 고해상도 이미지를 로드할 때 OOM이 발생하는 경우 BitmapFactory 객체를 이용해 다운샘플링, 디코딩 방식을 선택해 적절하게 뷰에 로드하면 된다. 하지만 많은 이미지를 사용하게 되면서 OOM이 발생한다면, 이미지 캐싱을 이용해보는 것이 어떨까? Bitmap Caching이미지가 화면에서 사라지고 다시 구성할 때 이미지를 매번 로드하는 것은 성능상으로나 사용자 경험에 좋지 않다. 이럴 때 메모리와 디스크 캐시를 이용하여 어디에선가 저장되어있던 비트맵을 다시 가져온다면 다시 로드하는 시간도 단축시킬 수 있으며 성능 개선도 가능할 것이다. 이 때 캐싱을 위해 Memory Cache와 Disk Cache 사용을 추천하는데 두가지가 어떤 차이점이 있는지 알아보자. 1. Memory CacheMemory Cache는 어플리케이션 내에 존재하는 메모리에 비트맵을 캐싱하고, 필요할 때 빠르게 접근가능하다. 하지만 Memory Cache도 곧 어플리케이션 용량을 키우는 주범이 될 수 있기 때문에 많은 캐싱을 요구하는 비트맵의 경우에는 Disk Cache에 넣는 것이 더 좋을 수 있다. 2. Disk CacheMemory Cache에 넣기엔 많은 캐시를 요구하는 경우, 혹은 앱이 백그라운드로 전환되어도 적재한 캐시가 삭제되지 않기를 바란다면 Disk Cache를 이용하는 것이 좋다. 하지만 Disk로부터 캐싱된 비트맵을 가져올 때는 Memory에서 로드하는 것보다 오랜시간이 걸린다. BitmapPoolMemory Cache의 예시를 위해 소개할 것은 BitmapPool이다. BitmapPool의 원리는 사용하지 않는 Bitmap을 리스트에 넣어놓고, 추후에 동일한 이미지를 로드할 때 다시 메모리에 적재하지 않고 pool에 있는 이미지를 가져와 재사용하는 것이다. 보통 BitmapPool을 이용해 재사용 Pool을 만들게 될 때, LRU 캐싱 알고리즘으로 구현된 LinkedList (lruBItmapList)와 Byte Size 순으로 정렬된 LinkedList(bitmapList)를 사용하여 구현하게 된다. 이 둘은 들어있는 비트맵의 순서만 다를 뿐, 같은 비트맵이 담기게된다. 12private val lruBitmapList = LinkedList&lt;Bitmap&gt;()private val bitmapList = LinkedList&lt;Bitmap&gt;() LRU 알고리즘을 이용해 오랫동안 참조되지않은 비트맵 객체는 맨 뒤로 밀리게되고, 맨 뒤에있는 객체를 회수하면서 BitmapPool을 유지시키는 것이다. LRU 알고리즘을 이용하지 않는다면 처음 BitmapPool이 가득 찰 때까지는 문제없이 동작하지만, 비트맵을 재사용하는 시점부터는 특정 비트맵만 재사용될 수 있으며, 앱이 끝날 때까지 메모리가 줄어들지 않게된다. 자세한 내용은 이 블로그를 참고하길 바란다. 대표적인 이미지 로더 라이브러리인 Glide에서 구현한 LruBitmapPool Class 내부를 보며, LruBitmapList와 bitmapList가 어떻게 쓰이고있는지 살펴보자. 1234567891011121314public class LruBitmapPool implements BitmapPool { private static final String TAG = &quot;LruBitmapPool&quot;; private static final Bitmap.Config DEFAULT_CONFIG = Bitmap.Config.ARGB_8888; private final LruPoolStrategy strategy; private final Set&lt;Bitmap.Config&gt; allowedConfigs; private final BitmapTracker tracker; // Pool에 들어올수 있는 최대 크기 private long maxSize; // 현재 pool에 들어간 bitmap byte 크기 private long currentSize; // ... Glide내 LruBitmapPool Class 에서는 strategy(LruPoolStrategy)가 곧 LRU 기반으로 구현된 리스트이며, tracker(BitmapTracker)가 Bitmap size 순으로 정렬된 리스트이다. 12345678910111213141516171819202122232425262728293031323334353637383940414243@Overridepublic synchronized void put(Bitmap bitmap) { if (bitmap == null) { throw new NullPointerException(&quot;Bitmap must not be null&quot;); } // isRecycled: 재활용된 bitmap인지 여부 if (bitmap.isRecycled()) { throw new IllegalStateException(&quot;Cannot pool recycled bitmap&quot;); } // isMutable: canvas를 얻을 수 있는 bitmap 인지 여부. if (!bitmap.isMutable() || strategy.getSize(bitmap) &gt; maxSize || !allowedConfigs.contains(bitmap.getConfig())) { if (Log.isLoggable(TAG, Log.VERBOSE)) { Log.v( TAG, &quot;Reject bitmap from pool&quot; + &quot;, bitmap: &quot; + strategy.logBitmap(bitmap) + &quot;, is mutable: &quot; + bitmap.isMutable() + &quot;, is allowed config: &quot; + allowedConfigs.contains(bitmap.getConfig())); } bitmap.recycle(); return; } // pool에 넣으려는 bitmap의 사이즈를 얻어온다. final int size = strategy.getSize(bitmap); strategy.put(bitmap); tracker.add(bitmap); puts++; currentSize += size; if (Log.isLoggable(TAG, Log.VERBOSE)) { Log.v(TAG, &quot;Put bitmap in pool=&quot; + strategy.logBitmap(bitmap)); } dump(); evict();} Bitmap을 Pool에 넣을 수 있는 조건을 충족시킨다면, strategy &amp; tracker에 bitmap이 들어가게된다. 참고 Lru 기반인 strategy 는 최근에 들어온 bitmap일수록 리스트의 맨 앞으로 배치시켜야하는데, 그 로직이 LruPoolStrategy 구현체 내부에 존재하게 된다. 123456789101112131415161718192021222324// Pool의 최대 사용량을 넘기면 크기를 줄여준다.private synchronized void trimToSize(long size) { while (currentSize &gt; size) { //LRU List에서 삭제한다. final Bitmap removed = strategy.removeLast(); if (removed == null) { if (Log.isLoggable(TAG, Log.WARN)) { Log.w(TAG, &quot;Size mismatch, resetting&quot;); dumpUnchecked(); } currentSize = 0; return; } // BitmapList에서 삭제한다. tracker.remove(removed); currentSize -= strategy.getSize(removed); evictions++; if (Log.isLoggable(TAG, Log.DEBUG)) { Log.d(TAG, &quot;Evicting bitmap=&quot; + strategy.logBitmap(removed)); } dump(); removed.recycle(); }} trimToSize()를 이용하면 pool이 최대사용량을 넘어선 경우 참조를 가장 적게하고 있는 lastIndex 부터 객체를 지워가며 크기를 줄여줄 수 있다. 1234567891011121314151617181920@Override@Nullablepublic Bitmap get(int width, int height, Bitmap.Config config) { final int size = Util.getBitmapByteSize(width, height, config); Key key = keyPool.get(size); Integer possibleSize = sortedSizes.ceilingKey(size); if (possibleSize != null &amp;&amp; possibleSize != size &amp;&amp; possibleSize &lt;= size * MAX_SIZE_MULTIPLE) { keyPool.offer(key); key = keyPool.get(possibleSize); } final Bitmap result = groupedMap.get(key); // 비트맵을 찾은 경우, pool에서 제거한다. if (result != null) { result.reconfigure(width, height, config); decrementBitmapOfSize(possibleSize); } return result;} 이미지를 로드하기 위해 pool에서 필요한 비트맵을 가져온다. Jetpack Compose에서 이미지 라이브러리 사용하기Google 에서는 Jetpack Compose를 보다 편하게 사용하기 위한 라이브러리를 묶어서 제공한다. Accompanist 라고 하는 GroupId를 가진 라이브러리 모음이다. 참고 Google#Accompanist Repository Accompanist에서는 Glide와 Coil을 지원하고 있다. 의존성 설정은 아래와 같다. 123456dependencies { ... implementation &quot;com.google.accompanist:accompanist-glide:0.11.1&quot; implementation &quot;com.google.accompanist:accompanist-coil:0.11.1&quot; ...} Glide는 아래와 같이 적용한다. 1234567891011121314Image( painter = rememberGlidePainter( request = &quot;https://picsum.photos/300/300&quot;, // placeHolder ), contentDescription = stringResource(R.string.image_content_desc))Image( painter = rememberGlidePainter( request = &quot;https://cataas.com/cat/gif&quot;, // placeHolder ), contentDescription = null) Coil은 아래와 같이 적용한다. 1234567Image( painter = rememberCoilPainter( request = &quot;https://picsum.photos/300/300&quot;, // placeHolder ), contentDescription = null) Coil에서 gif를 렌더링하기 위해선 coil-gif 의존성을 추가한다. 12345678dependencies { ... implementation &quot;com.google.accompanist:accompanist-glide:0.11.1&quot; implementation &quot;com.google.accompanist:accompanist-coil:0.11.1&quot; // Coil 에서 gif 를 사용하기 위해서 추가 implementation &quot;io.coil-kt:coil-gif:1.2.2&quot; ...} 아래와 같이 별도의 ImageLoader를 설정한다. 123456789fun gifImageLoader(context: Context) = ImageLoader.Builder(context) .componentRegistry { if (SDK_INT &gt;= 28) { add(ImageDecoderDecoder(context)) } else { add(GifDecoder()) } } .build() Image의 적용은 아래와 같이 적용한다. 1234567Image( painter = rememberCoilPainter( request = &quot;https://cataas.com/cat/gif&quot;, imageLoader = gifImageLoader(LocalContext*.current), ), contentDescription = null)","link":"/Team-Blog/2021/06/24/2021-06-24%20Image%20Loading%20and%20Caching%20Library%20Part%202/"},{"title":"Image Loading and Caching Library Part 3 — Performance Test","text":"Writers by 곽욱현 @Knowre by 김남훈 @Naver by 배희성 @RocketPunch by 송시영 @SmartStudy by 옥수환 @Naver by 이기정 @BankSalad by 정세희 @BankSalad 이미지 라이브러리들 중 Glide, Fresco, Coil에 대해서 성능 테스트를 해보자. 성능 테스트에 사용한 기기는 Pixel 4a, 값의 측정은 Android Studio Profiler를 사용하였다. 각 세트는 동일한 조건에서 테스트하였으며, 별도의 추가 옵션없이 각 라이브러리의 기본 세팅으로 테스트를 수행하였다. 측정값은 이미지 로딩 전후로 CPU, Memory, Disk를 10번씩 측정한 후의 평균값이다. 테스트 애플리케이션의 스토리지가 증가한 뒤, 스토리지를 비우고 다시 측정하였다. 참고 기본 세팅이니만큼 Picasso의 경우 거대한 이미지를 대부분 불러오지 못했다. Case 1) 하나의 거대한 이미지를 출력하는 경우테스트에 쓰인 이미지는 7,680 x 4,320의 사이즈와 4.29mb의 용량을 가진 24-bit의 color depth를 가진 이미지이다. Library CPU Memory Disk Coil 38.3% 4.26MB X Glide 40.8% 3.41MB 0.21MB Fresco 40.2% 8.14MB X 1개의 거대한 이미지의 경우 특기할만한 성능 차이는 존재하지 않았다. Case 2) 동일한 이미지를 여러 번 출력하는 경우Case 1의 이미지를 ScrollView에 50개 추가하여 테스트하였다. Library CPU Memory Disk Coil 93.6% 350.8MB X Glide 45.4% 4.6MB 0.21MB Fresco 72.4% 8.4MB X Coil의 Cpu, Memory 사용량이 매우 크게 증가하였다. Glide는 앱을 끈 후 다시 로딩했을 때 딜레이가 없었어 재로딩 했을 때 매우 효율적으로 동작하였다. 아래 세부 프로파일링을 보면 Coil이 Coroutine을 사용할 때 CPU, Memory가 정말 많이 사용된다는 것을 알 수 있다. 아래는 Coil로 테스트하였을 때의 프로파일링 결과이다. 아래는 Glide로 테스트하였을 때의 프로파일링 결과이다. Glide가 하나의 이미지를 여러개 불러올 때 제일 효율이 좋은 것으로 나타났다. Case 3) 여러 이미지를 각각 출력해보는 경우 (feat_ ScrollView)2mb ~ 10mb 사이의 각기 다른 용량을 가진 이미지 10개를 ScrollView에 추가하여 테스트하였다. Library CPU Memory Disk Coil 88.6% 800MB X Glide 89% 303.3MB 4.6MB Fresco 92.6% 276MB X 캐싱을 기대할 수 없는 만큼 대체적으로 모두 CPU, Memory사용량이 올라갔다. 그 중 Coil이 제일 많은 Memory를 사용하였다. Case 4) 여러 이미지를 각각 출력해보는 경우 (feat_ RecyclerView)Case 3에서 사용한 이미지를 RecyclerView에 추가하여 테스트하였다. Library CPU Memory Disk Coil 94% 800MB X Glide 94% 270MB 4.52MB Fresco 94.6% 281MB X Coil의 경우 ScrollView에 로딩할 때보다 CPU 사용량이 증가한 것을 확인할 수 있었다. 마무리Coil이 Coroutine으로 만들어져 기대를 많이 하고 테스트를 해보았는데 생각보다 CPU, Memory의 사용량이 많았다. Gilde는 정말로 모든 부분에서 최적화가 잘 되어있는 것으로 보이는 것에 비해, Picasso는 잘 사용하고 싶다면 정말 커스텀을 많이, 잘 해야될 필요가 있어보인다. Fresco는 최적화가 정말 잘 되어있지만 러닝커브가 높다. 퍼포먼스 측면에서는 Glide와 제일 비슷하였다. ReferencesMembers of Study https://namhoon.kim/2021/05/25/android_deep_dive/017_Image%20Loading%20and%20Caching%20Library%20Part%201/ https://namhoon.kim/2021/06/01/android_deep_dive/018_Image%20Loading%20and%20Caching%20Library%20Part%202/ https://velog.io/@jshme/Android-Image-Loader-Library https://velog.io/@jshme/Android-Hello-Out-Of-Memory https://www.charlezz.com/wordpress/wp-content/uploads/2020/10/www.charlezz.com-glide-v4-glide-v4--by-charlezz.pdf Official Android Developers#Drawble Resources Android Developers#Handling bitmaps Android Developers#LruCache androidx.collection.LruCache Cache replacement policies#recently used Google#Accompanist Repository https://square.github.io/picasso/ https://bumptech.github.io/glide/ https://github.com/coil-kt/coil https://frescolib.org https://github.com/nostra13/Android-Universal-Image-Loader/wiki ETC https://futurestud.io/tutorials/glide-caching-basics https://wooooooak.github.io/%EB%B2%88%EC%97%AD%ED%95%98%EB%A9%B0%20%EA%B3%B5%EB%B6%80%ED%95%98%EA%B8%B0/2021/02/21/How-The-Android-Image-Loading-Library-Glide-and-Fresco-Works/","link":"/Team-Blog/2021/06/24/2021-06-24%20Image%20Loading%20and%20Caching%20Library%20Part%203/"},{"title":"Kotlin Symbol Processing Api Part 1 — Annotation과 KAPT","text":"Writers by 곽욱현 @Knowre by 김남훈 @Naver by 송시영 @SmartStudy by 옥수환 @Naver by 이기정 @BankSalad by 정세희 @BankSalad AnnotationAnnotation Processor이란 용어는 낯설더라도, 아래와 같은 코드들은 개발하면서 종종 보았을 것이다. 123@Overide@NonNull@Nallable 이러한 코드를 Annotation이라고 한다. Annotation 은 소스 코드에 추가 할 수 있는 메타데이터의 한 형태로 컴파일러가 이를 참조 할 수 있도록 한다. 이 참조를 통해 미리 지정된 코드를 생성하기 위한 용도로 사용된다. Android 뿐만 아니라 Spring Framework 등을 개발할때에도 자주 활용한다. 다음의 오라클 문서에서 발췌한 Annotation의 정의를 살펴보자. Annotations, a form of metadata, provide data about a program that is not part of the program itself. Annotations have no direct effect on the operation of the code they annotate. 문서의 내용을 해석하면 Annotation은 일종의 메타데이터 형태이며, 프로그램의 일부가 아니라 프로그램에 대한 정보를 제공한다.Annotation 자체로는 실행되는 코드에 직접적인 영향을 미치지 않는다. Annotation은 Java 5부터 지원하고 있으며, 주로 다음과 같은 용도로 사용된다. 1. Information for the compiler컴파일러가 에러를 검출하거나, 경고를 표시하지 않도록 사전에 정보를 전달한다. 2. Compile-time and deployment-time processing코드나 xml 파일 등을 컴파일 타임에 생성할 수 있도록 처리한다. 3. Runtime processing몇몇 annotation들은 런타임에도 검사를 수행하도록 처리해준다. 참고 Oracle JavaDoc#Annotations 이미 정의된 Annotation 살펴보기java.lang 패키지에는 자바에서 제공하는 Annotation들이 있다. 대표적인 것 두 가지만 가지 살펴보자. @Deprecated : deprecated 됐음을 의미하며 더 이상 쓰지 말 것을 권장할 때 사용한다. 이 Annotation이 달린 코드를 사용하면 컴파일러는 경고를 내뱉는다. @SuppressWarnings : 이 Annotation은 컴파일러가 생성할 경고를 억제하도록 지시한다. 123456@SuppressWarnings(&quot;deprecation&quot;)void useDeprecatedMethod() { // deprecation warning // - suppressed objectOne.deprecatedMethod();} java.lang 하위의 annotation 패키지 즉 java.lang.annotation 패키지에서는 Meta Annotation 이라고 불리는 것들이 존재한다. @Retention : Retention Annotation은 표기된 Annotation이 저장되는 방법을 지정한다. RetentionPolicy.SOURCE : 소스 코드에서만 유지되며, 컴파일러에서는 무시된다. RetentionPolicy.CLASS : 컴파일 타임에 컴파일러에 의해 유지되지만, JVM에서는 무시된다. RetentionPolicy.RUNTIME : JVM에 의해서 유지되므로 런타임에서 사용가능하다. @Documented : Annotation이 사용될 때 마다 해당 element가 Javadoc에 문서화 되어야 함을 나타낸다. @Target : Annotation을 적용할 수 있는 Java Elements 종류를 제한한다. @Inherited : super class 로부터 상속될 수 있는 Annotation 타입이다. class 선언시에만 적용. 이 Meta Annotation의 특징은 다른 Annotation에 적용이 가능한 Annotation이라는 점이다. Android 앱 개발시에는 java.lang 대신 androidx.annotation 패키지를 참조하면 다양한 Annotation을 활용할 수 있다. androidx.annotation 패키지에 속한 annotation 목록은 아래 링크를 참고하자. 참고 Android Developers#androidx.annotation Annotation Processor앞서 소개한 Annotation의 용도를 사용하기 위해서 Annotation Processor가 필요하다. Annotation Processor는 Java 컴파일러 플러그인의 일종으로, 컴파일러에게 어떠한 요소(클래스, 메서드, 필드 등)에 annotation이 추가 되어있는지 확인하도록 한다. 컴파일러는 컴파일 타임에 코드베이스를 검사하거나 확인된 정보를 통해 새로운 코드를 생성하는 식으로 동작하며, 주로 개발자가 정의한 태스크를 자동화하거나 보일러 플레이트 작성을 줄이는 용도로 사용된다. Annotation Processor의 특징을 정리하자면 다음과 같다. 컴파일 타임에 특정 작업을 수행한다. 리플렉션없이 프로그램의 의미 및 구조를 파악할 수 있게 된다. 자동으로 보일러 플레이트를 생성할 수 있게 된다. Annotation processor 실행 순서Annotation processor는 여러 라운드에 걸쳐 수행된다. 실행 순서를 간단히 정리하자면 다음과 같다. 등록된 Annotation processor들과 함께 컴파일러가 시작된다. Annotation processor들이 작성된 Annotation을 기반으로 코드 검사 및 생성을 수행한다. 컴파일러가 모든 Annotation processor의 작업이 끝났는지 확인하고, 그렇지 않다면 2번을 반복한다. 모든 처리가 끝난다면 전체 코드에 대한 컴파일을 시작한다. (이후 프로세스는 기존과 동일) Android에서 Annotation Processor를 사용하는 라이브러리들Room Android에서 SQLite에 대한 추상화를 제공하는 Room 라이브러리에도 Annotation Processor가 적용되어 있다. 아래는 대표적인 예제인 User 관련 코드이다. 1234567// User.kt@Entitydata class User( @PrimaryKey val uid: Int, @ColumnInfo(name = &quot;first_name&quot;) val firstName: String?, @ColumnInfo(name = &quot;last_name&quot;) val lastName: String?) 12345678910111213141516171819// UserDao.kt@Daointerface UserDao { @Query(&quot;SELECT * FROM user&quot;) fun getAll(): List&lt;User&gt; @Query(&quot;SELECT * FROM user WHERE uid IN (:userIds)&quot;) fun loadAllByIds(userIds: IntArray): List&lt;User&gt; @Query(&quot;SELECT * FROM user WHERE first_name LIKE :first AND &quot; + &quot;last_name LIKE :last LIMIT 1&quot;) fun findByName(first: String, last: String): User @Insert fun insertAll(vararg users: User) @Delete fun delete(user: User)} 12345// AppDatabase.kt@Database(entities = arrayOf(User::class), version = 1)abstract class AppDatabase : RoomDatabase() { abstract fun userDao(): UserDao} 위의 에졔에서 쓰인 Annotation들은 @Entity, @PrimaryKey, @ColumnInfo, @Dao, @Query, @Insert, @Delete이다. 이 Annotation들의 구현체를 확인해보자. 1234567891011// Entity.java@Target(ElementType.TYPE)@Retention(RetentionPolicy.CLASS)public @interface Entity { String tableName() default &quot;&quot;; Index[] indices() default {}; boolean inheritSuperIndices() default false; String[] primaryKeys() default {}; ForeignKey[] foreignKeys() default {}; String[] ignoredColumns() default {};} 123456// PrimaryKey.java@Target({ElementType.FIELD, ElementType.METHOD})@Retention(RetentionPolicy.CLASS)public @interface PrimaryKey { boolean autoGenerate() default false;} 1234567891011121314151617181920212223242526272829303132333435// ColumnInfo.java@Target({ElementType.FIELD, ElementType.METHOD})@Retention(RetentionPolicy.CLASS)public @interface ColumnInfo { String name() default INHERIT_FIELD_NAME; @SuppressWarnings(&quot;unused&quot;) @SQLiteTypeAffinity int typeAffinity() default UNDEFINED; boolean index() default false; String defaultValue() default VALUE_UNSPECIFIED; String INHERIT_FIELD_NAME = &quot;[field-name]&quot;; int UNDEFINED = 1; int TEXT = 2; int INTEGER = 3; int REAL = 4; int BLOB = 5; @IntDef({UNDEFINED, TEXT, INTEGER, REAL, BLOB}) @Retention(RetentionPolicy.CLASS) @interface SQLiteTypeAffinity { } int UNSPECIFIED = 1; int BINARY = 2; int NOCASE = 3; int RTRIM = 4; @RequiresApi(21) int LOCALIZED = 5; @RequiresApi(21) int UNICODE = 6; @IntDef({UNSPECIFIED, BINARY, NOCASE, RTRIM, LOCALIZED, UNICODE}) @Retention(RetentionPolicy.CLASS) @interface Collate { } String VALUE_UNSPECIFIED = &quot;[value-unspecified]&quot;;} 이 외에도 @Dao, @Query, @Insert, @Delete과 같은 Annotation들은 각자 인터페이스, 구현체 값들을 이미 가지고 있다. Room 뿐만 아니라 범용적으로 사용되는 Dagger, Glide와 같은 라이브러리들도 Annotation(Processor)을 기반으로 동작한다. KAPT (Kotlin Annotation Processing Tool)코틀린 프로젝트를 컴파일 할 때는 javac가 아닌 kotlinc로 컴파일을 하기 때문에 Java로 작성한 애노테이션 프로세서(AbstractProcessor)가 동작하지 않는다. 따라서 코틀린에서는 이러한 애노테이션 처리기를 위해 KAPT(Kotlin Annotation Processing Tool)를 제공한다. KAPT를 사용하기 위해 모듈의 build.gradle에 다음과 같은 코드를 추가한다. 123// Groovy DSLapply plugin: 'kotlin-android'apply plugin: 'kotlin-kapt' 이 때 kotlin-android 설정을 먼저 해줘야 kotlin-kapt를 쓸 수 있다. Annotation processor가 포함된 라이브러리를 추가한다면 다음과 같이 의존성을 추가한다. 12345dependencies { // 기존 annotationProcessor 대신 kapt로 대체 // annotationProcessor 'groupId:artifactId:version' kapt 'groupId:artifactId:version'} hilt로 예시를 바꿔보면 아래와 같다. 1234dependencies{ //annotationProcessor &quot;com.google.dagger:hilt-android-compiler:$hilt_version&quot; kapt &quot;com.google.dagger:hilt-android-compiler:$hilt_version&quot;} Pluggable Annotation Processing API (JSR#269)자바 이외의 언어에서 어노테이션을 지원하기 위해서는 몇가지 옵션이 있다. 자바의 컴파일러와 어노테이션 프로세스를 위한 플러그인 대상 API가 필요한데, 이를 정리한 스펙 문서가 JSR 269이다. 참고 JSR 269 : Pluggable Annotation Processing API in JCP 이 플러그인 API를 사용하면 특정 어노테이션이 정의되었을때, 컴파일러에게 어노테이션에 작성된 클래스, 메서드, 필드 등의 구성 요소를 질의하고 컴파일러는 해당 구성 요소를 나타내는 객체의 컬렉션을 반환하게 된다. 이후 프로세서가 이 컬렉션을 검증하고, 새로운 코드(=Stub)을 생성하게 된다. 코틀린의 경우 빌드한 바이너리가 자바이기 때문에, 코틀린 컴파일러의 실행후 자바 컴파일러가 바이너리 파일인 *.class를 인식한다. 이때 컴파일러는 코틀린과 자바에서 생성된 각 바이너리에 대해서 구별할 수는 없다. 다만, 코틀린은 언어의 특성상 Processor가 생성한 선언을 참조할 수 없고, 바이너리에는 주석이 포함되지않기때문에 이를 해결하기 위해 KAPT를 사용하는 것이다. KAPT를 사용하면 APT와 똑같이 Stub을 생성하고 자바의 의존성을 가지는 대신 구현이 상대적으로 쉽다는 장점이 있다. 자바와 코틀린간의 간극을 없애주는 KAPT의 대표적인 예시로 Android의 DI를 위해 사용하는 Dagger나 Databinding을 코틀린에서도 사용할 수 있는 점을 들 수 있다. 하지만 KAPT 도 APT와 마찬가지로 결국 Stub을 생성하기 위해 많은 컴파일 및 빌트 타임을 소모하게 되는 문제점은 그대로 남아있게 된다. 이번 포스팅의 주제이자, 위의 문제를 해결하기 위해 나온 KSP를 다음 파트에서 자세히 알아보자.","link":"/Team-Blog/2021/07/21/2021-07-21%20Kotlin%20Symbol%20Processing%20Api%20Part%201/"},{"title":"Kotlin Symbol Processing Api Part 2 — What is it?","text":"Writers by 곽욱현 @Knowre by 김남훈 @Naver by 송시영 @SmartStudy by 옥수환 @Naver by 이기정 @BankSalad by 정세희 @BankSalad KSP란 무엇인가?KSP(Kotlin Symbol Processing) 은 2021년 2월 10일 구글이 발표한 코틀린에서 경량화된 컴파일러 플러그인을 개발할 수 있는 API다. 학습곡선을 최소한으로 줄이고, 코틀린의 기능을 활용할 수 있는 단순화된 API를 제공한다. 여러 플랫폼에 호환성을 염두하고 만들어졌으며, 코틀린 1.4.30 버전 이상부터 호환된다. KSP는 코틀린 언어가 갖는 특징인 확장 함수, 로컬 함수 같은 기능을 이해한다. 또한 KSP는 타입을 명시적으로 다루고, 기본적인 타입 검사와 동등성 검사를 지원한다. API는 코틀린 문법에 따라 symbol 수준에서 코틀린 프로그램 구조를 모델링 한다. KSP 기반 플러그인이 소스 프로그램을 처리할 때 클래스, 클래스 멤버, 함수 및 관련 매개 변수와 같은 구성은 프로세서에서 쉽게 접근할 수 있기 때문에 코틀린 개발자들에게 편리하다. 개념적으로 KSP는 Kotlin 리플렉션의 KType과 유사하다. API 를 사용하면 프로세서가 클래스 선언에서 특정 타입 인자가 있는 해당 타입, 또는 그 반대로 탐색할 수 있다. KAPT와 비교했을 때 KSP를 사용하는 Annotation Processor는 최대 2배 더 빠르게 실행할 수 있다. 자세한 내용은 Google KSP repository에서 소스코드 및 문서를 확인할 수 있다. 왜 KSP를 사용해야 할까?컴파일러 플러그인은 코드 작성 방법을 크게 향상시킬 수 있는 강력한 메타프로그래밍 도구이다. 컴파일러 플러그인은 컴파일러를 라이브러리로 직접 호출하여 입력 프로그램을 분석하고 편집하여 다양한 용도로 쓰일 수 있는 산출물들을 생성한다.. 예를 들어, Boiler Plate를 생성하거나 Parcelble과 같은 특별히 마크된 프로그램 요소에 대한 전체 구현을 생성할 수도 있다. 플러그인은 다양한 용도로 사용되며 언어로 직접 제공되지 않는 기능을 구현하고 미세 조정하는 데 사용할 수도 있다. 다만 컴파일러 플러그인은 컴파일러에 대한 배경 지식 및 특정 컴파일러의 구현 세부 사항에 대한 숙련도를 어느정도 필요로 하므로 어느 정도의 진입 장벽이 요구된다. 이 진입 장벽을 최대한 낮추고자 KSP 는 컴파일러의 변경사항을 은닉하도록 설계되어 최소한의 유지 보수로 플러그인을 개발할 수 있게 해준다. 또한 JVM에 종속되지않도록 설계되었으므로, 다른 플랫폼에 적용하는 것도 용이하다. 무엇보다 KSP는 빌드시간을 최소화하는 것이 가장 큰 장점이다. Glide 와 같은 일부 Processor의 경우 KSP는 KAPT와 비교할 때 컴파일 시간을 25%까지 줄이는 것으로 확인되었다. kotlinc 컴파일러 플러그인과의 비교kotlinc 컴파일러 플러그인의 경우 강력한 기능을 제공하는 것은 맞지만, 그만큼 컴파일러에 대한 의존성이 크기때문에 유지보수에 대한 용이성이 떨어진다. 반면 KSP는 대부분의 컴파일러 변경사항을 은닉하여 api를 통해 접근할 수 있도록 해준다. 물론 한 단계를 더 건너야하는 만큼 kotlinc의 모든 기능을 지원하지는 않지만, 기술 부채를 고려하였을 때 합리적인 선택이 될 것이다. kotlin.reflect 와의 비교KSP는 kotlin.reflect와 유사하게 생겼지만, KSP는 타입에 대한 참조를 명시적으로 지정해주어야 한다. KSP의 한계점KSP는 기존의 Annotation Processor에 비해 상대적으로 간단한 방법론을 제공하기 위해 몇 가지 절충한 부분이 존재한다. 따라서 아래의 기능들은 KSP에서 제공하고자 하는 대상이 아니다. 소스 코드의 표현 수준 정보를 조사하기 소스 코드 수정하기 Java Annotation Processing API와 100% 호환하기 IDE와 통합하기 (현재는 IDE가 생성 된 코드를 읽지 못함) 특히 4번 항목때문에 Android Studio에서 KSP를 개발하여 사용하고자 하는 경우엔 아래와 같은 경로를 명시해야 한다. 1build/generated/ksp/debug/kotlin build.gradle.kts 예시 1234567891011android { buildTypes { getByName(&quot;debug&quot;) { sourceSets { getByName(&quot;main&quot;) { java.srcDir(File(&quot;build/generated/ksp/debug/kotlin&quot;)) } } } }} KSP 내부 살펴보기 위의 그림은 매우 복잡하고 사이즈가 크니, 클릭해서 크게 보는 것을 권장한다. 참고 KSP API definition 참고 KSP Symbol definition KSP 모델에 대한 딥다이브를 해보자. 먼저 KSP의 전체 구조는 아래와 같다. KSP가 파일을 파싱하는 구조KSP를 사용하기 위해 작업하는 경우 아래와 같은 구조로 작성해야 한다. 복잡해보이지만 KS는 prefix일 뿐이고, kotlin으로 작성한 파일 구조를 추종한다는 것을 알 수 있다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455KSFile /** * File의 정보 * - Package Name / File Name / 적용된 Anootation 리스트 * - simpleName, qualifiedName 등을 포함한 선언 정보 */ packageName: KSName fileName: String annotations: List&lt;KSAnnotation&gt; (File annotations) declarations: List&lt;KSDeclaration&gt; /** * Class / Interface / Object */ KSClassDeclaration simpleName: KSName qualifiedName: KSName containingFile: String typeParameters: KSTypeParameter parentDeclaration: KSDeclaration classKind: ClassKind primaryConstructor: KSFunctionDeclaration superTypes: List&lt;KSTypeReference&gt; declarations: List&lt;KSDeclaration&gt; // contains inner classes, member functions, properties, etc. /** * Top-Level Funtion */ KSFunctionDeclaration simpleName: KSName qualifiedName: KSName containingFile: String typeParameters: KSTypeParameter parentDeclaration: KSDeclaration functionKind: FunctionKind extensionReceiver: KSTypeReference? returnType: KSTypeReference parameters: List&lt;KSValueParameter&gt; declarations: List&lt;KSDeclaration&gt; // contains local classes, local functions, local variables, etc. /* * Global Variable */ KSPropertyDeclaration simpleName: KSName qualifiedName: KSName containingFile: String typeParameters: KSTypeParameter parentDeclaration: KSDeclaration extensionReceiver: KSTypeReference? type: KSTypeReference getter: KSPropertyGetter returnType: KSTypeReference setter: KSPropertySetter parameter: KSValueParameter 위의 파일 구조를 실제 구조에 대입하여 파악해보자. AppcompatActivity를 상속한 SampleActivity가 있다고 할때, Annotation이 붙여진 어떠한 것이 변수인지, 함수인지, 클래스인지를 알고 싶다면, 위 구성을 이해하면 된다. 아래와 같이 Activity를 구성했다고 가정해보자. 1234567891011121314151617181920212223// KSFilepackage com.jshme.kspsampleimport androidx.appcompat.app.AppCompatActivityimport android.os.Bundle@TestAnnotation //KClassDeclaration class SampleActivity : AppCompatActivity() { @Test //KSPropertyDeclaration var number: Int = 0 @Test //KSPropertyDeclaration var str: String = &quot;&quot; override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_sample) number = 2 str = &quot;Test Sample&quot; }} @TestAnnotation 이 달린 곳은 클래스 타입이므로 KClassDeclaration으로 구성될 것이고, @Test가 달린 곳은 KSPropertyDeclaration으로 구성될 것이다. 파일 내부를 돌면서 클래스, 함수, 변수타입을 구별해내KSDeclaration` 으로 정의하는 것이다. 이 구조도와 예제를 통해 KSClassDeclaration, KSFunctionDeclaration, KSPropertyDeclaration 세 가지 타입의 경우 KSDeclaration를 상속받고 있기때문에 타입 캐스팅을 사용할 수 있기때문에, 리스트 형태로 관리할 수 있음을 확인할 수 있다. KSP의 타입 참조 프로세스KSP에서 타입에 대한 참조는 몇 가지 예외를 제외하면 명시적으로 지정하도록 되어있다. KSFunctionDeclaration.returnType 혹은 KSAnnotation.annotationType과 같이 타입을 참조하는 경우, 타입은 항상 annotation과 modifier가 포함된 KSReferenceElement 기반의 KSTypeReference이다. 12345678interface KSFunctionDeclaration : ... { val returnType: KSTypeReference? ...}interface KSTypeReference : KSAnnotated, KSModifierListOwner { val type: KSReferenceElement} KSTypeReference는 Kotlin의 타입 시스템의 KSType으로 resolve()할 수 있고, Kotlin 문법과 일치하는 KSReferenceElement를 가지고 있다. 이번엔 KSReferenceElement다. 123interface KSReferenceElement : KSNode { val typeArguments: List&lt;KSTypeArgument&gt;} KSReferenceElement는 유용한 정보를 많이 포함하고 있는 KSClassifierReference 혹은 KSCallableReference가 될 수 있다. 12345678interface KSClassifierReference : KSReferenceElement { val qualifier: KSClassifierReference? fun referencedName(): String override fun &lt;D, R&gt; accept(visitor: KSVisitor&lt;D, R&gt;, data: D): R { return visitor.visitClassifierReference(this, data) }} 예를 들어 KSClassifierReference는 referencedName라는 속성을 가지고 있으며, 123456789interface KSCallableReference : KSReferenceElement { val receiverType: KSTypeReference? val functionParameters: List&lt;KSValueParameter&gt; val returnType: KSTypeReference override fun &lt;D, R&gt; accept(visitor: KSVisitor&lt;D, R&gt;, data: D): R { return visitor.visitCallableReference(this, data) }} KSCallableReference는 receiverType과 functionArguments 그리고 returnType을 가지고 있다. KSTypeReference에서 참조되는 타입의 선언이 필요한 경우 아래와 같은 순서로 접근한다. 1KSTypeReference -&gt; .resolve() -&gt; KSType -&gt; .declaration -&gt; KSDeclaration resolve()를 통해 KSType으로 접근하고, declaration 속성을 통해 KSDeclaration 객체를 획득한다. Java Annotation Processing에 대응하는 KSP 레퍼런스기존에 Annotation processor를 작성해 본 경험이 있다면 아래의 내용을 참조하면 좋다. 내용이 방대하여 링크로 대체한다. 참고 Github ksp#references KSP 개발 프로세스KSP repository에도 playground가 있지만, 공식 repo와 문서가 자세하거나 친절하게 작성되어있지않아 임의로 개발 프로세스를 예제 기반으로 명세해보았다. 개략적인 내용은 ksp repository의 QuickStart 문서에 나와있다. 참고 Github ksp#quickstart KSP 개발을 위한 환경은 갖추어져 있다고 가정한다. Step 1You’ll need to implement com.google.devtools.ksp.processing.SymbolProcessor and com.google.devtools.ksp.processing.SymbolProcessorProvider. Your implementation of SymbolProcessorProvider will be loaded as a service to instantiate the SymbolProcessor you implement. 먼저 SymbolProcessor를 상속받은 구현체를 작성한다. 1234567// BuilderProcessor.ktclass BuilderProcessor( val codeGenerator: CodeGenerator, val logger: KSPLogger) : SymbolProcessor { // ...} 그리고 SymbolProcessorProvider를 상속받은 구현체도 선언한다. 1234// BuilderProcessorProvider.ktclass BuilderProcessorProvider : SymbolProcessorProvider { // ...} Step 2Implement SymbolProcessorProvider.create() to create a SymbolProcessor. Dependencies your processor needs (e.g. CodeGenerator, processor options) are passed through the parameters of SymbolProcessorProvider.create(). BuilderProcessorProvider 클래스에 SymbolProcessorProvider.create() 메소드를 구현한다. 123456// BuilderProcessorProvider.ktclass BuilderProcessorProvider : SymbolProcessorProvider { override fun create(environment: SymbolProcessorEnvironment): SymbolProcessor { return BuilderProcessor(environment.codeGenerator, environment.logger) }} Step 3Your main logic should be in the SymbolProcessor.process() method. BuilderProcessor의 핵심 로직인 SymbolProcessor.process() 메서드를 오버라이딩 한다. 1234567class BuilderProcessor : SymbolProcessor { override fun process(resolver: Resolver): List&lt;KSAnnotated&gt; { // ... } // ...} Step 4Use resolver.getSymbolsWithAnnotation() to get the symbols you want to process, given the fully-qualified name of an annotation. Step 3에서 선언한 BuilderProcessor 클래스의 process()에 파라미터로 주어지는 resolver에 getSymbolsWithAnnotation() 메소드를 호출하여 KSP를 명시한다. 12345678910111213141516class BuilderProcessor( val codeGenerator: CodeGenerator, val logger: KSPLogger) : SymbolProcessor { override fun process(resolver: Resolver): List&lt;KSAnnotated&gt; { val symbols = resolver.getSymbolsWithAnnotation(&quot;android.deepdive.ksp.builder.Builder&quot;) val ret = symbols.filter { !it.validate() }.toList() symbols .filter { it is KSClassDeclaration &amp;&amp; it.validate() } .forEach { it.accept(BuilderVisitor(), Unit) } return ret } // ...} Step 5A common use case for KSP is to implement a customized visitor (interface com.google.devtools.ksp.symbol.KSVisitor) for operating on symbols. A simple template visitor is com.google.devtools.ksp.symbol.KSDefaultVisitor. com.google.devtools.ksp.symbol.KSDefaultVisitor를 참조하여 Visiter 클래스를 작성한다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758class BuilderProcessor( val codeGenerator: CodeGenerator, val logger: KSPLogger) : SymbolProcessor { // ... inner class BuilderVisitor : KSVisitorVoid() { override fun visitClassDeclaration(classDeclaration: KSClassDeclaration, data: Unit) { classDeclaration.primaryConstructor!!.accept(this, data) } override fun visitFunctionDeclaration(function: KSFunctionDeclaration, data: Unit) { val parent = function.parentDeclaration as KSClassDeclaration val packageName = parent.containingFile!!.packageName.asString() val className = &quot;${parent.simpleName.asString()}Builder&quot; val file = codeGenerator.createNewFile(Dependencies(true, function.containingFile!!), packageName, className) file.appendText(&quot;package $packageName\\n\\n&quot;) file.appendText(&quot;import HELLO\\n\\n&quot;) file.appendText(&quot;class $className{\\n&quot;) function.parameters.forEach { val name = it.name!!.asString() val typeName = StringBuilder(it.type.resolve().declaration.qualifiedName?.asString() ?: &quot;&lt;ERROR&gt;&quot;) val typeArgs = it.type.element!!.typeArguments if (it.type.element!!.typeArguments.isNotEmpty()) { typeName.append(&quot;&lt;&quot;) typeName.append( typeArgs.map { val type = it.type?.resolve() &quot;${it.variance.label} ${type?.declaration?.qualifiedName?.asString() ?: &quot;ERROR&quot;}&quot; + if (type?.nullability == Nullability.NULLABLE) &quot;?&quot; else &quot;&quot; }.joinToString(&quot;, &quot;) ) typeName.append(&quot;&gt;&quot;) } file.appendText(&quot; private var $name: $typeName? = null\\n&quot;) file.appendText(&quot; internal fun with${name.capitalize()}($name: $typeName): $className {\\n&quot;) file.appendText(&quot; this.$name = $name\\n&quot;) file.appendText(&quot; return this\\n&quot;) file.appendText(&quot; }\\n\\n&quot;) } file.appendText(&quot; internal fun build(): ${parent.qualifiedName!!.asString()} {\\n&quot;) file.appendText(&quot; return ${parent.qualifiedName!!.asString()}(&quot;) file.appendText( function.parameters.map { &quot;${it.name!!.asString()}!!&quot; }.joinToString(&quot;, &quot;) ) file.appendText(&quot;)\\n&quot;) file.appendText(&quot; }\\n&quot;) file.appendText(&quot;}\\n&quot;) file.close() } } // ...} Step 6For sample implementations of the SymbolProcessorProvider and SymbolProcessor interfaces, see the following files in the sample project. src/main/kotlin/BuilderProcessor.kt src/main/kotlin/TestProcessor.kt 작성한 클래스는 아래와 같다. src/main/java/android/deepdive/ksp/builder/BuilderProcessor.kt src/main/java/android/deepdive/ksp/builder/BuilderProcessorProvider.kt Step 7After writing your own processor, register your processor provider to the package by including its fully-qualified name in resources/META-INF/services/com.google.devtools.ksp.processing.SymbolProcessorProvider. META-INF에 작성한 BuilderProcessorProvider의 path를 명시한다. 12// path : src/main/resources/META-INF/services/com.google.devtools.ksp.processing.SymbolProcessorProviderandroid.deepdive.ksp.builder.BuilderProcessorProvider 실제 스터디를 진행하면서 만들어본 KSP 예제는 아래 링크를 참조하면 된다. Android Deep Dive#Kotlin-Symbol-Processing-Api Charlezz#IntentBuilderSample SODA1127#KSPImplementationExample jsh-me#KSPWebViewLoader","link":"/Team-Blog/2021/07/21/2021-07-21%20Kotlin%20Symbol%20Processing%20Api%20Part%202/"},{"title":"Kotlin Symbol Processing Api Part 3 — KSP vs KAPT","text":"Writers by 곽욱현 @Knowre by 김남훈 @Naver by 송시영 @SmartStudy by 옥수환 @Naver by 이기정 @BankSalad by 정세희 @BankSalad 앞선 두 개의 포스팅에서 KAPT 와 KSP 에 대해서 다루었다. 이번 포스팅에서는 KAPT 와 KSP 를 서로 비교해본다. Better than KAPT앞선 포스팅에서 언급했듯 KAPT는 Kotlin 코드를 Java Annotation Processor를 수정하지 않기 위해 컴파일시 Java로 된 Stub을 생성하게 된다. Stub을 생성하는 것은 kotlinc의 분석 비용의 3분의 1이나 차지하므로, 빌드시 필연적으로 많은 오버헤드가 발생하게 된다. KAPT와 달리 KSP는 Java 관점이 아닌 Kotlin의 관점에서 접근하며, top-level function과 같은 Kotlin의 고유 기능에 더 적합하다. KAPT와 좀 더 자세하게 비교해보면 아래로 정리할 수 있다. 1. 빠르다 기존에는 코틀린 전용 애노테이션 프로세서가 없었기 때문에, javax.lang.model 패키지에서 제공하는 API를 통해 애노테이션 프로세서를 작성했다. 이 프로세서를 수행하기 위해 KAPT는 코틀린 코드를 자바 Stub 으로 컴파일하게 된다. 이러한 Stub을 생성하려면 KAPT가 코틀린 프로그램의 모든 기호(symbol)들을 확인해야 한다. Stub 코드를 생성하는 비용은 컴파일 전체의 1/3을 차지한다. 성능 평가를 위해 KSP에서 Glide의 단순화된 버전을 구현하여 Tachiyomi 프로젝트용 코드를 생성했는데 코틀린 컴파일 시간은 21.55초에서 KAPT가 코드를 생성하는데 8.67초, KSP가 코드를 생성하는데 1.15초가 걸렸다고 한다. 참고 Tachiyomi repository 2. 쉽다 KSP는 코틀린 친화적이다. KSP는 코틀린만의 고유한 기능들인 확장 함수(extension function), 선언 위치 변환 (Declaration-Site Variance), 지역 함수(local functions) 등을 이해한다. 또한 타입을 모델링하고 동등성 및 할당호환성(assign-comppatibility)과 같은 기본적인 타입을 검사하는 기능을 제공한다. KSP를 이용하여 소스코드를 처리할 때 클래스, 클래스 멤버, 함수 및 관련 매개변수와 같은 내용에 쉽게 접근이 가능하다. 개념적으로는 코틀린 리플렉션의 KType과 유사하기 때문에 커스텀 SymbolProcessor 작성 시 AbstractProcessor와 비교하여 작성이 편하다는 느낌을 받게 된다. 자세한 내용은 Part 2를 참고하자. 3. 호환성 및 유지보수 KSP는 JVM에 종속되지 않도록 설계되었기 때문에 향후 다른 플랫폼에 보다 쉽게 적용할 수 있다. 또한 컴파일러 변경 사항을 숨기도록 설계되어 이를 사용하는 프로세서의 유지 관리 노력을 최소화 한다. KAPT vs KSP 실제로 빌드해보기 (Feat_ Room)Rooom 라이브러리를 이용해 간단하게 테스트를 수행해보았다. 테스트 조건은 아래와 같다. 프로젝트로 작성된 간단한 프로젝트 RoomDatabase를 상속받은 클래스 하나 3개의 DAO, 3개의 Entity 클래스 KAPT 프로젝트빌드 스크립트에 kotlin-kapt를 추가한다. 123456// build.gradle (app)plugins { ... id 'kotlin-kapt' ...} 의존성으로는 테스트할 Room 라이브러리를 추가하고, kapt에서 room을 사용하도록 처리한다. 아래의 의존성으로 인해 Room 라이브러리는 Kotlin 어노테이션을 파싱한 뒤 SQLite를 사용하기 위한 자바 기반의 Stub 파일을 생성하게 된다. 1234567dependencies { // ... implementation &quot;androidx.room:room-runtime:2.3.0&quot; kapt &quot;androidx.room:room-compiler:2.3.0&quot; implementation &quot;androidx.room:room-ktx:2.3.0&quot; // ...} 이제 RoomDatabase를 상속한 ApplicationDatabase 클래스를 작성한다. 123456789101112131415161718@Database( entities = [AEntity::class, BEntity::class, CEntity::class], version = 1, exportSchema = false)abstract class ApplicationDatabase: RoomDatabase() { companion object { const val DB_NAME = &quot;ApplicationDataBase.db&quot; } abstract fun ADao(): ADao abstract fun BDao(): BDao abstract fun CDao(): CDao} Kotlin 코드는 다음과 같은 Java Stub 파일로 생성되게 된다. 12345678910111213141516171819// ... @SuppressWarnings({&quot;unchecked&quot;, &quot;deprecation&quot;})public final class ApplicationDatabase_Impl extends ApplicationDatabase { private volatile ADao _aDao; private volatile BDao _bDao; private volatile CDao _cDao; @Override protected SupportSQLiteOpenHelper createOpenHelper(DatabaseConfiguration configuration) { final SupportSQLiteOpenHelper.Callback _openCallback = new RoomOpenHelper(configuration, new RoomOpenHelper.Delegate(1) { @Override public void createAllTables(SupportSQLiteDatabase _db) { // ... } } // ... 빌드 타임 측정 프로젝트 클린 후 kaptGenerateStubsDebugKotlin으로 빌드시 16.6s 가 소요되었다. KSP 프로젝트위에서 작성한 KAPT 프로젝트를 KSP로 변경해보자. 프로젝트 단위의 build.gradle 설정에서는 아래와 같이 의존성을 하나 더 추가해준다. 1234567891011// build.gradle (root)buildscript { ext.kotlin_version = &quot;1.4.21&quot; repositories { google() } dependencies { ... classpath(&quot;com.google.devtools.ksp:com.google.devtools.ksp.gradle.plugin:1.5.20-1.0.0-beta04&quot;) }} app의 build.gradle에 com.google.devtools.ksp 플러그인을 추가한다. 123456plugins { ... id 'kotlin-kapt' id 'com.google.devtools.ksp' ...} 이후 기존 kapt로 추가했던 room-compiler 의존성을 ksp로 교체한다. 12345678dependencies { // ... implementation &quot;androidx.room:room-runtime:2.3.0&quot; // kapt &quot;androidx.room:room-compiler:2.3.0&quot; ksp &quot;androidx.room:room-compiler:2.3.0&quot; implementation &quot;androidx.room:room-ktx:2.3.0&quot; // ...} 빌드 타임 측정 프로젝트 클린 후 빌드하면 kaptGenerateStubsDebugKotlin이 12.54s kspDebugKotlin이 5.49s 만큼 시간이 소요되어 총합 18.03s 만큼 시간이 소요되었다. KSP를 써서 더 빨라질 것을 기대했는데 왜 더 걸린 것일까? Android Developer의 공식 블로그에 그 이유가 공개되어 있다. 참고 Announcing Kotlin Symbol Processing (KSP) Alpha 위의 문서를 보면 아래와 같은 문구가 있다. That said, using KAPT and KSP in the same module will likely slow down your build initially, so during this alpha period, it is best to use KSP and KAPT in separate modules. 동일한 모듈 내에서 kapt와 ksp를 동시에 사용하면 초기 빌드 속도가 더 소요된다고 명시되어있고, 이에 대한 해결책으로(ksp가 alpha인 동안은) kapt와 ksp를 별도의 모듈에서 사용하는 것을 권장하고 있다. 현재 프로젝트에서 KAPT를 사용하는 의존성을 전부 게거한 뒤, Room에 대한 KAPT, KSP를 비교하면 아래와 같은 결과를 얻을 수 있다. Compile Time By KAPT only using Room 8.40s Compile Time By KSP only using Room 0.71s 한정적인 테스트지만 빌드 시간이 현격히 감소한 것을 확인할 수 있다. ReferencesMembers of Study 찰스의 안드로이드 - [Android] Annotation Processor 만들기 Namhoon Kims’Coding Log - KSP Api Part 1 Namhoon Kims’Coding Log - KSP Api Part 2 소다의 개발 블로그 - Introduce Kotlin Symbol Processing 소다의 개발 블로그 - Implement Kotlin Symbol Processing jsh-me.log - KSP(Kotlin Symbol Processor) 톺아보기 Official Android Developers#androidx.annotation Google KSP Repository KSP API definition KSP Symbol definition KAPT(Kotlin Annotation Processing Tool) Announcing Kotlin Symbol Processing (KSP) Alpha Oracle JavaDoc#Annotations kapt: Annotation Processing for Kotlin Using kapt Etc Tachiyomi My first Kotlin Symbol Processing Tool for Android KSP: Fact or kapt? Annotation Processing 101 Kotlin : Kotlin plugin should be enabled before ‘kotlin-kapt’ Pushing the limits of Kotlin annotation processing","link":"/Team-Blog/2021/07/21/2021-07-21%20Kotlin%20Symbol%20Processing%20Api%20Part%203/"}],"tags":[{"name":"Android","slug":"Android","link":"/Team-Blog/tags/Android/"},{"name":"Jetpack","slug":"Jetpack","link":"/Team-Blog/tags/Jetpack/"},{"name":"Compose","slug":"Compose","link":"/Team-Blog/tags/Compose/"},{"name":"Rendering","slug":"Rendering","link":"/Team-Blog/tags/Rendering/"},{"name":"Principle","slug":"Principle","link":"/Team-Blog/tags/Principle/"},{"name":"Optimize","slug":"Optimize","link":"/Team-Blog/tags/Optimize/"},{"name":"UI","slug":"UI","link":"/Team-Blog/tags/UI/"},{"name":"Image","slug":"Image","link":"/Team-Blog/tags/Image/"},{"name":"Library","slug":"Library","link":"/Team-Blog/tags/Library/"},{"name":"KSP","slug":"KSP","link":"/Team-Blog/tags/KSP/"},{"name":"Kotlin","slug":"Kotlin","link":"/Team-Blog/tags/Kotlin/"},{"name":"Symbol","slug":"Symbol","link":"/Team-Blog/tags/Symbol/"},{"name":"Processing","slug":"Processing","link":"/Team-Blog/tags/Processing/"},{"name":"KAPT","slug":"KAPT","link":"/Team-Blog/tags/KAPT/"},{"name":"Annotation","slug":"Annotation","link":"/Team-Blog/tags/Annotation/"}],"categories":[{"name":"Jetpack Compose","slug":"Jetpack-Compose","link":"/Team-Blog/categories/Jetpack-Compose/"},{"name":"User Interface","slug":"User-Interface","link":"/Team-Blog/categories/User-Interface/"},{"name":"Image Library","slug":"Image-Library","link":"/Team-Blog/categories/Image-Library/"},{"name":"KSP","slug":"KSP","link":"/Team-Blog/categories/KSP/"}]}