{"pages":[],"posts":[{"title":"Jetpack Compose Part 1 - Compose 소개 및 코드랩 따라하기","text":"Writers by 김남훈 @Naver by 배희성 @RocketPunch by 송시영 @SmartStudy by 이기정 @BankSalad Jetpack Compose란 무엇인가? 출처 Android Developers#Jetpack Compse Compose는 Native UI를 코드레벨로 구현할 수 있는 최신 툴킷이다. 기존의 뷰를 업데이트하는 방식과 달리 Compose를 사용하면 필요한 영역의 뷰를 다시 그려주는 방식으로 작업할 수 있다. 아래는 아주 간단한 예제이다. 1234@Composablefun Greeting(name: String) { Text(&quot;Hello $name&quot;)} 위의 예제처럼 UI를 구성하는 것이 아니라 화면을 구성하는 뷰의 State 설명하는 것이므로 아무것도 반환하지 않는다. 아래는 공식 서비스 소개 영상이다. Compose의 4가지 특징구글에서 설명하는 Compose를 이용시 얻을 수 있는 장점은 아래와 같다. Less Code - 코드 감소 적은 수의 코드로 더 많은 작업을 하고 전체 버그 클래스를 방지할 수 있으므로 코드가 간단하며 유지 관리하기 쉽습니다. Intuitive - 직관적 UI만 설명하면 나머지는 Compose에서 처리합니다. 앱 상태가 변경되면 UI가 자동으로 업데이트됩니다. Accelerate Development - 빠른 개발 과정 기존의 모든 코드와 호환되므로 언제 어디서든 원하는 대로 사용할 수 있습니다. 실시간 미리보기 및 완전한 Android 스튜디오 지원으로 빠르게 반복할 수 있습니다. Powerful - 강력한 성능 Android 플랫폼 API에 직접 액세스하고 머티리얼 디자인, 어두운 테마, 애니메이션 등을 기본적으로 지원하는 멋진 앱을 만들 수 있습니다. 늘 그렇듯 구글에서 말하는 설명만 보면 안 쓸 이유가 없어보이고, 대세가 된다면 Android 개발자에게 또 하나의 러닝커브로 작용할 것이다. Codelab - Jetpack Compose basics1. 시작하기전에Compose는 아직 정식으로 릴리즈되지 않은 기능이므로 Android Studio Canary에서 프로젝트를 구성하며 몇 가지 제한사항이 존재한다. Android Studio Canary Canary는 아래 링크에서 다운 받을 수 있다. Android Studio Preview 최신 버전의 Kotlin plugin 1ext.kotlin_version = '1.4.31' buildFeatures 및 composeOption 활성화 123456789101112131415161718android { ... buildFeatures { compose true } composeOptions { kotlinCompilerExtensionVersion 1.0.0-beta02 }}dependencies { ... implementation &quot;androidx.compose.ui:ui:1.0.0-beta02&quot; implementation &quot;androidx.activity:activity-compose:1.3.0-alpha03&quot; implementation &quot;androidx.compose.material:material:1.0.0-beta02&quot; implementation &quot;androidx.compose.ui:ui-tooling:1.0.0-beta02&quot; ...} 2. Empty Compose 프로젝트 생성[File] - [New] - [New Project…] 를 눌러 새로운 프로젝트를 선택하고(Preview) Empty Compose Activity 를 선택한다. 선택 이후 Next를 클릭하고, Compose를 구현할 수 있는 최소 API 레벨인 21을 선택해야한다. 프로젝트를 생성하면 아래와 같이 app/build.gradle에 의존성 설정 및 추가가 되어 있는것을 알 수 있다. 12345678910111213141516171819202122android { ... kotlinOptions { jvmTarget = '1.8' useIR = true } buildFeatures { compose true } composeOptions { kotlinCompilerExtensionVersion compose_version }}dependencies { ... implementation &quot;androidx.compose.ui:ui:$compose_version&quot; implementation &quot;androidx.activity:activity-compose:1.3.0-alpha03&quot; implementation &quot;androidx.compose.material:material:$compose_version&quot; implementation &quot;androidx.compose.ui:ui-tooling:$compose_version&quot; ...} 이때 composeOptions 설정에서 kotlinCompilerVersion 에 따라 compose 가 다르게 동작할 수 있음을 유의하자. 프로젝트를 생성하면 아래와 같은 기본 파일들이 생성된다. MainActivity.kt 1234567891011121314151617181920212223242526class MainActivity : AppCompatActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { MyFirstComposeApplicationTheme { // A surface container using the 'background' color from the theme Surface(color = MaterialTheme.colors.background) { Greeting(&quot;Android&quot;) } } } }}@Composablefun Greeting(name: String) { Text(text = &quot;Hello $name!&quot;)}@Preview(showBackground = true)@Composablefun DefaultPreview() { MyFirstComposeApplicationTheme { Greeting(&quot;Android&quot;) }} ui/theme/Theme.kt 123456789101112131415161718192021222324252627282930313233343536private val DarkColorPalette = darkColors( primary = Purple200, primaryVariant = Purple700, secondary = Teal200)private val LightColorPalette = lightColors( primary = Purple500, primaryVariant = Purple700, secondary = Teal200* /* Other default colors to override background = Color.White, surface = Color.White, onPrimary = Color.White, onSecondary = Color.Black, onBackground = Color.Black, onSurface = Color.Black, */)@Composablefun MyFirstComposeApplicationTheme(darkTheme: Boolean = isSystemInDarkTheme(), content: @Composable () -&gt; Unit) { val colors = if (darkTheme) { DarkColorPalette* } else { LightColorPalette* } MaterialTheme( colors = colors, typography = Typography, shapes = Shapes, content = content )} 기본 생성된 코드를 보았을 때, Compose는 총 3가지의 구성 요소를 가지는 것으로 추측할 수 있다. 위젯을 포함하는 Composable 함수 Preview를 하기 위한 Preview Composable 함수 setContent 람다 표현식으로 실제 화면에 노출하는 코드 일반적으로 우리가 아는 Activity의 라이프사이클 콜백 onCreate()에서 setContentView(Int) 함수를 호출하던것이 setContent() 함수로 바뀐것이 가장 큰 특징으로 보여진다. 3. Composable FunctionComposable Function은 어노테이션을 이용한 기술이다. 함수위에 @Composable 어노테이션을 붙이게 되면 함수 안 다른 함수를 호출할 수 있게된다. 아래 코드를 보자. 123456@Composablefun Greeting(names: List&lt;String&gt;) { for (name in names) { Text(&quot;Hello $name&quot;) }} 단순하게 내부에는 Text라는 함수가 존재하는데, 이를 통해 UI계층 별 요구하는 컴포넌트를 생성해준다. 기본적으로 보이는 text 파라미터는 내부 속성에서 받는 일부 중 하나이다. 4. TextView 만들기위 코드를 실행시켜보면 당연하게도 Hello로 시작하는 TextView가 화면에 그려질것을 암시한다. 12345678setContent { BasicsCodelabTheme { // A surface container using the 'background' color from the theme Surface(color = MaterialTheme.colors.background) { Greeting(&quot;Android&quot;) } }} 5. @Preview말 그대로 어노테이션을 이용하여 IDE에서 Preview를하기 위한 용도이다. 아래 코드와 같이 @Preview 어노테이션을 추가하면 다음 결과를 볼 수 있다. 123456789@Preview(&quot;Greeting Preview&quot;)@Composablefun GreetingPreview() { BasicsCodelabTheme { Surface(color = MaterialTheme.colors.background) { Greeting(&quot;Android&quot;) } }} 6. setContent / Theme / Surface12345678setContent { BasicsCodelabTheme { // A surface container using the 'background' color from the theme Surface(color = MaterialTheme.colors.background) { Greeting(&quot;Android&quot;) } }} 기존에 onCreate시점에 화면을 그려주기 위한 필수적인 요소를 정리해보자면 setContent : Activity에서 setContentView함수를 사용하는 것과 동일한 동작을 하는 확장함수이다. 다만, setContent의 경우 (@Composable) -&gt; Unit 타입의 컴포즈 UI를 구현해주어야한다. XXXTheme : Theme정보를 의미한다. 해당 프로젝트에서는 Theme.kt에 여러 테마에 필요한 정보를 정리하고, 컴포즈 UI 구현을 위한 코드를 작성해두었다. 123456789101112131415161718192021222324252627282930313233343536373839private val DarkColorPalette = darkColors( primary = purple200, primaryVariant = purple700, secondary = teal200)private val LightColorPalette = lightColors( primary = purple500, primaryVariant = purple700, secondary = teal200 /* Other default colors to override background = Color.White, surface = Color.White, onPrimary = Color.White, onSecondary = Color.Black, onBackground = Color.Black, onSurface = Color.Black, */)@Composablefun BasicsCodelabTheme( darkTheme: Boolean = isSystemInDarkTheme(), content: @Composable () -&gt; Unit) { val colors = if (darkTheme) { DarkColorPalette } else { LightColorPalette } MaterialTheme( colors = colors, typography = typography, shapes = shapes, content = content )} Surface : Greeting을 감싸는 뷰에 해당한다. 여기서는 크기를 정하지 않고, background 색상을 정의하고 있다. 역시 람다 표현식이다. 색상에 대한 Paramter로 color 라는 값을 사용하여 부여가 가능하다. 내부코드를 보면 123456789101112131415161718192021222324252627282930313233343536@Composablefun Surface( modifier: Modifier = Modifier, shape: Shape = RectangleShape, color: Color = MaterialTheme.colors.surface, contentColor: Color = contentColorFor(color), border: BorderStroke? = null, elevation: Dp = 0.dp, content: @Composable () -&gt; Unit) { val elevationPx = with(LocalDensity.current) { elevation.toPx() } val elevationOverlay = LocalElevationOverlay.current val absoluteElevation = LocalAbsoluteElevation.current + elevation val backgroundColor = if (color == MaterialTheme.colors.surface &amp;&amp; elevationOverlay != null) { elevationOverlay.apply(color, absoluteElevation) } else { color } CompositionLocalProvider( LocalContentColor provides contentColor, LocalAbsoluteElevation provides absoluteElevation ) { Box( modifier.graphicsLayer(shadowElevation = elevationPx, shape = shape) .then(if (border != null) Modifier.border(border, shape) else Modifier) .background( color = backgroundColor, shape = shape ) .clip(shape), propagateMinConstraints = true ) { content() } }} 7. Declarative UI - 선언형 UI노란색 배경을 입혀 기존 TextView에 추가해보았다. 또한, Greeting에는 Modifier라는 것을 이용하여 Padding을 추가했다. 아래와 같은 결과가 나오게 되었다. 123456BasicsCodelabTheme { // A surface container using the 'background' color from the theme Surface(color = Color.Yellow) { Greeting(&quot;Android&quot;) }} 12345678910111213@Composablefun Greeting(name: String) { var isSelected by remember { mutableStateOf(false) } val backgroundColor by animateColorAsState(if (isSelected) Color.Red else Color.Transparent) Text( text = &quot;Hello $name!&quot;, modifier = Modifier .padding(24.dp) .background(color = backgroundColor) .clickable(onClick = { isSelected = !isSelected }) )} 선언형 UI의 장점은 말 그대로 내가 UI를 정의한대로 시각적으로 표현이 가능하다는 장점이 있다. 기존에는 속성을 매번 On/Off와 같은 옵션을 통해 변경하는 것이 다반사였지만, 이제는 매번 속성에 변경이 생길때마다 새로 그려주게 되는것이다. 8. 재사용Compose의 장점 중 하나는 재사용성이 뛰어난것인데, XML에서 우리가 include 태그를 통해 여러곳에서 갖다쓸 수 있던것처럼, 함수를 통해 여러곳에서 정의하여 사용이 가능하다. 참고해야할 점은 Compose 컴포넌트 확장 시 @Composable 어노테이션을 붙여야 한다. 9. Container 작성MyApp이라는 이름으로 컴포즈 컴포넌트를 구횬하여 여러곳에서 공통으로 사용할 수 있는 Composable을 구현하였다. 내부적으로 Container내 내가 원하는 컴포넌트를 넣어주려면 아래와 같이 인자로 @Composable () -&gt; Unit 타입을 넘겨받아 처리해주면 된다. 12345678@Composablefun MyApp(content: @Composable () -&gt; Unit) { BasicsCodelabTheme { Surface(color = Color.Yellow) { content() } }} 위 함수를 통해 이제는 어디서든 반복해서 사용할 수 있는 Container를 구현하게 되어 아래와 같이 코드를 활용할 수 있게되었다. 12345678910class MainActivity : AppCompatActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { MyApp { Greeting(&quot;Android&quot;) } } ... } 10. 레이아웃을 활용한 Compose function의 다중 호출지금까지는 하나의 컴포넌트만을 갖고 사용했지만, 여러개의 컴포넌트를 넣는것도 가능하다. 12345678@Composablefun MyScreenContent() { Column { Greeting(&quot;Android&quot;) Divider(color = Color.Black) Greeting(&quot;there&quot;) }} Column과 위에서부터 사용하던 Greeting 함수를 사용하고, 라인을 그어주기 위한 Divider를 추가한 결과물은 다음과 같다. 위 컴포넌트 중 못보던 컴포저블이 있는데, 아래와 같이 설명이 가능하다. Column : 항목을 순서대로 배치하기 위해 사용한다. Divider : 선 긋기 가능한 Compose 함수이다. 이를 리스트 형태로도 구현이 가능하다. 123456789@Composablefun MyColumnScreen(names: List&lt;String&gt; = listOf(&quot;Line One&quot;, &quot;Line Two&quot;)) { Column { names.forEach { Greeting(name = it) Divider(color = Color.Black) } }} 11. State in Compose - Compose에서의 상태값 관리컴포넌트에 버튼을 클릭했을 때 클릭한 카운트를 집계하는 간단한 컴포넌트를 만들어보았다. 1234567891011121314151617@Composablefun MyColumnScreen(names: List&lt;String&gt; = listOf(&quot;Line One&quot;, &quot;Line Two&quot;)) { val counterState = remember { mutableStateOf(0) } // Column { names.forEach { Greeting(name = it) Divider(color = Color.Black) } Counter( count = counterState.value, updateCount = { newCount -&gt; counterState.value = newCount } ) }} remember라는 함수를 사용하여 기존에 존재하는 컴포넌트의 상태값을 기억하게 하는 함수가 있다. remember 함수의 내부를 살펴보자. 12345678/** * Remember the value produced by [calculation]. [calculation] will only be evaluated during the composition. * Recomposition will always return the value produced by composition. */@OptIn(ComposeCompilerApi::class)@Composableinline fun &lt;T&gt; remember(calculation: @DisallowComposableCalls () -&gt; T): T = currentComposer.cache(false, calculation) 매 호출마다 Recomposition(재조합)하게되는 경우 컴포넌트에 값을 다시 제공하는 것을 알 수 있다. @Composable 어노테이션에 들어간 함수는 매번 해당 상태를 구독하고, 상태가 변경될때마다 알림을 받아 기존 화면을 갱신해준다. 그리고, 아래 Counter를 보면 Button을 이용하여 이벤트를 받아 처리하도록 했다. 1234567891011@Composablefun Counter(count: Int, updateCount: (Int) -&gt; Unit) { Button( onClick = { updateCount(count + 1) }, colors = ButtonDefaults.buttonColors( backgroundColor = if (count &gt; 5) Color.Green else Color.White ) ) { Text(&quot;I've been clicked $count times&quot;) }} updateCount(Int) 함수릉 통해 매번 값을 업데이트 해주는데, 이를 통해 counterState에 값을 넣어주면서 해당 컴포넌트가 매번 변경이 되는것이다. 따라서 결과를 보면, 다음과 같다. Count가 5가 넘어가면 초록색으로 바뀐다. 그 외에도 여러형태의 모양을 구성할수 있도록 옵션이 제공되어 있다. 자세한 정보는 나중에 Codelabs에 더 나와 있으니 보도록하고, 이번에 setContent에 대한 동작원리를 함께 고민해보자. 12. Activity에서의 View 생성 방식과의 비교Compose를 안드로이드 앱에서 사용하려면 Activity, Fragment와 같은곳에서 contentView로 뿌려줘야한다. 기존에 우리가 사용하던 함수를 보자. 12345678910111213/*** Set the activity content from a layout resource. The resource will be* inflated, adding all top-level views to the activity.** @param layoutResID Resource ID to be inflated.** @see #setContentView(android.view.View)* @see #setContentView(android.view.View, android.view.ViewGroup.LayoutParams)*/public void setContentView(@LayoutRes int layoutResID) { getWindow().setContentView(layoutResID); initWindowDecorActionBar();} UI 컴포넌트에서 화면을 붙일 수 있는 Window라는 녀석에서 Layout Resource Id를 통해 기존에 등록되어있던 Layout XML 파일을 로드하여 인플레이터에서 파싱하고, 이를통해 레이아웃 계층에 있는 뷰객체를 생성하여 순차적으로 ViewGroup, View를 만들어 넣어주게 된다. PhoneWindow를 보면 자세하게 알 수 있는데, Window를 구현한 setContentView에서 처음에 생성되는 최상위 레이아웃 그 위에 따로 없다면 installDecor() 함수를 통해 mContentParent(레이아웃 리소스가 붙게될 ViewGroup)를 생성하고, 하위에 넣어주게 된다. 그러면 기존 방식은 이정도로 설명을하고, 이번엔 Compose에서 setContent() 라는 함수를 어떻게 사용하는지 보자. 123456789101112131415161718192021222324252627282930313233343536373839404142/** * Composes the given composable into the given activity. The [content] will become the root view * of the given activity. * * This is roughly equivalent to calling [ComponentActivity.setContentView] with a [ComposeView] * i.e.: * * ``` * setContentView( * ComposeView(this).apply { * setContent { * MyComposableContent() * } * } * ) * ``` * * @param parent The parent composition reference to coordinate scheduling of composition updates * @param content A `@Composable` function declaring the UI contents */public fun ComponentActivity.setContent( parent: CompositionContext? = null, content: @Composable () -&gt; Unit) { val existingComposeView = window.decorView .findViewById&lt;ViewGroup&gt;(android.R.id.content) .getChildAt(0) as? ComposeView if (existingComposeView != null) with(existingComposeView) { setParentCompositionContext(parent) setContent(content) } else ComposeView(this).apply { // Set content and parent **before** setContentView // to have ComposeView create the composition on attach setParentCompositionContext(parent) setContent(content) // Set the view tree owners before setting the content view so that the inflation process // and attach listeners will see them already present setOwners() setContentView(this, DefaultActivityContentLayoutParams) }} 이녀석도 마찬가지로 window.decorView.findViewById&lt;ViewGroup&gt;(android.R.id.content) 함수를 호출하여 decorView를 가져온다. 만약 compose를 통해 만들어진 최상위 레이아웃이 존재하면, 기존에 inflator에서 ViewGroup, View를 생성해서 넣어주던것 처럼 setContent() =&gt; window가 Activity/Fragment에 붙으면 createComposition()를 호출하여 검증 후 ensureCompsositionCreated() 함수를 호출한다. 현재는 내부적으로 ViewGroup.setContent() 를 사용하고 있는데, 곧 교체 될 예정이라고 한다. 이코드도 보면 기존에 있는 ViewGroup에 확장함수로 구현한 녀석인데, 쉽게 말해 ViewGroup에 하위 View, ViewGroup에 Composable로 구현된 함수로 컴포넌트를 넣어줄 때 AndroidComposeView라는 객체를 꺼내오거나 없다면 새로 생성하여 넣어준다. 1234567891011121314151617181920212223242526/** * Composes the given composable into the given view. * * The new composition can be logically &quot;linked&quot; to an existing one, by providing a * [parent]. This will ensure that invalidations and CompositionLocals will flow through * the two compositions as if they were not separate. * * Note that this [ViewGroup] should have an unique id for the saved instance state mechanism to * be able to save and restore the values used within the composition. See [View.setId]. * * @param parent The [Recomposer] or parent composition reference. * @param content Composable that will be the content of the view. */internal fun ViewGroup.setContent( parent: CompositionContext, content: @Composable () -&gt; Unit): Composition { GlobalSnapshotManager.ensureStarted() val composeView = if (childCount &gt; 0) { getChildAt(0) as? AndroidComposeView } else { removeAllViews(); null } ?: AndroidComposeView(context).also { addView(it.view, DefaultLayoutParams) } return doSetContent(composeView, parent, content)} 다시 돌아와서, ComposeView의 setContent() 이라는 녀석을 보자. 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * A [android.view.View] that can host Jetpack Compose UI content. * Use [setContent] to supply the content composable function for the view. * * This [android.view.View] requires that the window it is attached to contains a * [ViewTreeLifecycleOwner]. This [androidx.lifecycle.LifecycleOwner] is used to * [dispose][androidx.compose.runtime.Composition.dispose] of the underlying composition * when the host [Lifecycle] is destroyed, permitting the view to be attached and * detached repeatedly while preserving the composition. Call [disposeComposition] * to dispose of the underlying composition earlier, or if the view is never initially * attached to a window. (The requirement to dispose of the composition explicitly * in the event that the view is never (re)attached is temporary.) */class ComposeView @JvmOverloads constructor( context: Context, attrs: AttributeSet? = null, defStyleAttr: Int = 0) : AbstractComposeView(context, attrs, defStyleAttr) { private val content = mutableStateOf&lt;(@Composable () -&gt; Unit)?&gt;(null) @Suppress(&quot;RedundantVisibilityModifier&quot;) protected override var shouldCreateCompositionOnAttachedToWindow: Boolean = false private set @Composable override fun Content() { content.value?.invoke() } /** * Set the Jetpack Compose UI content for this view. * Initial composition will occur when the view becomes attached to a window or when * [createComposition] is called, whichever comes first. */ fun setContent(content: @Composable () -&gt; Unit) { shouldCreateCompositionOnAttachedToWindow = true this.content.value = content if (isAttachedToWindow) { createComposition() } }} 결론적으로 AbstractComposeView 라는 녀석은 ViewGroup을 상속받은 녀석이며, 모든 composable의 상태가 변화 되었을 때 이를 감지하는 중요한 녀석이다. setContent()라는 함수는 위에서 설명했으니 넘어가고, 이번에는 Content라는 녀석을 보자. 이녀석은 추상 메소드로, createComposition() 이라는 함수가 호출 되었을 때, 가장 먼저 불리는 함수이다. 아까 언급되었던 ensureCompsositionCreated() 함수에서 tree계층의 ComposeView가 다 붙었다면, 이후에 즉시 Content함수가 호출이된다. 123456789101112131415@Suppress(&quot;DEPRECATION&quot;) // Still using ViewGroup.setContent for now private fun ensureCompositionCreated() { if (composition == null) { try { creatingComposition = true composition = setContent( parentContext ?: findViewTreeCompositionContext() ?: windowRecomposer ) { Content() // 이곳에서 뷰가 다 window에 붙게되면 콜백을 호출한다. } } finally { creatingComposition = false } } } 그러면 아래 ComposeView의 오버라이딩 된 Content가 호출되면서, 기존에 생성된 View에 UI속성과 같은 Content가 붙게된다. 12345678/*** The Jetpack Compose UI content for this view.* Subclasses must implement this method to provide content. Initial composition will* occur when the view becomes attached to a window or when [createComposition] is called,* whichever comes first.*/@Composableabstract fun Content() Content는 설명에서 보는것과 같이 createComposition() 함수 호출 후 View가 Window에 붙은 이후 즉시 호출된다. 최종적으로 ComponentActivity.setContent(CompositionContext?, @Composable () -&gt; Unit) 함수에서 구현된 ComposeView 인스턴스를 ContentLayout을 widht/height를 wrapContent크기로 정하여 ContentView를 Set해주게 된다. 123456789101112131415161718192021222324252627282930313233343536/** * Composes the given composable into the given activity. The [content] will become the root view * of the given activity. * * This is roughly equivalent to calling [ComponentActivity.setContentView] with a [ComposeView] * i.e.: * * ``` * setContentView( * ComposeView(this).apply { * setContent { * MyComposableContent() * } * } * ) * ``` * * @param parent The parent composition reference to coordinate scheduling of composition updates * @param content A `@Composable` function declaring the UI contents */public fun ComponentActivity.setContent( parent: CompositionContext? = null, content: @Composable () -&gt; Unit) { ... else ComposeView(this).apply { // Set content and parent **before** setContentView // to have ComposeView create the composition on attach setParentCompositionContext(parent) setContent(content) // Set the view tree owners before setting the content view so that the inflation process // and attach listeners will see them already present setOwners() setContentView(this, DefaultActivityContentLayoutParams) }} 13. ComposeViewandroid.view.View 는 Jetpack Compose UI 콘텐츠를 사용할 수 있도록 해줍니다. setContent 를 사용하면 composable function content 를 뷰에 제공할 수 있다. Compose 의 계층 구조는 아래와 같으며. ComposeView 를 통해 androidx.compose.materia 에 정의된 다양한 컴포넌트를 조합하여 Composable function 콘텐츠를 구성할 수 있다. 12345kotlin.Any ↳ android.view.View ↳ android.view.ViewGroup ↳ androidx.compose.ui.platform.AbstractComposeView ↳ androidx.compose.ui.platform.ComposeView 14. Compose Compiler / Compose RuntimeCompose Compiler 는 @Composable 이 설정된 경우 Composable function 으로 코드 변환과 코틀린 컴파일러 플러그인과 함께 최적화를 활성화한다. Compose Runtime은 Compose의 프로그래밍 모델과 상태 관리, 그리고 Compose 컴파일러를 지정하기 위한 코어 런타임에 대한 기본 설정을 수행한다. 12345@Composablefun Greeting(name: String) { var greet by remember { mutableStateOf(&quot;Hello $name&quot;) } Text(text = greet, color = Color.Red)} 위의 코드는 Compose Compiler에 의해 @Composeable은 아래와 같이 변경된다. 12345678910fun Greeting( $composer: Composer, $static: Int, name: String) { $composer.start(123) var greet by remember { mutableStateOf(&quot;Hello $name&quot;) } Text(text = greet, color = Color.Red) $composer.end()} Compose 는 composer.start 에서 고유의 키를 가지고 있고, 이는 Compose 의 state 가 변경될 때 해당 키를 가진 Compose 만 변경되도록 동작한다. static 은 상태(state)의 변경여부를 알 수 있는데 상태의 변화가 없는 경우, composer.start 와 composer.end 사이의 UI 의 변경을 하지 않는다. 이때 데이터의 상태가 변경되어 UI 를 다시 구성하는 경우는 Recomposition 이라고 한다.","link":"/Team-Blog/2021/04/07/2021-04-07%20Jetpack%20Compose%20Part%201/"},{"title":"Jetpack Compose Part 2 - Preview &#x2F; Layout &#x2F; Decompile","text":"Writers by 김남훈 @Naver by 배희성 @RocketPunch by 송시영 @SmartStudy by 이기정 @BankSalad Android Studio의 Jetpack ComposeAndroid Studio Preview를 사용해 Compose를 사용하다보면 Preview라 코드레벨에서 활성화되는 것을 알 수 있다. 좀 더 자세히 살펴보자. Preview의 기능들Preview 와 Compose 를 사용해서 아래와 같이 구성할 수 있다. Split(design/code) 을 선택에 따라 코드 및 디자인의 패널을 변경할 수도 있다. 미리보기에서 인터렉티브 모드를 설정할 수 있다. 인터렉티브 모드를 설정하면 실제 디바이스처럼 클릭이나 드래그 등의 상호 작용을 확인해 볼 수 있다. 다만, 네트워크나 파일에 접근 또는 일부 Context API 는 인터렉티브 모드를 지원하지 않고 있다. 간헐적으로 interactive 모드가 작동하지 않는 경우가 있다. 미리보기에서 직접 디바이스 혹은 에뮬레이터로 배포하여 결과를 확인할 수도 있다. @Preview Annotation 분석위에서 언급했다시피 @Preview를 사용하면 디바이스나 에뮬레이터를 실행하지 않고 실시간으로 Compose UI 를 볼 수 있다. @Preview를는 아래와 같이 구성되어 있으며 설정에 따라서 미리보기를 다양하게 구성할 수 있다. 12345678910111213141516annotation class Preview( val name: String = &quot;&quot;, val group: String = &quot;&quot;, @IntRange(from = 1) val apiLevel: Int = -1, // TODO(mount): Make this Dp when they are inline classes val widthDp: Int = -1, // TODO(mount): Make this Dp when they are inline classes val heightDp: Int = -1, val locale: String = &quot;&quot;, @FloatRange(from = 0.01) val fontScale: Float = 1f, val showSystemUi: Boolean = false, val showBackground: Boolean = false, val backgroundColor: Long = 0, @UiMode val uiMode: Int = 0, @Device val device: String = Devices.DEFAULT) name : Preview 의 이름을 지정하며, 기본 값은 function 이름으로 설정된다. group : Preview 의 그룹을 지정한다, 기본 값은 function 이름으로 설정된다. apiLevel : api level 설정에 따라 Composable 을 렌더링해준다. widthDp : Preview 의 너비를 설정한다. (기본 단위는 dp) heightDp : Preview 의 높이를 설정한다. (기본 단위는 dp) locale : 사용자 locales 에 따라 보여지는 UI 를 테스트 하기 위해 사용한다. fontScale : 기본 density 애 배율을 적용해서 폰트 사이즈를 변경할 수 있다. showSystemUi : true 로 설정하면 status bar 와 action bar 를 노출한다. showBackground : true 로 설정하면 기본 배경색상을 적용해준다. backgroundColor : 미리보기의 배경색을 설정할 수 있으며, showBackground 설정에 따라 노출 유무를 결정한다. uiMode : uiMode 를 설정한다. device : 기존 정의된 디바이스를 프리뷰에 적용한다. Devices object 에 정의된 값을 선택해서 사용할 수 있습니다. (Devices.NEXUS_9) Compose의 레이아웃 구성 Column : 아이템을 세로로 배치한다. 1234567@Composablefun ComposeColumn() { Column { Text(text = &quot;My First Compose&quot;) Text(text = &quot;My First Compose&quot;) }} Row : 아이템을 가로로 배치한다. 1234567@Composablefun ComposeRow() { Row { Text(text = &quot;My First Compose&quot;) Text(text = &quot;My First Compose&quot;) }} Box : 구성 요소를 다른 구성 요소 위에 배치한다. 1234567@Composablefun ComposeBox() { Box { Text(text = &quot;My First Compose 1&quot;) Text(text = &quot;My First Compose 2&quot;) }} Modifier : 구성 요소의 크기, 마진등을 변경하거나 클릭이나 스크롤 등의 이벤트를 제어할 수 있도록 한다. 12345678@Composablefun ComposeModifier() { Box(modifier = Modifier .padding(5.dp) ) { Text(text = &quot;Compose Modifier&quot;) }} LazyColumn / LazyRow : Recyclerview 유사하게 화면에 보여지는 구성 요소만을 렌더링한다. 큰 데이터셋을 다루기에 용이하다. 12345678910@Composablefun ComposeLazyColumn() { val itemsList = (0..100).toList() LazyColumn { items(items = itemsList, itemContent = { item -&gt; Text(text = &quot;Item : $item&quot;, style = TextStyle(fontSize = 80.sp)) }) }} ConstraintLayout : 기존 ContraintLayout 과 같이 여러 제약 참조를 설정해서 사용할 수 있다.createRefs / createRefFor 를 통해 참조를 생성하며, constrainAs 를 통해 제약 조건을 설정한다. 123456789101112131415161718192021222324252627282930@Composablefun ComposeConstraintLayout() { ConstraintLayout(modifier = Modifier.size(100.dp, 200.dp)) { val (text1, image, text3) = createRefs() Text(&quot;Text Item 1&quot;, Modifier.constrainAs(text1) { top.linkTo(parent.top) start.linkTo(parent.start) end.linkTo(parent.end) }) Image( painterResource(R.drawable.ic_launcher_foreground), contentDescription = &quot;&quot;, contentScale = ContentScale.Crop, modifier = Modifier.fillMaxSize().constrainAs(image) { top.linkTo(text1.bottom) bottom.linkTo(text3.top) start.linkTo(parent.start) end.linkTo(parent.end) } ) Text(&quot;Text Item 3&quot;, Modifier.constrainAs(text3) { bottom.linkTo(parent.bottom) start.linkTo(parent.start) end.linkTo(parent.end) }) }} Jetpack Compose 의 ConstraintLayout 을 사용하기 위해서는 아래 의존성을 추가해야 한다. 1implementation &quot;androidx.constraintlayout:constraintlayout-compose:1.0.0-alpha05&quot; Jetpack Compose의 동작 원리 파악을 위한 빌드 과정 추적1. 프로젝트 생성Compose가 내부적으로 어떻게 동작하는 지 알아보기 위해 먼저 프로젝트를 빌드해보자. 빌드 후 Kotlin &gt; Byte Code &gt; Decompiled Java 순서로 변환하여 살펴볼 것이다. Android Studio Preview에서 Empty Compose Activity로 프로젝트를 생성하면 아래와 같은 샘플 코드를 얻을 수 있다. 프로젝트 생성 후 임의로 Hello World로 파라미터값을 변경하였다. 1234567891011121314151617181920212223242526class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { HelloWorldTheme { // A surface container using the 'background' color from the theme Surface(color = MaterialTheme.colors.background) { Greeting(&quot;World&quot;) } } } }}@Composablefun Greeting(name: String) { Text(text = &quot;Hello $name!&quot;)}@Preview(showBackground = true)@Composablefun DefaultPreview() { HelloWorldTheme { Greeting(&quot;World&quot;) }} 부가적으로 src 폴더 내부에 ui.theme 패키지가 생성되고 Color.kt, Shape.kt, Theme.kt, Type.kt 파일도 생성된다. 이 파일들은 필요한 경우 들여다 보도록 하자. 생성 후 Preview에 아래와 같이 렌더링 된다. 2. MainActivity 디컴파일12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152@Metadata( mv = {1, 4, 2}, bv = {1, 0, 3}, k = 2, d1 = {&quot;...&quot;}, d2 = {&quot;DefaultPreview&quot;, &quot;&quot;, &quot;Greeting&quot;, &quot;name&quot;, &quot;&quot;, &quot;app_debug&quot;})public final class MainActivityKt { @Composable public static final void Greeting(@NotNull String name) { Intrinsics.checkNotNullParameter(name, &quot;name&quot;); TextKt.Text-Vh6c2nE$default(&quot;Hello &quot; + name + '!', (Modifier)null, 0L, 0L, (FontStyle)null, (FontWeight)null, (FontFamily)null, 0L, (TextDecoration)null, (TextAlign)null, 0L, (TextOverflow)null, false, 0, (Function1)null, (TextStyle)null, 65534, (Object)null ); } @Composable public static final void DefaultPreview() { ThemeKt.HelloWorldTheme$default(false, (Function0)null.INSTANCE, 1, (Object)null); }}// MainActivity.java@Metadata( mv = {1, 4, 2}, bv = {1, 0, 3}, k = 1, d1 = {&quot;...&quot;}, d2 = {&quot;...&quot;})public final class MainActivity extends ComponentActivity { protected void onCreate(@Nullable Bundle savedInstanceState) { super.onCreate(savedInstanceState); ComponentActivityKt.setContent$default(this, (CompositionContext)null, (Function0)null.INSTANCE, 1, (Object)null); }} ComponentActivityKt.setContent()의 구현체는 아래와 같다. 12345678910111213141516171819public fun ComponentActivity.setContent( parent: CompositionContext? = null, content: @Composable () -&gt; Unit) { val existingComposeView = window.decorView .findViewById&lt;ViewGroup&gt;(android.R.id.content) .getChildAt(0) as? ComposeView if (existingComposeView != null) with(existingComposeView) { setParentCompositionContext(parent) setContent(content) } else ComposeView(this).apply { // Set content and parent **before** setContentView // to have ComposeView create the composition on attach setParentCompositionContext(parent) setContent(content) setContentView(this, DefaultActivityContentLayoutParams) }} CompositionContext 파라미터는 null을 그대로 넘겨주었고, (Function0)null.INSTANCE, 1, (Object)null의 값으로 무언가를 넘겨주는데, 이 값이 @Composable Annotation의 구현체이다. 위의 코드 흔적을 술어로 표현해보면 @Composable 구현체를 넘겨주면 이를 기반으로 ComposeView 객체를 생성하여 Activity의 setContentView()에 적용한다. 가 되겠다. 3. @Composable 구현체 확인Composable Annotaion 클래스의 구현체는 아래와 같다. 1234567891011121314151617181920212223242526@MustBeDocumented@Retention(AnnotationRetention.BINARY)@Target( // function declarations // @Composable fun Foo() { ... } // lambda expressions // val foo = @Composable { ... } AnnotationTarget.FUNCTION, // type declarations // var foo: @Composable () -&gt; Unit = { ... } // parameter types // foo: @Composable () -&gt; Unit AnnotationTarget.TYPE, // composable types inside of type signatures // foo: (@Composable () -&gt; Unit) -&gt; Unit AnnotationTarget.TYPE_PARAMETER, // composable property getters and setters // val foo: Int @Composable get() { ... } // var bar: Int // @Composable get() { ... } AnnotationTarget.PROPERTY_GETTER)annotation class Composable AnnotationTarget을 통해 메서드나 Lambda 객체를 넘겨서 뷰를 조립하는 방식인데, View와 ViewGroup처럼 내부적으로 트리 구조로 실행지점에 대한 정보를 저장하고 있다. 파면 팔수록 Flutter의 Widget, React Native의 Component와 유사한 느낌을 준다.","link":"/Team-Blog/2021/04/07/2021-04-07%20Jetpack%20Compose%20Part%202/"},{"title":"Jetpack Compose Part 3 - Retrospect","text":"Writers by 김남훈 @Naver by 배희성 @RocketPunch by 송시영 @SmartStudy by 이기정 @BankSalad Jetpack Compose의 Coupling과 Cohesion비단 Android 애플리케이션뿐만 아니라, 소프트웨어를 잘 개발하기 위해 지켜야할 원칙 중 하나는 관심사의 분리(Separation of concerns) 라는 개념이다. 흔히 복잡성을 극복하기 위해 여러가지 디자인 패턴을 적용하여 View와 Controller를 분리하기 위해 애쓰는 사람들이 많은 것도 결국 프로덕트의 복잡성을 (완전히 없앨 수는 있을까?) 최소화하기 위해서이다. Compose 또한 이 복잡성의 극복을 위해 나온 도구라고 봐도 무방할 것이다. 따라서 Compose를 적용하면서 계속 머릿속에 캐시해두어야할 개념은 Coupling 과 Cohesion 이다. 흔히들 커플링이 심하다라고 표현하긴 하는데, 굳이 한글로 번역하자면 각각, 어떠한 컴포넌트들간의 결속 과 분리된 각 모듈 내부의 응집 을 뜻한다고 볼 수 있다. 출처 How Cohesion and Coupling Correlate 위의 세 그림을 아래 개념을 뜻한다. A : Low cohesion, tight coupling B : High cohesion, tight coupling C : High cohesion, loose coupling 결국 Compose를 잘 쓴다는 것은 UI/UX 입장에서 뷰를 잘 분리하여 재사용을 통해 우리가 개발하려는 프로덕트가 C의 구조가 되게끔 작성하는 것이다. Compose 사용시 주의사항 최대한 재사용성이 높게 설계되어야 한다. 뷰 모델과 비지니스 모델 분리가 필요하다. 지속적으로 재사용하는데 ViewModel과 같은 비지니스 모델이 수행되면 무거워지기 때문 매개변수나 람다를 이용하자. 호출 순서가 보장되지 않으므로, 각 함수는 독립적으로 설계해야 한다. Compose의 Stateremember 예약어를 통해 메모리에 단일 객체를 저장 가능하다. 상위 컴포넌트가 재구성되기 전까지 상태를 가지고 있다. Stateless Satateless Composable은 말그대로 상태값을 가지고 있지 않다. 외부에서 매개변수나 람다를 통해 상태를 받아 사용한다. Stateful 상태 값을 가지고 있는 Composable State&lt;T&gt; 객체를 통해 관찰가능한 값을 가지고 있으므로 사용이 권장된다. Runtime시 통합된다. 이전 상태를 복원하기 위해서는 rememberSaveable 키워드를 사용한다. Bundle에 데이터가 자동으로 저장된다. Compose Samples코드랩 뿐만 아니라 다양한 Compose 샘플들을 구글이 모아두었다. 아래 링크를 참조하자. Github#Android Compose Samples 현재 작업하고 있는 뷰와 제일 유사한 것들을 통해 Compose를 이해하는 것도 하나의 방법이 될 수 있다. 마무리하며 뷰를 제작함에 있어서 선언형 프로그래밍은 좋은 효율을 낼 수 있을 것 같다 Flutter나 SwiftUI를 사용해보면 뷰 제작 속도가 얼마나 다른지 알 수 있다. (개개인의 차이가 있을 수 있음) 요즘 제일 많이 사용하는 MVVM 아키텍처도 적용 가능하지만 이게 적합한지는 잘 모르겠다. MVI 같은 아키텍처가 오히려 더 잘 맞을 수 있다고 생각한다. 안드로이드에서 전혀 생각지도 못한 선언형 프로그래밍 방식을 도입할 수 있던 것이 신선하다고 생각한다. 선언형 프로그래밍도 결국 유행하지않을까? 기존에 React나 Flutter를 통해 선언형 프로그래밍을 쉽게 접했던 개발자들은 더 쉽게 안드로이드 개발을 도전해보지 않을까 싶다. 오히려 반대로 기존에 XML로 레이아웃 코드를 짜던 개발자들은 생소한 방식이라 적응하는데 시간이 꽤나 걸릴 것이다. 다만, 아직도 alpha버전이라 바뀔 수 있는 것이 너무나도 많은 상황이다. 앞으로 좋은 예시들이 나오고, 좀 더 기존 안드로이드 개발자들이 익숙해 할만한 컴포넌트로 제공이 되면, 좀 더 많은 개발자들이 선언형 프로그래밍으로 넘어갈 수 있지 않을까 싶다. 당장 기존에 있던 코드와 공존하면서 쓰기에는 여간 불편할것 같다. Flutter의 경우 선언형 프로그래밍 방식으로 렌더링을 지원하기 때문에 처음부터 개발을 선언형으로 하게되니, 굳이 이럴바에는 Flutter로 서비스를 따로 구현하는 게 낫지 않을까라는 생각이 들었다. ReferencesMembers of Study https://namhoon.kim/2021/03/14/android_deep_dive/001/ https://namhoon.kim/2021/03/21/android_deep_dive/002/ https://sysys.medium.com/jetpack-compose-%EC%B2%B4%ED%97%98%EA%B8%B0-8f90aff89f47 https://soda1127.github.io/introduce-jetpack-compose/ Official Android Developers#Jetpack Compose Android Developers#Compose 이해 Android Developers#Compose Cource Android#Compose Samples Etc Understanding Jetpack Compose - part 1 of 2 Understanding Jetpack Compose - part 2 of 2 foso.github.io","link":"/Team-Blog/2021/04/07/2021-04-07%20Jetpack%20Compose%20Part%203/"},{"title":"Introduce Android UI Rendering Principle and View Optimization Part 1","text":"Writers by 김남훈 @Naver by 배희성 @RocketPunch by 송시영 @SmartStudy by 이기정 @BankSalad by 정세희 @BankSalad by 최소영 @BankSalad 우리는 안드로이드 개발자로 있으면서 기본적인 것들을 놓치곤한다. 안드로이드에서 가장 중요한것은 사용자에게 보여지는 UI와 UX이다. 이를 위해서 안드로이드 개발자가 해야할 일은 UI를 이쁘게 요구사항에 맞게 그리고, 지연없는 UI로딩을 통해 UI를 그리는 것이다. 글을 작성하다 보니 문득 든 생각이 있었다. 과연 우리가 안드로이드에서 UI를 그릴 때 정확하게 방법을 알고 View를 그리는 코드를 작성하고 있었을까? 나 스스로도 그렇지 않다라는 생각이 들었고, 궁금증이 생겨 ADD 멤버분들과 함께 글을 정리해보았다. Android View안드로이드 개발자라면 한번쯤은 들어봤을 법한, 컴포넌트들이 있다. 바로 아래의 녀석들이다. 안드로이드의 다양한 컴포넌트들은 다음과 같이 View라는 녀석을 상속받아서 만들어졌다. View &amp; ViewGroup간단히 개념만 잡고 넘어가보도록 해보자. 안드로이드에서 화면을 나누는 두가지 부류는 View와 ViewGroup 두가지로 나눌 수 있다. View는 Activity, 즉 한 화면에서 화면을 구성하는 최소 단위의 개념이다. 또다른 말로는 위젯이라고 하는데, 이 View를 상속받아 구현되는 수많은 요소들이 존재한다. 대표적으로 ImageView, TextView, Button과 같은 녀석이 있다. 위젯이나 노티피케이션 위젯과 같이 사용성이 특수한 경우 RemoteView를 이용하여 구현을 해야하는 경우도 있는데, 여기서는 이에 대한 설명은 생략하겠다. ViewGroup은 View를 상속받아 구현된 클래스이다. 다른말로는 레이아웃이라고 하며, View를 N개 담을 수 있는 녀석이다. 대표적으로 LinearLayout, FrameLayout, RelativeLayout, ConsraintLayout이 있다. 이러한 방식으로 View, ViewGroup은 Java, 또는 Kotlin코드로 구성될 수 있지만, 더 쉬운 방법으로 Mark-Up 랭귀지를 이용하여 구성도 가능하다. 안드로이드 프로그래밍에서는 XML이라는 마크업 랭귀지를 이용하는데, 결국 이도 XML Parser를 통해 파싱되어 Java코드로 변환되어진다. 안드로이드 개발자들은 어플리케이션의 좋은 성능을 낼 수 있는 방법과, 올바른 방법으로 개발을 하기 위해서라도 View가 그려지는 과정과 생명주기에 대해 잘 알고 있어야 한다. 이를 위해서 먼저 View가 어떤 생명주기를 갖는지 보도록하자. View Life-Cycle상용화 하는 어플리케이션을 만들수록, 우리가 만들어나가는 View는 고도화 될 필요가 있다. 특히 View, ViewGroup을 기반으로 한 컴포넌트를 구성하게 될 때, 우리는 커스텀 뷰라는 것을만들게 된다. 커스텀 뷰를 만들게 될 때, 만들면 만들수록 점점 뷰를 그려지는 방식은 복잡해지고, 성능적인 부분을 충족하기 위해 최적화할 수 있는 방법을 고민해야한다. 이를 위해서는 View의 생명주기에 대해서도 잘 알고 있어야 한다. 안드로이드 컴포넌트, Fragment와 마찬가지로 View도 생명주기를 갖고있다. View의 생명주기는 아래와 같이 도식화 하여 표현 가능하다, 생명주기에 대해 몇 가지 특징적으로 나눌 수 있는 부분이 있다. ConstructorsProgrammatically하게 View를 생성하는 방법이다. View를 생성하는 방법은 여러가지가 존재하지만, 가장 직관적인 방법 중 하나이다. 생성자의 종류는 여러가지가 존재한다. View(Context context) View(Context context, @Nullable AttributeSet attrs) View(Context context, @Nullable AttributeSet attrs, int defStyleAttr) View(Context context, @Nullable AttributeSet attrs, int defStyleAttr, int defStyleRes) Attachment / Detachment Attachment는 Window에서 붙었음을 의미한다. Detachment는 Window에서 떼어졌음을 의미한다. 위 동작이 수행되었음을 받을 수 있는 Callback Function으로 두가지 함수를 각각 제공한다. onAttachedToWindow()View가 Window에 붙었을 때 호출된다. 이때부터는 View가 Active하다고 판단되며, 이때부터는 리소스 할당, 파라미터에 대한 계산, 리스너를 부착할 수 있는 준비가 된다. onDetachedFromWindow()View가 Window에 떼어졌을 때 호출된다. Window상에서 더 이상 존재하지 않으므로, Inactive하며, 기존에 View에 할당된 리소스를 해제해주어야한다. 해당 콜백함수가 불리는 케이스로는 두가지가 있다. ViewGroup에서 View가 제거될 때 Activity가 finish() 함수를 호출하여 Activity가 Destroyed될 때 onMeasure()View의 크기를 계산한다. ViewGroup은 하위 노드인 View에 대한 크기를 측정하고, 관계성을 파악 후 자신의 크기를 계산한다. 따라서, 하위 노드가 ViewGroup에 올바르게 붙었는지 확인해야한다. 12345678910111213/** * * 기본적으로 View의 크기를 측정할 때는 Background의 Dimension Size를 보고 결정한다. * * 현재 계산된 크기를 비교하여 Background크기보다 작은경우, Background크기를 반환하여 크기를 반환한다. * @param widthMeasureSpec 부모뷰에 의해 적용된 수평 공간 * @param heightMeasureSpec 부모뷰에 의해 적용된 수직 공간 * */protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) { setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec), getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));} MeasureSpecViewGroup의 하위 컴포넌트인 View에서는 크기에 대한 제약을 정하기 위해 스펙을 정하게 되는데, 이를 MeasureSpec을 통해 해결한다. MeasureSpec은 Width, Height에 대한 스펙이며, 크기와 모드로 나뉜다. 그리고 세가지의 값으로 나뉜다. MeasureSpec.EXACTLY : 부모뷰가 자식뷰의 정확한 크기를 결정한다. 자식뷰의 사이즈와 관계없이 주어진 경계내에서 사이즈가 결정된다. MeasureSpec.AT_MOST : 자식뷰는 지정된 크기까지 원하는 만큼 커질 수 있다. MeasureSpec.UNSPECIFIED : 부모뷰가 자식뷰에 제한을 두지 않기 때문에, 자식뷰는 원하는 크기가 될 수 있다. 아래와 같은 코드로 체크할 수 있다. 1234567@Overridepublic void onMeasure(int widthMeasureSpec, int heightMeasureSpec) { int mode = MeasureSpec.getMode(heightMeasureSpec) if (mode != MeasureSpec.EXACTLY) { // Logic }} onLayout()계산이 된 이후에는 onLayout 함수를 통해 계산된 View를 Window에 배치한다. View와 같은 경우 아래 코드를 기반으로 상속받아 처리한다. 1protected void onLayout(boolean changed, int left, int top, int right, int bottom) onDraw()onLayout에서 View에 대한 크기 계산 및 배치가 완료되었으므로, 이를 기반으로 onDraw에서는 Canvas라는 인스턴스를 넘겨주며, 해당 Canvas 인스턴스는 DisplayList에 그릴 데이터를 담아서 넘겨준다. onDraw는 한프레임을 그리는 함수기 때문에 반복적으로 호출이된다. 특이하게 여러번 호출되고 CPU연산이 되는 곳이기 떄문에, 객체를 만들어서 사용하는 것은 금기시한다. View가 draw를 하는 기준은 두가지로 나눌 수 있다. View의 모양이 변형이 생겼을 때 - invalidate() View의 경계에 변화가 생겼을 때 - requestLayout() Invalidate()invalidate 함수는 직접적으로도 호출이 가능하지만, 상위에서 View에서 여러 View내에 상태가 변형이 되었을 때 호출을한다. 직접 코드를 까보는 것이 아무래도 좋으니, 본인이 확인한 invalidate를 호출하는 시점을 리스트업 해본다. drawableStateChanged - Background, 포커스 되었을 때 나타다는 하이라이트, Foreground Drawable에 대해 변경점을 체크하며, 상태가 존재하면 변경된 것으로 판단 setDefaultFocusHighlight - 포커스 되었을 때 하이라이트를 기본적으로 세팅해줌. 무조건 새로 그림 setForeground setScrollIndicators - indicator의 색상과 마스크를 설정한다. 기존 마스크와 머지하고, 플래그를 체크하여 업데이트 된 경우 새로 그린다. setAutoFilled requestAccessibilityFocus - 포커스를 쓸 수 있는 권한을 요청할 때 View에대한 포커스에 대해서 달라진 점이 생기면 플래그로 비교하여 처리 setForceDarkAllowed - 어둡게 처리시 필요한 함수 onDrawScrollBars - 스크롤바에 움직임이 생길 시 setLayerPaint - 색상에 대한 변형이 있을 때 처리한다. (alpha, Xfermode, colorFilter) requestLayout()뷰의 경계가 변경되면 무조건 호출돼야하는 함수이다. 이를 통해 재 계산을 거쳐 onMeasure =&gt; onLayout을 거친다. View State Save/RestoreView는 Activity의 상태에 따라 상태를 저장/복원해야 할 필요가있다. 이를 위한 두가지의 함수를 제공한다. onSaveInstanceState() -&gt; Parcelable상태를 저장하기 위한 함수에서는 상태를 저장할 때 각 View에 대한 고유 ID를 필요로한다. 저장을 할때는 Bundle 인스턴스를 생성하여 저장하면 된다. Bundle은 Parcelable을 구현한 클래스로, 적절하게 저장하여 처리할 수 있다. 아래 코드를 참고하자. 12345678910@Overridepublic Parcelable onSaveInstanceState() { Bundle bundle = new Bundle(); // The vars you want to save - in this instance a string and a boolean String someString = &quot;something&quot;; boolean someBoolean = true; State state = new State(super.onSaveInstanceState(), someString, someBoolean); bundle.putParcelable(State.STATE, state); return bundle;} State라는 녀석이 보이는데, 해당 State는 직접 구현해주어야 하는 클래스가 될 수 있다. View에대한 상태를 저장할 수 있는 어떤것이든 상관없다. onRestoreInstanceState(Parcelable state)해당함수를 오버라이딩하면 다시 Paracleable로 된 인스턴스를 받아서 처리가 가능하다. Parcelable을 그대로 쓸수는 없으니, 구현체에 해당하는 인스턴스로 캐스팅하여 처리하면 된다. 아래는 예시이다. 1234567891011121314@Overridepublic void onRestoreInstanceState(Parcelable state) { if (state instanceof Bundle) { Bundle bundle = (Bundle) state; State customViewState = (State) bundle.getParcelable(State.STATE); // The vars you saved - do whatever you want with them String someString = customViewState.getText(); boolean someBoolean = customViewState.isSomethingShowing()); super.onRestoreInstanceState(customViewState.getSuperState()); return; } // Stops a bug with the wrong state being passed to the super super.onRestoreInstanceState(BaseSavedState.EMPTY_STATE); } View가 그려지는 순서View가 렌더링 될 때, 상위수준의 ViewGroup 에서부터 하위 자식인 View 로 내려가면서 Measure -&gt; Layout -&gt; Draw 를 거치게 된다. Measure Pass측정 패스는 measure(int, int) 로 구현되며 뷰 트리의 탑-다운으로 순회한다. 각 뷰는 트리를 재귀하는 동안 측정한 수치를 트리 아래로 보낸다. 측정이 모두 끝나면 모든 뷰는 측정한 값을 가지게 된다. 두번째 단계 또한 탑-다운으로 layout(int, int, int) 에서 일어난다. 각각의 부모는 측정단계에서 계산된 사이즈를 사용해서 자신의 모든 자식을 배치한다. View 의 크기는 2가지로 정의될 수 있다. measured width &amp; measured height : 뷰가 부모뷰 크기의 범위 내에서 가지고 싶어하는 너비와 높이이다. drawing width &amp; drawing height : 뷰의 실제 너비와 높이로 뷰를 그리기 위해서 사용한다. View의 Padding, Margin 등을 고려하면 원하는 크기에서 Padding 및 Margin 값을 빼야 하기 때문에 Measured Width, Measured Height 는 Drawing Width, Drawing Height 와 다를 수 있다. Layout Pass레이아웃을 시작하려면, requestLayout() 를 호출한다. 일반적으로 현재 범위내에 더이상 맞지 않을때 자체적으로 뷰에 의해 호출된다. 이 과정에서도 top-down 형식의 탐색이 일어나게 되는데, 이 때는 각각의 ViewGroup이 Measure 단계에서 측정된 크기를 이용해서 하위속성들의 위치를 결정한다. Draw PassGPU에게 명령을 내려주는 단계이다. 그려야 할 객체들의 리스트를 GPU에게 보내기 위해 View Tree에서 각 객체의 대한 Canvas 객체가 생성된다. 이 때, 이전 1,2단계를 거쳐 결정된 객체들의 크기와 위치에 대한 정보가 들어가게 된다. 만약 View가 변할 때, 시스템에게 알려주기 위한 2가지 방법이 존재하는데, Invaliadate()가 호출 될 때에는 draw부터 다시 작업이 시행되고, requestLayout()이 호출될 때에는 measure -&gt; layout -&gt; draw 단계를 다시 거치게 된다. 코드로 보면서 어떤식으로 View가 그려지는지 한번 보도록하자. 실험을 통한 View Rendering Process 관찰123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;androidx.constraintlayout.widget.ConstraintLayout android:id=&quot;@+id/root1&quot; xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;.MainActivity&quot;&gt; &lt;androidx.constraintlayout.widget.ConstraintLayout android:id=&quot;@+id/constraintContainer2&quot; android:layout_width=&quot;400dp&quot; android:layout_height=&quot;400dp&quot; android:background=&quot;@color/teal_200&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintEnd_toEndOf=&quot;parent&quot; app:layout_constraintBottom_toBottomOf=&quot;parent&quot;&gt; &lt;TextView android:id=&quot;@+id/constraintTextView3&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;First TextView&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; /&gt; &lt;LinearLayout android:id=&quot;@+id/linearContainer4&quot; android:layout_width=&quot;200dp&quot; android:layout_height=&quot;200dp&quot; android:orientation=&quot;vertical&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; app:layout_constraintEnd_toEndOf=&quot;parent&quot;&gt; &lt;ImageView android:id=&quot;@+id/linearImageView5&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:background=&quot;@drawable/ic_launcher_foreground&quot;/&gt; &lt;TextView android:id=&quot;@+id/linearTextView5&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;Second TextView&quot;/&gt; &lt;RelativeLayout android:id=&quot;@+id/relativeContainer5&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:background=&quot;@color/purple_500&quot;&gt; &lt;TextView android:id=&quot;@+id/relativeTextView6&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;Thired TextView&quot;/&gt; &lt;/RelativeLayout&gt; &lt;/LinearLayout&gt; &lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; &lt;FrameLayout android:id=&quot;@+id/frameContainer2&quot; android:layout_width=&quot;100dp&quot; android:layout_height=&quot;100dp&quot; android:background=&quot;@color/teal_200_30&quot; app:layout_constraintEnd_toEndOf=&quot;parent&quot; app:layout_constraintBottom_toBottomOf=&quot;parent&quot; /&gt;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; root Container 를 부모 레이아웃으로 삼아 다양한 depth 의 View 가 쌓여져 있고, 이는 아래처럼 그래프로 나타낼 수 있다. 각각의 View, ViewGroup에 onLayout 시점을 포착할 수 있는 코드를 구현해, 어느 순서로 View 가 그려지는지 확인해보자. doOnLayout, doOnDraw, doOnXXX 등을 통해 원하는 라이프사이클 시점을 포착할 수 있다. OnLayout 호출로 순서 보기1234567891011121314151617181920212223242526272829303132333435linearContainer4.doOnLayout { println(&quot;linearContainer4 doOnLayout&quot;)}constraintContainer2.doOnLayout { println(&quot;ConstraintContainer2 doOnLayout&quot;)}constraintTextView3.doOnLayout { println(&quot;constraintTextView3 doOnLayout&quot;)}root1.doOnLayout { println(&quot;root1 doOnLayout&quot;)}relativeContainer5.doOnLayout { println(&quot;relativeContainer5 doOnLayout&quot;)}relativeTextView6.doOnLayout { println(&quot;relativeTextView6 doOnLayout&quot;)}linearImageView5.doOnLayout { println(&quot;linearImageView5 doOnLayout&quot;)}linearTextView5.doOnLayout { println(&quot;linearTextView5 doOnLayout&quot;)}frameContainer2.doOnLayout { println(&quot;frameContainer2 doOnLayout&quot;)} onLayout 시점에는 트리구조로 이루어진 View &amp; ViewGroup 이 후위순회를 하며 측정이 된다는 것을 알 수 있다. 실험을 통해 알게 된 결론Layout 내에 존재하는 Chile View가 lifecycle 를 거치면서 크기가 측정되는 순서와, 그려지는 순서는 다르다. Child View 들의 크기가 정해지고 Parent View 가 그 측정값을 알아야지 자신의 크기를 정할 수 있는 것이고, (Layout 단계) 도화지가 준비되어야 그림을 그릴 수 있듯이, Parent View 가 먼저 그려져야 Child View 가 그려질 수 있기 때문이다. (Draw 단계) Extra Infolayout_weight 의 배신Linear Layout 의 layout_weight 속성을 사용하는 경우 자식 뷰는 두번의 Measure pass가 필요하기 때문에 많은 비용이 소모된다. layout_weight는 단순히 비율을 나누어 공간을 차지하는 것이 아닌, 부모의 View가 그려지고 나서 남은 공간이 얼마만큼인지, 다른 View들이 그려지고 나서 다시한번 남은공간도 계산하고 나서 자기 자신을 그리기 때문에 지속적인 계산이 일어나게 된다. 복잡한 View의 계산을 피하기 위해 Releative Layout &amp; Constraint Layout을 권하는 것이다. Overdraw 를 피하는 방법OverDraw를 피하는 방법 중, 사용자에게 보여지지 않는 Layout의 Background 색을 제거하면 성능 향상에 도움이 된다는 글이 많이 존재한다. 하지만 어째서 배경 색을 지우는 것만으로도 성능이 크게 향상될 수 있다는 것일까? Layout에 Background를 제거한 후 디버깅을 해보면 View Lifecycle의 onDraw를 거치지 않음을 알 수 있다. UI 렌더링 시 가장 비용이 많이 드는 부분이 onDraw(GPU에 업로드 하는 과정) 인데, 이 부분이 skip 되니 성능이 향상되는건 당연한 부분일 것이다. 여기까지 View의 생명주기, View가 그려지는 과정에 대해 알아보았다. 다음 글에서는 View 상위에서 그려지는 요소인 Window, Surface, Canvas에 대해 소개하고, 소프트웨어 레벨에서 어떻게 하드웨어 레벨까지 동기화 되는지 분석하고, 현재 사용하는 하드웨어 모델 기반 렌더링에 대해 소개하도록 하겠다.","link":"/Team-Blog/2021/05/19/2021-05-19%20Android%20UI%20Rendering%20Optimization%20Part%201/"},{"title":"Introduce Android UI Rendering Principle and View Optimization Part 2","text":"Writers by 김남훈 @Naver by 배희성 @RocketPunch by 송시영 @SmartStudy by 이기정 @BankSalad by 정세희 @BankSalad by 최소영 @BankSalad 저번 포스트에서는 View와 ViewGroup 개념, UI가 그려지는 과정, UI가 그려질 때 View의 생명주기에 대해 보았다. 이번시간에는 UI Rendering 시 화면에 보여질 때 어떤 과정을 거치는지 알아보자. UI Rendering아래 내용은 Google Android Source Document의 그래픽 아키텍쳐 내용을 참고하여 작성되었다. 위와 같은 최적화가 내부적으로 일어나기 위해서는 화면을 그리는 필수요소로, Window, Surface, Canvas, View 레이어로 나눠서 처리하게 된다. Window무언가를 그릴 수 있는 창(Window)이다. 이 영역에서는 그릴 수 있는 Surface를 들고 있고, 애플리케이션은 WindowManager와 상호작용을 통해 Window를 만들고, Window위에 올려진 Surface를 통해 UI를 그린다. 하나의 화면에서는 여러개의 Window를 가지며, WindowManager를 통해 관리받게 된다. 대표적으로 PhoneWindowManager, DialogWindowManager와 같은 요소가 있다. Surface and SurfacHolder기본적으로 안드로이드에서 모든 화면에 그려지는 요소들은, Surface를 통해 처리된다. 안드로이드에서는 Surface와 SurfaceHolder를 통해 그려지는 영역을 제어한다. SurfaceSurface는 화면에 표시하는 이미지를 앱이 렌더링 할 수 있도록 해준다. 해당 클래스는 Android 1.0 초창기부터 API에 내장되어 있었으며, 안드로이드 온라인 도움말 사이트에는 Surface 클래스에 대해서 Screen Compositor가 관리하는 하나의 Raw 버퍼를 가리키는 핸들이라고 설명한다. 잘 이해가 안갈테니, 이미지를 함께 보면서 이해 해보도록 하자. 하나의 애플리케이션은 기본적으로 하나의 Surface를 가진다. BufferQueue는 그래픽 데이터의 버퍼를 생성하는 요소(생산자)를 표시 데이터 또는 추가 처리를 허용하는 요소(소비자)에 연결한다. Suface는 자주 사용되는 BufferQueue를 생성하고(Producer), 버퍼에 데이터를 담아 SurfaceFlinger(Consumer)로 전달하여 출력한다. 이를 통해 화면에 drawing을 하여 Application과 상호작용하게 된다. 각 Surface는 이중 버퍼 렌더링을 위한 1개 이상 (보통 2개)의 버퍼를 가진다. 이중 버퍼 렌더링(Double Buffer Rendering)스크린에 출력될 화면 데이터는 프레임 버퍼에 저장되는데, 하나의 버퍼만 가지는 경우 이미지가 반복해서 그려지게 되거나, 이미지가 다 그려지지 않아도 화면 주사율 때문에 렌더링을 해야할 때, 다 그려지지 않은 프레임 버퍼가 렌더링이 되어서 이미지가 깜빡이는 Flicker 현상이 나타날 수 있다. 이를 해결하기 위해 프레임 버퍼에 바로 렌더링 하지 않고, 다른 버퍼를 만들어서 그 버퍼에 렌더링을 완료 하고, 다음 프레임 버퍼에 옮기는 방식을 사용하여 Flicker 현상을 해결한다. SurfaceFlingerSurfaceFlinger는 버퍼를 받아들이고 버퍼를 구성하며 버퍼를 디스플레이로 보내는 역할을 한다. SurfaceFlinger는 BufferQueue 및 SurfaceControl을 통해 버퍼를 처리할 수 있다. 안드로이드 10부터는 ASurfaceControl라는 것을 통해 버퍼를 받아들인다. 자세한 내용은 Google Android Source Document의 SurfaceFlinger 및 WindowManager를 참고하자. SurfaceHolderSurfaceHolder 인터페이스는 앱이 Surface을 수정하고 제어할 수 있게 해준다. 일부 서비스에서는 제어가 필요한 케이스가 있는데, 대표적으로 SurfaceView, GLSurfaceView를 사용한 기능이다. 영상처리나 카메라 미리보기 화면을 렌더링할 때 특히 많이 사용한다. 일반 VIew와 달리 onDraw를 호출하는 것이 아닌, Thread를 이용하여 화면에 강제로 그려 처리한다. Canvas Rendering안드로이드에서 모든 그려지는 UI 요소는 대부분은 OpenGL ES 또는 Vulkan을 사용하여 View를 렌더링한다. 하지만, 예외 요소도 있기 마련이다. 예를들면 2D게임을 구현한다던지, 스트리밍 컨텐츠를 보여주는 플레이어라던지, 카메라 등에서는 캔버스 API를 통해 뷰를 그리는 작업이 이뤄진다. 이를 Canvas Rendering이라 한다. Canvas가 가지는 특징을 정리하면 아래와 같다. onDraw() 재정의 Canvas(그리는 내용) =&gt; Paint(그리기 방법) 직접 구현도 가능하고, Drawable를 상속한 BitmapDrawable를 이용하여 그릴 수 있다. 프로젝트에 저장된 이미지 리소스(비트맵 파일)를 확장한다. Drawable 속성을 정의하는 XML 리소스(우리가 아는 벡터 파일 변환도 여기 해당!) 도형 Drawable(라운딩 처리 된 사각형, 동그라미 등등등..) NinePatch 드로어블 최종적으로는 SKIA를 통해 캔버스 c++ native API를 호출하여 그린다. 예전에는 모든 렌더링은 소프트웨어 레벨에서 처리되었다. 지금은 하드웨어 레벨에서 처리되어 최적화되어 구현이 가능하지만, 이러한 방식으로 수동적으로 처리가 가능하다. 안드로이드의 경우 일반적으로 그리기를 프레임워크에 맡겨서 Rendering Process를 거치지만(우리가 알고 있는 onDraw() 함수를 통해 그리는 것을 말함), 위에서 언급한 Canvas Rendering의 경우 쓰레드를 이용해 화면에 강제로 그려 원하는 시점에 화면에 그릴 수 있다. 캔버스 구현은 Skia 그래픽 라이브러리에서 제공한다. 직사각형을 그리고 싶은 경우 적절히 버퍼에 바이트를 설정하는 캔버스 API를 호출한다. Canvas 인스턴스를 생성할 때는 이에 바탕이 되는 Bitmap 인스턴스를 생성하여 처리한다. Surface까지 도달하기 위해 어떤 흐름을 타는지 알아보자. 예를 들어, 우리가 View에서 직접 Rect를 생성하여 사각형을 그리고 싶다면, Skia 라이브러리를 호출하여 처리할 수 있다. Skia는 바이트들을 적절하게 버퍼의 형태로 구성한다. 그리고 버퍼가 두 클라이언트에 의해 한번에 업데이트 되는 것을 방지하기 위해, 버퍼에 액세스 하기 위해서는 락을 사용해야 한다. **lockCanvas()**는 버퍼에 락을 걸고 드로잉을 처리하기 위한 Canvas를 리턴한다. 그리고 **unlockCanvasAnsPost()**는 버퍼에 락을 해제하고, 그것을 compositor로 전달한다. 그 과정에서 일어나는 매커니즘은 매우 복잡하지만, 결론은 Surface로 전달 된다. 과거에는 View를 캔버스로 처리했지만, 현재는 범용 3D 엔진을 탑재한 기기들이 늘어나면서, 안드로이드에서 모든 그려지는 UI 요소는 대부분은 OpenGL ES 또는 Vulkan을 사용하여 View를 렌더링하도록 구성된다. 하지만 이전에 사용하던 API와의 호환성이 중요하기 때문에, 하드웨어 가속 Canvas API가 만들어지게 되었다. 지금까지는 그래픽 데이터를 처리하는 과정 및 요소에 대한 내용을 보았다면, 이번에는 해당 데이터를 화면에 직접 보여지는 과정에서 어떤 요소들이 필요하고 어떻게 동작하는지 보도록 하겠다. Surface Flinger and Harware Composer해당글은 Android Drawing Process 1(App surface, SF Layer)를 참고하여 작성하였다. 앞에서 언급했던 SyrfaceFlinger에서는 **HWComposer(Hardware Composer)**를 통해 그래픽 데이터를 디바이스 디스플레이에 전송한다. 이를 도식화 하면, 아래와 같이 표현 가능하다. Layer Management여기서 Layer Management는 우리가 앞서 언급한 각 어플리케이션이 갖는 Surface에서 SufraceFlinger에 의해 Layer 형태로 관리된다. 도식화 하면 아래와 같다. Screen Refreshing디바이스 디스플레이는 특정 주기로 리프레시되며, 일반적으로는 폰이나 테블릿에서는 초당 60프레임의 속도로 리프레시된다. 요즘 나오는 디바이스의 경우 90hz, 120hz 등 고주사율 디스플레이를 탑재하면서, 게임이 아닌 일반적인 애플리케이션은 높은 fps를 지원하게 되었다. 일반적인 디스플레이 주사율을 기준으로 했을 때, 60 FPS(1초에 60프레임)을 지원하며, 이를 바꿔부르면, 16ms안에 화면을 갱신하면 사용자에게 있어 자연스러운 화면전환을 제공할 수 있기 때문에, 16ms 안에 draw가 완료되어야 한다. 안드로이드 4.0 - ICS(아이스크림 샌드위치) 버전까지는 Screen Refershing과정에서 Framebuffer 출력이 SurfaceFligner의 Thread 동작 주기로 임으로 출력이 출력이 되어 프레임이 일정하지 않았다. 만약 16ms 이상 걸리게 된다면 어떻게 될까? View 렌더링 과정이 지체되어 사용자 경험에 좋지 않을 것이고, 애니메이션이 매끄럽게 보이지 않으며, 앱이 정상적으로 작동되지 않는 것처럼 보이게 될 것이다. 흔히 “렉 걸린다” 라는 표현을 주로 하는데, 이를 Frame Drop 이라고 부른다. Frame Drop 이 발생하는 원인은 오랜 시간동안 뷰의 계층구조를 새로 그리거나, 유저가 볼 수 없는 화면에 공을 들여 색칠하는 경우 CPU &amp; GPU 에 과부하를 일으키게 된다. 만약 디스플레이 컨텐츠가 UI 리프레시 도중에 업데이트가 된다면, 티어링(tearing) / 프레임 드롭(Frame Drop) 현상이 나타날 것이다. Project Butter 이러한 문제를 해결하기 위해 Android 4.1JB(젤리빈) 버전부터는 Project Butter를 발표하여 60hz디스플레이에 온전하게 60 FPS를 애플리케이션에서 지원하도록 하였다. 그래서 각 리프레시 주기 동안에 컨텐츠 업데이트를 마무리 하는 것이 중요하다. Proejct Butter에서는 매끄러운 화면 출력을 위해 VSync 기술과 Choreographer를 도입하였다. Vsync ProcessingVSync는 Vertical Synchronization(수직 동기화)의 약자이다. VSync는 화면의 출력되는 정보가 변경이 되었을 때 이를 동기화하고, 지속적으로 갱신해주는 기능이다. 쉽게 설명하면, GPU의 Rendering Rate, 즉 fps와 Device Presenting Rate, 즉 hz사이의 간극이 있을 때 이를 조정한다. 예를들면, GPU가 그리는 프레임은 100fps(초 당 100개의 프레임을 그림), Device Screen의 주사율은 60hz(초 당 60개의 화면을 그림)라면, GPU에서 그리는 것을 그대로 Device Screen에 뿌리게 되면 계속 지연(Delay)이 생길 수 있다. 이 때, VSync가 GPU 프레임과 Device 화면간의 시간차(Time Gap)를 계산하여 필요한 프레임만 만 그려주어 최적화를 해준다. VSync에 대한 Detail한 원리에 대해서 잘 소개된 영상은 Android Performance Patterns: Understanding VSYNC 영상을 참고하라. ChoreographerSurfaceFlinger에서 송신되는 Vsync Event를 요청/수신하여 아래 작업을 처리한다. Input Event Handling Self-Invalidation Animation ViewRootImplViewRootImpl은 DecorView와 Choreographer를 연결해주는 일종의 핸들러 역할을 하는 객체로써, DecorView와 Choreographer 사이에서 둘의 요청을 처리하고 중계한다. Rendering Flow최종적으로 Vsync Process에서는 아래 과정으로 처리된다. 실제 그리기는 현재 foreground에 표시되고 있는 어플리케이션에서 그릴 것이 생김으로써 시작한다. 특정 변화가 생겨 Invalidate를 호출하게 되면 ViewRootImpl에 scheduleTraversal() 함수를 호출한다. scheduleTraversal() 메서드 내부에서는 Choreographer 객체에게 다음 Vsync를 예약해달라는 요청을 보내게 된다. 이 작업이 위 그림에서 Invalidate와 Vsync scheduling에 해당한다. Choreographer에 VSync 스케쥴링을 요청하여 Frame Render를 Screen Rate에 맞춘다. Vsync 예약 요청을 받은 Choreographer는 SurfaceFlinger로 하여금 다음 Vsync 도착 시 알려달라고 요청한다. 다음 Vsync signal이 도착하여 Choreographer에서 받게된다. Choreographer는 ViewRootImpl의 performTraversal() 메서드를 호출한다. performTraversal 메서드 내부에서는 다시 그려야 될 부분을 measure()하고, 레이아웃을 재구성한다. 마지막으로 performDraw() 메서드를 호출하여 그리기를 수행한다. Software Rendering Model V.S. Hardare Rendering Model안드로이드의 렌더링 모델은 안드로이드3.0((API 레벨 11, 허니컴))버전을 기준으로 나뉜다. 이전까지는 소프트웨어 모델을 기반으로 렌더링이 되었다. Software Rendering ModelSoftware Rendering Model은 Android 3.0 전 버전까지 사용되던 방식이다. CPU 연산기반으로 동작하였으며, 아래 두단계로 그려진다. 계층 구조 무효화 계층 구조 그리기 Hardare Rendering Model (By using GPU)Android 3.0부터 Android 2D 렌더링 파이프라인 하드웨어에서는 가속화를 지원하므로, View의 캔버스에서 실행되는 모든 그리기 작업에서 GPU를 사용한다. 하드웨어 가속을 사용하려면 필요한 리소스가 늘어나므로 앱에서 더 많은 RAM을 사용한다. Android 시스템에서는 여전히 invalidate() 및 draw()를 사용하여 화면을 업데이트하고 보기를 렌더링하지만, 실제 그리기는 다르게 처리한다. Android 시스템에서는 즉시 그리기 명령을 실행하지 않고, 보기 계층 구조의 그리기 코드 출력을 포함하는 표시 목록에 기록한다. 또한 Android 시스템에서 invalidate() 호출을 통해 더티로 표시된 보기의 표시 목록을 기록하고 업데이트만 하면 되도록 최적화한다. 무효화되지 않은 보기는 단순히 이전에 기록된 표시 목록을 다시 실행하여 다시 그릴 수 있습니다. 새 그리기 모델에는 다음 세 단계가 포함된다. 계층 구조 무효화 표시 목록 기록 및 업데이트 표시 목록 그리기 Internal UI Rendering Optimization우리가 사용하는 상위 수준의 객체들(Button, TextView, etc.)은 아래의 과정을 거쳐 화면의 픽셀로 나타낼 수 있다. CPU Level에서 상위 수준의 객체들을 가져오고, 이 객체를 그리기 위한 집합인 displaylist 로 바꾸어준다. GPU는 높은 수준의 객체들을 가져와 텍스처 또는 화면에서 픽셀로 바꾸어주는 Rasterization기능을 수행한다. CPU에서 만들어진 명령어들은 OpenGL-ES api를 이용해 GPU에 업로드 되며, 픽셀화에 이용된다. 한번 업로드되면 displaylist 객체는 캐싱되는데, 이는 우리가 다시 displaylist를 통해 그리고 싶다면 다시 새로 생성할 필요없이 기존에 존재하는 것을 다시 그리기 때문에 비용이 훨씬 더 저렴하다. UI 렌더링이 진행될 때, CPU에서 displaylist 를 생성하고 GPU에 업로드 하는 과정은 매우 고비용(High Cost)적이기 때문에, 효율적인 개선안을 찾아야한다. Extra InfoDisplaylist란 ? 안드로이드 3.0 이전에는 View의 변경사항이 일어나면, ViewRoot까지 전파하도록 설계되었다. View에서 ViewGroup, ViewRoot를 거쳐 다시 View 까지 내려와야하는 과정이 많은 코드를 접근하기 때문에 비효율적이었다. 이러한 대안에 Displaylist가 나오게 되었는데, 이는 UI 요소를 그리기 위한 정보를 리스트로 모아둔 것이다. UI요소의 변경이 일어났을 때, 다시 View Tree 를 탈 필요가 없이 리스트를 확인하고 사용하면 된다는 이점이 있다. 이번시간에는 Window, Surface, Canvas에 대해 소개하고, 소프트웨어 레벨에서 어떻게 하드웨어 레벨까지 동기화 되는지 정리해보았다. 또한 View가 렌더링 될 때 두가지 방식으로 어떻게 동작하는지 개념 설명 및 원리 설명을 했다. 다음 포스트에서는 하드웨어 가속을 사용하는 GPU 렌더링 체계의 경우 어떤 문제가 있고, 어떻게 프로파일링 하고, 어떻게 모니터링하는지 알아보도록 하겠다. 그리고 어떻게 최적화 할 수 있을지 방법을 소개하도록 하겠다.","link":"/Team-Blog/2021/05/19/2021-05-19%20Android%20UI%20Rendering%20Optimization%20Part%202/"},{"title":"Introduce Android UI Rendering Principle and View Optimization Part 3","text":"Writers by 김남훈 @Naver by 배희성 @RocketPunch by 송시영 @SmartStudy by 이기정 @BankSalad by 정세희 @BankSalad by 최소영 @BankSalad 저번 포스트에서는 UI Rendering 시 화면에 보여질 때 어떤 과정을 거치는지 알 수 있었고, 현재 보편적으로 사용되는 하드웨어 모델 기반 렌더링 방식에서 발생하는 문제는 무엇이고, 해당 문제를 해결하기 위해 어떤 방법이 있는지, 실제로 어느정도의 성과를 낼 수 있는지 정리해보았다. 버벅거림(Jank)앱이 느린 렌더링으로 어려움을 겪는 경우, 시스템은 프레임을 건너 뛰게되고 사용자는 앱에서 끊김을 감지하게 된다. 버벅거림에는 여러문제가 있지만, 대표적으로 UI렌더링 시에는 OverDraw, Slow Rendering과 같은 문제가 존재한다. Slow Rendering 방지하기해당 내용은 Google Android Source Document의 느린 렌더링글 을 참고하였다. 렌더링 시 버벅거림을 감지할 수 있는 방법은 세가지이다. Visual inspection Systrace Custom performance monitoring 시각적 검사(Visual Inspection)우리는 안드로이드에서 제공하는 몇가지 옵션을 통해 시각화 하여 문제를 해결할 수 있다. 해결책은 아래와 같다. Profile GPU Rendering 을 활성화60fps(GPU 연산으로 초 당 60프레임으로 화면을 뿌리는 것)일 때 렌더링에 얼마나 성능을 잡아먹는지 확인하기 위해 개발자 옵션을 통해 다음 도구를 사용설정 할 수 있다. 프로파일링은 Android 4.1(API 16 ) 이상에서 사용 가능하며 미리 해당 기능을 활성화하는 작업이 필요하다. 다음과 같은 순서로 진행하면 활성화 할 수 있다. 여는방법 기기에서 설정으로 이동하여 개발자 옵션을 탭한다. 모니터링 섹션에서 프로필 GPU 렌더링을 선택한다. ‘프로필 GPU 렌더링’ 대화상자에서 화면에 막대로 표시를 선택하여 기기의 화면에 그래프를 오버레이한다. 프로파일링하려는 앱을 연다. 설정을 활성화 하고 확인해보면, 아래와 같이 히스토그램으로 표시되는 것을 볼 수 있다. 표시되는 각 애플리케이션에 관해 그래프가 표시된다. 가로축의 각 세로 막대는 프레임을 나타내며 각 세로 막대의 높이는 프레임을 렌더링하는 데 걸린 시간(밀리초)을 나타낸다. 녹색 가로선은 16밀리초를 나타냅니다. 60fps를 달성하려면 각 프레임의 세로 막대가 이 선 아래에 머물러야 합니다. 막대가 이 선을 넘어서면 애니메이션이 일시중지될 수 있다. 16밀리초 임계값을 초과하는 프레임은 막대를 더 넓고 덜 투명하게 만들어 강조표시한다. 각 막대에는 렌더링 파이프라인의 단계로 매핑되는 색상으로 표시된 구성요소가 있습니다. 구성요소의 수는 기기의 API 수준에 따라 다르다. 각 막대에는 렌더링 파이프 라인의 단계에 매핑되는 색상 구성 요소가 있으므로 어느 부분이 가장 오래 걸리는지 확인할 수 있다. 예를 들어 프레임이 입력을 처리하는 데 많은 시간을 소비하는 경우 사용자 입력을 처리하는 앱 코드를 살펴 봐야한다. 막대 색상 별 의미 세로 막대 차트는 위와 같이 8개의 단계로 표시된다. 프로세스/스왑버퍼(Swap): 안드로이드는 디스플레이 목록을 GPU 에 제출하는것을 끝내면, 시스템은 그래픽 드라이버에 현재 프레임이 완료되었음을 알리며 드라이버를 업데이트된 이미지를 화면에 표시한다. CPU 와 GPU 는 병렬로 처리되는데 CPU 가 GPU 처리보다 빠른 경우, 프로세스간 통신 큐가 가득찰 수 있다. CPU 는 큐에 공간이 생길때까지 기다린다. 큐가 가득한 상태는 스왑버퍼 상태에서 자주 발생하는데 이 단계에서 프레임 전체의 명령어가 제출되기 때문이다. 명령어 실행 단계와 비슷하게 GPU 에서 일어나는 일의 복잡성을 줄여 문제를 해결할 수 있다. 명령어 실행(Issue): 디스플레이 목록을 화면에 그리기 위한 모든 명령어를 실행하기 위해 걸리는 시간을 측정한다. 주어진 프레임에서 렌더링하는 디스플레이 목록과 수량을 직접적으로 측정한다. 내재적으로 많은 그리기 동작이 있는 경우, 오랜 시간이 걸릴수 있다. 동기화/업로드(Upload): 현재 프레임에서 비트맵 객체가 CPU 메모리에서 GPU 메모리로 전송되는데 걸리는 시간을 측정한다. 오랜 시간이 걸리는 경우는 작은 리소스가 많이 로드되어 있거나 적지만 큰 리소스가 로드되어 있는 경우이다. 비트맵 해상도가 실제 디스플레이 해상도보다 큰 사이즈로 로드되어 있지 않도록 하거나 동기화 전에 비동기로 미리 업로드해서 실행 시간을 줄일 수 있다. 그리기(Draw): 백그라운드 혹은 텍스트 그리기와 같은 뷰를 그리기 명령어로 번역하는 단계로 시스템은 명령어를 디스플레이 목록에 캡처한다. 무효화된 뷰에서 onDraw 호출을 실행해 걸리는 모든 시간을 측정하며, 오랜 시간이 걸린다는 것은 무효화된 뷰가 많다는 것을 의미한다. 뷰가 무효화되는 경우 뷰의 디스프레이 목록을 재생성한다. 혹은 커스텀한 뷰가 onDraw 할때 복잡한 로직을 가질 때도 실행시간이 오랜 걸린다. 측정 및 배치(Measure): 안드로이드에서 뷰를 스크린에 그리기 위해 측정하고 배치하는데 걸리는 시간을 측정한다. 일반적으로 오랜 시간이 걸리는 경우는 배치할 뷰가 너무 많거나 혹은 계층구조의 잘못된 장소에서 중복 계산이 이뤄지며, Traceview와 Systrace 를 사용해서 호출 스택을 확인하여 문제를 파악할 수 있다. 애니메이션(Anim): 현재 프레임에서 실행되는 애니메이션에 대해 걸리는 시간을 측정한다. 일반적으로 오랜 시간이 걸리는 경우는 애니메이션의 속성 변경으로 인해 발생한다. 입력 처리(Input): 앱이 입력 이벤트를 처리하는 시간으로 입력 이벤트 콜백의 결과로 호출된 코드를 실행하는데 걸리는 시간을 나타낸다. 일반적으로 오랜 시간이 걸리는 경우는 메인쓰레드에서 발생하며, 작업을 최적화하거나 다른 쓰레드를 이용해서 작업을 실행하도록 한다. 기타(Misc): 렌더링 시스템이 작업을 수행하는 시간외에 렌더링과 관련 없는 추가적인 작업이 있다. 일반적으로 렌더링의 연속된 두 프레임 사이에서 UI 스레드에서 발생할 수 있는 일을 나타낸다. 오랜 시간이 걸리는 경우, 다른스레드에서 실행해야할 콜백, 인텐트 또는 기타 다른 작업이 있을 수 있다. Method tracing 또는 Systrace 를 사용하면 메인스레드에서 실행중인 작업을 확인해 문제를 해결할 수 있다. 아래에는 이미지 뷰에 클릭 이벤트를 설정하고 이미지 리소스를 변경하는 로직이다. 좌측에는 단순하게 이미지 리소스를 변경하는 로직만 추가하였고, 우측에는 리소스를 변경하는 과정에서 스레드를 일시 중단하는 코드를 추가하였다. 그 결과 입력처리 시간에 차이가 발생한다는 것을 확인할 수 있다. 아래에는 이미지 뷰에 각각 다른 크기의 이미지 리소스를 배치하였다. 좌측에는 8.1MB 크기의 이미지 리소스를 배치하고 우측에는 16KB 크기의 이미지 리소스를 배치하였다. 그 결과 이미지를 업로드 시간에 차이가 발생한 다는 것을 확인할 수 있다. Etc예외적인 케이스에 대한 해법으로는 아래 세가지가 있다. Release 버전의 앱을 실행하자. ART(Android Runtime)는 디버깅 기능을 지원하기 위해 몇 가지 중요한 최적화를 비활성화하기 때문이다. 때때로 버벅거림은 앱이 cold start 에서 시작될 때만 재현 될 수 있다. 버벅거림을 극대화 시키기 위해 더 느린 장치에서 앱을 실행해 봐라. Systrace기기가 수행하는 전체 작업을 보여주는 도구이지만 앱에서 버벅거림을 식별하는 데 유용할 수 있다. Systrace는 최소한의 시스템 오버헤드를 가지므로 계측 중에 현실적인 버벅거림을 경험할 수 있다. 버벅거림을 유발할 수 있는 요소들버벅거림을 유발하는 요소는 대표적으로 Scrollable lists, Layout performance, Rendering performance가 있다. Scrollable listsListView 및 특히 RecyclerView는 버벅거림에 가장 취약한 복잡한 스크롤 목록에 일반적으로 사용된다. 둘 다 Systrace 마커가 포함되어 있으므로 Systrace를 사용하여 앱에서 버벅거림을 유발하는지 여부를 파악할 수 있다. RecyclerView의 systrace 섹션을 표시하려면 명령에 -a &lt;your-package-name&gt;을 전달해야한다. 사용 가능한 경우 systrace 출력에 생성 된 경고의 지침을 따르자. Systrace 내에서 RecyclerView systrace 섹션을 클릭하여 RecyclerView가 수행하는 작업에 대한 설명을 볼 수 있다. 작은 업데이트를 위해 notifyDataSetChanged(), setAdapter(Adapter), or swapAdapter(Adapter, boolean)를 호출하지 마라. 전체 목록 아이템이 변경되었다고 알리기 때문이다. 대신 SortedList 또는 DiffUtil을 사용하여 콘텐츠가 변경되거나 추가 될 때 최소한의 업데이트를 하도록하자. Nested recyclerview 내부 RecyclerView의 LinearLayoutManager에 setInitialPrefetchItemCount(int) 를 설정할 수도 있다. 예를 들어 항상 3.5 개의 항목이 한 행에 표시되는 경우, innerLinearLayoutManager.setInitialItemPrefetchCount(4); 를 호출한다. RecyclerView 의 view type 이 적을수록 새 item type 이 화면에 표시 될 때 수행해야하는 inflation 이 줄어 든다. 만약 아이콘, 색상, 작은 문구 변경 차이라면, 별도의 view type 으로 나누지 않고 bind 할 때 변경하는 것이 낫다. (동시에 앱의 메모리 사용량 감소) Bind (즉, onBindViewHolder (VH, int) 는 매우 간단해야하며 가장 복잡한 항목을 제외한 모든 항목에 대해 1 밀리 초 미만이 소요되야 한다. 단순히 adapter 의 내부 item 에서 POJO item 을 가져와서, ViewHolder의 view 에서 setter 를 호출해야 한다. Layout performanceSystrace에서 Choreographer # doFrame의 레이아웃 세그먼트가 너무 많은 작업을 수행하거나 너무 자주 작업을 수행하는 것으로 표시되면 레이아웃 성능 문제가 있음을 의미한다. 세그먼트가 몇 밀리 초보다 길면 RelativeLayouts 또는 weighted-LinearLayouts에 대해 최악의 경우 중첩 성능에 도달 할 수 있다. 이러한 각 레이아웃은 자식의 여러 측정 / 레이아웃 패스를 트리거 할 수 있으므로 중첩하면 중첩 깊이에서 O (n ^ 2) 동작이 발생할 수 있다. 계층 구조의 최하위 리프 노드를 제외한 모든 노드에서 RelativeLayout 또는 LinearLayout의 가중치 기능을 피해라. Rendering performanceAndroid UI는 UI 스레드의 Record View # draw와 RenderThread의 DrawFrame의 두 단계로 작동한다. 첫 번째는 모든 invalidated View 에서 draw (Canvas)를 실행한다. 두 번째는 기본 RenderThread에서 실행되지만 View#draw() 단계에서 생성 된 작업을 기반으로 작동한다. View#draw() 가 너무 오래 걸린다면, 이 경우는 보통 UI 스레드에서 bitmap 이 그려지는 경우다. Bitmap 에 그리기는 CPU 렌더링을 사용하므로 일반적으로 가능하면 이를 피해야 한다. Custom Performance Monitoring(맞춤 성능 모니터링 사용)로컬 기기에서 버벅거림을 재현할 수 없는 경우 앱에 맞춤 성능 모니터링을 빌드하여 현장에서 기기의 버벅거림 원인을 식별할 수 있다. 이를 위해 FrameMetricsAggregator를 사용하여 앱의 특정 부분에서 프레임 렌더링 시간을 수집하고 Firebase Performance Monitoring을 사용하여 데이터를 기록하고 분석할 수 있다. 자세한 내용은 아래내용을 참조하자. Android Vitals Firebase Performance Monitoring 사용 Overdraw An app may draw the same pixel more than once within a single frame, an event called overdraw. Overdraw is usually unnecessary, and best eliminated. It manifests itself as a performance problem by wasting GPU time to render pixels that don’t contribute to what the user sees on the screen. 오버드로는 시스템이 단일 렌더링 프레임에서 화면에 여러 번 픽셀을 그리는 것을 말한다. 참고 : Overdraw는 더 이상 Google I/O 성능 세션 및 성능 패턴 동영상에서 논의되었을 때 만큼 심각한 문제가 아니다. 이는 저가형 장치가 GPU 성능에서 지속적으로 성장하는 반면 디스플레이는 상대적으로 낮은 해상도에서 정체 되었기 때문. 알려진 저 성능 GPU 장치를 최적화하지 않는 한, 원활한 앱 성능을 보장하는 것 대신 UI 스레드 작업을 최적화하는 데 집중하는 것이 좋다. 참고영상을 확인하자. 다른 개발자 옵션으로 UI 에 컬러를 지정함으로써 오버드로를 식별할 수 있다. 같은 프레임내에서 같은 픽셀을 한번 이상 그릴 때 오버드로가 발생한다. 앱에서 필요 이상으로 많은 렌더링이 발생하는 곳을 시각화로 보여주며, 사용자에게 보여지지 않는 픽셀을 렌더링하기 위해 추가 GPU 작업으로 성능 문제가 발생한 수 있음을 알 수 있다. 다음과 같이 설정하면 오버드로 시각화를 확인 할 수 있다. Overdraw 디버깅여는방법 기기에서 설정으로 이동하여 개발자 옵션을 탭한다. 하드웨어 가속 렌더링 섹션으로 스크롤하여 GPU 오버드로 디버그를 선택한다. GPU 오버드로 디버그 대화상자에서 오버드로 영역 표시를 선택한다. 분석 True color: No overdraw Blue: Overdrawn 1 time Green: Overdrawn 2 times Pink: Overdrawn 3 times Red: Overdrawn 4 or more times 디버깅 결과는 아래와 같이 비교 가능하다. 뷰의 배치에 따라 각각 오버드로가 발생한 픽셀을 확인할 수 있다. Overdraw 줄이기Overdraw를 줄일 수 있는 방법은 대표적으로 세가지가 있다. layouts 에서 불필요한 backgrounds 는 제거하자 View 계층을 평면화하자 투명도를 줄이자 알파 렌더링으로 알려진 화면에서 투명 픽셀을 렌더링하는 것은 오버드로의 주요 원인이다. 시스템이 그 위에 불투명 한 픽셀을 그려서 기존의 그려진 픽셀을 완전히 숨기는 표준 오버드로와 달리, 투명한 객체는 올바른 blending equation 이 발생하도록 기존 픽셀을 먼저 그려야한다. 참고 blending equation : 2개의 픽셀 컬러 값을 결합시키는 것. 관련 블로그 UI 렌더링 성능 개선지금까지는 원인 및 분석 방법에 대해서 살펴보았다. 이번에는 본격적으로 코드레벨에서 분석 및 개선방안을 통해 어떻게 개선할 수 있는지 보자. 레이아웃 재사용 include, merge를 통해 뷰를 재사용한다. include로만 뷰를 재사용하면 다음과 같이 뷰가 중첩될 수 있다. merge를 같이 사용하여 중첩을 줄여준다 오버드로잉 방지(뷰 백그라운드)일반적으로 우리는 앱의 배경 색상을 적용하기 위해 android:background=&quot;@color/white&quot; 해당 뷰의 배경색상을 적용한다. 1234567891011121314151617181920&lt;!-- /res/layout/activity_main.xml --&gt;&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;.MainActivity&quot; android:background=&quot;@color/white&quot;&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;Hello World!&quot; app:layout_constraintBottom_toBottomOf=&quot;parent&quot; app:layout_constraintLeft_toLeftOf=&quot;parent&quot; app:layout_constraintRight_toRightOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; 이러한 방법은 View에 그려짐에 있어 중복으로 그릴 수 있는 여지가 있다. 왜 Overdraw가 생기는지 확인을 위해 앱 테마 값을 확인해보았다. 1234567891011121314151617&lt;!-- /res/values/themes.xml --&gt;&lt;resources xmlns:tools=&quot;http://schemas.android.com/tools&quot;&gt; &lt;!-- Base application theme. --&gt; &lt;style name=&quot;Theme.UITest&quot; parent=&quot;Theme.MaterialComponents.DayNight.DarkActionBar&quot;&gt; &lt;!-- Primary brand color. --&gt; &lt;item name=&quot;colorPrimary&quot;&gt;@color/purple_500&lt;/item&gt; &lt;item name=&quot;colorPrimaryVariant&quot;&gt;@color/purple_700&lt;/item&gt; &lt;item name=&quot;colorOnPrimary&quot;&gt;@color/white&lt;/item&gt; &lt;!-- Secondary brand color. --&gt; &lt;item name=&quot;colorSecondary&quot;&gt;@color/teal_200&lt;/item&gt; &lt;item name=&quot;colorSecondaryVariant&quot;&gt;@color/teal_700&lt;/item&gt; &lt;item name=&quot;colorOnSecondary&quot;&gt;@color/black&lt;/item&gt; &lt;!-- Status bar color. --&gt; &lt;item name=&quot;android:statusBarColor&quot; tools:targetApi=&quot;l&quot;&gt;?attr/colorPrimaryVariant&lt;/item&gt; &lt;!-- Customize your theme here. --&gt; &lt;/style&gt;&lt;/resources&gt; 특별히 지정해준 사항이 없어 해당 테마의 Parent를 따라가 보았다. 12345Base.V14.Theme.MaterialComponents.Lightㄴ Base.Theme.MaterialComponents.Light ㄴ Base.Theme.MaterialComponents.Light.DarkActionBar ㄴ Theme.MaterialComponents.Light.DarkActionBar ㄴ Theme.MaterialComponents.DayNight.DarkActionBar 해당 소스에서 아래와 같이 배경 색상을 지정하는 걸 확인하였고 1&lt;item name=&quot;android:colorBackground&quot;&gt;@color/design_default_color_background&lt;/item&gt; 해당 값을 확인해보니 아래와 같이 흰색으로 설정하고 있었다. 1&lt;color name=&quot;design_default_color_background&quot;&gt;#FFFFFF&lt;/color&gt; 한마디로 배경 색상을 흰색으로 칠해주고 그 위에 다시 흰색으로 칠해주고 있었다. 해당 Overdraw를 없애고 내가 원하는 색상으로 설정하기 위해 테마 파일을 아래와 같이 &lt;item name=&quot;android:windowBackground&quot;&gt;@color/beige&lt;/item&gt; 를 통해 오버드로잉 문제를 해결할 수 있다. 123456789101112131415161718&lt;!-- /res/values/themes.xml --&gt;&lt;resources xmlns:tools=&quot;http://schemas.android.com/tools&quot;&gt; &lt;!-- Base application theme. --&gt; &lt;style name=&quot;Theme.UITest&quot; parent=&quot;Theme.MaterialComponents.DayNight.NoActionBar&quot;&gt; &lt;!-- Primary brand color. --&gt; &lt;item name=&quot;colorPrimary&quot;&gt;@color/purple_500&lt;/item&gt; &lt;item name=&quot;colorPrimaryVariant&quot;&gt;@color/purple_700&lt;/item&gt; &lt;item name=&quot;colorOnPrimary&quot;&gt;@color/white&lt;/item&gt; &lt;!-- Secondary brand color. --&gt; &lt;item name=&quot;colorSecondary&quot;&gt;@color/teal_200&lt;/item&gt; &lt;item name=&quot;colorSecondaryVariant&quot;&gt;@color/teal_700&lt;/item&gt; &lt;item name=&quot;colorOnSecondary&quot;&gt;@color/black&lt;/item&gt; &lt;!-- Status bar color. --&gt; &lt;item name=&quot;android:statusBarColor&quot; tools:targetApi=&quot;l&quot;&gt;?attr/colorPrimaryVariant&lt;/item&gt; &lt;!-- Customize your theme here. --&gt; &lt;item name=&quot;android:windowBackground&quot;&gt;@color/beige&lt;/item&gt; &lt;/style&gt;&lt;/resources&gt; /res/layout/activity_main.xml 파일에 android:background=&quot;@color/beige&quot; 코드를 입력 후 Overdraw를 확인한 결과는 다음과 같다. 결론적으로 배경 색상 지정을 테마를 통해 지정하면 Overdraw를 줄일 수 있다. Lazy Load by ViewStub해당 내용은 찰스의 안드로이드 - ViewStub 활용으로 성능 높이기글 을 참고하였다. ViewStub은 사이즈가 없는 보이지 않는 뷰로 런타임에서 늦은 전개(lazy-inflate)를 원할 때 사용할 수 있다. ViewStub을 보이게 만들거나 inflate() 메서드를 호출하면 레이아웃이 전개되면서 ViewStub을 대체하기 때문에 ViewStub은 사라진다. 전개된 뷰는 ViewStub의 부모 뷰에 추가 된다. 레이아웃에서 ViewStub을 사용하는 예제를 확인하자. 12345&lt;ViewStub android:id=&quot;@+id/stub&quot; android:inflatedId=&quot;@+id/subTree&quot; android:layout=&quot;@layout/mySubTree&quot; android:layout_width=&quot;120dp&quot; android:layout_height=&quot;40dp&quot; /&gt; findViewById() 호출을 통해 ViewStub에 접근할 수 있다. 1val viewStub = findViewById(R.id.stub) 생성되는 바인딩 클래스에서 ViewStub은 ViewStubProxy로 표현되며, ViewStub에 대해 접근할 수 있게 해준다. 123val binding: ActivityMainBinding = ...val viewStubProxy = binding.stubval viewStub = viewStubProxy.viewStub() ViewStub에 지정된 레이아웃을 전개 시키기 위해서 서는 setVisibility() 또는 inflate()를 호출 할 수 있다. 123val viewStub: ViewStub = ...viewStub.inflate()//또는 viewStub.visibility = View.VISIBLE ViewStub은 복잡하게 구성된 레이아웃을 빠르게 전개시켜야하는 상황에서, 레이아웃의 전개 시기를 선택적으로 늦출 수 있다. 예를 들어 리스트 형태의 UI를 구성하고 하나의 뷰홀더가 전개 되는데 상당한 비용이 발생한다고 가정하자. 이 때 사용자가 빠르게 화면을 스크롤 할 경우 프레임 드랍이 발생 할 수 있다. 이럴 때 선택적으로 불필요한 레이아웃의 전개를 제어하고 전개 시기를 늦춤으로써 성능을 개선시킬 수 있다. 우리는 1, 2, 3편에서 안드로이드의 기본적인 UI구성요소, 내부적인 렌더링 매커니즘, 렌더링 되면서 성능상 이슈가 있는 부분을 알아보았고 마지막으로 성능에 대한 개선방안에 대해 알 수 있었다. 안드로이드를 공부하는 여러분들께 조금이나마 도움이 되길 바란다. ReferenceMembers of Studyhttps://soda1127.github.io/introduce-jetpack-compose/ https://velog.io/@jshme/How-To-Render-UI-In-Android https://velog.io/@jshme/How-To-Render-UI-In-Android-22 OfficialDocsAndroid vitals Android 드로잉 보기 방법 느린렌터링 Firebase Performance Monitoring 사용 GPU 렌더링 속도 및 오버드로 검사 맞춤 그리기 뷰 최적화 VideosAndroid Performance Patterns: Understanding VSYNC Android Performance Patterns: Rendering Performance 101 Android Performance Patterns: Tool - Profile GPU Rendering Android Performance Patterns: Understanding Overdraw Android Performance Patterns: Invalidations, Layouts, and Performance Android Performance Patterns: Hidden Cost of Transparency Etc찰스의 안드로이드 - ViewStub 활용으로 성능 높이기 Android Drawing Process 1(App surface, SF Layer)","link":"/Team-Blog/2021/05/19/2021-05-19%20Android%20UI%20Rendering%20Optimization%20Part%203/"}],"tags":[{"name":"Android","slug":"Android","link":"/Team-Blog/tags/Android/"},{"name":"Jetpack","slug":"Jetpack","link":"/Team-Blog/tags/Jetpack/"},{"name":"Compose","slug":"Compose","link":"/Team-Blog/tags/Compose/"},{"name":"Rendering","slug":"Rendering","link":"/Team-Blog/tags/Rendering/"},{"name":"Principle","slug":"Principle","link":"/Team-Blog/tags/Principle/"},{"name":"Optimize","slug":"Optimize","link":"/Team-Blog/tags/Optimize/"},{"name":"UI","slug":"UI","link":"/Team-Blog/tags/UI/"}],"categories":[{"name":"Jetpack Compose","slug":"Jetpack-Compose","link":"/Team-Blog/categories/Jetpack-Compose/"},{"name":"User Interface","slug":"User-Interface","link":"/Team-Blog/categories/User-Interface/"}]}