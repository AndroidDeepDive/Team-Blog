<!doctype html>
<html lang="ko"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="theme-color" content="#71D88D"><title>Introduce Android UI Rendering Principle and View Optimization Part 3 - Android Deep Dive</title><link rel="manifest" href="/Team-Blog/manifest.json"><meta name="application-name" content="Android Deep Dive"><meta name="msapplication-TileImage" content="/img/favicon.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Android Deep Dive"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="Writers         by 김남훈 @Naver         by 배희성 @RocketPunch         by 송시영 @SmartStudy         by 이기정 @BankSalad         by 정세희 @BankSalad         by 최소영 @BankSalad"><meta property="og:type" content="blog"><meta property="og:title" content="Introduce Android UI Rendering Principle and View Optimization Part 3"><meta property="og:url" content="https://androiddeepdive.github.io/2021/05/19/2021-05-19%20Android%20UI%20Rendering%20Optimization%20Part%203/"><meta property="og:site_name" content="Android Deep Dive"><meta property="og:description" content="Writers         by 김남훈 @Naver         by 배희성 @RocketPunch         by 송시영 @SmartStudy         by 이기정 @BankSalad         by 정세희 @BankSalad         by 최소영 @BankSalad"><meta property="og:locale" content="ko_KR"><meta property="og:image" content="https://androiddeepdive.github.io/Team-Blog/img/og_image.png"><meta property="article:published_time" content="2021-05-18T18:00:00.000Z"><meta property="article:modified_time" content="2021-07-25T13:28:28.008Z"><meta property="article:author" content="Android Deep Dive"><meta property="article:tag" content="Android"><meta property="article:tag" content="Rendering"><meta property="article:tag" content="Principle"><meta property="article:tag" content="Optimize"><meta property="article:tag" content="UI"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="https://androiddeepdive.github.io/Team-Blog/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://androiddeepdive.github.io/2021/05/19/2021-05-19%20Android%20UI%20Rendering%20Optimization%20Part%203/"},"headline":"Introduce Android UI Rendering Principle and View Optimization Part 3","image":["https://androiddeepdive.github.io/Team-Blog/images/cover_ui_rendering.png"],"datePublished":"2021-05-18T18:00:00.000Z","dateModified":"2021-07-25T13:28:28.008Z","author":{"@type":"Person","name":"Android Deep Dive"},"publisher":{"@type":"Organization","name":"Android Deep Dive","logo":{"@type":"ImageObject","url":"https://androiddeepdive.github.io/img/logo.png"}},"description":"Writers         by 김남훈 @Naver         by 배희성 @RocketPunch         by 송시영 @SmartStudy         by 이기정 @BankSalad         by 정세희 @BankSalad         by 최소영 @BankSalad"}</script><link rel="canonical" href="https://androiddeepdive.github.io/2021/05/19/2021-05-19%20Android%20UI%20Rendering%20Optimization%20Part%203/"><link rel="icon" href="/Team-Blog/img/favicon.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/Team-Blog/css/default.css"><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.4.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/Team-Blog/"><img src="/Team-Blog/img/logo.png" alt="Android Deep Dive" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/Team-Blog/">홈</a><a class="navbar-item" href="/Team-Blog/archives">아카이브</a><a class="navbar-item" href="/Team-Blog/categories">카테고리</a><a class="navbar-item" href="/Team-Blog/tags">태그</a><a class="navbar-item" href="/Team-Blog/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Repository of Study" href="https://github.com/AndroidDeepDive"><i class="fab fa-github"></i></a><a class="navbar-item search" title="검색" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main"><div class="card"><div class="card-image"><span class="image is-7by3"><img class="fill" src="https://androiddeepdive.github.io/Team-Blog/images/cover_ui_rendering.png" alt="Introduce Android UI Rendering Principle and View Optimization Part 3"></span></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-05-18T18:00:00.000Z" title="2021. 5. 19. 오전 3:00:00">2021-05-19</time>&nbsp;게시 됨</span><span class="level-item"><time dateTime="2021-07-25T13:28:28.008Z" title="2021. 7. 25. 오후 10:28:28">2021-07-25</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/Team-Blog/categories/User-Interface/">User Interface</a></span></div></div><h1 class="title is-3 is-size-4-mobile">Introduce Android UI Rendering Principle and View Optimization Part 3</h1><div class="content"><article class="message message-immersive is-primary">
    <div class="message-body">
        <i class="fas fa-pen-fancy mr-2"></i>Writers<br>
        by 김남훈 @Naver<br>
        by 배희성 @RocketPunch<br>
        by 송시영 @SmartStudy<br>
        by 이기정 @BankSalad<br>
        by 정세희 @BankSalad<br>
        by 최소영 @BankSalad
    </div>
</article>


<span id="more"></span>

<p>저번 포스트에서는 UI Rendering 시 화면에 보여질 때 어떤 과정을 거치는지 알 수 있었고, 현재 보편적으로 사용되는 하드웨어 모델 기반 렌더링 방식에서 발생하는 문제는 무엇이고, 해당 문제를 해결하기 위해 어떤 방법이 있는지, 실제로 어느정도의 성과를 낼 수 있는지 정리해보았다.</p>
<h2 id="버벅거림-Jank"><a href="#버벅거림-Jank" class="headerlink" title="버벅거림(Jank)"></a>버벅거림(Jank)</h2><p>앱이 느린 렌더링으로 어려움을 겪는 경우, 시스템은 프레임을 건너 뛰게되고 사용자는 앱에서 끊김을 감지하게 된다.</p>
<img src="/Team-Blog/2021/05/19/2021-05-19%20Android%20UI%20Rendering%20Optimization%20Part%203/image.png" class="" title="[Frame Drop]">

<p>버벅거림에는 여러문제가 있지만, 대표적으로 UI렌더링 시에는 <strong>OverDraw, Slow Rendering</strong>과 같은 문제가 존재한다.</p>
<h2 id="Slow-Rendering-방지하기"><a href="#Slow-Rendering-방지하기" class="headerlink" title="Slow Rendering 방지하기"></a>Slow Rendering 방지하기</h2><p>해당 내용은 Google Android Source Document의 <a target="_blank" rel="noopener" href="https://developer.android.com/topic/performance/vitals/render#custom-monitoring">느린 렌더링</a>글 을 참고하였다.</p>
<p>렌더링 시 버벅거림을 감지할 수 있는 방법은 세가지이다.</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://developer.android.com/topic/performance/vitals/render#visual-inspection">Visual inspection</a></li>
<li><a target="_blank" rel="noopener" href="https://developer.android.com/topic/performance/vitals/render#systrace">Systrace</a></li>
<li><a target="_blank" rel="noopener" href="https://developer.android.com/topic/performance/vitals/render#custom-monitoring">Custom performance monitoring</a></li>
</ul>
<h3 id="시각적-검사-Visual-Inspection"><a href="#시각적-검사-Visual-Inspection" class="headerlink" title="시각적 검사(Visual Inspection)"></a>시각적 검사(Visual Inspection)</h3><p>우리는 안드로이드에서 제공하는 몇가지 옵션을 통해 시각화 하여 문제를 해결할 수 있다. 해결책은 아래와 같다.</p>
<h4 id="Profile-GPU-Rendering-을-활성화"><a href="#Profile-GPU-Rendering-을-활성화" class="headerlink" title="Profile GPU Rendering 을 활성화"></a><code>Profile GPU Rendering</code> 을 활성화</h4><p>60fps(GPU 연산으로 초 당 60프레임으로 화면을 뿌리는 것)일 때 렌더링에 얼마나 성능을 잡아먹는지 확인하기 위해 개발자 옵션을 통해 다음 도구를 사용설정 할 수 있다.</p>
<p>프로파일링은 Android 4.1(API 16 ) 이상에서 사용 가능하며 미리 해당 기능을 활성화하는 작업이 필요하다. 다음과 같은 순서로 진행하면 활성화 할 수 있다.</p>
<h5 id="여는방법"><a href="#여는방법" class="headerlink" title="여는방법"></a>여는방법</h5><ol>
<li>기기에서 <strong>설정</strong>으로 이동하여 <strong>개발자 옵션</strong>을 탭한다.</li>
<li><strong>모니터링</strong> 섹션에서 <strong>프로필 GPU 렌더링</strong>을 선택한다.</li>
<li>‘프로필 GPU 렌더링’ 대화상자에서 <strong>화면에 막대로 표시</strong>를 선택하여 기기의 화면에 그래프를 오버레이한다.</li>
<li>프로파일링하려는 앱을 연다.</li>
</ol>
<p>설정을 활성화 하고 확인해보면, 아래와 같이 히스토그램으로 표시되는 것을 볼 수 있다. </p>
<img src="/Team-Blog/2021/05/19/2021-05-19%20Android%20UI%20Rendering%20Optimization%20Part%203/gpu_profile.png" class="" title="[Profile GPU Rendering]">

<ul>
<li>표시되는 각 애플리케이션에 관해 그래프가 표시된다.</li>
<li>가로축의 각 세로 막대는 프레임을 나타내며 각 세로 막대의 높이는 프레임을 렌더링하는 데 걸린 시간(밀리초)을 나타낸다.</li>
<li>녹색 가로선은 16밀리초를 나타냅니다. 60fps를 달성하려면 각 프레임의 세로 막대가 이 선 아래에 머물러야 합니다. 막대가 이 선을 넘어서면 애니메이션이 일시중지될 수 있다.</li>
<li>16밀리초 임계값을 초과하는 프레임은 막대를 더 넓고 덜 투명하게 만들어 강조표시한다.</li>
<li>각 막대에는 렌더링 파이프라인의 단계로 매핑되는 색상으로 표시된 구성요소가 있습니다. 구성요소의 수는 기기의 API 수준에 따라 다르다.</li>
<li>각 막대에는 렌더링 파이프 라인의 단계에 매핑되는 색상 구성 요소가 있으므로 어느 부분이 가장 오래 걸리는지 확인할 수 있다.</li>
<li>예를 들어 프레임이 입력을 처리하는 데 많은 시간을 소비하는 경우 사용자 입력을 처리하는 앱 코드를 살펴 봐야한다.</li>
</ul>
<h5 id="막대-색상-별-의미"><a href="#막대-색상-별-의미" class="headerlink" title="막대 색상 별 의미"></a>막대 색상 별 의미</h5><img src="/Team-Blog/2021/05/19/2021-05-19%20Android%20UI%20Rendering%20Optimization%20Part%203/graph_color.png" class="" title="[Profile Graph Color]">

<p>세로 막대 차트는 위와 같이 8개의 단계로 표시된다.</p>
<ul>
<li><strong>프로세스/스왑버퍼(Swap)</strong>: 안드로이드는 디스플레이 목록을 GPU 에 제출하는것을 끝내면, 시스템은 그래픽 드라이버에 현재 프레임이 완료되었음을 알리며 드라이버를 업데이트된 이미지를 화면에 표시한다. CPU 와 GPU 는 병렬로 처리되는데 CPU 가 GPU 처리보다 빠른 경우, 프로세스간 통신 큐가 가득찰 수 있다. CPU 는 큐에 공간이 생길때까지 기다린다. 큐가 가득한 상태는 스왑버퍼 상태에서 자주 발생하는데 이 단계에서 프레임 전체의 명령어가 제출되기 때문이다. 명령어 실행 단계와 비슷하게 GPU 에서 일어나는 일의 복잡성을 줄여 문제를 해결할 수 있다.</li>
<li><strong>명령어 실행(Issue)</strong>: 디스플레이 목록을 화면에 그리기 위한 모든 명령어를 실행하기 위해 걸리는 시간을 측정한다. 주어진 프레임에서 렌더링하는 디스플레이 목록과 수량을 직접적으로 측정한다. 내재적으로 많은 그리기 동작이 있는 경우, 오랜 시간이 걸릴수 있다.</li>
<li><strong>동기화/업로드(Upload)</strong>: 현재 프레임에서 비트맵 객체가 CPU 메모리에서 GPU 메모리로 전송되는데 걸리는 시간을 측정한다. 오랜 시간이 걸리는 경우는 작은 리소스가 많이 로드되어 있거나 적지만 큰 리소스가 로드되어 있는 경우이다. 비트맵 해상도가 실제 디스플레이 해상도보다 큰 사이즈로 로드되어 있지 않도록 하거나 동기화 전에 비동기로 미리 업로드해서 실행 시간을 줄일 수 있다.</li>
<li><strong>그리기(Draw)</strong>: 백그라운드 혹은 텍스트 그리기와 같은 뷰를 그리기 명령어로 번역하는 단계로 시스템은 명령어를 디스플레이 목록에 캡처한다. 무효화된 뷰에서 onDraw 호출을 실행해 걸리는 모든 시간을 측정하며, 오랜 시간이 걸린다는 것은 무효화된 뷰가 많다는 것을 의미한다. 뷰가 무효화되는 경우 뷰의 디스프레이 목록을 재생성한다. 혹은 커스텀한 뷰가 onDraw 할때 복잡한 로직을 가질 때도 실행시간이 오랜 걸린다.</li>
<li><strong>측정 및 배치(Measure)</strong>: 안드로이드에서 뷰를 스크린에 그리기 위해 측정하고 배치하는데 걸리는 시간을 측정한다. 일반적으로 오랜 시간이 걸리는 경우는 배치할 뷰가 너무 많거나 혹은 계층구조의 잘못된 장소에서 중복 계산이 이뤄지며, Traceview와 Systrace 를 사용해서 호출 스택을 확인하여 문제를 파악할 수 있다.</li>
<li><strong>애니메이션(Anim)</strong>: 현재 프레임에서 실행되는 애니메이션에 대해 걸리는 시간을 측정한다. 일반적으로 오랜 시간이 걸리는 경우는 애니메이션의 속성 변경으로 인해 발생한다.</li>
<li><strong>입력 처리(Input)</strong>: 앱이 입력 이벤트를 처리하는 시간으로 입력 이벤트 콜백의 결과로 호출된 코드를 실행하는데 걸리는 시간을 나타낸다. 일반적으로 오랜 시간이 걸리는 경우는 메인쓰레드에서 발생하며, 작업을 최적화하거나 다른 쓰레드를 이용해서 작업을 실행하도록 한다.</li>
<li><strong>기타(Misc)</strong>: 렌더링 시스템이 작업을 수행하는 시간외에 렌더링과 관련 없는 추가적인 작업이 있다. 일반적으로 렌더링의 연속된 두 프레임 사이에서 UI 스레드에서 발생할 수 있는 일을 나타낸다. 오랜 시간이 걸리는 경우, 다른스레드에서 실행해야할 콜백, 인텐트 또는 기타 다른 작업이 있을 수 있다. Method tracing 또는 Systrace 를 사용하면 메인스레드에서 실행중인 작업을 확인해 문제를 해결할 수 있다.</li>
</ul>
<p>아래에는 이미지 뷰에 클릭 이벤트를 설정하고 이미지 리소스를 변경하는 로직이다. 좌측에는 단순하게 이미지 리소스를 변경하는 로직만 추가하였고, 우측에는 리소스를 변경하는 과정에서 스레드를 일시 중단하는 코드를 추가하였다. 그 결과 입력처리 시간에 차이가 발생한다는 것을 확인할 수 있다.</p>
<img src="/Team-Blog/2021/05/19/2021-05-19%20Android%20UI%20Rendering%20Optimization%20Part%203/gpu_rendering_profile_1.png" class="" title="[Image Comparison By GPU Rendering Profiling - 1]">

<p>아래에는 이미지 뷰에 각각 다른 크기의 이미지 리소스를 배치하였다. 좌측에는 8.1MB 크기의 이미지 리소스를 배치하고 우측에는 16KB 크기의 이미지 리소스를 배치하였다. </p>
<p>그 결과 이미지를 업로드 시간에 차이가 발생한 다는 것을 확인할 수 있다.</p>
<img src="/Team-Blog/2021/05/19/2021-05-19%20Android%20UI%20Rendering%20Optimization%20Part%203/gpu_rendering_profile_2.png" class="" title="[Image Comparison By GPU Rendering Profiling - 2]">

<h4 id="Etc"><a href="#Etc" class="headerlink" title="Etc"></a>Etc</h4><p>예외적인 케이스에 대한 해법으로는 아래 세가지가 있다.</p>
<ol>
<li>Release 버전의 앱을 실행하자.<ul>
<li>ART(Android Runtime)는 디버깅 기능을 지원하기 위해 몇 가지 중요한 최적화를 비활성화하기 때문이다.</li>
</ul>
</li>
<li>때때로 버벅거림은 앱이 <a target="_blank" rel="noopener" href="https://developer.android.com/topic/performance/vitals/launch-time#cold">cold start</a> 에서 시작될 때만 재현 될 수 있다.</li>
<li>버벅거림을 극대화 시키기 위해 더 느린 장치에서 앱을 실행해 봐라.</li>
</ol>
<h3 id="Systrace"><a href="#Systrace" class="headerlink" title="Systrace"></a>Systrace</h3><p>기기가 수행하는 전체 작업을 보여주는 도구이지만 앱에서 버벅거림을 식별하는 데 유용할 수 있다.</p>
<p>Systrace는 최소한의 시스템 오버헤드를 가지므로 계측 중에 현실적인 버벅거림을 경험할 수 있다.</p>
<h3 id="버벅거림을-유발할-수-있는-요소들"><a href="#버벅거림을-유발할-수-있는-요소들" class="headerlink" title="버벅거림을 유발할 수 있는 요소들"></a>버벅거림을 유발할 수 있는 요소들</h3><p>버벅거림을 유발하는 요소는 대표적으로 <strong>Scrollable lists, Layout performance, Rendering performance</strong>가 있다.</p>
<h4 id="Scrollable-lists"><a href="#Scrollable-lists" class="headerlink" title="Scrollable lists"></a>Scrollable lists</h4><p>ListView 및 특히 RecyclerView는 버벅거림에 가장 취약한 복잡한 스크롤 목록에 일반적으로 사용된다.</p>
<p>둘 다 Systrace 마커가 포함되어 있으므로 Systrace를 사용하여 앱에서 버벅거림을 유발하는지 여부를 파악할 수 있다.</p>
<p>RecyclerView의 systrace 섹션을 표시하려면 명령에 <code>-a &lt;your-package-name&gt;</code>을 전달해야한다. 사용 가능한 경우 systrace 출력에 생성 된 경고의 지침을 따르자.</p>
<p>Systrace 내에서 RecyclerView systrace 섹션을 클릭하여 RecyclerView가 수행하는 작업에 대한 설명을 볼 수 있다.</p>
<ol>
<li><p>작은 업데이트를 위해 <code>notifyDataSetChanged()</code>, <code>setAdapter(Adapter)</code>, or <code>swapAdapter(Adapter, boolean)</code>를 호출하지 마라.</p>
<ul>
<li>전체 목록 아이템이 변경되었다고 알리기 때문이다.</li>
<li>대신 <code>SortedList</code> 또는 <code>DiffUtil</code>을 사용하여 콘텐츠가 변경되거나 추가 될 때 최소한의 업데이트를 하도록하자.</li>
</ul>
</li>
<li><p><strong>Nested recyclerview</strong></p>
<ul>
<li>내부 RecyclerView의 LinearLayoutManager에 <code>setInitialPrefetchItemCount(int)</code> 를 설정할 수도 있다.</li>
<li>예를 들어 항상 3.5 개의 항목이 한 행에 표시되는 경우, <code>innerLinearLayoutManager.setInitialItemPrefetchCount(4);</code> 를 호출한다.</li>
</ul>
</li>
<li><p><code>RecyclerView</code> 의 <code>view type</code> 이 적을수록 새 item type 이 화면에 표시 될 때 수행해야하는 inflation 이 줄어 든다.</p>
<ul>
<li>만약 아이콘, 색상, 작은 문구 변경 차이라면, 별도의 view type 으로 나누지 않고 bind 할 때 변경하는 것이 낫다. (동시에 앱의 메모리 사용량 감소)</li>
</ul>
</li>
<li><p>Bind (즉, onBindViewHolder (VH, int) 는 매우 간단해야하며 가장 복잡한 항목을 제외한 모든 항목에 대해 1 밀리 초 미만이 소요되야 한다.</p>
<ul>
<li>단순히 adapter 의 내부 item 에서 POJO item 을 가져와서, ViewHolder의 view 에서 setter 를 호출해야 한다.</li>
</ul>
</li>
</ol>
<h4 id="Layout-performance"><a href="#Layout-performance" class="headerlink" title="Layout performance"></a>Layout performance</h4><p><code>Systrace</code>에서 <code>Choreographer # doFrame</code>의 레이아웃 세그먼트가 너무 많은 작업을 수행하거나 너무 자주 작업을 수행하는 것으로 표시되면 레이아웃 성능 문제가 있음을 의미한다.</p>
<p>세그먼트가 몇 밀리 초보다 길면 <code>RelativeLayouts</code> 또는 <code>weighted-LinearLayouts</code>에 대해 최악의 경우 중첩 성능에 도달 할 수 있다. </p>
<p>이러한 각 레이아웃은 자식의 여러 측정 / 레이아웃 패스를 트리거 할 수 있으므로 중첩하면 중첩 깊이에서 O (n ^ 2) 동작이 발생할 수 있다. </p>
<p><strong>계층 구조의 최하위 리프 노드를 제외한 모든 노드에서 RelativeLayout 또는 LinearLayout의 가중치 기능을 피해라.</strong></p>
<h4 id="Rendering-performance"><a href="#Rendering-performance" class="headerlink" title="Rendering performance"></a>Rendering performance</h4><p><strong>Android UI는 UI 스레드의 Record <code>View # draw</code>와 RenderThread의 <code>DrawFrame</code>의 두 단계로 작동한다</strong>.</p>
<p>첫 번째는 모든 <code>invalidated View</code> 에서 <code>draw (Canvas)</code>를 실행한다.</p>
<p>두 번째는 기본 <code>RenderThread</code>에서 실행되지만 <code>View#draw()</code> 단계에서 생성 된 작업을 기반으로 작동한다.</p>
<p><code>View#draw()</code> 가 너무 오래 걸린다면, 이 경우는 보통 UI 스레드에서 bitmap 이 그려지는 경우다. <code>Bitmap</code> 에 그리기는 CPU 렌더링을 사용하므로 일반적으로 가능하면 이를 피해야 한다.</p>
<h3 id="Custom-Performance-Monitoring-맞춤-성능-모니터링-사용"><a href="#Custom-Performance-Monitoring-맞춤-성능-모니터링-사용" class="headerlink" title="Custom Performance Monitoring(맞춤 성능 모니터링 사용)"></a>Custom Performance Monitoring(맞춤 성능 모니터링 사용)</h3><p>로컬 기기에서 버벅거림을 재현할 수 없는 경우 앱에 맞춤 성능 모니터링을 빌드하여 현장에서 기기의 버벅거림 원인을 식별할 수 있다.</p>
<p>이를 위해 <a target="_blank" rel="noopener" href="https://developer.android.com/reference/androidx/core/app/FrameMetricsAggregator"><code>FrameMetricsAggregator</code></a>를 사용하여 앱의 특정 부분에서 프레임 렌더링 시간을 수집하고 <a target="_blank" rel="noopener" href="https://firebase.google.com/docs/perf-mon/">Firebase Performance Monitoring</a>을 사용하여 데이터를 기록하고 분석할 수 있다.</p>
<p>자세한 내용은 아래내용을 참조하자.</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://developer.android.com/topic/performance/vitals">Android Vitals</a></li>
<li><a target="_blank" rel="noopener" href="https://firebase.google.com/docs/perf-mon/get-started-android#pdc">Firebase Performance Monitoring 사용</a></li>
</ul>
<h2 id="Overdraw"><a href="#Overdraw" class="headerlink" title="Overdraw"></a>Overdraw</h2><blockquote>
<p>An app may draw the same pixel more than once within a single frame, an event called overdraw. Overdraw is usually unnecessary, and best eliminated. It manifests itself as a performance problem by wasting GPU time to render pixels that don’t contribute to what the user sees on the screen.</p>
</blockquote>
<p>오버드로는 시스템이 단일 렌더링 프레임에서 화면에 여러 번 픽셀을 그리는 것을 말한다.</p>
<blockquote>
<p><strong>참고</strong> : Overdraw는 더 이상 Google I/O 성능 세션 및 성능 패턴 동영상에서 논의되었을 때 만큼 심각한 문제가 아니다.</p>
<p>이는 저가형 장치가 GPU 성능에서 지속적으로 성장하는 반면 디스플레이는 상대적으로 낮은 해상도에서 정체 되었기 때문. 알려진 저 성능 GPU 장치를 최적화하지 않는 한, 원활한 앱 성능을 보장하는 것 대신 UI 스레드 작업을 최적화하는 데 집중하는 것이 좋다.</p>
<p><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=vkTn3Ule4Ps">참고영상</a>을 확인하자.</p>
</blockquote>
<p>다른 개발자 옵션으로 UI 에 컬러를 지정함으로써 오버드로를 식별할 수 있다. 같은 프레임내에서 같은 픽셀을 한번 이상 그릴 때 오버드로가 발생한다.</p>
<p>앱에서 필요 이상으로 많은 렌더링이 발생하는 곳을 시각화로 보여주며, 사용자에게 보여지지 않는 픽셀을 렌더링하기 위해 추가 GPU 작업으로 성능 문제가 발생한 수 있음을 알 수 있다. 다음과 같이 설정하면 오버드로 시각화를 확인 할 수 있다.</p>
<h3 id="Overdraw-디버깅"><a href="#Overdraw-디버깅" class="headerlink" title="Overdraw 디버깅"></a>Overdraw 디버깅</h3><h5 id="여는방법-1"><a href="#여는방법-1" class="headerlink" title="여는방법"></a>여는방법</h5><ol>
<li>기기에서 <strong>설정</strong>으로 이동하여 <strong>개발자 옵션</strong>을 탭한다.</li>
<li><strong>하드웨어 가속 렌더링</strong> 섹션으로 스크롤하여 <strong>GPU 오버드로 디버그</strong>를 선택한다.</li>
<li><strong>GPU 오버드로 디버그</strong> 대화상자에서 <strong>오버드로 영역 표시</strong>를 선택한다.</li>
<li><strong>분석</strong></li>
</ol>
<ul>
<li><strong>True color:</strong> No overdraw</li>
<li><strong>Blue:</strong> Overdrawn 1 time <img src="/Team-Blog/2021/05/19/2021-05-19%20Android%20UI%20Rendering%20Optimization%20Part%203/overdrawn_1.png" class="" title="[Overdrawn 1 time]"></li>
<li><strong>Green:</strong> Overdrawn 2 times <img src="/Team-Blog/2021/05/19/2021-05-19%20Android%20UI%20Rendering%20Optimization%20Part%203/overdrawn_2.png" class="" title="[Overdrawn 2 time]"></li>
<li><strong>Pink:</strong> Overdrawn 3 times <img src="/Team-Blog/2021/05/19/2021-05-19%20Android%20UI%20Rendering%20Optimization%20Part%203/overdrawn_3.png" class="" title="[Overdrawn 3 time]"></li>
<li><strong>Red:</strong> Overdrawn 4 or more times <img src="/Team-Blog/2021/05/19/2021-05-19%20Android%20UI%20Rendering%20Optimization%20Part%203/overdrawn_4.png" class="" title="[Overdrawn 4 time]"></li>
</ul>
<p>디버깅 결과는 아래와 같이 비교 가능하다.</p>
<p>뷰의 배치에 따라 각각 오버드로가 발생한 픽셀을 확인할 수 있다.</p>
<img src="/Team-Blog/2021/05/19/2021-05-19%20Android%20UI%20Rendering%20Optimization%20Part%203/zw3H5pZ.png" class="" title="[Overdraw Visialization]">


<h3 id="Overdraw-줄이기"><a href="#Overdraw-줄이기" class="headerlink" title="Overdraw 줄이기"></a>Overdraw 줄이기</h3><p>Overdraw를 줄일 수 있는 방법은 대표적으로 세가지가 있다.</p>
<ol>
<li><p>layouts 에서 불필요한 backgrounds 는 제거하자</p>
</li>
<li><p>View 계층을 평면화하자</p>
</li>
<li><p>투명도를 줄이자 </p>
</li>
</ol>
<ul>
<li>알파 렌더링으로 알려진 화면에서 투명 픽셀을 렌더링하는 것은 오버드로의 주요 원인이다.</li>
<li>시스템이 그 위에 불투명 한 픽셀을 그려서 기존의 그려진 픽셀을 완전히 숨기는 표준 오버드로와 달리, 투명한 객체는 올바른 <code>blending equation</code> 이 발생하도록 기존 픽셀을 먼저 그려야한다.</li>
</ul>
<blockquote>
<p><strong>참고</strong> blending equation : 2개의 픽셀 컬러 값을 결합시키는 것. <a target="_blank" rel="noopener" href="https://xysterxx.tistory.com/50">관련 블로그</a></p>
</blockquote>
<h2 id="UI-렌더링-성능-개선"><a href="#UI-렌더링-성능-개선" class="headerlink" title="UI 렌더링 성능 개선"></a>UI 렌더링 성능 개선</h2><p>지금까지는 원인 및 분석 방법에 대해서 살펴보았다. 이번에는 본격적으로 코드레벨에서 분석 및 개선방안을 통해 어떻게 개선할 수 있는지 보자.</p>
<h3 id="레이아웃-재사용"><a href="#레이아웃-재사용" class="headerlink" title="레이아웃 재사용"></a>레이아웃 재사용</h3><ul>
<li>include, merge를 통해 뷰를 재사용한다.</li>
<li>include로만 뷰를 재사용하면 다음과 같이 뷰가 중첩될 수 있다.</li>
</ul>
<img src="/Team-Blog/2021/05/19/2021-05-19%20Android%20UI%20Rendering%20Optimization%20Part%203/before_merge.png" class="" title="[before_merge]">

<ul>
<li>merge를 같이 사용하여 중첩을 줄여준다 </li>
</ul>
<img src="/Team-Blog/2021/05/19/2021-05-19%20Android%20UI%20Rendering%20Optimization%20Part%203/after_merge.png" class="" title="[after_merge]">

<h3 id="오버드로잉-방지-뷰-백그라운드"><a href="#오버드로잉-방지-뷰-백그라운드" class="headerlink" title="오버드로잉 방지(뷰 백그라운드)"></a>오버드로잉 방지(뷰 백그라운드)</h3><p>일반적으로 우리는 앱의 배경 색상을 적용하기 위해 <code>android:background=&quot;@color/white&quot;</code> 해당 뷰의 배경색상을 적용한다.</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- /res/layout/activity_main.xml --&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">&quot;.MainActivity&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:background</span>=<span class="string">&quot;@color/white&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;Hello World!&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintBottom_toBottomOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintLeft_toLeftOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintRight_toRightOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">&quot;parent&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>이러한 방법은 View에 그려짐에 있어 중복으로 그릴 수 있는 여지가 있다.</p>
<img src="/Team-Blog/2021/05/19/2021-05-19%20Android%20UI%20Rendering%20Optimization%20Part%203/example1.png" class="" title="[example1]">

<p>왜 Overdraw가 생기는지 확인을 위해 앱 테마 값을 확인해보았다.</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- /res/values/themes.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resources</span> <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Base application theme. --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">&quot;Theme.UITest&quot;</span> <span class="attr">parent</span>=<span class="string">&quot;Theme.MaterialComponents.DayNight.DarkActionBar&quot;</span>&gt;</span><span class="xml"></span></span><br><span class="line"><span class="xml">        <span class="comment">&lt;!-- Primary brand color. --&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;colorPrimary&quot;</span>&gt;</span>@color/purple_500<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;colorPrimaryVariant&quot;</span>&gt;</span>@color/purple_700<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;colorOnPrimary&quot;</span>&gt;</span>@color/white<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="comment">&lt;!-- Secondary brand color. --&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;colorSecondary&quot;</span>&gt;</span>@color/teal_200<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;colorSecondaryVariant&quot;</span>&gt;</span>@color/teal_700<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;colorOnSecondary&quot;</span>&gt;</span>@color/black<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="comment">&lt;!-- Status bar color. --&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;android:statusBarColor&quot;</span> <span class="attr">tools:targetApi</span>=<span class="string">&quot;l&quot;</span>&gt;</span>?attr/colorPrimaryVariant<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="comment">&lt;!-- Customize your theme here. --&gt;</span></span></span><br><span class="line"><span class="xml">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>특별히 지정해준 사항이 없어 해당 테마의 Parent를 따라가 보았다.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Base.V14.Theme.MaterialComponents.Light</span><br><span class="line">ㄴ Base.Theme.MaterialComponents.Light</span><br><span class="line">    ㄴ Base.Theme.MaterialComponents.Light.DarkActionBar</span><br><span class="line">        ㄴ Theme.MaterialComponents.Light.DarkActionBar</span><br><span class="line">            ㄴ Theme.MaterialComponents.DayNight.DarkActionBar</span><br></pre></td></tr></table></figure>

<p>해당 소스에서 아래와 같이 배경 색상을 지정하는 걸 확인하였고</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;android:colorBackground&quot;</span>&gt;</span>@color/design_default_color_background<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>해당 값을 확인해보니 아래와 같이 흰색으로 설정하고 있었다.</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">color</span> <span class="attr">name</span>=<span class="string">&quot;design_default_color_background&quot;</span>&gt;</span>#FFFFFF<span class="tag">&lt;/<span class="name">color</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>한마디로 배경 색상을 흰색으로 칠해주고 그 위에 다시 흰색으로 칠해주고 있었다. 해당 Overdraw를 없애고 내가 원하는 색상으로 설정하기 위해 테마 파일을 아래와 같이 <code>&lt;item name=&quot;android:windowBackground&quot;&gt;@color/beige&lt;/item&gt;</code> 를 통해 오버드로잉 문제를 해결할 수 있다.</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- /res/values/themes.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resources</span> <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Base application theme. --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">&quot;Theme.UITest&quot;</span> <span class="attr">parent</span>=<span class="string">&quot;Theme.MaterialComponents.DayNight.NoActionBar&quot;</span>&gt;</span><span class="xml"></span></span><br><span class="line"><span class="xml">        <span class="comment">&lt;!-- Primary brand color. --&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;colorPrimary&quot;</span>&gt;</span>@color/purple_500<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;colorPrimaryVariant&quot;</span>&gt;</span>@color/purple_700<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;colorOnPrimary&quot;</span>&gt;</span>@color/white<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="comment">&lt;!-- Secondary brand color. --&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;colorSecondary&quot;</span>&gt;</span>@color/teal_200<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;colorSecondaryVariant&quot;</span>&gt;</span>@color/teal_700<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;colorOnSecondary&quot;</span>&gt;</span>@color/black<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="comment">&lt;!-- Status bar color. --&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;android:statusBarColor&quot;</span> <span class="attr">tools:targetApi</span>=<span class="string">&quot;l&quot;</span>&gt;</span>?attr/colorPrimaryVariant<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="comment">&lt;!-- Customize your theme here. --&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;android:windowBackground&quot;</span>&gt;</span>@color/beige<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p> <code>/res/layout/activity_main.xml</code> 파일에 <code>android:background=&quot;@color/beige&quot;</code> 코드를 입력 후 Overdraw를 확인한 결과는 다음과 같다.</p>
<img src="/Team-Blog/2021/05/19/2021-05-19%20Android%20UI%20Rendering%20Optimization%20Part%203/example2.png" class="" title="[example2]">

<p>결론적으로 배경 색상 지정을 테마를 통해 지정하면 Overdraw를 줄일 수 있다.</p>
<h3 id="Lazy-Load-by-ViewStub"><a href="#Lazy-Load-by-ViewStub" class="headerlink" title="Lazy Load by ViewStub"></a>Lazy Load by ViewStub</h3><p>해당 내용은 <a target="_blank" rel="noopener" href="https://www.charlezz.com/?p=19977">찰스의 안드로이드 - ViewStub 활용으로 성능 높이기</a>글 을 참고하였다.</p>
<p>ViewStub은 사이즈가 없는 보이지 않는 뷰로 런타임에서 늦은 전개(lazy-inflate)를 원할 때 사용할 수 있다.</p>
<p>ViewStub을 보이게 만들거나 inflate() 메서드를 호출하면 레이아웃이 전개되면서 ViewStub을 대체하기 때문에 ViewStub은 사라진다.</p>
<p>전개된 뷰는 ViewStub의 부모 뷰에 추가 된다. 레이아웃에서 ViewStub을 사용하는 예제를 확인하자.</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ViewStub</span> <span class="attr">android:id</span>=<span class="string">&quot;@+id/stub&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:inflatedId</span>=<span class="string">&quot;@+id/subTree&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:layout</span>=<span class="string">&quot;@layout/mySubTree&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:layout_width</span>=<span class="string">&quot;120dp&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:layout_height</span>=<span class="string">&quot;40dp&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>



<p>findViewById() 호출을 통해 ViewStub에 접근할 수 있다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> viewStub = findViewById(R.id.stub)</span><br></pre></td></tr></table></figure>

<p>생성되는 바인딩 클래스에서 ViewStub은 ViewStubProxy로 표현되며, ViewStub에 대해 접근할 수 있게 해준다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> binding: ActivityMainBinding = ...</span><br><span class="line"><span class="keyword">val</span> viewStubProxy = binding.stub</span><br><span class="line"><span class="keyword">val</span> viewStub = viewStubProxy.viewStub()</span><br></pre></td></tr></table></figure>

<p>ViewStub에 지정된 레이아웃을 전개 시키기 위해서 서는 setVisibility() 또는 inflate()를 호출 할 수 있다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> viewStub: ViewStub = ...</span><br><span class="line">viewStub.inflate()</span><br><span class="line"><span class="comment">//또는 viewStub.visibility = View.VISIBLE</span></span><br></pre></td></tr></table></figure>

<p>ViewStub은 복잡하게 구성된 레이아웃을 빠르게 전개시켜야하는 상황에서, 레이아웃의 전개 시기를 선택적으로 늦출 수 있다.</p>
<p>예를 들어 리스트 형태의 UI를 구성하고 하나의 뷰홀더가 전개 되는데 상당한 비용이 발생한다고 가정하자.</p>
<p>이 때 사용자가 빠르게 화면을 스크롤 할 경우 프레임 드랍이 발생 할 수 있다. 이럴 때 선택적으로 불필요한 레이아웃의 전개를 제어하고 전개 시기를 늦춤으로써 성능을 개선시킬 수 있다.</p>
<p>우리는 1, 2, 3편에서 안드로이드의 기본적인 UI구성요소, 내부적인 렌더링 매커니즘, 렌더링 되면서 성능상 이슈가 있는 부분을 알아보았고 마지막으로 성능에 대한 개선방안에 대해 알 수 있었다.</p>
<p>안드로이드를 공부하는 여러분들께 조금이나마 도움이 되길 바란다.</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><h3 id="Members-of-Study"><a href="#Members-of-Study" class="headerlink" title="Members of Study"></a>Members of Study</h3><p><a target="_blank" rel="noopener" href="https://soda1127.github.io/introduce-jetpack-compose/">https://soda1127.github.io/introduce-jetpack-compose/</a></p>
<p><a target="_blank" rel="noopener" href="https://velog.io/@jshme/How-To-Render-UI-In-Android">https://velog.io/@jshme/How-To-Render-UI-In-Android</a></p>
<p><a target="_blank" rel="noopener" href="https://velog.io/@jshme/How-To-Render-UI-In-Android-22">https://velog.io/@jshme/How-To-Render-UI-In-Android-22</a></p>
<h3 id="Official"><a href="#Official" class="headerlink" title="Official"></a>Official</h3><h4 id="Docs"><a href="#Docs" class="headerlink" title="Docs"></a>Docs</h4><p><a target="_blank" rel="noopener" href="https://developer.android.com/topic/performance/vitals">Android vitals</a></p>
<p><a target="_blank" rel="noopener" href="https://developer.android.com/guide/topics/ui/how-android-draws">Android 드로잉 보기 방법</a></p>
<p><a target="_blank" rel="noopener" href="https://developer.android.com/topic/performance/vitals/render#custom-monitoring">느린렌터링</a></p>
<p><a target="_blank" rel="noopener" href="https://firebase.google.com/docs/perf-mon/get-started-android#pdc">Firebase Performance Monitoring 사용</a></p>
<p><a target="_blank" rel="noopener" href="https://developer.android.com/topic/performance/rendering/inspect-gpu-rendering">GPU 렌더링 속도 및 오버드로 검사</a></p>
<p><a target="_blank" rel="noopener" href="https://developer.android.com/training/custom-views/custom-drawing?hl=ko">맞춤 그리기</a></p>
<p><a target="_blank" rel="noopener" href="https://developer.android.com/training/custom-views/optimizing-view?hl=ko">뷰 최적화</a></p>
<h4 id="Videos"><a href="#Videos" class="headerlink" title="Videos"></a>Videos</h4><p><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=1iaHxmfZGGc">Android Performance Patterns: Understanding VSYNC</a></p>
<p><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=HXQhu6qfTVU&list=PLOU2XLYxmsIKEOXh5TwZEv89aofHzNCiu&index=48">Android Performance Patterns: Rendering Performance 101</a></p>
<p><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=VzYkVL1n4M8&list=PLOU2XLYxmsIKEOXh5TwZEv89aofHzNCiu&index=51">Android Performance Patterns: Tool - Profile GPU Rendering</a></p>
<p><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=T52v50r-JfE&list=PLOU2XLYxmsIKEOXh5TwZEv89aofHzNCiu&index=49">Android Performance Patterns: Understanding Overdraw</a></p>
<p><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=we6poP0kw6E&list=PLOU2XLYxmsIKEOXh5TwZEv89aofHzNCiu&index=54">Android Performance Patterns: Invalidations, Layouts, and Performance</a></p>
<p><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=wIy8g8yNhNk&index=46&list=PLWz5rJ2EKKc9CBxr3BVjPTPoDPLdPIFCE">Android Performance Patterns: Hidden Cost of Transparency</a></p>
<h3 id="Etc-1"><a href="#Etc-1" class="headerlink" title="Etc"></a>Etc</h3><p><a target="_blank" rel="noopener" href="https://www.charlezz.com/?p=19977">찰스의 안드로이드 - ViewStub 활용으로 성능 높이기</a></p>
<p><a target="_blank" rel="noopener" href="https://lastyouth.tistory.com/24">Android Drawing Process 1(App surface, SF Layer)</a></p>
</div><div class="article-licensing box"><div class="licensing-title"><p>Introduce Android UI Rendering Principle and View Optimization Part 3</p><p><a href="https://androiddeepdive.github.io/2021/05/19/2021-05-19 Android UI Rendering Optimization Part 3/">https://androiddeepdive.github.io/2021/05/19/2021-05-19 Android UI Rendering Optimization Part 3/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>Author</h6><p>Android Deep Dive</p></div></div><div class="level-item is-narrow"><div><h6>Posted on</h6><p>2021-05-19</p></div></div><div class="level-item is-narrow"><div><h6>Updated on</h6><p>2021-07-25</p></div></div><div class="level-item is-narrow"><div><h6>Licensed under</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/Team-Blog/tags/Android/">Android</a><a class="link-muted mr-2" rel="tag" href="/Team-Blog/tags/Rendering/">Rendering</a><a class="link-muted mr-2" rel="tag" href="/Team-Blog/tags/Principle/">Principle</a><a class="link-muted mr-2" rel="tag" href="/Team-Blog/tags/Optimize/">Optimize</a><a class="link-muted mr-2" rel="tag" href="/Team-Blog/tags/UI/">UI</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/Team-Blog/2021/06/24/2021-06-24%20Image%20Loading%20and%20Caching%20Library%20Part%201/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">Image Loading and Caching Library Part 1 — Why use?</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/Team-Blog/2021/05/19/2021-05-19%20Android%20UI%20Rendering%20Optimization%20Part%202/"><span class="level-item">Introduce Android UI Rendering Principle and View Optimization Part 2</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/Team-Blog/img/avatar.png" alt="ADD"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">ADD</p><p class="is-size-6 is-block">Android Deep Dive</p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">포스트</p><a href="/Team-Blog/archives"><p class="title">12</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">카테고리</p><a href="/Team-Blog/categories"><p class="title">4</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">태그</p><a href="/Team-Blog/tags"><p class="title">15</p></a></div></div></nav></div></div><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">링크</h3><ul class="menu-list"><li><a class="level is-mobile" href="http://github.com/AndroidDeepDive/Study" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Study</span></span><span class="level-right"><span class="level-item tag">github.com</span></span></a></li><li><a class="level is-mobile" href="https://github.com/AndroidDeepDive/Contact-Us" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Contact-Us</span></span><span class="level-right"><span class="level-item tag">github.com</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">카테고리</h3><ul class="menu-list"><li><a class="level is-mobile" href="/Team-Blog/categories/Image-Library/"><span class="level-start"><span class="level-item">Image Library</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/Team-Blog/categories/Jetpack-Compose/"><span class="level-start"><span class="level-item">Jetpack Compose</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/Team-Blog/categories/KSP/"><span class="level-start"><span class="level-item">KSP</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/Team-Blog/categories/User-Interface/"><span class="level-start"><span class="level-item">User Interface</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">최근 글</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-07-20T18:00:00.000Z">2021-07-21</time></p><p class="title"><a href="/Team-Blog/2021/07/21/2021-07-21%20Kotlin%20Symbol%20Processing%20Api%20Part%203/">Kotlin Symbol Processing Api Part 3 — KSP vs KAPT</a></p><p class="categories"><a href="/Team-Blog/categories/KSP/">KSP</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-07-20T17:00:00.000Z">2021-07-21</time></p><p class="title"><a href="/Team-Blog/2021/07/21/2021-07-21%20Kotlin%20Symbol%20Processing%20Api%20Part%202/">Kotlin Symbol Processing Api Part 2 — What is it?</a></p><p class="categories"><a href="/Team-Blog/categories/KSP/">KSP</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-07-20T16:00:00.000Z">2021-07-21</time></p><p class="title"><a href="/Team-Blog/2021/07/21/2021-07-21%20Kotlin%20Symbol%20Processing%20Api%20Part%201/">Kotlin Symbol Processing Api Part 1 — Annotation과 KAPT</a></p><p class="categories"><a href="/Team-Blog/categories/KSP/">KSP</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-06-23T18:00:00.000Z">2021-06-24</time></p><p class="title"><a href="/Team-Blog/2021/06/24/2021-06-24%20Image%20Loading%20and%20Caching%20Library%20Part%203/">Image Loading and Caching Library Part 3 — Performance Test</a></p><p class="categories"><a href="/Team-Blog/categories/Image-Library/">Image Library</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-06-23T17:00:00.000Z">2021-06-24</time></p><p class="title"><a href="/Team-Blog/2021/06/24/2021-06-24%20Image%20Loading%20and%20Caching%20Library%20Part%202/">Image Loading and Caching Library Part 2 — Principle / Memory &amp; Footprint / Compose</a></p><p class="categories"><a href="/Team-Blog/categories/Image-Library/">Image Library</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">아카이브</h3><ul class="menu-list"><li><a class="level is-mobile" href="/Team-Blog/archives/2021/07/"><span class="level-start"><span class="level-item">7월 2021</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/Team-Blog/archives/2021/06/"><span class="level-start"><span class="level-item">6월 2021</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/Team-Blog/archives/2021/05/"><span class="level-start"><span class="level-item">5월 2021</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/Team-Blog/archives/2021/04/"><span class="level-start"><span class="level-item">4월 2021</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">태그</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/Team-Blog/tags/Android/"><span class="tag">Android</span><span class="tag">9</span></a></div><div class="control"><a class="tags has-addons" href="/Team-Blog/tags/Annotation/"><span class="tag">Annotation</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/Team-Blog/tags/Compose/"><span class="tag">Compose</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/Team-Blog/tags/Image/"><span class="tag">Image</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/Team-Blog/tags/Jetpack/"><span class="tag">Jetpack</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/Team-Blog/tags/KAPT/"><span class="tag">KAPT</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/Team-Blog/tags/KSP/"><span class="tag">KSP</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/Team-Blog/tags/Kotlin/"><span class="tag">Kotlin</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/Team-Blog/tags/Library/"><span class="tag">Library</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/Team-Blog/tags/Optimize/"><span class="tag">Optimize</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/Team-Blog/tags/Principle/"><span class="tag">Principle</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/Team-Blog/tags/Processing/"><span class="tag">Processing</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/Team-Blog/tags/Rendering/"><span class="tag">Rendering</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/Team-Blog/tags/Symbol/"><span class="tag">Symbol</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/Team-Blog/tags/UI/"><span class="tag">UI</span><span class="tag">3</span></a></div></div></div></div></div><!--!--></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/Team-Blog/"><img src="/Team-Blog/img/logo.png" alt="Android Deep Dive" height="28"></a><p class="is-size-7"><span>&copy; 2021 Android Deep Dive</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("ko");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/Team-Blog/js/column.js"></script><a id="back-to-top" title="맨 위로" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/Team-Blog/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/Team-Blog/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="입력 하세요..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/Team-Blog/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/Team-Blog/content.json"}, {"hint":"입력 하세요...","untitled":"(제목 없음)","posts":"포스트","pages":"페이지","categories":"카테고리","tags":"태그"});
        });</script></body></html>